var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { Layer } from '../../../lib';
import HexagonLayer from '../hexagon-layer/hexagon-layer';
import { log } from '../../../lib/utils';

import { ordinalScale, linearScale } from '../../../utils/scale-utils';
import { defaultColorRange } from '../../../utils/color-utils';
import { pointToHexbin } from './hexagon-aggregator';

var defaultRadius = 1000;
var defaultCoverage = 1;
var defaultElevationRange = [0, 1000];
var defaultElevationScale = 1;
var defaultAggregator = pointToHexbin;

var defaultProps = {
  colorRange: defaultColorRange,
  elevationRange: defaultElevationRange,
  elevationScale: defaultElevationScale,
  radius: defaultRadius,
  coverage: defaultCoverage,
  hexagonAggregator: defaultAggregator,
  getPosition: function getPosition(x) {
    return x.position;
  }
};

function noop() {}

function _needsReProjectPoints(oldProps, props) {
  return oldProps.radius !== props.radius;
}

function _getCountRange(hexagons) {
  return [Math.min.apply(null, hexagons.map(function (bin) {
    return bin.points.length;
  })), Math.max.apply(null, hexagons.map(function (bin) {
    return bin.points.length;
  }))];
}

var PointDensityHexagonLayer = function (_Layer) {
  _inherits(PointDensityHexagonLayer, _Layer);

  function PointDensityHexagonLayer(props) {
    _classCallCheck(this, PointDensityHexagonLayer);

    if (!props.radius) {
      log.once(0, 'PointDensityHexagonLayer: radius in meter is needed to aggregate points into ' + 'hexagonal bins, Now using 1000 meter as default');

      props.radius = defaultRadius;
    }

    return _possibleConstructorReturn(this, (PointDensityHexagonLayer.__proto__ || Object.getPrototypeOf(PointDensityHexagonLayer)).call(this, props));
  }

  _createClass(PointDensityHexagonLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        hexagons: [],
        countRange: null,
        pickedCell: null
      };
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      if (changeFlags.dataChanged || _needsReProjectPoints(oldProps, props)) {
        var hexagonAggregator = this.props.hexagonAggregator;
        var viewport = this.context.viewport;


        var hexagons = hexagonAggregator(this.props, viewport);
        var countRange = _getCountRange(hexagons);

        Object.assign(this.state, { hexagons: hexagons, countRange: countRange });
      }
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(opts) {
      var info = _get(PointDensityHexagonLayer.prototype.__proto__ || Object.getPrototypeOf(PointDensityHexagonLayer.prototype), 'getPickingInfo', this).call(this, opts);
      var pickedCell = this.state.pickedCell;

      return Object.assign(info, {
        layer: this,
        // override index with cell index
        index: pickedCell ? pickedCell.index : -1,
        picked: Boolean(pickedCell),
        // override object with picked cell
        object: pickedCell
      });
    }
  }, {
    key: '_onHoverSublayer',
    value: function _onHoverSublayer(info) {

      this.state.pickedCell = info.picked && info.index > -1 ? this.state.hexagons[info.index] : null;
    }
  }, {
    key: '_onGetSublayerColor',
    value: function _onGetSublayerColor(cell) {
      var colorRange = this.props.colorRange;

      var colorDomain = this.props.colorDomain || this.state.countRange;

      return ordinalScale(colorDomain, colorRange, cell.points.length);
    }
  }, {
    key: '_onGetSublayerElevation',
    value: function _onGetSublayerElevation(cell) {
      var elevationRange = this.props.elevationRange;

      var elevationDomain = this.props.elevationDomain || [0, this.state.countRange[1]];
      return linearScale(elevationDomain, elevationRange, cell.points.length);
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      var _props = this.props,
          id = _props.id,
          radius = _props.radius;


      return new HexagonLayer(Object.assign({}, this.props, {
        id: id + '-density-hexagon',
        data: this.state.hexagons,
        radius: radius,
        angle: Math.PI,
        getColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        // Override user's onHover and onClick props
        onHover: this._onHoverSublayer.bind(this),
        onClick: noop,
        updateTriggers: {
          getColor: { colorRange: this.props.colorRange },
          getElevation: { elevationRange: this.props.elevationRange }
        }
      }));
    }
  }]);

  return PointDensityHexagonLayer;
}(Layer);

export default PointDensityHexagonLayer;


PointDensityHexagonLayer.layerName = 'PointDensityHexagonLayer';
PointDensityHexagonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wb2ludC1kZW5zaXR5LWhleGFnb24tbGF5ZXIvcG9pbnQtZGVuc2l0eS1oZXhhZ29uLWxheWVyLmpzIl0sIm5hbWVzIjpbIkxheWVyIiwiSGV4YWdvbkxheWVyIiwibG9nIiwib3JkaW5hbFNjYWxlIiwibGluZWFyU2NhbGUiLCJkZWZhdWx0Q29sb3JSYW5nZSIsInBvaW50VG9IZXhiaW4iLCJkZWZhdWx0UmFkaXVzIiwiZGVmYXVsdENvdmVyYWdlIiwiZGVmYXVsdEVsZXZhdGlvblJhbmdlIiwiZGVmYXVsdEVsZXZhdGlvblNjYWxlIiwiZGVmYXVsdEFnZ3JlZ2F0b3IiLCJkZWZhdWx0UHJvcHMiLCJjb2xvclJhbmdlIiwiZWxldmF0aW9uUmFuZ2UiLCJlbGV2YXRpb25TY2FsZSIsInJhZGl1cyIsImNvdmVyYWdlIiwiaGV4YWdvbkFnZ3JlZ2F0b3IiLCJnZXRQb3NpdGlvbiIsIngiLCJwb3NpdGlvbiIsIm5vb3AiLCJfbmVlZHNSZVByb2plY3RQb2ludHMiLCJvbGRQcm9wcyIsInByb3BzIiwiX2dldENvdW50UmFuZ2UiLCJoZXhhZ29ucyIsIk1hdGgiLCJtaW4iLCJhcHBseSIsIm1hcCIsImJpbiIsInBvaW50cyIsImxlbmd0aCIsIm1heCIsIlBvaW50RGVuc2l0eUhleGFnb25MYXllciIsIm9uY2UiLCJzdGF0ZSIsImNvdW50UmFuZ2UiLCJwaWNrZWRDZWxsIiwiY2hhbmdlRmxhZ3MiLCJkYXRhQ2hhbmdlZCIsInZpZXdwb3J0IiwiY29udGV4dCIsIk9iamVjdCIsImFzc2lnbiIsIm9wdHMiLCJpbmZvIiwibGF5ZXIiLCJpbmRleCIsInBpY2tlZCIsIkJvb2xlYW4iLCJvYmplY3QiLCJjZWxsIiwiY29sb3JEb21haW4iLCJlbGV2YXRpb25Eb21haW4iLCJpZCIsImRhdGEiLCJhbmdsZSIsIlBJIiwiZ2V0Q29sb3IiLCJfb25HZXRTdWJsYXllckNvbG9yIiwiYmluZCIsImdldEVsZXZhdGlvbiIsIl9vbkdldFN1YmxheWVyRWxldmF0aW9uIiwib25Ib3ZlciIsIl9vbkhvdmVyU3VibGF5ZXIiLCJvbkNsaWNrIiwidXBkYXRlVHJpZ2dlcnMiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxLQUFSLFFBQW9CLGNBQXBCO0FBQ0EsT0FBT0MsWUFBUCxNQUF5QixnQ0FBekI7QUFDQSxTQUFRQyxHQUFSLFFBQWtCLG9CQUFsQjs7QUFFQSxTQUFRQyxZQUFSLEVBQXNCQyxXQUF0QixRQUF3Qyw0QkFBeEM7QUFDQSxTQUFRQyxpQkFBUixRQUFnQyw0QkFBaEM7QUFDQSxTQUFRQyxhQUFSLFFBQTRCLHNCQUE1Qjs7QUFFQSxJQUFNQyxnQkFBZ0IsSUFBdEI7QUFDQSxJQUFNQyxrQkFBa0IsQ0FBeEI7QUFDQSxJQUFNQyx3QkFBd0IsQ0FBQyxDQUFELEVBQUksSUFBSixDQUE5QjtBQUNBLElBQU1DLHdCQUF3QixDQUE5QjtBQUNBLElBQU1DLG9CQUFvQkwsYUFBMUI7O0FBRUEsSUFBTU0sZUFBZTtBQUNuQkMsY0FBWVIsaUJBRE87QUFFbkJTLGtCQUFnQkwscUJBRkc7QUFHbkJNLGtCQUFnQkwscUJBSEc7QUFJbkJNLFVBQVFULGFBSlc7QUFLbkJVLFlBQVVULGVBTFM7QUFNbkJVLHFCQUFtQlAsaUJBTkE7QUFPbkJRLGVBQWE7QUFBQSxXQUFLQyxFQUFFQyxRQUFQO0FBQUE7QUFQTSxDQUFyQjs7QUFVQSxTQUFTQyxJQUFULEdBQWdCLENBQUU7O0FBRWxCLFNBQVNDLHFCQUFULENBQStCQyxRQUEvQixFQUF5Q0MsS0FBekMsRUFBZ0Q7QUFDOUMsU0FBT0QsU0FBU1IsTUFBVCxLQUFvQlMsTUFBTVQsTUFBakM7QUFDRDs7QUFFRCxTQUFTVSxjQUFULENBQXdCQyxRQUF4QixFQUFrQztBQUNoQyxTQUFPLENB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LGFBQU9uQyxZQUFZb0QsZUFBWixFQUE2QjFDLGNBQTdCLEVBQTZDd0MsS0FBS3JCLE1BQUwsQ0FBWUMsTUFBekQsQ0FBUDtBQUNEOzs7bUNBRWM7QUFBQSxtQkFDUSxLQUFLVCxLQURiO0FBQUEsVUFDTmdDLEVBRE0sVUFDTkEsRUFETTtBQUFBLFVBQ0Z6QyxNQURFLFVBQ0ZBLE1BREU7OztBQUdiLGFBQU8sSUFBSWYsWUFBSixDQUFpQjRDLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQ3RCLEtBQUtyQixLQURpQixFQUNWO0FBQ1ZnQyxZQUFPQSxFQUFQLHFCQURVO0FBRVZDLGNBQU0sS0FBS3BCLEtBQUwsQ0FBV1gsUUFGUDtBQUdWWCxzQkFIVTtBQUlWMkMsZUFBTy9CLEtBQUtnQyxFQUpGO0FBS1ZDLGtCQUFVLEtBQUtDLG1CQUFMLENBQXlCQyxJQUF6QixDQUE4QixJQUE5QixDQUxBO0FBTVZDLHNCQUFjLEtBQUtDLHVCQUFMLENBQTZCRixJQUE3QixDQUFrQyxJQUFsQyxDQU5KO0FBT1Y7QUFDQUcsaUJBQVMsS0FBS0MsZ0JBQUwsQ0FBc0JKLElBQXRCLENBQTJCLElBQTNCLENBUkM7QUFTVkssaUJBQVM5QyxJQVRDO0FBVVYrQyx3QkFBZ0I7QUFDZFIsb0JBQVUsRUFBQ2hELFlBQVksS0FBS1ksS0FBTCxDQUFXWixVQUF4QixFQURJO0FBRWRtRCx3QkFBYyxFQUFDbEQsZ0JBQWdCLEtBQUtXLEtBQUwsQ0FBV1gsY0FBNUI7QUFGQTtBQVZOLE9BRFUsQ0FBakIsQ0FBUDtBQWdCRDs7OztFQXBGbURkLEs7O2VBQWpDb0Msd0I7OztBQXVGckJBLHlCQUF5QmtDLFNBQXpCLEdBQXFDLDBCQUFyQztBQUNBbEMseUJBQXlCeEIsWUFBekIsR0FBd0NBLFlBQXhDIiwiZmlsZSI6InBvaW50LWRlbnNpdHktaGV4YWdvbi1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgSGV4YWdvbkxheWVyIGZyb20gJy4uL2hleGFnb24tbGF5ZXIvaGV4YWdvbi1sYXllcic7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcblxuaW1wb3J0IHtvcmRpbmFsU2NhbGUsIGxpbmVhclNjYWxlfSBmcm9tICcuLi8uLi8uLi91dGlscy9zY2FsZS11dGlscyc7XG5pbXBvcnQge2RlZmF1bHRDb2xvclJhbmdlfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb2xvci11dGlscyc7XG5pbXBvcnQge3BvaW50VG9IZXhiaW59IGZyb20gJy4vaGV4YWdvbi1hZ2dyZWdhdG9yJztcblxuY29uc3QgZGVmYXVsdFJhZGl1cyA9IDEwMDA7XG5jb25zdCBkZWZhdWx0Q292ZXJhZ2UgPSAxO1xuY29uc3QgZGVmYXVsdEVsZXZhdGlvblJhbmdlID0gWzAsIDEwMDBdO1xuY29uc3QgZGVmYXVsdEVsZXZhdGlvblNjYWxlID0gMTtcbmNvbnN0IGRlZmF1bHRBZ2dyZWdhdG9yID0gcG9pbnRUb0hleGJpbjtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBjb2xvclJhbmdlOiBkZWZhdWx0Q29sb3JSYW5nZSxcbiAgZWxldmF0aW9uUmFuZ2U6IGRlZmF1bHRFbGV2YXRpb25SYW5nZSxcbiAgZWxldmF0aW9uU2NhbGU6IGRlZmF1bHRFbGV2YXRpb25TY2FsZSxcbiAgcmFkaXVzOiBkZWZhdWx0UmFkaXVzLFxuICBjb3ZlcmFnZTogZGVmYXVsdENvdmVyYWdlLFxuICBoZXhhZ29uQWdncmVnYXRvcjogZGVmYXVsdEFnZ3JlZ2F0b3IsXG4gIGdldFBvc2l0aW9uOiB4ID0+IHgucG9zaXRpb25cbn07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBfbmVlZHNSZVByb2plY3RQb2ludHMob2xkUHJvcHMsIHByb3BzKSB7XG4gIHJldHVybiBvbGRQcm9wcy5yYWRpdXMgIT09IHByb3BzLnJhZGl1cztcbn1cblxuZnVuY3Rpb24gX2dldENvdW50UmFuZ2UoaGV4YWdvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICBNYXRoLm1pbi5hcHBseShudWxsLCBoZXhhZ29ucy5tYXAoYmluID0+IGJpbi5wb2ludHMubGVuZ3RoKSksXG4gICAgTWF0aC5tYXguYXBwbHkobnVsbCwgaGV4YWdvbnMubWFwKGJpbiA9PiBiaW4ucG9pbnRzLmxlbmd0aCkpXG4gIF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50RGVuc2l0eUhleGFnb25MYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLnJhZGl1cykge1xuICAgICAgbG9nLm9uY2UoMCwgJ1BvaW50RGVuc2l0eUhleGFnb25MYXllcjogcmFkaXVzIGluIG1ldGVyIGlzIG5lZWRlZCB0byBhZ2dyZWdhdGUgcG9pbnRzIGludG8gJyArXG4gICAgICAgICdoZXhhZ29uYWwgYmlucywgTm93IHVzaW5nIDEwMDAgbWV0ZXIgYXMgZGVmYXVsdCcpO1xuXG4gICAgICBwcm9wcy5yYWRpdXMgPSBkZWZhdWx0UmFkaXVzO1xuICAgIH1cblxuICAgIHN1cGVyKHByb3BzKTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaGV4YWdvbnM6IFtdLFxuICAgICAgY291bnRSYW5nZTogbnVsbCxcbiAgICAgIHBpY2tlZENlbGw6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkIHx8IF9uZWVkc1JlUHJvamVjdFBvaW50cyhvbGRQcm9wcywgcHJvcHMpKSB7XG4gICAgICBjb25zdCB7aGV4YWdvbkFnZ3JlZ2F0b3J9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGNvbnN0IGhleGFnb25zID0gaGV4YWdvbkFnZ3JlZ2F0b3IodGhpcy5wcm9wcywgdmlld3BvcnQpO1xuICAgICAgY29uc3QgY291bnRSYW5nZSA9IF9nZXRDb3VudFJhbmdlKGhleGFnb25zKTtcblxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCB7aGV4YWdvbnMsIGNvdW50UmFuZ2V9KTtcbiAgICB9XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyhvcHRzKSB7XG4gICAgY29uc3QgaW5mbyA9IHN1cGVyLmdldFBpY2tpbmdJbmZvKG9wdHMpO1xuICAgIGNvbnN0IHBpY2tlZENlbGwgPSB0aGlzLnN0YXRlLnBpY2tlZENlbGw7XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihpbmZvLCB7XG4gICAgICBsYXllcjogdGhpcyxcbiAgICAgIC8vIG92ZXJyaWRlIGluZGV4IHdpdGggY2VsbCBpbmRleFxuICAgICAgaW5kZXg6IHBpY2tlZENlbGwgPyBwaWNrZWRDZWxsLmluZGV4IDogLTEsXG4gICAgICBwaWNrZWQ6IEJvb2xlYW4ocGlja2VkQ2VsbCksXG4gICAgICAvLyBvdmVycmlkZSBvYmplY3Qgd2l0aCBwaWNrZWQgY2VsbFxuICAgICAgb2JqZWN0OiBwaWNrZWRDZWxsXG4gICAgfSk7XG4gIH1cblxuICBfb25Ib3ZlclN1YmxheWVyKGluZm8pIHtcblxuICAgIHRoaXMuc3RhdGUucGlja2VkQ2VsbCA9IGluZm8ucGlja2VkICYmIGluZm8uaW5kZXggPiAtMSA/XG4gICAgICB0aGlzLnN0YXRlLmhleGFnb25zW2luZm8uaW5kZXhdIDogbnVsbDtcbiAgfVxuXG4gIF9vbkdldFN1YmxheWVyQ29sb3IoY2VsbCkge1xuICAgIGNvbnN0IHtjb2xvclJhbmdlfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgY29sb3JEb21haW4gPSB0aGlzLnByb3BzLmNvbG9yRG9tYWluIHx8IHRoaXMuc3RhdGUuY291bnRSYW5nZTtcblxuICAgIHJldHVybiBvcmRpbmFsU2NhbGUoY29sb3JEb21haW4sIGNvbG9yUmFuZ2UsIGNlbGwucG9pbnRzLmxlbmd0aCk7XG4gIH1cblxuICBfb25HZXRTdWJsYXllckVsZXZhdGlvbihjZWxsKSB7XG4gICAgY29uc3Qge2VsZXZhdGlvblJhbmdlfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZWxldmF0aW9uRG9tYWluID0gdGhpcy5wcm9wcy5lbGV2YXRpb25Eb21haW4gfHwgWzAsIHRoaXMuc3RhdGUuY291bnRSYW5nZVsxXV07XG4gICAgcmV0dXJuIGxpbmVhclNjYWxlKGVsZXZhdGlvbkRvbWFpbiwgZWxldmF0aW9uUmFuZ2UsIGNlbGwucG9pbnRzLmxlbmd0aCk7XG4gIH1cblxuICByZW5kZXJMYXllcnMoKSB7XG4gICAgY29uc3Qge2lkLCByYWRpdXN9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiBuZXcgSGV4YWdvbkxheWVyKE9iamVjdC5hc3NpZ24oe30sXG4gICAgICB0aGlzLnByb3BzLCB7XG4gICAgICAgIGlkOiBgJHtpZH0tZGVuc2l0eS1oZXhhZ29uYCxcbiAgICAgICAgZGF0YTogdGhpcy5zdGF0ZS5oZXhhZ29ucyxcbiAgICAgICAgcmFkaXVzLFxuICAgICAgICBhbmdsZTogTWF0aC5QSSxcbiAgICAgICAgZ2V0Q29sb3I6IHRoaXMuX29uR2V0U3VibGF5ZXJDb2xvci5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRFbGV2YXRpb246IHRoaXMuX29uR2V0U3VibGF5ZXJFbGV2YXRpb24uYmluZCh0aGlzKSxcbiAgICAgICAgLy8gT3ZlcnJpZGUgdXNlcidzIG9uSG92ZXIgYW5kIG9uQ2xpY2sgcHJvcHNcbiAgICAgICAgb25Ib3ZlcjogdGhpcy5fb25Ib3ZlclN1YmxheWVyLmJpbmQodGhpcyksXG4gICAgICAgIG9uQ2xpY2s6IG5vb3AsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0Q29sb3I6IHtjb2xvclJhbmdlOiB0aGlzLnByb3BzLmNvbG9yUmFuZ2V9LFxuICAgICAgICAgIGdldEVsZXZhdGlvbjoge2VsZXZhdGlvblJhbmdlOiB0aGlzLnByb3BzLmVsZXZhdGlvblJhbmdlfVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gIH1cbn1cblxuUG9pbnREZW5zaXR5SGV4YWdvbkxheWVyLmxheWVyTmFtZSA9ICdQb2ludERlbnNpdHlIZXhhZ29uTGF5ZXInO1xuUG9pbnREZW5zaXR5SGV4YWdvbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==