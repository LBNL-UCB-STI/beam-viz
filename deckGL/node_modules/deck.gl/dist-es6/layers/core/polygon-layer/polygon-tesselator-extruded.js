var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import * as Polygon from './polygon';
// import {getPolygonVertexCount, getPolygonTriangleCount} from './polygon';
import earcut from 'earcut';
import flattenDeep from 'lodash.flattendeep';
import { vec3 } from 'gl-matrix';
import { fp64ify } from '../../../lib/utils/fp64';
import { Container } from '../../../lib/utils';
// import {Container, flattenVertices, fillArray} from '../../../lib/utils';

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

export var PolygonTesselatorExtruded = function () {
  function PolygonTesselatorExtruded(_ref) {
    var polygons = _ref.polygons,
        _ref$getHeight = _ref.getHeight,
        getHeight = _ref$getHeight === undefined ? function (x) {
      return 1000;
    } : _ref$getHeight,
        _ref$getColor = _ref.getColor,
        getColor = _ref$getColor === undefined ? function (x) {
      return [0, 0, 0, 255];
    } : _ref$getColor,
        _ref$wireframe = _ref.wireframe,
        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,
        _ref$fp = _ref.fp64,
        fp64 = _ref$fp === undefined ? false : _ref$fp;

    _classCallCheck(this, PolygonTesselatorExtruded);

    this.fp64 = fp64;

    // Expensive operation, convert all polygons to arrays
    polygons = Container.map(polygons, function (complexPolygon, polygonIndex) {
      var height = getHeight(polygonIndex) || 0;
      return Container.map(Polygon.normalize(complexPolygon), function (polygon) {
        return Container.map(polygon, function (coord) {
          return [coord[0], coord[1], height];
        });
      });
    });

    var groupedVertices = polygons;
    this.groupedVertices = polygons;
    this.wireframe = wireframe;

    this.attributes = {};

    var positionsJS = calculatePositionsJS({ groupedVertices: groupedVertices, wireframe: wireframe });
    Object.assign(this.attributes, {
      positions: calculatePositions(positionsJS, this.fp64),
      indices: calculateIndices({ groupedVertices: groupedVertices, wireframe: wireframe }),
      normals: calculateNormals({ groupedVertices: groupedVertices, wireframe: wireframe }),
      // colors: calculateColors({groupedVertices, wireframe, getColor}),
      pickingColors: calculatePickingColors({ groupedVertices: groupedVertices, wireframe: wireframe })
    });
  }

  _createClass(PolygonTesselatorExtruded, [{
    key: 'indices',
    value: function indices() {
      return this.attributes.indices;
    }
  }, {
    key: 'positions',
    value: function positions() {
      return this.attributes.positions;
    }
  }, {
    key: 'normals',
    value: function normals() {
      return this.attributes.normals;
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$getColor = _ref2.getColor,
          getColor = _ref2$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref2$getColor;

      var groupedVertices = this.groupedVertices,
          wireframe = this.wireframe;

      return calculateColors({ groupedVertices: groupedVertices, wireframe: wireframe, getColor: getColor });
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      return this.attributes.pickingColors;
    }

    // updateTriggers: {
    //   positions: ['getHeight'],
    //   colors: ['getColors']
    //   pickingColors: 'none'
    // }

  }]);

  return PolygonTesselatorExtruded;
}();

function countVertices(vertices) {
  return vertices.reduce(function (count, polygon) {
    return count + polygon.length;
  }, 0);
}

function calculateIndices(_ref3) {
  var groupedVertices = _ref3.groupedVertices,
      _ref3$wireframe = _ref3.wireframe,
      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe;

  // adjust index offset for multiple buildings
  var multiplier = wireframe ? 2 : 5;
  var offsets = groupedVertices.reduce(function (acc, vertices) {
    return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + countVertices(vertices) * multiplier]);
  }, [0]);

  var indices = groupedVertices.map(function (vertices, buildingIndex) {
    return wireframe ?
    // 1. get sequentially ordered indices of each building wireframe
    // 2. offset them by the number of indices in previous buildings
    calculateContourIndices(vertices, offsets[buildingIndex]) :
    // 1. get triangulated indices for the internal areas
    // 2. offset them by the number of indices in previous buildings
    calculateSurfaceIndices(vertices, offsets[buildingIndex]);
  });

  return new Uint32Array(flattenDeep(indices));
}

// Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays
// Remarks:
// * each top vertex is on 3 surfaces
// * each bottom vertex is on 2 surfaces
function calculatePositionsJS(_ref4) {
  var groupedVertices = _ref4.groupedVertices,
      _ref4$wireframe = _ref4.wireframe,
      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;

  var positions = Container.map(groupedVertices, function (complexPolygon) {
    return Container.map(complexPolygon, function (vertices) {
      var topVertices = [].concat(vertices);
      var baseVertices = topVertices.map(function (v) {
        return [v[0], v[1], 0];
      });
      return wireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];
    });
  });
  return flattenDeep(positions);
}

function calculatePositions(positionsJS, fp64) {
  var positionLow = void 0;
  if (fp64) {
    // We only need x, y component
    positionLow = new Float32Array(positionsJS / 3 * 2);
    for (var i = 0; i < positionsJS.length / 3; i++) {
      positionLow[i * 2 + 0] = fp64ify(positionsJS[i * 3 + 0])[1];
      positionLow[i * 2 + 1] = fp64ify(positionsJS[i * 3 + 1])[1];
    }
  }
  return { positions: new Float32Array(positionsJS), positions64xyLow: positionLow };
}

function calculateNormals(_ref5) {
  var groupedVertices = _ref5.groupedVertices,
      wireframe = _ref5.wireframe;

  var up = [0, 1, 0];

  var normals = groupedVertices.map(function (vertices, buildingIndex) {
    var topNormals = new Array(countVertices(vertices)).fill(up);
    var sideNormals = vertices.map(function (polygon) {
      return calculateSideNormals(polygon);
    });
    var sideNormalsForward = sideNormals.map(function (n) {
      return n[0];
    });
    var sideNormalsBackward = sideNormals.map(function (n) {
      return n[1];
    });

    return wireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];
  });

  return new Float32Array(flattenDeep(normals));
}

function calculateSideNormals(vertices) {
  var numVertices = vertices.length;
  var normals = [];

  for (var i = 0; i < numVertices - 1; i++) {
    var n = getNormal(vertices[i], vertices[i + 1]);
    normals.push(n);
  }

  return [[].concat(normals, [normals[0]]), [normals[0]].concat(normals)];
}

/*
function calculateColors({polygons, pointCount, getColor}) {
  const attribute = new Uint8Array(pointCount * 4);
  let i = 0;
  polygons.forEach((complexPolygon, polygonIndex) => {
    // Calculate polygon color
    const color = getColor(polygonIndex);
    color[3] = Number.isFinite(color[3]) ? color[3] : 255;

    const count = Polygon.getVertexCount(complexPolygon);
    fillArray({target: attribute, source: color, start: i, count});
    i += color.length * count;
  });
  return attribute;
}
*/

function calculateColors(_ref6) {
  var groupedVertices = _ref6.groupedVertices,
      getColor = _ref6.getColor,
      _ref6$wireframe = _ref6.wireframe,
      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;

  var colors = groupedVertices.map(function (complexPolygon, polygonIndex) {
    var color = getColor(polygonIndex);
    color[3] = Number.isFinite(color[3]) ? color[3] : 255;

    // const baseColor = Array.isArray(color) ? color[0] : color;
    // const topColor = Array.isArray(color) ? color[color.length - 1] : color;
    var numVertices = countVertices(complexPolygon);
    var topColors = new Array(numVertices).fill(color);
    var baseColors = new Array(numVertices).fill(color);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray(flattenDeep(colors));
}

function calculatePickingColors(_ref7) {
  var groupedVertices = _ref7.groupedVertices,
      _ref7$color = _ref7.color,
      color = _ref7$color === undefined ? [0, 0, 0] : _ref7$color,
      _ref7$wireframe = _ref7.wireframe,
      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;

  var colors = groupedVertices.map(function (vertices, buildingIndex) {
    // const baseColor = Array.isArray(color) ? color[0] : color;
    // const topColor = Array.isArray(color) ? color[color.length - 1] : color;
    var numVertices = countVertices(vertices);
    var topColors = new Array(numVertices).fill([0, 0, 0]);
    var baseColors = new Array(numVertices).fill([0, 0, 0]);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray(flattenDeep(colors));
}

function calculateContourIndices(vertices, offset) {
  var stride = countVertices(vertices);

  return vertices.map(function (polygon) {
    var indices = [offset];
    var numVertices = polygon.length;

    // building top
    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset);

    // building sides
    for (var _i = 0; _i < numVertices - 1; _i++) {
      indices.push(_i + offset, _i + stride + offset);
    }

    offset += numVertices;
    return indices;
  });
}

function calculateSurfaceIndices(vertices, offset) {
  var stride = countVertices(vertices);
  var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];

  function drawRectangle(i) {
    return quad.map(function (v) {
      return i + v[0] + stride * v[1] + offset;
    });
  }

  var holes = null;

  if (vertices.length > 1) {
    holes = vertices.reduce(function (acc, polygon) {
      return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);
    }, [0]).slice(1, vertices.length);
  }

  var topIndices = earcut(flattenDeep(vertices), holes, 3).map(function (index) {
    return index + offset;
  });

  var sideIndices = vertices.map(function (polygon) {
    var numVertices = polygon.length;
    // building top
    var indices = [];

    // building sides
    for (var i = 0; i < numVertices - 1; i++) {
      indices.push.apply(indices, _toConsumableArray(drawRectangle(i)));
    }

    offset += numVertices;
    return indices;
  });

  return [topIndices, sideIndices];
}

// helpers

// get normal vector of line segment
function getNormal(p1, p2) {
  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    return [1, 0, 0];
  }

  var degrees2radians = Math.PI / 180;
  var lon1 = degrees2radians * p1[0];
  var lon2 = degrees2radians * p2[0];
  var lat1 = degrees2radians * p1[1];
  var lat2 = degrees2radians * p2[1];
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return vec3.normalize([], [b, 0, -a]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwiZWFyY3V0IiwiZmxhdHRlbkRlZXAiLCJ2ZWMzIiwiZnA2NGlmeSIsIkNvbnRhaW5lciIsIkRFRkFVTFRfQ09MT1IiLCJQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIiwicG9seWdvbnMiLCJnZXRIZWlnaHQiLCJnZXRDb2xvciIsIndpcmVmcmFtZSIsImZwNjQiLCJtYXAiLCJjb21wbGV4UG9seWdvbiIsInBvbHlnb25JbmRleCIsImhlaWdodCIsIm5vcm1hbGl6ZSIsInBvbHlnb24iLCJjb29yZCIsImdyb3VwZWRWZXJ0aWNlcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbnNKUyIsImNhbGN1bGF0ZVBvc2l0aW9uc0pTIiwiT2JqZWN0IiwiYXNzaWduIiwicG9zaXRpb25zIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwiaW5kaWNlcyIsImNhbGN1bGF0ZUluZGljZXMiLCJub3JtYWxzIiwiY2FsY3VsYXRlTm9ybWFscyIsInBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwiY2FsY3VsYXRlQ29sb3JzIiwiY291bnRWZXJ0aWNlcyIsInZlcnRpY2VzIiwicmVkdWNlIiwiY291bnQiLCJsZW5ndGgiLCJtdWx0aXBsaWVyIiwib2Zmc2V0cyIsImFjYyIsImJ1aWxkaW5nSW5kZXgiLCJjYWxjdWxhdGVDb250b3VySW5kaWNlcyIsImNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzIiwiVWludDMyQXJyYXkiLCJ0b3BWZXJ0aWNlcyIsImNvbmNhdCIsImJhc2VWZXJ0aWNlcyIsInYiLCJwb3NpdGlvbkxvdyIsIkZsb2F0MzJBcnJheSIsImkiLCJwb3NpdGlvbnM2NHh5TG93IiwidXAiLCJ0b3BOb3JtYWxzIiwiQXJyYXkiLCJmaWxsIiwic2lkZU5vcm1hbHMiLCJjYWxjdWxhdGVTaWRlTm9ybWFscyIsInNpZGVOb3JtYWxzRm9yd2FyZCIsIm4iLCJzaWRlTm9ybWFsc0JhY2t3YXJkIiwibnVtVmVydGljZXMiLCJnZXROb3JtYWwiLCJwdXNoIiwiY29sb3JzIiwiY29sb3IiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInRvcENvbG9ycyIsImJhc2VDb2xvcnMiLCJVaW50OENsYW1wZWRBcnJheSIsIm9mZnNldCIsInN0cmlkZSIsInF1YWQiLCJkcmF3UmVjdGFuZ2xlIiwiaG9sZXMiLCJzbGljZSIsInRvcEluZGljZXMiLCJpbmRleCIsInNpZGVJbmRpY2VzIiwicDEiLCJwMiIsImRlZ3JlZXMycmFkaWFucyIsIk1hdGgiLCJQSSIsImxvbjEiLCJsb24yIiwibGF0MSIsImxhdDIiLCJhIiwic2luIiwiY29zIiwiYiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBTyxLQUFLQSxPQUFaLE1BQXlCLFdBQXpCO0FBQ0E7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5CO0FBQ0EsT0FBT0MsV0FBUCxNQUF3QixvQkFBeEI7QUFDQSxTQUFRQyxJQUFSLFFBQW1CLFdBQW5CO0FBQ0EsU0FBUUMsT0FBUixRQUFzQix5QkFBdEI7QUFDQSxTQUFRQyxTQUFSLFFBQXdCLG9CQUF4QjtBQUNBOztBQUVBLElBQU1DLGdCQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLEdBQVYsQ0FBdEIsQyxDQUFzQzs7QUFFdEMsV0FBYUMseUJBQWI7QUFFRSwyQ0FNRztBQUFBLFFBTERDLFFBS0MsUUFMREEsUUFLQztBQUFBLDhCQUpEQyxTQUlDO0FBQUEsUUFKREEsU0FJQyxrQ0FKVztBQUFBLGFBQUssSUFBTDtBQUFBLEtBSVg7QUFBQSw2QkFIREMsUUFHQztBQUFBLFFBSERBLFFBR0MsaUNBSFU7QUFBQSxhQUFLLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsR0FBVixDQUFMO0FBQUEsS0FHVjtBQUFBLDhCQUZEQyxTQUVDO0FBQUEsUUFGREEsU0FFQyxrQ0FGVyxLQUVYO0FB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SixLQUFLTyxHQUFMLENBQVNGLElBQVQsQ0FBakIsR0FDUkwsS0FBS08sR0FBTCxDQUFTSCxJQUFULElBQWlCSixLQUFLUSxHQUFMLENBQVNILElBQVQsQ0FBakIsR0FBa0NMLEtBQUtRLEdBQUwsQ0FBU0wsT0FBT0QsSUFBaEIsQ0FEcEM7QUFFQSxTQUFPckYsS0FBS2MsU0FBTCxDQUFlLEVBQWYsRUFBbUIsQ0FBQzhFLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQ0gsQ0FBUixDQUFuQixDQUFQO0FBQ0QiLCJmaWxlIjoicG9seWdvbi10ZXNzZWxhdG9yLWV4dHJ1ZGVkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUG9seWdvbiBmcm9tICcuL3BvbHlnb24nO1xuLy8gaW1wb3J0IHtnZXRQb2x5Z29uVmVydGV4Q291bnQsIGdldFBvbHlnb25UcmlhbmdsZUNvdW50fSBmcm9tICcuL3BvbHlnb24nO1xuaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xuaW1wb3J0IGZsYXR0ZW5EZWVwIGZyb20gJ2xvZGFzaC5mbGF0dGVuZGVlcCc7XG5pbXBvcnQge3ZlYzN9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQge2ZwNjRpZnl9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCB7Q29udGFpbmVyfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuLy8gaW1wb3J0IHtDb250YWluZXIsIGZsYXR0ZW5WZXJ0aWNlcywgZmlsbEFycmF5fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07IC8vIEJsYWNrXG5cbmV4cG9ydCBjbGFzcyBQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIHtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgcG9seWdvbnMsXG4gICAgZ2V0SGVpZ2h0ID0geCA9PiAxMDAwLFxuICAgIGdldENvbG9yID0geCA9PiBbMCwgMCwgMCwgMjU1XSxcbiAgICB3aXJlZnJhbWUgPSBmYWxzZSxcbiAgICBmcDY0ID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuZnA2NCA9IGZwNjQ7XG5cbiAgICAvLyBFeHBlbnNpdmUgb3BlcmF0aW9uLCBjb252ZXJ0IGFsbCBwb2x5Z29ucyB0byBhcnJheXNcbiAgICBwb2x5Z29ucyA9IENvbnRhaW5lci5tYXAocG9seWdvbnMsIChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBnZXRIZWlnaHQocG9seWdvbkluZGV4KSB8fCAwO1xuICAgICAgcmV0dXJuIENvbnRhaW5lci5tYXAoUG9seWdvbi5ub3JtYWxpemUoY29tcGxleFBvbHlnb24pLFxuICAgICAgICBwb2x5Z29uID0+IENvbnRhaW5lci5tYXAocG9seWdvbiwgY29vcmQgPT4gW2Nvb3JkWzBdLCBjb29yZFsxXSwgaGVpZ2h0XSkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ3JvdXBlZFZlcnRpY2VzID0gcG9seWdvbnM7XG4gICAgdGhpcy5ncm91cGVkVmVydGljZXMgPSBwb2x5Z29ucztcbiAgICB0aGlzLndpcmVmcmFtZSA9IHdpcmVmcmFtZTtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgY29uc3QgcG9zaXRpb25zSlMgPSBjYWxjdWxhdGVQb3NpdGlvbnNKUyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcywge1xuICAgICAgcG9zaXRpb25zOiBjYWxjdWxhdGVQb3NpdGlvbnMocG9zaXRpb25zSlMsIHRoaXMuZnA2NCksXG4gICAgICBpbmRpY2VzOiBjYWxjdWxhdGVJbmRpY2VzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0pLFxuICAgICAgbm9ybWFsczogY2FsY3VsYXRlTm9ybWFscyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KSxcbiAgICAgIC8vIGNvbG9yczogY2FsY3VsYXRlQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSwgZ2V0Q29sb3J9KSxcbiAgICAgIHBpY2tpbmdDb2xvcnM6IGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSlcbiAgICB9KTtcbiAgfVxuXG4gIGluZGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5pbmRpY2VzO1xuICB9XG5cbiAgcG9zaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb25zO1xuICB9XG5cbiAgbm9ybWFscygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbHM7XG4gIH1cblxuICBjb2xvcnMoe2dldENvbG9yID0geCA9PiBERUZBVUxUX0NPTE9SfSA9IHt9KSB7XG4gICAgY29uc3Qge2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSA9IHRoaXM7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUsIGdldENvbG9yfSk7XG4gIH1cblxuICBwaWNraW5nQ29sb3JzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMucGlja2luZ0NvbG9ycztcbiAgfVxuXG4gIC8vIHVwZGF0ZVRyaWdnZXJzOiB7XG4gIC8vICAgcG9zaXRpb25zOiBbJ2dldEhlaWdodCddLFxuICAvLyAgIGNvbG9yczogWydnZXRDb2xvcnMnXVxuICAvLyAgIHBpY2tpbmdDb2xvcnM6ICdub25lJ1xuICAvLyB9XG59XG5cbmZ1bmN0aW9uIGNvdW50VmVydGljZXModmVydGljZXMpIHtcbiAgcmV0dXJuIHZlcnRpY2VzLnJlZHVjZSgoY291bnQsIHBvbHlnb24pID0+IGNvdW50ICsgcG9seWdvbi5sZW5ndGgsIDApO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJbmRpY2VzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSA9IGZhbHNlfSkge1xuICAvLyBhZGp1c3QgaW5kZXggb2Zmc2V0IGZvciBtdWx0aXBsZSBidWlsZGluZ3NcbiAgY29uc3QgbXVsdGlwbGllciA9IHdpcmVmcmFtZSA/IDIgOiA1O1xuICBjb25zdCBvZmZzZXRzID0gZ3JvdXBlZFZlcnRpY2VzLnJlZHVjZShcbiAgICAoYWNjLCB2ZXJ0aWNlcykgPT5cbiAgICAgIFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSAqIG11bHRpcGxpZXJdLFxuICAgIFswXVxuICApO1xuXG4gIGNvbnN0IGluZGljZXMgPSBncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgYnVpbGRpbmdJbmRleCkgPT5cbiAgICB3aXJlZnJhbWUgP1xuICAgICAgLy8gMS4gZ2V0IHNlcXVlbnRpYWxseSBvcmRlcmVkIGluZGljZXMgb2YgZWFjaCBidWlsZGluZyB3aXJlZnJhbWVcbiAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBidWlsZGluZ3NcbiAgICAgIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXRzW2J1aWxkaW5nSW5kZXhdKSA6XG4gICAgICAvLyAxLiBnZXQgdHJpYW5ndWxhdGVkIGluZGljZXMgZm9yIHRoZSBpbnRlcm5hbCBhcmVhc1xuICAgICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIGJ1aWxkaW5nc1xuICAgICAgY2FsY3VsYXRlU3VyZmFjZUluZGljZXModmVydGljZXMsIG9mZnNldHNbYnVpbGRpbmdJbmRleF0pXG4gICk7XG5cbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShmbGF0dGVuRGVlcChpbmRpY2VzKSk7XG59XG5cbi8vIENhbGN1bGF0ZSBhIGZsYXQgcG9zaXRpb24gYXJyYXkgaW4gSlMgLSBjYW4gYmUgbWFwcGVkIHRvIDMyIG9yIDY0IGJpdCB0eXBlZCBhcnJheXNcbi8vIFJlbWFya3M6XG4vLyAqIGVhY2ggdG9wIHZlcnRleCBpcyBvbiAzIHN1cmZhY2VzXG4vLyAqIGVhY2ggYm90dG9tIHZlcnRleCBpcyBvbiAyIHN1cmZhY2VzXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbnNKUyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgY29uc3QgcG9zaXRpb25zID0gQ29udGFpbmVyLm1hcChncm91cGVkVmVydGljZXMsIGNvbXBsZXhQb2x5Z29uID0+XG4gICAgQ29udGFpbmVyLm1hcChjb21wbGV4UG9seWdvbiwgdmVydGljZXMgPT4ge1xuICAgICAgY29uc3QgdG9wVmVydGljZXMgPSBbXS5jb25jYXQodmVydGljZXMpO1xuICAgICAgY29uc3QgYmFzZVZlcnRpY2VzID0gdG9wVmVydGljZXMubWFwKHYgPT4gW3ZbMF0sIHZbMV0sIDBdKTtcbiAgICAgIHJldHVybiB3aXJlZnJhbWUgP1xuICAgICAgICBbdG9wVmVydGljZXMsIGJhc2VWZXJ0aWNlc10gOlxuICAgICAgICBbdG9wVmVydGljZXMsIHRvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzLCBiYXNlVmVydGljZXNdO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiBmbGF0dGVuRGVlcChwb3NpdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbnMocG9zaXRpb25zSlMsIGZwNjQpIHtcbiAgbGV0IHBvc2l0aW9uTG93O1xuICBpZiAoZnA2NCkge1xuICAgIC8vIFdlIG9ubHkgbmVlZCB4LCB5IGNvbXBvbmVudFxuICAgIHBvc2l0aW9uTG93ID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnNKUyAvIDMgKiAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uc0pTLmxlbmd0aCAvIDM7IGkrKykge1xuICAgICAgcG9zaXRpb25Mb3dbaSAqIDIgKyAwXSA9IGZwNjRpZnkocG9zaXRpb25zSlNbaSAqIDMgKyAwXSlbMV07XG4gICAgICBwb3NpdGlvbkxvd1tpICogMiArIDFdID0gZnA2NGlmeShwb3NpdGlvbnNKU1tpICogMyArIDFdKVsxXTtcbiAgICB9XG5cbiAgfVxuICByZXR1cm4ge3Bvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnNKUyksIHBvc2l0aW9uczY0eHlMb3c6IHBvc2l0aW9uTG93fTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTm9ybWFscyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KSB7XG4gIGNvbnN0IHVwID0gWzAsIDEsIDBdO1xuXG4gIGNvbnN0IG5vcm1hbHMgPSBncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgYnVpbGRpbmdJbmRleCkgPT4ge1xuICAgIGNvbnN0IHRvcE5vcm1hbHMgPSBuZXcgQXJyYXkoY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykpLmZpbGwodXApO1xuICAgIGNvbnN0IHNpZGVOb3JtYWxzID0gdmVydGljZXMubWFwKHBvbHlnb24gPT4gY2FsY3VsYXRlU2lkZU5vcm1hbHMocG9seWdvbikpO1xuICAgIGNvbnN0IHNpZGVOb3JtYWxzRm9yd2FyZCA9IHNpZGVOb3JtYWxzLm1hcChuID0+IG5bMF0pO1xuICAgIGNvbnN0IHNpZGVOb3JtYWxzQmFja3dhcmQgPSBzaWRlTm9ybWFscy5tYXAobiA9PiBuWzFdKTtcblxuICAgIHJldHVybiB3aXJlZnJhbWUgP1xuICAgIFt0b3BOb3JtYWxzLCB0b3BOb3JtYWxzXSA6XG4gICAgW3RvcE5vcm1hbHMsIHNpZGVOb3JtYWxzRm9yd2FyZCwgc2lkZU5vcm1hbHNCYWNrd2FyZCwgc2lkZU5vcm1hbHNGb3J3YXJkLCBzaWRlTm9ybWFsc0JhY2t3YXJkXTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZmxhdHRlbkRlZXAobm9ybWFscykpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTaWRlTm9ybWFscyh2ZXJ0aWNlcykge1xuICBjb25zdCBudW1WZXJ0aWNlcyA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgY29uc3Qgbm9ybWFscyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICBjb25zdCBuID0gZ2V0Tm9ybWFsKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tpICsgMV0pO1xuICAgIG5vcm1hbHMucHVzaChuKTtcbiAgfVxuXG4gIHJldHVybiBbWy4uLm5vcm1hbHMsIG5vcm1hbHNbMF1dLCBbbm9ybWFsc1swXSwgLi4ubm9ybWFsc11dO1xufVxuXG4vKlxuZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3JzKHtwb2x5Z29ucywgcG9pbnRDb3VudCwgZ2V0Q29sb3J9KSB7XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBVaW50OEFycmF5KHBvaW50Q291bnQgKiA0KTtcbiAgbGV0IGkgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgLy8gQ2FsY3VsYXRlIHBvbHlnb24gY29sb3JcbiAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgY29sb3JbM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTU7XG5cbiAgICBjb25zdCBjb3VudCA9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQoY29tcGxleFBvbHlnb24pO1xuICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBhdHRyaWJ1dGUsIHNvdXJjZTogY29sb3IsIHN0YXJ0OiBpLCBjb3VudH0pO1xuICAgIGkgKz0gY29sb3IubGVuZ3RoICogY291bnQ7XG4gIH0pO1xuICByZXR1cm4gYXR0cmlidXRlO1xufVxuKi9cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3JzKHtncm91cGVkVmVydGljZXMsIGdldENvbG9yLCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgY29uc3QgY29sb3JzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcCgoY29tcGxleFBvbHlnb24sIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3IocG9seWdvbkluZGV4KTtcbiAgICBjb2xvclszXSA9IE51bWJlci5pc0Zpbml0ZShjb2xvclszXSkgPyBjb2xvclszXSA6IDI1NTtcblxuICAgIC8vIGNvbnN0IGJhc2VDb2xvciA9IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3JbMF0gOiBjb2xvcjtcbiAgICAvLyBjb25zdCB0b3BDb2xvciA9IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3JbY29sb3IubGVuZ3RoIC0gMV0gOiBjb2xvcjtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IGNvdW50VmVydGljZXMoY29tcGxleFBvbHlnb24pO1xuICAgIGNvbnN0IHRvcENvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgY29uc3QgYmFzZUNvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgcmV0dXJuIHdpcmVmcmFtZSA/XG4gICAgICBbdG9wQ29sb3JzLCBiYXNlQ29sb3JzXSA6XG4gICAgICBbdG9wQ29sb3JzLCB0b3BDb2xvcnMsIHRvcENvbG9ycywgYmFzZUNvbG9ycywgYmFzZUNvbG9yc107XG4gIH0pO1xuICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGZsYXR0ZW5EZWVwKGNvbG9ycykpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHtncm91cGVkVmVydGljZXMsIGNvbG9yID0gWzAsIDAsIDBdLCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgY29uc3QgY29sb3JzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcCgodmVydGljZXMsIGJ1aWxkaW5nSW5kZXgpID0+IHtcbiAgICAvLyBjb25zdCBiYXNlQ29sb3IgPSBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yWzBdIDogY29sb3I7XG4gICAgLy8gY29uc3QgdG9wQ29sb3IgPSBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yW2NvbG9yLmxlbmd0aCAtIDFdIDogY29sb3I7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcbiAgICBjb25zdCB0b3BDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoWzAsIDAsIDBdKTtcbiAgICBjb25zdCBiYXNlQ29sb3JzID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKS5maWxsKFswLCAwLCAwXSk7XG4gICAgcmV0dXJuIHdpcmVmcmFtZSA/XG4gICAgICBbdG9wQ29sb3JzLCBiYXNlQ29sb3JzXSA6XG4gICAgICBbdG9wQ29sb3JzLCB0b3BDb2xvcnMsIHRvcENvbG9ycywgYmFzZUNvbG9ycywgYmFzZUNvbG9yc107XG4gIH0pO1xuICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGZsYXR0ZW5EZWVwKGNvbG9ycykpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gIGNvbnN0IHN0cmlkZSA9IGNvdW50VmVydGljZXModmVydGljZXMpO1xuXG4gIHJldHVybiB2ZXJ0aWNlcy5tYXAocG9seWdvbiA9PiB7XG4gICAgY29uc3QgaW5kaWNlcyA9IFtvZmZzZXRdO1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG5cbiAgICAvLyBidWlsZGluZyB0b3BcbiAgICAvLyB1c2UgdmVydGV4IHBhaXJzIGZvciBHTC5MSU5FUyA9PiBbMCwgMSwgMSwgMiwgMiwgLi4uLCBuLTEsIG4tMSwgMF1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIG9mZnNldCk7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChvZmZzZXQpO1xuXG4gICAgLy8gYnVpbGRpbmcgc2lkZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIHN0cmlkZSArIG9mZnNldCk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU3VyZmFjZUluZGljZXModmVydGljZXMsIG9mZnNldCkge1xuICBjb25zdCBzdHJpZGUgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcbiAgY29uc3QgcXVhZCA9IFtcbiAgICBbMCwgMV0sIFswLCAzXSwgWzEsIDJdLFxuICAgIFsxLCAyXSwgWzAsIDNdLCBbMSwgNF1cbiAgXTtcblxuICBmdW5jdGlvbiBkcmF3UmVjdGFuZ2xlKGkpIHtcbiAgICByZXR1cm4gcXVhZC5tYXAodiA9PiBpICsgdlswXSArIHN0cmlkZSAqIHZbMV0gKyBvZmZzZXQpO1xuICB9XG5cbiAgbGV0IGhvbGVzID0gbnVsbDtcblxuICBpZiAodmVydGljZXMubGVuZ3RoID4gMSkge1xuICAgIGhvbGVzID0gdmVydGljZXMucmVkdWNlKFxuICAgICAgKGFjYywgcG9seWdvbikgPT4gWy4uLmFjYywgYWNjW2FjYy5sZW5ndGggLSAxXSArIHBvbHlnb24ubGVuZ3RoXSxcbiAgICAgIFswXVxuICAgICkuc2xpY2UoMSwgdmVydGljZXMubGVuZ3RoKTtcbiAgfVxuXG4gIGNvbnN0IHRvcEluZGljZXMgPSBlYXJjdXQoZmxhdHRlbkRlZXAodmVydGljZXMpLCBob2xlcywgMykubWFwKGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0KTtcblxuICBjb25zdCBzaWRlSW5kaWNlcyA9IHZlcnRpY2VzLm1hcChwb2x5Z29uID0+IHtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuICAgIC8vIGJ1aWxkaW5nIHRvcFxuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcblxuICAgIC8vIGJ1aWxkaW5nIHNpZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKC4uLmRyYXdSZWN0YW5nbGUoaSkpO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfSk7XG5cbiAgcmV0dXJuIFt0b3BJbmRpY2VzLCBzaWRlSW5kaWNlc107XG59XG5cbi8vIGhlbHBlcnNcblxuLy8gZ2V0IG5vcm1hbCB2ZWN0b3Igb2YgbGluZSBzZWdtZW50XG5mdW5jdGlvbiBnZXROb3JtYWwocDEsIHAyKSB7XG4gIGlmIChwMVswXSA9PT0gcDJbMF0gJiYgcDFbMV0gPT09IHAyWzFdKSB7XG4gICAgcmV0dXJuIFsxLCAwLCAwXTtcbiAgfVxuXG4gIGNvbnN0IGRlZ3JlZXMycmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG4gIGNvbnN0IGxvbjEgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMVswXTtcbiAgY29uc3QgbG9uMiA9IGRlZ3JlZXMycmFkaWFucyAqIHAyWzBdO1xuICBjb25zdCBsYXQxID0gZGVncmVlczJyYWRpYW5zICogcDFbMV07XG4gIGNvbnN0IGxhdDIgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMlsxXTtcbiAgY29uc3QgYSA9IE1hdGguc2luKGxvbjIgLSBsb24xKSAqIE1hdGguY29zKGxhdDIpO1xuICBjb25zdCBiID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsYXQyKSAtXG4gICAgTWF0aC5zaW4obGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGxvbjIgLSBsb24xKTtcbiAgcmV0dXJuIHZlYzMubm9ybWFsaXplKFtdLCBbYiwgMCwgLWFdKTtcbn1cbiJdfQ==