var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { CompositeLayer, get } from '../../../lib';
import ScatterplotLayer from '../scatterplot-layer/scatterplot-layer';
import PathLayer from '../path-layer/path-layer';
import PolygonLayer from '../polygon-layer/polygon-layer';

import { getGeojsonFeatures, separateGeojsonFeatures } from './geojson';

var defaultPointColor = [0xFF, 0x88, 0x00, 0xFF];
var defaultStrokeColor = [0x33, 0x33, 0x33, 0xFF];
var defaultFillColor = [0xBD, 0xE2, 0x7A, 0xFF];

var defaultProps = {
  drawPoints: true,
  drawLines: true,
  drawPolygons: true,
  fillPolygons: true,
  // extrudePolygons: false,
  // wireframe: false,

  // Point accessors
  getPointColor: function getPointColor(f) {
    return get(f, 'properties.color') || defaultPointColor;
  },
  getPointSize: function getPointSize(f) {
    return get(f, 'properties.size') || 5;
  },

  // Line and polygon outline accessors
  getStrokeColor: function getStrokeColor(f) {
    return get(f, 'properties.strokeColor') || defaultStrokeColor;
  },
  getStrokeWidth: function getStrokeWidth(f) {
    return get(f, 'properties.strokeWidth') || 1;
  },

  // Polygon fill accessors
  getFillColor: function getFillColor(f) {
    return get(f, 'properties.fillColor') || defaultFillColor;
  },

  // Polygon extrusion accessor
  getElevation: function getElevation(f) {
    return 1000;
  },
  fp64: false
};

var getCoordinates = function getCoordinates(f) {
  return get(f, 'geometry.coordinates');
};

var GeoJsonLayer = function (_CompositeLayer) {
  _inherits(GeoJsonLayer, _CompositeLayer);

  function GeoJsonLayer() {
    _classCallCheck(this, GeoJsonLayer);

    return _possibleConstructorReturn(this, (GeoJsonLayer.__proto__ || Object.getPrototypeOf(GeoJsonLayer)).apply(this, arguments));
  }

  _createClass(GeoJsonLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        subLayers: null
      };
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      if (changeFlags.dataChanged) {
        var data = this.props.data;

        var features = getGeojsonFeatures(data);
        this.state.subLayers = separateGeojsonFeatures(features);
      }
    }
  }, {
    key: '_onHoverSubLayer',
    value: function _onHoverSubLayer(info) {
      info.object = info.object && info.object.feature || info.object;
      this.props.onHover(info);
    }
  }, {
    key: '_onClickSubLayer',
    value: function _onClickSubLayer(info) {
      info.object = info.object && info.object.feature || info.object;
      this.props.onClick(info);
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      var _state$subLayers = this.state.subLayers,
          pointFeatures = _state$subLayers.pointFeatures,
          lineFeatures = _state$subLayers.lineFeatures,
          polygonFeatures = _state$subLayers.polygonFeatures,
          polygonOutlineFeatures = _state$subLayers.polygonOutlineFeatures;
      var _props = this.props,
          id = _props.id,
          getPointColor = _props.getPointColor,
          getPointSize = _props.getPointSize,
          getStrokeColor = _props.getStrokeColor,
          getStrokeWidth = _props.getStrokeWidth,
          getFillColor = _props.getFillColor,
          getElevation = _props.getElevation;
      var _props2 = this.props,
          extruded = _props2.extruded,
          wireframe = _props2.wireframe;
      var _props3 = this.props,
          drawPoints = _props3.drawPoints,
          drawLines = _props3.drawLines,
          drawPolygons = _props3.drawPolygons,
          fillPolygons = _props3.fillPolygons;

      drawPoints = drawPoints && pointFeatures && pointFeatures.length > 0;
      drawLines = drawLines && lineFeatures && lineFeatures.length > 0;
      drawPolygons = drawPolygons && polygonOutlineFeatures && polygonOutlineFeatures.length > 0;
      fillPolygons = fillPolygons && polygonFeatures && polygonFeatures.length > 0;

      var onHover = this._onHoverSubLayer.bind(this);
      var onClick = this._onClickSubLayer.bind(this);

      // Filled Polygon Layer
      var polygonFillLayer = fillPolygons && new PolygonLayer(Object.assign({}, this.props, {
        id: id + '-polygon-fill',
        data: polygonFeatures,
        getPolygon: getCoordinates,
        getElevation: getElevation,
        getColor: getFillColor,
        extruded: extruded,
        wireframe: false,
        onHover: onHover,
        onClick: onClick,
        updateTriggers: {
          getElevation: this.props.updateTriggers.getElevation,
          getColor: this.props.updateTriggers.getFillColor
        }
      }));

      // Polygon outline or wireframe
      var polygonOutlineLayer = null;
      if (drawPolygons && extruded && wireframe) {
        polygonOutlineLayer = new PolygonLayer(Object.assign({}, this.props, {
          id: id + '-polygon-wireframe',
          data: polygonFeatures,
          getPolygon: getCoordinates,
          getElevation: getElevation,
          getColor: getStrokeColor,
          extruded: true,
          wireframe: true,
          onHover: onHover,
          onClick: onClick,
          updateTriggers: {
            getColor: this.props.updateTriggers.getStrokeColor
          }
        }));
      } else if (drawPolygons) {
        polygonOutlineLayer = new PathLayer(Object.assign({}, this.props, {
          id: id + '-polygon-outline',
          data: polygonOutlineFeatures,
          getPath: getCoordinates,
          getColor: getStrokeColor,
          getStrokeWidth: getStrokeWidth,
          onHover: onHover,
          onClick: onClick,
          updateTriggers: {
            getColor: this.props.updateTriggers.getStrokeColor,
            getStrokeWidth: this.props.updateTriggers.getStrokeWidth
          }
        }));
      }

      var lineLayer = drawLines && new PathLayer(Object.assign({}, this.props, {
        id: id + '-line-paths',
        data: lineFeatures,
        getPath: getCoordinates,
        getColor: getStrokeColor,
        getStrokeWidth: getStrokeWidth,
        onHover: onHover,
        onClick: onClick,
        updateTriggers: {
          getColor: this.props.updateTriggers.getStrokeColor,
          getStrokeWidth: this.props.updateTriggers.getStrokeWidth
        }
      }));

      var pointLayer = drawPoints && new ScatterplotLayer(Object.assign({}, this.props, {
        id: id + '-points',
        data: pointFeatures,
        getPosition: getCoordinates,
        getColor: getPointColor,
        getRadius: getPointSize,
        onHover: onHover,
        onClick: onClick,
        updateTriggers: {
          getColor: this.props.updateTriggers.getPointColor,
          getRadius: this.props.updateTriggers.getPointSize
        },
        fp64: this.props.fp64
      }));

      return [polygonFillLayer, polygonOutlineLayer, lineLayer, pointLayer].filter(Boolean);
    }
  }]);

  return GeoJsonLayer;
}(CompositeLayer);

export default GeoJsonLayer;


GeoJsonLayer.layerName = 'GeoJsonLayer';
GeoJsonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9nZW9qc29uLWxheWVyL2dlb2pzb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiQ29tcG9zaXRlTGF5ZXIiLCJnZXQiLCJTY2F0dGVycGxvdExheWVyIiwiUGF0aExheWVyIiwiUG9seWdvbkxheWVyIiwiZ2V0R2VvanNvbkZlYXR1cmVzIiwic2VwYXJhdGVHZW9qc29uRmVhdHVyZXMiLCJkZWZhdWx0UG9pbnRDb2xvciIsImRlZmF1bHRTdHJva2VDb2xvciIsImRlZmF1bHRGaWxsQ29sb3IiLCJkZWZhdWx0UHJvcHMiLCJkcmF3UG9pbnRzIiwiZHJhd0xpbmVzIiwiZHJhd1BvbHlnb25zIiwiZmlsbFBvbHlnb25zIiwiZ2V0UG9pbnRDb2xvciIsImYiLCJnZXRQb2ludFNpemUiLCJnZXRTdHJva2VDb2xvciIsImdldFN0cm9rZVdpZHRoIiwiZ2V0RmlsbENvbG9yIiwiZ2V0RWxldmF0aW9uIiwiZnA2NCIsImdldENvb3JkaW5hdGVzIiwiR2VvSnNvbkxheWVyIiwic3RhdGUiLCJzdWJMYXllcnMiLCJvbGRQcm9wcyIsInByb3BzIiwiY2hhbmdlRmxhZ3MiLCJkYXRhQ2hhbmdlZCIsImRhdGEiLCJmZWF0dXJlcyIsImluZm8iLCJvYmplY3QiLCJmZWF0dXJlIiwib25Ib3ZlciIsIm9uQ2xpY2siLCJwb2ludEZlYXR1cmVzIiwibGluZUZlYXR1cmVzIiwicG9seWdvbkZlYXR1cmVzIiwicG9seWdvbk91dGxpbmVGZWF0dXJlcyIsImlkIiwiZXh0cnVkZWQiLCJ3aXJlZnJhbWUiLCJsZW5ndGgiLCJfb25Ib3ZlclN1YkxheWVyIiwiYmluZCIsIl9vbkNsaWNrU3ViTGF5ZXIiLCJwb2x5Z29uRmlsbExheWVyIiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0UG9seWdvbiIsImdldENvbG9yIiwidXBkYXRlVHJpZ2dlcnMiLCJwb2x5Z29uT3V0bGluZUxheWVyIiwiZ2V0UGF0aCIsImxpbmVMYXllciIsInBvaW50TGF5ZXIi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d0JBTlU7QUFPVkMsd0JBUFU7QUFRVmlCLHdCQUFnQjtBQUNkRCxvQkFBVSxLQUFLekIsS0FBTCxDQUFXMEIsY0FBWCxDQUEwQnZDLGFBRHRCO0FBRWQ2QyxxQkFBVyxLQUFLaEMsS0FBTCxDQUFXMEIsY0FBWCxDQUEwQnJDO0FBRnZCLFNBUk47QUFZVkssY0FBTSxLQUFLTSxLQUFMLENBQVdOO0FBWlAsT0FEd0MsQ0FBckIsQ0FBakM7O0FBZ0JBLGFBQU8sQ0FDTDJCLGdCQURLLEVBRUxNLG1CQUZLLEVBR0xFLFNBSEssRUFJTEMsVUFKSyxFQUtMRyxNQUxLLENBS0VDLE9BTEYsQ0FBUDtBQU1EOzs7O0VBakl1QzlELGM7O2VBQXJCd0IsWTs7O0FBb0lyQkEsYUFBYXVDLFNBQWIsR0FBeUIsY0FBekI7QUFDQXZDLGFBQWFkLFlBQWIsR0FBNEJBLFlBQTVCIiwiZmlsZSI6Imdlb2pzb24tbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0NvbXBvc2l0ZUxheWVyLCBnZXR9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgU2NhdHRlcnBsb3RMYXllciBmcm9tICcuLi9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllcic7XG5pbXBvcnQgUGF0aExheWVyIGZyb20gJy4uL3BhdGgtbGF5ZXIvcGF0aC1sYXllcic7XG5pbXBvcnQgUG9seWdvbkxheWVyIGZyb20gJy4uL3BvbHlnb24tbGF5ZXIvcG9seWdvbi1sYXllcic7XG5cbmltcG9ydCB7Z2V0R2VvanNvbkZlYXR1cmVzLCBzZXBhcmF0ZUdlb2pzb25GZWF0dXJlc30gZnJvbSAnLi9nZW9qc29uJztcblxuY29uc3QgZGVmYXVsdFBvaW50Q29sb3IgPSBbMHhGRiwgMHg4OCwgMHgwMCwgMHhGRl07XG5jb25zdCBkZWZhdWx0U3Ryb2tlQ29sb3IgPSBbMHgzMywgMHgzMywgMHgzMywgMHhGRl07XG5jb25zdCBkZWZhdWx0RmlsbENvbG9yID0gWzB4QkQsIDB4RTIsIDB4N0EsIDB4RkZdO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGRyYXdQb2ludHM6IHRydWUsXG4gIGRyYXdMaW5lczogdHJ1ZSxcbiAgZHJhd1BvbHlnb25zOiB0cnVlLFxuICBmaWxsUG9seWdvbnM6IHRydWUsXG4gIC8vIGV4dHJ1ZGVQb2x5Z29uczogZmFsc2UsXG4gIC8vIHdpcmVmcmFtZTogZmFsc2UsXG5cbiAgLy8gUG9pbnQgYWNjZXNzb3JzXG4gIGdldFBvaW50Q29sb3I6IGYgPT4gZ2V0KGYsICdwcm9wZXJ0aWVzLmNvbG9yJykgfHwgZGVmYXVsdFBvaW50Q29sb3IsXG4gIGdldFBvaW50U2l6ZTogZiA9PiBnZXQoZiwgJ3Byb3BlcnRpZXMuc2l6ZScpIHx8IDUsXG5cbiAgLy8gTGluZSBhbmQgcG9seWdvbiBvdXRsaW5lIGFjY2Vzc29yc1xuICBnZXRTdHJva2VDb2xvcjogZiA9PiBnZXQoZiwgJ3Byb3BlcnRpZXMuc3Ryb2tlQ29sb3InKSB8fCBkZWZhdWx0U3Ryb2tlQ29sb3IsXG4gIGdldFN0cm9rZVdpZHRoOiBmID0+IGdldChmLCAncHJvcGVydGllcy5zdHJva2VXaWR0aCcpIHx8IDEsXG5cbiAgLy8gUG9seWdvbiBmaWxsIGFjY2Vzc29yc1xuICBnZXRGaWxsQ29sb3I6IGYgPT4gZ2V0KGYsICdwcm9wZXJ0aWVzLmZpbGxDb2xvcicpIHx8IGRlZmF1bHRGaWxsQ29sb3IsXG5cbiAgLy8gUG9seWdvbiBleHRydXNpb24gYWNjZXNzb3JcbiAgZ2V0RWxldmF0aW9uOiBmID0+IDEwMDAsXG4gIGZwNjQ6IGZhbHNlXG59O1xuXG5jb25zdCBnZXRDb29yZGluYXRlcyA9IGYgPT4gZ2V0KGYsICdnZW9tZXRyeS5jb29yZGluYXRlcycpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHZW9Kc29uTGF5ZXIgZXh0ZW5kcyBDb21wb3NpdGVMYXllciB7XG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgc3ViTGF5ZXJzOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgY29uc3Qge2RhdGF9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGZlYXR1cmVzID0gZ2V0R2VvanNvbkZlYXR1cmVzKGRhdGEpO1xuICAgICAgdGhpcy5zdGF0ZS5zdWJMYXllcnMgPSBzZXBhcmF0ZUdlb2pzb25GZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgfVxuICB9XG5cbiAgX29uSG92ZXJTdWJMYXllcihpbmZvKSB7XG4gICAgaW5mby5vYmplY3QgPSAoaW5mby5vYmplY3QgJiYgaW5mby5vYmplY3QuZmVhdHVyZSkgfHwgaW5mby5vYmplY3Q7XG4gICAgdGhpcy5wcm9wcy5vbkhvdmVyKGluZm8pO1xuICB9XG5cbiAgX29uQ2xpY2tTdWJMYXllcihpbmZvKSB7XG4gICAgaW5mby5vYmplY3QgPSAoaW5mby5vYmplY3QgJiYgaW5mby5vYmplY3QuZmVhdHVyZSkgfHwgaW5mby5vYmplY3Q7XG4gICAgdGhpcy5wcm9wcy5vbkNsaWNrKGluZm8pO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IHtzdWJMYXllcnM6IHtwb2ludEZlYXR1cmVzLCBsaW5lRmVhdHVyZXMsIHBvbHlnb25GZWF0dXJlcyxcbiAgICAgIHBvbHlnb25PdXRsaW5lRmVhdHVyZXN9fSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge2lkLCBnZXRQb2ludENvbG9yLCBnZXRQb2ludFNpemUsIGdldFN0cm9rZUNvbG9yLCBnZXRTdHJva2VXaWR0aCxcbiAgICAgIGdldEZpbGxDb2xvciwgZ2V0RWxldmF0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge2V4dHJ1ZGVkLCB3aXJlZnJhbWV9ID0gdGhpcy5wcm9wcztcblxuICAgIGxldCB7ZHJhd1BvaW50cywgZHJhd0xpbmVzLCBkcmF3UG9seWdvbnMsIGZpbGxQb2x5Z29uc30gPSB0aGlzLnByb3BzO1xuICAgIGRyYXdQb2ludHMgPSBkcmF3UG9pbnRzICYmIHBvaW50RmVhdHVyZXMgJiYgcG9pbnRGZWF0dXJlcy5sZW5ndGggPiAwO1xuICAgIGRyYXdMaW5lcyA9IGRyYXdMaW5lcyAmJiBsaW5lRmVhdHVyZXMgJiYgbGluZUZlYXR1cmVzLmxlbmd0aCA+IDA7XG4gICAgZHJhd1BvbHlnb25zID0gZHJhd1BvbHlnb25zICYmIHBvbHlnb25PdXRsaW5lRmVhdHVyZXMgJiYgcG9seWdvbk91dGxpbmVGZWF0dXJlcy5sZW5ndGggPiAwO1xuICAgIGZpbGxQb2x5Z29ucyA9IGZpbGxQb2x5Z29ucyAmJiBwb2x5Z29uRmVhdHVyZXMgJiYgcG9seWdvbkZlYXR1cmVzLmxlbmd0aCA+IDA7XG5cbiAgICBjb25zdCBvbkhvdmVyID0gdGhpcy5fb25Ib3ZlclN1YkxheWVyLmJpbmQodGhpcyk7XG4gICAgY29uc3Qgb25DbGljayA9IHRoaXMuX29uQ2xpY2tTdWJMYXllci5iaW5kKHRoaXMpO1xuXG4gICAgLy8gRmlsbGVkIFBvbHlnb24gTGF5ZXJcbiAgICBjb25zdCBwb2x5Z29uRmlsbExheWVyID0gZmlsbFBvbHlnb25zICYmIG5ldyBQb2x5Z29uTGF5ZXIoT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgIHRoaXMucHJvcHMsIHtcbiAgICAgICAgaWQ6IGAke2lkfS1wb2x5Z29uLWZpbGxgLFxuICAgICAgICBkYXRhOiBwb2x5Z29uRmVhdHVyZXMsXG4gICAgICAgIGdldFBvbHlnb246IGdldENvb3JkaW5hdGVzLFxuICAgICAgICBnZXRFbGV2YXRpb24sXG4gICAgICAgIGdldENvbG9yOiBnZXRGaWxsQ29sb3IsXG4gICAgICAgIGV4dHJ1ZGVkLFxuICAgICAgICB3aXJlZnJhbWU6IGZhbHNlLFxuICAgICAgICBvbkhvdmVyLFxuICAgICAgICBvbkNsaWNrLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldEVsZXZhdGlvbjogdGhpcy5wcm9wcy51cGRhdGVUcmlnZ2Vycy5nZXRFbGV2YXRpb24sXG4gICAgICAgICAgZ2V0Q29sb3I6IHRoaXMucHJvcHMudXBkYXRlVHJpZ2dlcnMuZ2V0RmlsbENvbG9yXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgIC8vIFBvbHlnb24gb3V0bGluZSBvciB3aXJlZnJhbWVcbiAgICBsZXQgcG9seWdvbk91dGxpbmVMYXllciA9IG51bGw7XG4gICAgaWYgKGRyYXdQb2x5Z29ucyAmJiBleHRydWRlZCAmJiB3aXJlZnJhbWUpIHtcbiAgICAgIHBvbHlnb25PdXRsaW5lTGF5ZXIgPSBuZXcgUG9seWdvbkxheWVyKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgaWQ6IGAke2lkfS1wb2x5Z29uLXdpcmVmcmFtZWAsXG4gICAgICAgIGRhdGE6IHBvbHlnb25GZWF0dXJlcyxcbiAgICAgICAgZ2V0UG9seWdvbjogZ2V0Q29vcmRpbmF0ZXMsXG4gICAgICAgIGdldEVsZXZhdGlvbixcbiAgICAgICAgZ2V0Q29sb3I6IGdldFN0cm9rZUNvbG9yLFxuICAgICAgICBleHRydWRlZDogdHJ1ZSxcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgICAgICBvbkhvdmVyLFxuICAgICAgICBvbkNsaWNrLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldENvbG9yOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzLmdldFN0cm9rZUNvbG9yXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKGRyYXdQb2x5Z29ucykge1xuICAgICAgcG9seWdvbk91dGxpbmVMYXllciA9IG5ldyBQYXRoTGF5ZXIoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICBpZDogYCR7aWR9LXBvbHlnb24tb3V0bGluZWAsXG4gICAgICAgIGRhdGE6IHBvbHlnb25PdXRsaW5lRmVhdHVyZXMsXG4gICAgICAgIGdldFBhdGg6IGdldENvb3JkaW5hdGVzLFxuICAgICAgICBnZXRDb2xvcjogZ2V0U3Ryb2tlQ29sb3IsXG4gICAgICAgIGdldFN0cm9rZVdpZHRoLFxuICAgICAgICBvbkhvdmVyLFxuICAgICAgICBvbkNsaWNrLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldENvbG9yOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzLmdldFN0cm9rZUNvbG9yLFxuICAgICAgICAgIGdldFN0cm9rZVdpZHRoOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzLmdldFN0cm9rZVdpZHRoXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBsaW5lTGF5ZXIgPSBkcmF3TGluZXMgJiYgbmV3IFBhdGhMYXllcihPYmplY3QuYXNzaWduKHt9LFxuICAgICAgdGhpcy5wcm9wcywge1xuICAgICAgICBpZDogYCR7aWR9LWxpbmUtcGF0aHNgLFxuICAgICAgICBkYXRhOiBsaW5lRmVhdHVyZXMsXG4gICAgICAgIGdldFBhdGg6IGdldENvb3JkaW5hdGVzLFxuICAgICAgICBnZXRDb2xvcjogZ2V0U3Ryb2tlQ29sb3IsXG4gICAgICAgIGdldFN0cm9rZVdpZHRoLFxuICAgICAgICBvbkhvdmVyLFxuICAgICAgICBvbkNsaWNrLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldENvbG9yOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzLmdldFN0cm9rZUNvbG9yLFxuICAgICAgICAgIGdldFN0cm9rZVdpZHRoOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzLmdldFN0cm9rZVdpZHRoXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgIGNvbnN0IHBvaW50TGF5ZXIgPSBkcmF3UG9pbnRzICYmIG5ldyBTY2F0dGVycGxvdExheWVyKE9iamVjdC5hc3NpZ24oe30sXG4gICAgICB0aGlzLnByb3BzLCB7XG4gICAgICAgIGlkOiBgJHtpZH0tcG9pbnRzYCxcbiAgICAgICAgZGF0YTogcG9pbnRGZWF0dXJlcyxcbiAgICAgICAgZ2V0UG9zaXRpb246IGdldENvb3JkaW5hdGVzLFxuICAgICAgICBnZXRDb2xvcjogZ2V0UG9pbnRDb2xvcixcbiAgICAgICAgZ2V0UmFkaXVzOiBnZXRQb2ludFNpemUsXG4gICAgICAgIG9uSG92ZXIsXG4gICAgICAgIG9uQ2xpY2ssXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0Q29sb3I6IHRoaXMucHJvcHMudXBkYXRlVHJpZ2dlcnMuZ2V0UG9pbnRDb2xvcixcbiAgICAgICAgICBnZXRSYWRpdXM6IHRoaXMucHJvcHMudXBkYXRlVHJpZ2dlcnMuZ2V0UG9pbnRTaXplXG4gICAgICAgIH0sXG4gICAgICAgIGZwNjQ6IHRoaXMucHJvcHMuZnA2NFxuICAgICAgfSkpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIHBvbHlnb25GaWxsTGF5ZXIsXG4gICAgICBwb2x5Z29uT3V0bGluZUxheWVyLFxuICAgICAgbGluZUxheWVyLFxuICAgICAgcG9pbnRMYXllclxuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuICB9XG59XG5cbkdlb0pzb25MYXllci5sYXllck5hbWUgPSAnR2VvSnNvbkxheWVyJztcbkdlb0pzb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=