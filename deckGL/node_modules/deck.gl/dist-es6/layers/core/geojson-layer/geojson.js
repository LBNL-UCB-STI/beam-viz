import { get } from '../../../lib';
import { Container } from '../../../lib/utils';

/**
 * "Normalizes" complete or partial GeoJSON data into iterable list of features
 * Can accept GeoJSON geometry or "Feature", "FeatureCollection" in addition
 * to plain arrays and iterables.
 * Works by extracting the feature array or wrapping single objects in an array,
 * so that subsequent code can simply iterate over features.
 *
 * @param {object} geojson - geojson data
 * @param {Object|Array} data - geojson object (FeatureCollection, Feature or
 *  Geometry) or array of features
 * @return {Array|"iteratable"} - iterable list of features
 */
export function getGeojsonFeatures(geojson) {
  // If array, assume this is a list of features
  if (Array.isArray(geojson)) {
    return geojson;
  }

  var type = get(geojson, 'type');
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'Polygon':
    case 'MultiPolygon':
    case 'GeometryCollection':
      // Wrap the geometry object in a 'Feature' object and wrap in an array
      return [{ type: 'Feature', properties: {}, geometry: geojson }];
    case 'Feature':
      // Wrap the feature in a 'Features' array
      return [geojson];
    case 'FeatureCollection':
      // Just return the 'Features' array from the collection
      return get(geojson, 'features');
    default:
      throw new Error('Unknown geojson type');
  }
}

// Linearize
export function separateGeojsonFeatures(features) {
  var pointFeatures = [];
  var lineFeatures = [];
  var polygonFeatures = [];
  var polygonOutlineFeatures = [];

  Container.forEach(features, function (feature) {
    var type = get(feature, 'geometry.type');
    var coordinates = get(feature, 'geometry.coordinates');
    var properties = get(feature, 'properties');
    switch (type) {
      case 'Point':
        pointFeatures.push(feature);
        break;
      case 'MultiPoint':
        // TODO - split multipoints
        Container.forEach(coordinates, function (point) {
          pointFeatures.push({ geometry: { coordinates: point }, properties: properties, feature: feature });
        });
        break;
      case 'LineString':
        lineFeatures.push(feature);
        break;
      case 'MultiLineString':
        // Break multilinestrings into multiple lines with same properties
        Container.forEach(coordinates, function (path) {
          lineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });
        });
        break;
      case 'Polygon':
        polygonFeatures.push(feature);
        // Break polygon into multiple lines with same properties
        Container.forEach(coordinates, function (path) {
          polygonOutlineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });
        });
        break;
      case 'MultiPolygon':
        // Break multipolygons into multiple polygons with same properties
        Container.forEach(coordinates, function (polygon) {
          polygonFeatures.push({ geometry: { coordinates: polygon }, properties: properties, feature: feature });
          // Break polygon into multiple lines with same properties
          Container.forEach(polygon, function (path) {
            polygonOutlineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });
          });
        });
        break;
      // Not yet supported
      case 'GeometryCollection':
      default:
        throw new Error('GeoJsonLayer: ' + type + ' not supported.');
    }
  });

  return {
    pointFeatures: pointFeatures,
    lineFeatures: lineFeatures,
    polygonFeatures: polygonFeatures,
    polygonOutlineFeatures: polygonOutlineFeatures
  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9nZW9qc29uLWxheWVyL2dlb2pzb24uanMiXSwibmFtZXMiOlsiZ2V0IiwiQ29udGFpbmVyIiwiZ2V0R2VvanNvbkZlYXR1cmVzIiwiZ2VvanNvbiIsIkFycmF5IiwiaXNBcnJheSIsInR5cGUiLCJwcm9wZXJ0aWVzIiwiZ2VvbWV0cnkiLCJFcnJvciIsInNlcGFyYXRlR2VvanNvbkZlYXR1cmVzIiwiZmVhdHVyZXMiLCJwb2ludEZlYXR1cmVzIiwibGluZUZlYXR1cmVzIiwicG9seWdvbkZlYXR1cmVzIiwicG9seWdvbk91dGxpbmVGZWF0dXJlcyIsImZvckVhY2giLCJmZWF0dXJlIiwiY29vcmRpbmF0ZXMiLCJwdXNoIiwicG9pbnQiLCJwYXRoIiwicG9seWdvbiJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUUEsR0FBUixRQUFrQixjQUFsQjtBQUNBLFNBQVFDLFNBQVIsUUFBd0Isb0JBQXhCOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQSxPQUFPLFNBQVNDLGtCQUFULENBQTRCQyxPQUE1QixFQUFxQztBQUMxQztBQUNBLE1BQUlDLE1BQU1DLE9BQU4sQ0FBY0YsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLFdBQU9BLE9BQVA7QUFDRDs7QUFFRCxNQUFNRyxPQUFPTixJQUFJRyxPQUFKLEVBQWEsTUFBYixDQUFiO0FBQ0EsVUFBUUcsSUFBUjtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssaUJBQUw7QUFDQSxTQUFLLFNBQUw7QUFDQSxTQUFLLGNBQUw7QUFDQSxTQUFLLG9CQUFMO0FBQ0U7QUFDQSxhQUFPLENBQ0wsRUFBQ0EsTUFBTSxTQUFQLEVBQWtCQyxZQUFZLEVBQTlCLEVBQWtDQyxVQUFVTCxPQUE1QyxFQURLLENBQVA7QUFHRixTQUFLLFNBQUw7QUFDRTtBQUNBLGFBQU8sQ0FBQ0EsT0FBRCxDQUFQO0FBQ0YsU0FBSyxtQkFBTDtBQUNFO0FBQ0EsYUFBT0gsSUFBSUcsT0FBSixFQUFhLFVBQWIsQ0FBUDtBQUNGO0FBQ0UsWUFBTSxJQUFJTSxLQUFKLENBQVUsc0JBQVYsQ0FBTjtBQW5CRjtBQXFCRDs7QUFFRDtBQUNBLE9BQU8sU0FBU0MsdUJBQVQsQ0FBaUNDLFFBQWpDLEVBQTJDO0FBQ2hELE1BQU1DLGdCQUFnQixFQUF0QjtBQUNBLE1BQU1DLGVBQWUsRUFBckI7QUFDQSxNQUFNQyxrQkFBa0IsRUFBeEI7QUFDQSxNQUFNQyx5QkFBeUIsRUFBL0I7O0FBRUFkLFlBQVVlLE9BQVYsQ0FBa0JMLFFBQWxCLEVBQTRCLG1CQUFXO0FBQ3JDLFFBQU1MLE9BQU9OLElBQUlpQixPQUFKLEVBQWEsZUFBYixDQUFiO0FBQ0EsUUFBTUMsY0FBY2xCLElBQUlpQixPQUFKLEVBQWEsc0JBQWIsQ0FBcEI7QUFDQSxRQUFNVixhQUFhUCxJQUFJaUIsT0FBSixFQUFhLFlBQWIsQ0FBbkI7QUFDQSxZQUFRWCxJQUFSO0FBQ0EsV0FBSyxPQUFMO0FBQ0VNLHNCQUFjTyxJQUFkLENBQW1CRixPQUFuQjtBQUNBO0FBQ0YsV0FBSyxZQUFMO0FBQ0U7QUFDQWhCLGtCQUFVZSxPQUFWLENBQWtCRSxXQUFsQixFQUErQixpQkFBUztBQUN0Q04sd0JBQWNPLElBQWQsQ0FBbUIsRUFBQ1gsVUFBVSxFQUFDVSxhQUFhRSxLQUFkLEVBQVgsRUFBaUNiLHNCQUFqQyxFQUE2Q1UsZ0JBQTdDLEVBQW5CO0FBQ0QsU0FGRDtBQUdBO0FBQ0YsV0FBSyxZQUFMO0FBQ0VKLHFCQUFhTSxJQUFiLENBQWtCRixPQUFsQjtBQUNBO0FBQ0YsV0FBSyxpQkFBTDtBQUNFO0FBQ0FoQixrQkFBVWUsT0FBVixDQUFrQkUsV0FBbEIsRUFBK0IsZ0JBQVE7QUFDckNMLHVCQUFhTSxJQUFiLENBQWtCLEVBQUNYLFVBQVUsRUFBQ1UsYUFBYUcsSUFBZCxFQUFYLEVBQWdDZCxzQkFBaEMsRUFBNENVLGdCQUE1QyxFQUFsQjtBQUNELFNBRkQ7QUFHQTtBQUNGLFdBQUssU0FBTDtBQUNFSCx3QkFBZ0JLLElBQWhCLENBQXFCRixPQUFyQjtBQUNBO0FBQ0FoQixrQkFBVWUsT0FBVixDQUFrQkUsV0FBbEIsRUFBK0IsZ0JBQVE7QUFDckNILGlDQUF1QkksSUFBdkIsQ0FBNEIsRUFBQ1gsVUFBVSxFQUFDVSxhQUFhRyxJQUFkLEVBQVgsRUFBZ0NkLHNCQUFoQyxFQUE0Q1UsZ0JBQTVDLEVBQTVCO0FBQ0QsU0FGRDtBQUdBO0FBQ0YsV0FBSyxjQUFMO0FBQ0U7QUFDQWhCLGtCQUFVZSxPQUFWLENBQWtCRSxXQUFsQixFQUErQixtQkFBVztBQUN4Q0osMEJBQWdCSyxJQUFoQixDQUFxQixFQUFDWCxVQUFVLEVBQUNVLGFBQWFJLE9BQWQsRUFBWCxFQUFtQ2Ysc0JBQW5DLEVBQStDVSxnQkFBL0MsRUFBckI7QUFDQTtBQUNBaEIsb0JBQVVlLE9BQVYsQ0FBa0JNLE9BQWxCLEVBQTJCLGdCQUFRO0FBQ2pDUCxtQ0FBdUJJLElBQXZCLENBQTRCLEVBQUNYLFVBQVUsRUFBQ1UsYUFBYUcsSUFBZCxFQUFYLEVBQWdDZCxzQkFBaEMsRUFBNENVLGdCQUE1QyxFQUE1QjtBQUNELFdBRkQ7QUFHRCxTQU5EO0FBT0E7QUFDQTtBQUNGLFdBQUssb0JBQUw7QUFDQTtBQUNFLGNBQU0sSUFBSVIsS0FBSixvQkFBMkJILElBQTNCLHFCQUFOO0FBdkNGO0FBeUNELEdBN0NEOztBQStDQSxTQUFPO0FBQ0xNLGdDQURLO0FBRUxDLDhCQUZLO0FBR0xDLG9DQUhLO0FBSUxDO0FBSkssR0FBUDtBQU1EIiwiZmlsZSI6Imdlb2pzb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dldH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7Q29udGFpbmVyfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuXG4vKipcbiAqIFwiTm9ybWFsaXplc1wiIGNvbXBsZXRlIG9yIHBhcnRpYWwgR2VvSlNPTiBkYXRhIGludG8gaXRlcmFibGUgbGlzdCBvZiBmZWF0dXJlc1xuICogQ2FuIGFjY2VwdCBHZW9KU09OIGdlb21ldHJ5IG9yIFwiRmVhdHVyZVwiLCBcIkZlYXR1cmVDb2xsZWN0aW9uXCIgaW4gYWRkaXRpb25cbiAqIHRvIHBsYWluIGFycmF5cyBhbmQgaXRlcmFibGVzLlxuICogV29ya3MgYnkgZXh0cmFjdGluZyB0aGUgZmVhdHVyZSBhcnJheSBvciB3cmFwcGluZyBzaW5nbGUgb2JqZWN0cyBpbiBhbiBhcnJheSxcbiAqIHNvIHRoYXQgc3Vic2VxdWVudCBjb2RlIGNhbiBzaW1wbHkgaXRlcmF0ZSBvdmVyIGZlYXR1cmVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBnZW9qc29uIC0gZ2VvanNvbiBkYXRhXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZGF0YSAtIGdlb2pzb24gb2JqZWN0IChGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZSBvclxuICogIEdlb21ldHJ5KSBvciBhcnJheSBvZiBmZWF0dXJlc1xuICogQHJldHVybiB7QXJyYXl8XCJpdGVyYXRhYmxlXCJ9IC0gaXRlcmFibGUgbGlzdCBvZiBmZWF0dXJlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2VvanNvbkZlYXR1cmVzKGdlb2pzb24pIHtcbiAgLy8gSWYgYXJyYXksIGFzc3VtZSB0aGlzIGlzIGEgbGlzdCBvZiBmZWF0dXJlc1xuICBpZiAoQXJyYXkuaXNBcnJheShnZW9qc29uKSkge1xuICAgIHJldHVybiBnZW9qc29uO1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IGdldChnZW9qc29uLCAndHlwZScpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnUG9pbnQnOlxuICBjYXNlICdNdWx0aVBvaW50JzpcbiAgY2FzZSAnTGluZVN0cmluZyc6XG4gIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gIGNhc2UgJ1BvbHlnb24nOlxuICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxuICAgIC8vIFdyYXAgdGhlIGdlb21ldHJ5IG9iamVjdCBpbiBhICdGZWF0dXJlJyBvYmplY3QgYW5kIHdyYXAgaW4gYW4gYXJyYXlcbiAgICByZXR1cm4gW1xuICAgICAge3R5cGU6ICdGZWF0dXJlJywgcHJvcGVydGllczoge30sIGdlb21ldHJ5OiBnZW9qc29ufVxuICAgIF07XG4gIGNhc2UgJ0ZlYXR1cmUnOlxuICAgIC8vIFdyYXAgdGhlIGZlYXR1cmUgaW4gYSAnRmVhdHVyZXMnIGFycmF5XG4gICAgcmV0dXJuIFtnZW9qc29uXTtcbiAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgIC8vIEp1c3QgcmV0dXJuIHRoZSAnRmVhdHVyZXMnIGFycmF5IGZyb20gdGhlIGNvbGxlY3Rpb25cbiAgICByZXR1cm4gZ2V0KGdlb2pzb24sICdmZWF0dXJlcycpO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBnZW9qc29uIHR5cGUnKTtcbiAgfVxufVxuXG4vLyBMaW5lYXJpemVcbmV4cG9ydCBmdW5jdGlvbiBzZXBhcmF0ZUdlb2pzb25GZWF0dXJlcyhmZWF0dXJlcykge1xuICBjb25zdCBwb2ludEZlYXR1cmVzID0gW107XG4gIGNvbnN0IGxpbmVGZWF0dXJlcyA9IFtdO1xuICBjb25zdCBwb2x5Z29uRmVhdHVyZXMgPSBbXTtcbiAgY29uc3QgcG9seWdvbk91dGxpbmVGZWF0dXJlcyA9IFtdO1xuXG4gIENvbnRhaW5lci5mb3JFYWNoKGZlYXR1cmVzLCBmZWF0dXJlID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0KGZlYXR1cmUsICdnZW9tZXRyeS50eXBlJyk7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSBnZXQoZmVhdHVyZSwgJ2dlb21ldHJ5LmNvb3JkaW5hdGVzJyk7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IGdldChmZWF0dXJlLCAncHJvcGVydGllcycpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgIHBvaW50RmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgLy8gVE9ETyAtIHNwbGl0IG11bHRpcG9pbnRzXG4gICAgICBDb250YWluZXIuZm9yRWFjaChjb29yZGluYXRlcywgcG9pbnQgPT4ge1xuICAgICAgICBwb2ludEZlYXR1cmVzLnB1c2goe2dlb21ldHJ5OiB7Y29vcmRpbmF0ZXM6IHBvaW50fSwgcHJvcGVydGllcywgZmVhdHVyZX0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgIGxpbmVGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgIC8vIEJyZWFrIG11bHRpbGluZXN0cmluZ3MgaW50byBtdWx0aXBsZSBsaW5lcyB3aXRoIHNhbWUgcHJvcGVydGllc1xuICAgICAgQ29udGFpbmVyLmZvckVhY2goY29vcmRpbmF0ZXMsIHBhdGggPT4ge1xuICAgICAgICBsaW5lRmVhdHVyZXMucHVzaCh7Z2VvbWV0cnk6IHtjb29yZGluYXRlczogcGF0aH0sIHByb3BlcnRpZXMsIGZlYXR1cmV9KTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgICBwb2x5Z29uRmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgIC8vIEJyZWFrIHBvbHlnb24gaW50byBtdWx0aXBsZSBsaW5lcyB3aXRoIHNhbWUgcHJvcGVydGllc1xuICAgICAgQ29udGFpbmVyLmZvckVhY2goY29vcmRpbmF0ZXMsIHBhdGggPT4ge1xuICAgICAgICBwb2x5Z29uT3V0bGluZUZlYXR1cmVzLnB1c2goe2dlb21ldHJ5OiB7Y29vcmRpbmF0ZXM6IHBhdGh9LCBwcm9wZXJ0aWVzLCBmZWF0dXJlfSk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAvLyBCcmVhayBtdWx0aXBvbHlnb25zIGludG8gbXVsdGlwbGUgcG9seWdvbnMgd2l0aCBzYW1lIHByb3BlcnRpZXNcbiAgICAgIENvbnRhaW5lci5mb3JFYWNoKGNvb3JkaW5hdGVzLCBwb2x5Z29uID0+IHtcbiAgICAgICAgcG9seWdvbkZlYXR1cmVzLnB1c2goe2dlb21ldHJ5OiB7Y29vcmRpbmF0ZXM6IHBvbHlnb259LCBwcm9wZXJ0aWVzLCBmZWF0dXJlfSk7XG4gICAgICAgIC8vIEJyZWFrIHBvbHlnb24gaW50byBtdWx0aXBsZSBsaW5lcyB3aXRoIHNhbWUgcHJvcGVydGllc1xuICAgICAgICBDb250YWluZXIuZm9yRWFjaChwb2x5Z29uLCBwYXRoID0+IHtcbiAgICAgICAgICBwb2x5Z29uT3V0bGluZUZlYXR1cmVzLnB1c2goe2dlb21ldHJ5OiB7Y29vcmRpbmF0ZXM6IHBhdGh9LCBwcm9wZXJ0aWVzLCBmZWF0dXJlfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIE5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHZW9Kc29uTGF5ZXI6ICR7dHlwZX0gbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgcG9pbnRGZWF0dXJlcyxcbiAgICBsaW5lRmVhdHVyZXMsXG4gICAgcG9seWdvbkZlYXR1cmVzLFxuICAgIHBvbHlnb25PdXRsaW5lRmVhdHVyZXNcbiAgfTtcbn1cbiJdfQ==