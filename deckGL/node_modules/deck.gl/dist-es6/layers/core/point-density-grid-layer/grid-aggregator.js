var R_EARTH = 6378000;

/**
 * Calculate density grid from an array of points
 * @param {array} points
 * @param {number} worldUnitSize - unit size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid data, cell dimension and count range
 */
export function pointToDensityGridData(points, worldUnitSize, getPosition) {
  var _pointsToGridHashing2 = _pointsToGridHashing(points, worldUnitSize, getPosition),
      gridHash = _pointsToGridHashing2.gridHash,
      gridOffset = _pointsToGridHashing2.gridOffset;

  var layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);
  var countRange = _getCellCountExtent(layerData);

  return {
    gridOffset: gridOffset,
    layerData: layerData,
    countRange: countRange
  };
}

/**
 * Project points into each cell, return a hash table of cells
 * @param {array} points
 * @param {number} worldUnitSize - unit size in meters
 * @param {function} getPosition - position accessor
 * @returns {object} - grid hash and cell dimension
 */
function _pointsToGridHashing(points, worldUnitSize, getPosition) {

  // find the geometric center of sample points
  var allLat = points.map(function (p) {
    return getPosition(p)[1];
  });
  var latMin = Math.min.apply(null, allLat);
  var latMax = Math.max.apply(null, allLat);

  var centerLat = (latMin + latMax) / 2;

  var gridOffset = _calculateGridLatLonOffset(worldUnitSize, centerLat);

  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return { gridHash: {}, gridOffset: gridOffset };
  }
  // calculate count per cell
  var gridHash = points.reduce(function (accu, pt) {
    var latIdx = Math.floor((getPosition(pt)[1] + 90) / gridOffset.yOffset);
    var lonIdx = Math.floor((getPosition(pt)[0] + 180) / gridOffset.xOffset);
    var key = latIdx + '-' + lonIdx;

    accu[key] = accu[key] || { count: 0, points: [] };
    accu[key].count += 1;
    accu[key].points.push(pt);

    return accu;
  }, {});

  return { gridHash: gridHash, gridOffset: gridOffset };
}

function _getGridLayerDataFromGridHash(gridHash, gridOffset) {
  return Object.keys(gridHash).reduce(function (accu, key, i) {
    var idxs = key.split('-');
    var latIdx = parseInt(idxs[0], 10);
    var lonIdx = parseInt(idxs[1], 10);

    accu.push(Object.assign({
      index: i,
      position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]
    }, gridHash[key]));

    return accu;
  }, []);
}

function _getCellCountExtent(data) {
  return data.length ? [Math.min.apply(null, data.map(function (d) {
    return d.count;
  })), Math.max.apply(null, data.map(function (d) {
    return d.count;
  }))] : [0, 1];
}

/**
 * calculate grid layer cell size in lat lon based on world unit size
 * and current latitude
 * @param {number} worldUnitSize
 * @param {number} latitude
 * @returns {object} - lat delta and lon delta
 */
function _calculateGridLatLonOffset(worldUnitSize, latitude) {
  var yOffset = _calculateLatOffset(worldUnitSize);
  var xOffset = _calculateLonOffset(latitude, worldUnitSize);
  return { yOffset: yOffset, xOffset: xOffset };
}

/**
 * with a given x-km change, calculate the increment of latitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} dy - change in km
 * @return {number} - increment in latitude
 */
function _calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}

/**
 * with a given x-km change, and current latitude
 * calculate the increment of longitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} lat - latitude of current location (based on city)
 * @param {number} dx - change in km
 * @return {number} - increment in longitude
 */
function _calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wb2ludC1kZW5zaXR5LWdyaWQtbGF5ZXIvZ3JpZC1hZ2dyZWdhdG9yLmpzIl0sIm5hbWVzIjpbIlJfRUFSVEgiLCJwb2ludFRvRGVuc2l0eUdyaWREYXRhIiwicG9pbnRzIiwid29ybGRVbml0U2l6ZSIsImdldFBvc2l0aW9uIiwiX3BvaW50c1RvR3JpZEhhc2hpbmciLCJncmlkSGFzaCIsImdyaWRPZmZzZXQiLCJsYXllckRhdGEiLCJfZ2V0R3JpZExheWVyRGF0YUZyb21HcmlkSGFzaCIsImNvdW50UmFuZ2UiLCJfZ2V0Q2VsbENvdW50RXh0ZW50IiwiYWxsTGF0IiwibWFwIiwicCIsImxhdE1pbiIsIk1hdGgiLCJtaW4iLCJhcHBseSIsImxhdE1heCIsIm1heCIsImNlbnRlckxhdCIsIl9jYWxjdWxhdGVHcmlkTGF0TG9uT2Zmc2V0IiwieE9mZnNldCIsInlPZmZzZXQiLCJyZWR1Y2UiLCJhY2N1IiwicHQiLCJsYXRJZHgiLCJmbG9vciIsImxvbklkeCIsImtleSIsImNvdW50IiwicHVzaCIsIk9iamVjdCIsImtleXMiLCJpIiwiaWR4cyIsInNwbGl0IiwicGFyc2VJbnQiLCJhc3NpZ24iLCJpbmRleCIsInBvc2l0aW9uIiwiZGF0YSIsImxlbmd0aCIsImQiLCJsYXRpdHVkZSIsIl9jYWxjdWxhdGVMYXRPZmZzZXQiLCJfY2FsY3VsYXRlTG9uT2Zmc2V0IiwiZHkiLCJQSSIsImxhdCIsImR4IiwiY29zIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFNQSxVQUFVLE9BQWhCOztBQUVBOzs7Ozs7O0FBT0EsT0FBTyxTQUFTQyxzQkFBVCxDQUFnQ0MsTUFBaEMsRUFBd0NDLGFBQXhDLEVBQXVEQyxXQUF2RCxFQUFvRTtBQUFBLDhCQUUxQ0MscUJBQXFCSCxNQUFyQixFQUE2QkMsYUFBN0IsRUFBNENDLFdBQTVDLENBRjBDO0FBQUEsTUFFbEVFLFFBRmtFLHlCQUVsRUEsUUFGa0U7QUFBQSxNQUV4REMsVUFGd0Qs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QUFlRDs7QUFFRCxTQUFTZixtQkFBVCxDQUE2QmdDLElBQTdCLEVBQW1DO0FBQ2pDLFNBQU9BLEtBQUtDLE1BQUwsR0FBYyxDQUNuQjVCLEtBQUtDLEdBQUwsQ0FBU0MsS0FBVCxDQUFlLElBQWYsRUFBcUJ5QixLQUFLOUIsR0FBTCxDQUFTO0FBQUEsV0FBS2dDLEVBQUViLEtBQVA7QUFBQSxHQUFULENBQXJCLENBRG1CLEVBRW5CaEIsS0FBS0ksR0FBTCxDQUFTRixLQUFULENBQWUsSUFBZixFQUFxQnlCLEtBQUs5QixHQUFMLENBQVM7QUFBQSxXQUFLZ0MsRUFBRWIsS0FBUDtBQUFBLEdBQVQsQ0FBckIsQ0FGbUIsQ0FBZCxHQUdILENBQUMsQ0FBRCxFQUFJLENBQUosQ0FISjtBQUlEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU1YsMEJBQVQsQ0FBb0NuQixhQUFwQyxFQUFtRDJDLFFBQW5ELEVBQTZEO0FBQzNELE1BQU10QixVQUFVdUIsb0JBQW9CNUMsYUFBcEIsQ0FBaEI7QUFDQSxNQUFNb0IsVUFBVXlCLG9CQUFvQkYsUUFBcEIsRUFBOEIzQyxhQUE5QixDQUFoQjtBQUNBLFNBQU8sRUFBQ3FCLGdCQUFELEVBQVVELGdCQUFWLEVBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU3dCLG1CQUFULENBQTZCRSxFQUE3QixFQUFpQztBQUMvQixTQUFRQSxLQUFLakQsT0FBTixJQUFrQixNQUFNZ0IsS0FBS2tDLEVBQTdCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTRixtQkFBVCxDQUE2QkcsR0FBN0IsRUFBa0NDLEVBQWxDLEVBQXNDO0FBQ3BDLFNBQVFBLEtBQUtwRCxPQUFOLElBQWtCLE1BQU1nQixLQUFLa0MsRUFBN0IsSUFBbUNsQyxLQUFLcUMsR0FBTCxDQUFTRixNQUFNbkMsS0FBS2tDLEVBQVgsR0FBZ0IsR0FBekIsQ0FBMUM7QUFDRCIsImZpbGUiOiJncmlkLWFnZ3JlZ2F0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSX0VBUlRIID0gNjM3ODAwMDtcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGVuc2l0eSBncmlkIGZyb20gYW4gYXJyYXkgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSB3b3JsZFVuaXRTaXplIC0gdW5pdCBzaXplIGluIG1ldGVyc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0UG9zaXRpb24gLSBwb3NpdGlvbiBhY2Nlc3NvclxuICogQHJldHVybnMge29iamVjdH0gLSBncmlkIGRhdGEsIGNlbGwgZGltZW5zaW9uIGFuZCBjb3VudCByYW5nZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb0RlbnNpdHlHcmlkRGF0YShwb2ludHMsIHdvcmxkVW5pdFNpemUsIGdldFBvc2l0aW9uKSB7XG5cbiAgY29uc3Qge2dyaWRIYXNoLCBncmlkT2Zmc2V0fSA9IF9wb2ludHNUb0dyaWRIYXNoaW5nKHBvaW50cywgd29ybGRVbml0U2l6ZSwgZ2V0UG9zaXRpb24pO1xuICBjb25zdCBsYXllckRhdGEgPSBfZ2V0R3JpZExheWVyRGF0YUZyb21HcmlkSGFzaChncmlkSGFzaCwgZ3JpZE9mZnNldCk7XG4gIGNvbnN0IGNvdW50UmFuZ2UgPSBfZ2V0Q2VsbENvdW50RXh0ZW50KGxheWVyRGF0YSk7XG5cbiAgcmV0dXJuIHtcbiAgICBncmlkT2Zmc2V0LFxuICAgIGxheWVyRGF0YSxcbiAgICBjb3VudFJhbmdlXG4gIH07XG59XG5cbi8qKlxuICogUHJvamVjdCBwb2ludHMgaW50byBlYWNoIGNlbGwsIHJldHVybiBhIGhhc2ggdGFibGUgb2YgY2VsbHNcbiAqIEBwYXJhbSB7YXJyYXl9IHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IHdvcmxkVW5pdFNpemUgLSB1bml0IHNpemUgaW4gbWV0ZXJzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRQb3NpdGlvbiAtIHBvc2l0aW9uIGFjY2Vzc29yXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIGdyaWQgaGFzaCBhbmQgY2VsbCBkaW1lbnNpb25cbiAqL1xuZnVuY3Rpb24gX3BvaW50c1RvR3JpZEhhc2hpbmcocG9pbnRzLCB3b3JsZFVuaXRTaXplLCBnZXRQb3NpdGlvbikge1xuXG4gIC8vIGZpbmQgdGhlIGdlb21ldHJpYyBjZW50ZXIgb2Ygc2FtcGxlIHBvaW50c1xuICBjb25zdCBhbGxMYXQgPSBwb2ludHMubWFwKHAgPT4gZ2V0UG9zaXRpb24ocClbMV0pO1xuICBjb25zdCBsYXRNaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCBhbGxMYXQpO1xuICBjb25zdCBsYXRNYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBhbGxMYXQpO1xuXG4gIGNvbnN0IGNlbnRlckxhdCA9IChsYXRNaW4gKyBsYXRNYXgpIC8gMjtcblxuICBjb25zdCBncmlkT2Zmc2V0ID0gX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQod29ybGRVbml0U2l6ZSwgY2VudGVyTGF0KTtcblxuICBpZiAoZ3JpZE9mZnNldC54T2Zmc2V0IDw9IDAgfHwgZ3JpZE9mZnNldC55T2Zmc2V0IDw9IDApIHtcbiAgICByZXR1cm4ge2dyaWRIYXNoOiB7fSwgZ3JpZE9mZnNldH07XG4gIH1cbiAgLy8gY2FsY3VsYXRlIGNvdW50IHBlciBjZWxsXG4gIGNvbnN0IGdyaWRIYXNoID0gcG9pbnRzLnJlZHVjZSgoYWNjdSwgcHQpID0+IHtcbiAgICBjb25zdCBsYXRJZHggPSBNYXRoLmZsb29yKChnZXRQb3NpdGlvbihwdClbMV0gKyA5MCkgLyBncmlkT2Zmc2V0LnlPZmZzZXQpO1xuICAgIGNvbnN0IGxvbklkeCA9IE1hdGguZmxvb3IoKGdldFBvc2l0aW9uKHB0KVswXSArIDE4MCkgLyBncmlkT2Zmc2V0LnhPZmZzZXQpO1xuICAgIGNvbnN0IGtleSA9IGAke2xhdElkeH0tJHtsb25JZHh9YDtcblxuICAgIGFjY3Vba2V5XSA9IGFjY3Vba2V5XSB8fCB7Y291bnQ6IDAsIHBvaW50czogW119O1xuICAgIGFjY3Vba2V5XS5jb3VudCArPSAxO1xuICAgIGFjY3Vba2V5XS5wb2ludHMucHVzaChwdCk7XG5cbiAgICByZXR1cm4gYWNjdTtcbiAgfSwge30pO1xuXG4gIHJldHVybiB7Z3JpZEhhc2gsIGdyaWRPZmZzZXR9O1xufVxuXG5mdW5jdGlvbiBfZ2V0R3JpZExheWVyRGF0YUZyb21HcmlkSGFzaChncmlkSGFzaCwgZ3JpZE9mZnNldCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZ3JpZEhhc2gpLnJlZHVjZSgoYWNjdSwga2V5LCBpKSA9PiB7XG4gICAgY29uc3QgaWR4cyA9IGtleS5zcGxpdCgnLScpO1xuICAgIGNvbnN0IGxhdElkeCA9IHBhcnNlSW50KGlkeHNbMF0sIDEwKTtcbiAgICBjb25zdCBsb25JZHggPSBwYXJzZUludChpZHhzWzFdLCAxMCk7XG5cbiAgICBhY2N1LnB1c2goT2JqZWN0LmFzc2lnbih7XG4gICAgICBpbmRleDogaSxcbiAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgIC0xODAgKyBncmlkT2Zmc2V0LnhPZmZzZXQgKiBsb25JZHgsXG4gICAgICAgIC05MCArIGdyaWRPZmZzZXQueU9mZnNldCAqIGxhdElkeFxuICAgICAgXVxuICAgIH0sIGdyaWRIYXNoW2tleV0pKTtcblxuICAgIHJldHVybiBhY2N1O1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRDZWxsQ291bnRFeHRlbnQoZGF0YSkge1xuICByZXR1cm4gZGF0YS5sZW5ndGggPyBbXG4gICAgTWF0aC5taW4uYXBwbHkobnVsbCwgZGF0YS5tYXAoZCA9PiBkLmNvdW50KSksXG4gICAgTWF0aC5tYXguYXBwbHkobnVsbCwgZGF0YS5tYXAoZCA9PiBkLmNvdW50KSlcbiAgXSA6IFswLCAxXTtcbn1cblxuLyoqXG4gKiBjYWxjdWxhdGUgZ3JpZCBsYXllciBjZWxsIHNpemUgaW4gbGF0IGxvbiBiYXNlZCBvbiB3b3JsZCB1bml0IHNpemVcbiAqIGFuZCBjdXJyZW50IGxhdGl0dWRlXG4gKiBAcGFyYW0ge251bWJlcn0gd29ybGRVbml0U2l6ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxhdGl0dWRlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIGxhdCBkZWx0YSBhbmQgbG9uIGRlbHRhXG4gKi9cbmZ1bmN0aW9uIF9jYWxjdWxhdGVHcmlkTGF0TG9uT2Zmc2V0KHdvcmxkVW5pdFNpemUsIGxhdGl0dWRlKSB7XG4gIGNvbnN0IHlPZmZzZXQgPSBfY2FsY3VsYXRlTGF0T2Zmc2V0KHdvcmxkVW5pdFNpemUpO1xuICBjb25zdCB4T2Zmc2V0ID0gX2NhbGN1bGF0ZUxvbk9mZnNldChsYXRpdHVkZSwgd29ybGRVbml0U2l6ZSk7XG4gIHJldHVybiB7eU9mZnNldCwgeE9mZnNldH07XG59XG5cbi8qKlxuICogd2l0aCBhIGdpdmVuIHgta20gY2hhbmdlLCBjYWxjdWxhdGUgdGhlIGluY3JlbWVudCBvZiBsYXRpdHVkZVxuICogYmFzZWQgb24gc3RhY2tvdmVyZmxvdyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc0NzcwMDNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIGNoYW5nZSBpbiBrbVxuICogQHJldHVybiB7bnVtYmVyfSAtIGluY3JlbWVudCBpbiBsYXRpdHVkZVxuICovXG5mdW5jdGlvbiBfY2FsY3VsYXRlTGF0T2Zmc2V0KGR5KSB7XG4gIHJldHVybiAoZHkgLyBSX0VBUlRIKSAqICgxODAgLyBNYXRoLlBJKTtcbn1cblxuLyoqXG4gKiB3aXRoIGEgZ2l2ZW4geC1rbSBjaGFuZ2UsIGFuZCBjdXJyZW50IGxhdGl0dWRlXG4gKiBjYWxjdWxhdGUgdGhlIGluY3JlbWVudCBvZiBsb25naXR1ZGVcbiAqIGJhc2VkIG9uIHN0YWNrb3ZlcmZsb3cgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDc3MDAzXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0IC0gbGF0aXR1ZGUgb2YgY3VycmVudCBsb2NhdGlvbiAoYmFzZWQgb24gY2l0eSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeCAtIGNoYW5nZSBpbiBrbVxuICogQHJldHVybiB7bnVtYmVyfSAtIGluY3JlbWVudCBpbiBsb25naXR1ZGVcbiAqL1xuZnVuY3Rpb24gX2NhbGN1bGF0ZUxvbk9mZnNldChsYXQsIGR4KSB7XG4gIHJldHVybiAoZHggLyBSX0VBUlRIKSAqICgxODAgLyBNYXRoLlBJKSAvIE1hdGguY29zKGxhdCAqIE1hdGguUEkgLyAxODApO1xufVxuIl19