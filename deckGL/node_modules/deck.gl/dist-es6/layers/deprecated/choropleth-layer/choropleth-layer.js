var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { Layer } from '../../../lib';
import { assembleShaders } from '../../../shader-utils';
import { Container, flatten } from '../../../lib/utils';
import { extractPolygons } from './geojson';
import { GL, Model, Geometry } from 'luma.gl';
import earcut from 'earcut';

import { join } from 'path';

var DEFAULT_COLOR = [0, 0, 255, 255];

var defaultProps = {
  getColor: function getColor(feature) {
    return Container.get(feature, 'properties.color');
  },
  drawContour: false,
  strokeWidth: 1
};

var ChoroplethLayer = function (_Layer) {
  _inherits(ChoroplethLayer, _Layer);

  function ChoroplethLayer() {
    _classCallCheck(this, ChoroplethLayer);

    return _possibleConstructorReturn(this, (ChoroplethLayer.__proto__ || Object.getPrototypeOf(ChoroplethLayer)).apply(this, arguments));
  }

  _createClass(ChoroplethLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return {
        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#define SHADER_NAME choropleth-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// PICKING\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\nvoid picking_setPickColor(vec3 pickingColor) {\n  vPickingColor = vec4(pickingColor,  1.);\n}\nvec4 picking_setNormalAndPickColors(vec4 color, vec3 pickingColor) {\n  vec4 pickingColor4 = vec4(pickingColor.rgb, 1.);\n  vPickingColor = mix(color, pickingColor4, pickingEnabled);\n  return vPickingColor;\n}\n\n// PICKING\n// vec4 getColor(vec4 color, float opacity, vec3 pickingColor, float renderPickingBuffer) {\n//   vec4 color4 = vec4(color.xyz / 255., color.w / 255. * opacity);\n//   vec4 pickingColor4 = vec4(pickingColor / 255., 1.);\n//   return mix(color4, pickingColor4, renderPickingBuffer);\n// }\n\nvoid main(void) {\n\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\n\n  picking_setNormalAndPickColors(\n    color,\n    pickingColors / 255.\n  );\n\n  vec3 p = project_position(positions);\n  gl_Position = project_to_clipspace(vec4(p, 1.));\n}\n',
        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#define SHADER_NAME choropleth-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// PICKING\n// uniform bool pickingEnabled;\nvarying vec4 vPickingColor;\nvec4 picking_getColor() {\n  return vPickingColor;\n}\n// PICKING\n\nvoid main(void) {\n  gl_FragColor = picking_getColor();\n}\n'
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;
      var attributeManager = this.state.attributeManager;

      attributeManager.addDynamic({
        // Primtive attributes
        indices: { size: 1, update: this.calculateIndices, isIndexed: true },
        positions: { size: 3, update: this.calculatePositions },
        colors: { size: 4, type: GL.UNSIGNED_BYTE, update: this.calculateColors },
        // Instanced attributes
        pickingColors: {
          size: 3,
          type: GL.UNSIGNED_BYTE,
          update: this.calculatePickingColors,
          noAlloc: true
        }
      });

      var IndexType = gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array;

      this.setState({
        model: this.getModel(gl),
        numInstances: 0,
        IndexType: IndexType
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;
      var attributeManager = this.state.attributeManager;

      if (changeFlags.dataChanged) {
        this.state.choropleths = extractPolygons(props.data);
        attributeManager.invalidateAll();
      }

      if (oldProps.opacity !== props.opacity) {
        this.setUniforms({ opacity: props.opacity });
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var gl = this.context.gl;

      var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);
      gl.lineWidth(lineWidth);
      this.state.model.render(uniforms);
      // Setting line width back to 1 is here to workaround a Google Chrome bug
      // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with
      // correct parameter
      // This is not happening on Safari and Firefox
      gl.lineWidth(1.0);
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(opts) {
      var info = _get(ChoroplethLayer.prototype.__proto__ || Object.getPrototypeOf(ChoroplethLayer.prototype), 'getPickingInfo', this).call(this, opts);
      var index = this.decodePickingColor(info.color);
      var feature = index >= 0 ? Container.get(this.props.data, ['features', index]) : null;
      info.feature = feature;
      info.object = feature;
      return info;
    }
  }, {
    key: 'getModel',
    value: function getModel(gl) {
      var shaders = assembleShaders(gl, this.getShaders());

      return new Model({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new Geometry({
          drawMode: this.props.drawContour ? GL.LINES : GL.TRIANGLES
        }),
        vertexCount: 0,
        isIndexed: true
      });
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      var _this2 = this;

      // adjust index offset for multiple choropleths
      var offsets = this.state.choropleths.reduce(function (acc, choropleth) {
        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + choropleth.reduce(function (count, polygon) {
          return count + polygon.length;
        }, 0)]);
      }, [0]);
      var IndexType = this.state.IndexType;

      if (IndexType === Uint16Array && offsets[offsets.length - 1] > 65535) {
        throw new Error('Vertex count exceeds browser\'s limit');
      }

      var indices = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        return _this2.props.drawContour ?
        // 1. get sequentially ordered indices of each choropleth contour
        // 2. offset them by the number of indices in previous choropleths
        calculateContourIndices(choropleth).map(function (index) {
          return index + offsets[choroplethIndex];
        }) :
        // 1. get triangulated indices for the internal areas
        // 2. offset them by the number of indices in previous choropleths
        calculateSurfaceIndices(choropleth).map(function (index) {
          return index + offsets[choroplethIndex];
        });
      });

      attribute.value = new IndexType(flatten(indices));
      attribute.target = GL.ELEMENT_ARRAY_BUFFER;
      this.state.model.setVertexCount(attribute.value.length / attribute.size);
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      var vertices = flatten(this.state.choropleths);
      attribute.value = new Float32Array(vertices);
    }
  }, {
    key: 'calculateColors',
    value: function calculateColors(attribute) {
      var _props = this.props,
          data = _props.data,
          getColor = _props.getColor;

      var features = Container.get(data, 'features');
      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        var feature = Container.get(features, choropleth.featureIndex);
        var color = getColor(feature) || DEFAULT_COLOR;
        // Ensure alpha is set
        if (isNaN(color[3])) {
          color[3] = DEFAULT_COLOR[3];
        }
        return choropleth.map(function (polygon) {
          return polygon.map(function (vertex) {
            return color;
          });
        });
      });

      attribute.value = new Uint8Array(flatten(colors));
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      var _this3 = this;

      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        var featureIndex = choropleth.featureIndex;

        var color = _this3.props.drawContour ? [0, 0, 0] : [(featureIndex + 1) % 256, Math.floor((featureIndex + 1) / 256) % 256, Math.floor((featureIndex + 1) / 256 / 256) % 256];
        return choropleth.map(function (polygon) {
          return polygon.map(function (vertex) {
            return color;
          });
        });
      });

      attribute.value = new Uint8Array(flatten(colors));
    }
  }]);

  return ChoroplethLayer;
}(Layer);

export default ChoroplethLayer;


ChoroplethLayer.layerName = 'ChoroplethLayer';
ChoroplethLayer.defaultProps = defaultProps;

/*
 * get vertex indices for drawing choropleth contour
 * @param {[Number,Number,Number][][]} choropleth
 * @returns {[Number]} indices
 */
function calculateContourIndices(choropleth) {
  var offset = 0;

  return choropleth.reduce(function (acc, polygon) {
    var numVertices = polygon.length;

    // use vertex pairs for gl.LINES => [0, 1, 1, 2, 2, ..., n-2, n-2, n-1]
    var indices = [].concat(_toConsumableArray(acc), [offset]);
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset + numVertices - 1);

    offset += numVertices;
    return indices;
  }, []);
}

/*
 * get vertex indices for drawing choropleth mesh
 * @param {[Number,Number,Number][][]} choropleth
 * @returns {[Number]} indices
 */
function calculateSurfaceIndices(choropleth) {
  var holes = null;

  if (choropleth.length > 1) {
    holes = choropleth.reduce(function (acc, polygon) {
      return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);
    }, [0]).slice(1, choropleth.length);
  }

  return earcut(flatten(choropleth), holes, 3);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXIuanMiXSwibmFtZXMiOlsiTGF5ZXIiLCJhc3NlbWJsZVNoYWRlcnMiLCJDb250YWluZXIiLCJmbGF0dGVuIiwiZXh0cmFjdFBvbHlnb25zIiwiR0wiLCJNb2RlbCIsIkdlb21ldHJ5IiwiZWFyY3V0Iiwiam9pbiIsIkRFRkFVTFRfQ09MT1IiLCJkZWZhdWx0UHJvcHMiLCJnZXRDb2xvciIsImdldCIsImZlYXR1cmUiLCJkcmF3Q29udG91ciIsInN0cm9rZVdpZHRoIiwiQ2hvcm9wbGV0aExheWVyIiwidnMiLCJmcyIsImdsIiwiY29udGV4dCIsImF0dHJpYnV0ZU1hbmFnZXIiLCJzdGF0ZSIsImFkZER5bmFtaWMiLCJpbmRpY2VzIiwic2l6ZSIsInVwZGF0ZSIsImNhbGN1bGF0ZUluZGljZXMiLCJpc0luZGV4ZWQiLCJwb3NpdGlvbnMiLCJjYWxjdWxhdGVQb3NpdGlvbnMiLCJjb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUNvbG9ycyIsInBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwibm9BbGxvYyIsIkluZGV4VHlwZSIsImdldEV4dGVuc2lvbiIsIlVpbnQzMkFycmF5IiwiVWludDE2QXJyYXkiLCJzZXRTdGF0ZSIsIm1vZGVsIiwiZ2V0TW9kZWwiLCJudW1JbnN0YW5jZXMiLCJvbGRQcm9wcyIsInByb3BzIiwiY2hhbmdlRmxhZ3MiLCJkYXRhQ2hhbmdlZCIsImNob3JvcGxldGhzIiwiZGF0YSIsImludmFsaWRhdGVBbGwiLCJvcGFjaXR5Iiwic2V0VW5pZm9ybXMiLCJ1bmlmb3JtcyIsImxpbmVXaWR0aCIsInNjcmVlblRvRGV2aWNlUGl4ZWxzIiwicmVuZGVyIiwib3B0cyIsImluZm8iLCJpbmRleCIsImRlY29kZVBpY2tpbmdDb2xvciIsImNvbG9yIiwib2JqZWN0Iiwic2hhZGVycyIsImdldFNoYWRlcnMiLCJpZCIsImdlb21ldHJ5IiwiZHJhd01vZGUiLCJMSU5FUyIsIlRSSUFOR0xFUyIsInZlcnRleENvdW50IiwiYXR0cmlidXRlIiwib2Zmc2V0cyIsInJlZHVjZSIsImFjYyIsImNob3JvcGxldGgiLCJsZW5ndGgiLCJjb3VudCIsInBvbHlnb24iLCJFcnJvciIsIm1hcCIsImNob3JvcGxldGhJbmRleCIsImNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzIiwiY2FsY3VsYXRlU3VyZmFjZUluZGljZXMiLCJ2YWx1ZSIsInRhcmdldCIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwic2V0VmVydGV4Q291bnQiLCJ2ZXJ0aWNlcyIsIkZsb2F0MzJBcnJheSIsImZlYXR1cmVzIiwiZmVhdHVyZUluZGV4IiwiaXNOYU4iLCJVaW50OEFycmF5IiwiTWF0aCIsImZsb29yIiwibGF5ZXJOYW1lIiwib2Zmc2V0IiwibnVtVmVydGljZXMiLCJpIiwicHVzaCIsImhvbGVzIiwic2xpY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLEtBQVIsUUFBb0IsY0FBcEI7QUFDQSxTQUFRQyxlQUFSLFFBQThCLHVCQUE5QjtBQUNBLFNBQVFDLFNBQVIsRUFBbUJDLE9BQW5CLFFBQWlDLG9CQUFqQztBQUNBLFNBQVFDLGVBQVIsUUFBOEIsV0FBOUI7QUFDQSxTQUFRQyxFQUFSLEVBQVlDLEtBQVosRUFBbUJDLFFBQW5CLFFBQWtDLFNBQWxDO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjs7QUFFQSxTQUFRQyxJQUFSLFFBQW1CLE1BQW5COztBQUVBLElBQU1DLGdCQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sR0FBUCxFQUFZLEdBQVosQ0FBdEI7O0FBRUEsSUFBTUMsZUFBZTtBQUNuQkMsWUFBVTtB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RUFHTjBCLEtBSE0sQ0FHQSxDQUhBLEVBR0czQixXQUFXQyxNQUhkLENBQVI7QUFJRDs7QUFFRCxTQUFPdkUsT0FBT0wsUUFBUTJFLFVBQVIsQ0FBUCxFQUE0QjBCLEtBQTVCLEVBQW1DLENBQW5DLENBQVA7QUFDRCIsImZpbGUiOiJjaG9yb3BsZXRoLWxheWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7YXNzZW1ibGVTaGFkZXJzfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHtDb250YWluZXIsIGZsYXR0ZW59IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQge2V4dHJhY3RQb2x5Z29uc30gZnJvbSAnLi9nZW9qc29uJztcbmltcG9ydCB7R0wsIE1vZGVsLCBHZW9tZXRyeX0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5pbXBvcnQge3JlYWRGaWxlU3luY30gZnJvbSAnZnMnO1xuaW1wb3J0IHtqb2lufSBmcm9tICdwYXRoJztcblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAyNTUsIDI1NV07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgZ2V0Q29sb3I6IGZlYXR1cmUgPT4gQ29udGFpbmVyLmdldChmZWF0dXJlLCAncHJvcGVydGllcy5jb2xvcicpLFxuICBkcmF3Q29udG91cjogZmFsc2UsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9yb3BsZXRoTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZzOiByZWFkRmlsZVN5bmMoam9pbihfX2Rpcm5hbWUsICcuL2Nob3JvcGxldGgtbGF5ZXItdmVydGV4Lmdsc2wnKSwgJ3V0ZjgnKSxcbiAgICAgIGZzOiByZWFkRmlsZVN5bmMoam9pbihfX2Rpcm5hbWUsICcuL2Nob3JvcGxldGgtbGF5ZXItZnJhZ21lbnQuZ2xzbCcpLCAndXRmOCcpXG4gICAgfTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZER5bmFtaWMoe1xuICAgICAgLy8gUHJpbXRpdmUgYXR0cmlidXRlc1xuICAgICAgaW5kaWNlczoge3NpemU6IDEsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbmRpY2VzLCBpc0luZGV4ZWQ6IHRydWV9LFxuICAgICAgcG9zaXRpb25zOiB7c2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uc30sXG4gICAgICBjb2xvcnM6IHtzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlQ29sb3JzfSxcbiAgICAgIC8vIEluc3RhbmNlZCBhdHRyaWJ1dGVzXG4gICAgICBwaWNraW5nQ29sb3JzOiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQaWNraW5nQ29sb3JzLFxuICAgICAgICBub0FsbG9jOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBJbmRleFR5cGUgPSBnbC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG1vZGVsOiB0aGlzLmdldE1vZGVsKGdsKSxcbiAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgIEluZGV4VHlwZVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMgPSBleHRyYWN0UG9seWdvbnMocHJvcHMuZGF0YSk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMub3BhY2l0eSAhPT0gcHJvcHMub3BhY2l0eSkge1xuICAgICAgdGhpcy5zZXRVbmlmb3Jtcyh7b3BhY2l0eTogcHJvcHMub3BhY2l0eX0pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgbGluZVdpZHRoID0gdGhpcy5zY3JlZW5Ub0RldmljZVBpeGVscyh0aGlzLnByb3BzLnN0cm9rZVdpZHRoKTtcbiAgICBnbC5saW5lV2lkdGgobGluZVdpZHRoKTtcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gICAgLy8gU2V0dGluZyBsaW5lIHdpZHRoIGJhY2sgdG8gMSBpcyBoZXJlIHRvIHdvcmthcm91bmQgYSBHb29nbGUgQ2hyb21lIGJ1Z1xuICAgIC8vIGdsLmNsZWFyKCkgYW5kIGdsLmlzRW5hYmxlZCgpIHdpbGwgcmV0dXJuIEdMX0lOVkFMSURfVkFMVUUgZXZlbiB3aXRoXG4gICAgLy8gY29ycmVjdCBwYXJhbWV0ZXJcbiAgICAvLyBUaGlzIGlzIG5vdCBoYXBwZW5pbmcgb24gU2FmYXJpIGFuZCBGaXJlZm94XG4gICAgZ2wubGluZVdpZHRoKDEuMCk7XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyhvcHRzKSB7XG4gICAgY29uc3QgaW5mbyA9IHN1cGVyLmdldFBpY2tpbmdJbmZvKG9wdHMpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZWNvZGVQaWNraW5nQ29sb3IoaW5mby5jb2xvcik7XG4gICAgY29uc3QgZmVhdHVyZSA9IGluZGV4ID49IDAgPyBDb250YWluZXIuZ2V0KHRoaXMucHJvcHMuZGF0YSwgWydmZWF0dXJlcycsIGluZGV4XSkgOiBudWxsO1xuICAgIGluZm8uZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgaW5mby5vYmplY3QgPSBmZWF0dXJlO1xuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgZ2V0TW9kZWwoZ2wpIHtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiB0aGlzLnByb3BzLmRyYXdDb250b3VyID8gR0wuTElORVMgOiBHTC5UUklBTkdMRVNcbiAgICAgIH0pLFxuICAgICAgdmVydGV4Q291bnQ6IDAsXG4gICAgICBpc0luZGV4ZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgY2hvcm9wbGV0aHNcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5yZWR1Y2UoXG4gICAgICAoYWNjLCBjaG9yb3BsZXRoKSA9PiBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICtcbiAgICAgICAgY2hvcm9wbGV0aC5yZWR1Y2UoKGNvdW50LCBwb2x5Z29uKSA9PiBjb3VudCArIHBvbHlnb24ubGVuZ3RoLCAwKV0sXG4gICAgICBbMF1cbiAgICApO1xuICAgIGNvbnN0IHtJbmRleFR5cGV9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoSW5kZXhUeXBlID09PSBVaW50MTZBcnJheSAmJiBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV0gPiA2NTUzNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggY291bnQgZXhjZWVkcyBicm93c2VyXFwncyBsaW1pdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcChcbiAgICAgIChjaG9yb3BsZXRoLCBjaG9yb3BsZXRoSW5kZXgpID0+IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgP1xuICAgICAgICAvLyAxLiBnZXQgc2VxdWVudGlhbGx5IG9yZGVyZWQgaW5kaWNlcyBvZiBlYWNoIGNob3JvcGxldGggY29udG91clxuICAgICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgY2hvcm9wbGV0aHNcbiAgICAgICAgY2FsY3VsYXRlQ29udG91ckluZGljZXMoY2hvcm9wbGV0aCkubWFwKGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0c1tjaG9yb3BsZXRoSW5kZXhdKSA6XG4gICAgICAgIC8vIDEuIGdldCB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBmb3IgdGhlIGludGVybmFsIGFyZWFzXG4gICAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBjaG9yb3BsZXRoc1xuICAgICAgICBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyhjaG9yb3BsZXRoKS5tYXAoaW5kZXggPT4gaW5kZXggKyBvZmZzZXRzW2Nob3JvcGxldGhJbmRleF0pXG4gICAgKTtcblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBJbmRleFR5cGUoZmxhdHRlbihpbmRpY2VzKSk7XG4gICAgYXR0cmlidXRlLnRhcmdldCA9IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VmVydGV4Q291bnQoYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IGZsYXR0ZW4odGhpcy5zdGF0ZS5jaG9yb3BsZXRocyk7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyk7XG4gIH1cblxuICBjYWxjdWxhdGVDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldENvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBDb250YWluZXIuZ2V0KGRhdGEsICdmZWF0dXJlcycpO1xuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMubWFwKFxuICAgICAgKGNob3JvcGxldGgsIGNob3JvcGxldGhJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBmZWF0dXJlID0gQ29udGFpbmVyLmdldChmZWF0dXJlcywgY2hvcm9wbGV0aC5mZWF0dXJlSW5kZXgpO1xuICAgICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKGZlYXR1cmUpIHx8IERFRkFVTFRfQ09MT1I7XG4gICAgICAgIC8vIEVuc3VyZSBhbHBoYSBpcyBzZXRcbiAgICAgICAgaWYgKGlzTmFOKGNvbG9yWzNdKSkge1xuICAgICAgICAgIGNvbG9yWzNdID0gREVGQVVMVF9DT0xPUlszXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hvcm9wbGV0aC5tYXAocG9seWdvbiA9PiBwb2x5Z29uLm1hcCh2ZXJ0ZXggPT4gY29sb3IpKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoZmxhdHRlbihjb2xvcnMpKTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHBpY2tpbmcgY29sb3JzIGNhbGN1bGF0aW9uXG4gIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5tYXAoXG4gICAgICAoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHtmZWF0dXJlSW5kZXh9ID0gY2hvcm9wbGV0aDtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLnByb3BzLmRyYXdDb250b3VyID8gWzAsIDAsIDBdIDogW1xuICAgICAgICAgIChmZWF0dXJlSW5kZXggKyAxKSAlIDI1NixcbiAgICAgICAgICBNYXRoLmZsb29yKChmZWF0dXJlSW5kZXggKyAxKSAvIDI1NikgJSAyNTYsXG4gICAgICAgICAgTWF0aC5mbG9vcigoZmVhdHVyZUluZGV4ICsgMSkgLyAyNTYgLyAyNTYpICUgMjU2XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBjaG9yb3BsZXRoLm1hcChwb2x5Z29uID0+IHBvbHlnb24ubWFwKHZlcnRleCA9PiBjb2xvcikpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgVWludDhBcnJheShmbGF0dGVuKGNvbG9ycykpO1xuICB9XG59XG5cbkNob3JvcGxldGhMYXllci5sYXllck5hbWUgPSAnQ2hvcm9wbGV0aExheWVyJztcbkNob3JvcGxldGhMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbi8qXG4gKiBnZXQgdmVydGV4IGluZGljZXMgZm9yIGRyYXdpbmcgY2hvcm9wbGV0aCBjb250b3VyXG4gKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyLE51bWJlcl1bXVtdfSBjaG9yb3BsZXRoXG4gKiBAcmV0dXJucyB7W051bWJlcl19IGluZGljZXNcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQ29udG91ckluZGljZXMoY2hvcm9wbGV0aCkge1xuICBsZXQgb2Zmc2V0ID0gMDtcblxuICByZXR1cm4gY2hvcm9wbGV0aC5yZWR1Y2UoKGFjYywgcG9seWdvbikgPT4ge1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG5cbiAgICAvLyB1c2UgdmVydGV4IHBhaXJzIGZvciBnbC5MSU5FUyA9PiBbMCwgMSwgMSwgMiwgMiwgLi4uLCBuLTIsIG4tMiwgbi0xXVxuICAgIGNvbnN0IGluZGljZXMgPSBbLi4uYWNjLCBvZmZzZXRdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgIGluZGljZXMucHVzaChpICsgb2Zmc2V0LCBpICsgb2Zmc2V0KTtcbiAgICB9XG4gICAgaW5kaWNlcy5wdXNoKG9mZnNldCArIG51bVZlcnRpY2VzIC0gMSk7XG5cbiAgICBvZmZzZXQgKz0gbnVtVmVydGljZXM7XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH0sIFtdKTtcbn1cblxuLypcbiAqIGdldCB2ZXJ0ZXggaW5kaWNlcyBmb3IgZHJhd2luZyBjaG9yb3BsZXRoIG1lc2hcbiAqIEBwYXJhbSB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW119IGNob3JvcGxldGhcbiAqIEByZXR1cm5zIHtbTnVtYmVyXX0gaW5kaWNlc1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyhjaG9yb3BsZXRoKSB7XG4gIGxldCBob2xlcyA9IG51bGw7XG5cbiAgaWYgKGNob3JvcGxldGgubGVuZ3RoID4gMSkge1xuICAgIGhvbGVzID0gY2hvcm9wbGV0aC5yZWR1Y2UoXG4gICAgICAoYWNjLCBwb2x5Z29uKSA9PiBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICsgcG9seWdvbi5sZW5ndGhdLFxuICAgICAgWzBdXG4gICAgKS5zbGljZSgxLCBjaG9yb3BsZXRoLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gZWFyY3V0KGZsYXR0ZW4oY2hvcm9wbGV0aCksIGhvbGVzLCAzKTtcbn1cbiJdfQ==