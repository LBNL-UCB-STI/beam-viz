var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// View and Projection Matrix calculations for mapbox-js style
// map view properties
import Viewport, { createMat4 } from './viewport';
import { mat4, vec4, vec2 } from 'gl-matrix';

// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var WORLD_SCALE = TILE_SIZE / (2 * PI);

var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var WebMercatorViewport = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity, max-statements */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        mercatorEnabled = _ref.mercatorEnabled;

    _classCallCheck(this, WebMercatorViewport);

    // Viewport - support undefined arguments
    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    var scale = Math.pow(2, zoom);
    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var distanceScales = calculateDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var projectionMatrix = makeProjectionMatrixFromMercatorParams({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude
    });

    var _makeViewMatrixFromMe = makeViewMatrixFromMercatorParams({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      distanceScales: distanceScales
    }),
        viewMatrix = _makeViewMatrixFromMe.viewMatrix,
        viewMatrixUncentered = _makeViewMatrixFromMe.viewMatrixUncentered,
        viewCenter = _makeViewMatrixFromMe.viewCenter;

    // Add additional matrices
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix }));

    _this.viewMatrixUncentered = viewMatrixUncentered;
    _this.viewCenter = viewCenter;

    // Save parameters
    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    _this.scale = scale;

    _this._distanceScales = distanceScales;

    _this.getDistanceScales = _this.getDistanceScales.bind(_this);
    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind(_this);
    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind(_this);
    _this.addMetersToLngLat = _this.addMetersToLngLat.bind(_this);
    return _this;
  }
  /* eslint-enable complexity, max-statements */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return projectFlat(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return unprojectFlat(xy, scale);
    }
  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return this._distanceScales;
    }

    /**
     * Converts a meter offset to a lnglat offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
     */

  }, {
    key: 'metersToLngLatDelta',
    value: function metersToLngLatDelta(xyz) {
      var _xyz = _slicedToArray(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === undefined ? 0 : _xyz$;

      var _distanceScales = this._distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    /**
     * Converts a lnglat offset to a meter offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
     */

  }, {
    key: 'lngLatDeltaToMeters',
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;

      var _distanceScales2 = this._distanceScales,
          pixelsPerDegree = _distanceScales2.pixelsPerDegree,
          metersPerPixel = _distanceScales2.metersPerPixel;

      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */

  }, {
    key: 'addMetersToLngLat',
    value: function addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),
          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),
          deltaLng = _metersToLngLatDelta2[0],
          deltaLat = _metersToLngLatDelta2[1],
          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],
          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }

    // INTERNAL METHODS

  }, {
    key: '_getParams',
    value: function _getParams() {
      return this._distanceScales;
    }
  }]);

  return WebMercatorViewport;
}(Viewport);

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */


export default WebMercatorViewport;
function projectFlat(_ref2, scale) {
  var _ref3 = _slicedToArray(_ref2, 2),
      lng = _ref3[0],
      lat = _ref3[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5)));
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
function unprojectFlat(_ref4, scale) {
  var _ref5 = _slicedToArray(_ref4, 2),
      x = _ref5[0],
      y = _ref5[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = x / scale - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
function calculateDistanceScales(_ref6) {
  var latitude = _ref6.latitude,
      longitude = _ref6.longitude,
      scale = _ref6.scale;

  // Approximately 111km per degree at equator
  var METERS_PER_DEGREE = 111000;

  var latCosine = Math.cos(latitude * Math.PI / 180);

  var metersPerDegree = METERS_PER_DEGREE * latCosine;

  // Calculate number of pixels occupied by one degree longitude
  // around current lat/lon
  var pixelsPerDegreeX = vec2.distance(projectFlat([longitude + 0.5, latitude]), projectFlat([longitude - 0.5, latitude]));
  // Calculate number of pixels occupied by one degree latitude
  // around current lat/lon
  var pixelsPerDegreeY = vec2.distance(projectFlat([longitude, latitude + 0.5]), projectFlat([longitude, latitude - 0.5]));

  var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;
  var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;
  var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;
  // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];

  var worldSize = TILE_SIZE * scale;
  var altPixelsPerMeter = worldSize / (4e7 * latCosine);
  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];

  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];
  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ];

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return {
    pixelsPerMeter: pixelsPerMeter,
    metersPerPixel: metersPerPixel,
    pixelsPerDegree: pixelsPerDegree,
    degreesPerPixel: degreesPerPixel
  };
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js
function makeProjectionMatrixFromMercatorParams(_ref7) {
  var width = _ref7.width,
      height = _ref7.height,
      pitch = _ref7.pitch,
      altitude = _ref7.altitude;

  var pitchRadians = pitch * DEGREES_TO_RADIANS;

  // PROJECTION MATRIX: PROJECTS FROM CAMERA SPACE TO CLIPSPACE
  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  var projectionMatrix = mat4.perspective(createMat4(), 2 * Math.atan(height / 2 / altitude), // fov in radians
  width / height, // aspect ratio
  0.1, // near plane
  farZ * 10.0 // far plane
  );

  return projectionMatrix;
}

function makeViewMatrixFromMercatorParams(_ref8) {
  var width = _ref8.width,
      height = _ref8.height,
      longitude = _ref8.longitude,
      latitude = _ref8.latitude,
      zoom = _ref8.zoom,
      pitch = _ref8.pitch,
      bearing = _ref8.bearing,
      altitude = _ref8.altitude;

  // Center x, y
  var scale = Math.pow(2, zoom);
  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = createMat4();

  // Move camera to altitude
  mat4.translate(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  mat4.scale(vm, vm, [1, -1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  mat4.rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);
  mat4.rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS);

  var _projectFlat2 = projectFlat([longitude, latitude], scale),
      _projectFlat3 = _slicedToArray(_projectFlat2, 2),
      centerX = _projectFlat3[0],
      centerY = _projectFlat3[1];

  var center = [-centerX, -centerY, 0, 1];
  var viewCenter = vec4.transformMat4([], center, vm);

  var vmCentered = mat4.translate([], vm, [-centerX, -centerY, 0]);

  return {
    viewMatrix: vmCentered,
    viewMatrixUncentered: vm,
    viewCenter: viewCenter
  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL3dlYi1tZXJjYXRvci12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJWaWV3cG9ydCIsImNyZWF0ZU1hdDQiLCJtYXQ0IiwidmVjNCIsInZlYzIiLCJQSSIsIk1hdGgiLCJQSV80IiwiREVHUkVFU19UT19SQURJQU5TIiwiUkFESUFOU19UT19ERUdSRUVTIiwiVElMRV9TSVpFIiwiV09STERfU0NBTEUiLCJERUZBVUxUX01BUF9TVEFURSIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsImFsdGl0dWRlIiwiV2ViTWVyY2F0b3JWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwibWVyY2F0b3JFbmFibGVkIiwidW5kZWZpbmVkIiwic2NhbGUiLCJwb3ciLCJtYXgiLCJkaXN0YW5jZVNjYWxlcyIsImNhbGN1bGF0ZURpc3RhbmNlU2NhbGVzIiwicHJvamVjdGlvbk1hdHJpeCIsIm1ha2VQcm9qZWN0aW9uTWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zIiwibWFrZVZpZXdNYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMiLCJ2aWV3TWF0cml4Iiwidmlld01hdHJpeFVuY2VudGVyZWQiLCJ2aWV3Q2VudGVyIiwiX2Rpc3RhbmNlU2NhbGVzIiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJiaW5kIiwibWV0ZXJzVG9MbmdMYXREZWx0YSIsImxuZ0xhdERlbHRhVG9NZXRlcnMiLCJhZGRNZXRlcnNUb0xuZ0xhdCIsImxuZ0xhdCIsInByb2plY3RGbGF0IiwieHkiLCJ1bnByb2plY3RGbGF0IiwieHl6IiwieCIsInkiLCJ6IiwicGl4ZWxzUGVyTWV0ZXIiLCJkZWdyZWVzUGVyUGl4ZWwiLCJkZWx0YUxuZyIsImRlbHRhTGF0IiwibGVuZ3RoIiwiZGVsdGFMbmdMYXRaIiwiZGVsdGFaIiwicGl4ZWxzUGVyRGVncmVlIiwibWV0ZXJzUGVyUGl4ZWwiLCJkZWx0YVgiLCJkZWx0YVkiLCJsbmdMYXRaIiwibG5nIiwibGF0IiwiWiIsImxhbWJkYTIiLCJwaGkyIiwibG9nIiwidGFuIiwiYXRhbiIsImV4cCIsIk1FVEVSU19QRVJfREVHUkVFIiwibGF0Q29zaW5lIiwiY29zIiwibWV0ZXJzUGVyRGVncmVlIiwicGl4ZWxzUGVyRGVncmVlWCIsImRpc3RhbmNlIiwicGl4ZWxzUGVyRGVncmVlWSIsInBpeGVsc1Blck1ldGVyWCIsInBpeGVsc1Blck1ldGVyWSIsInBpeGVsc1Blck1ldGVyWiIsIndvcmxkU2l6ZSIsImFsdFBpeGVsc1Blck1ldGVyIiwicGl0Y2hSYWRpYW5zIiwiaGFsZkZvdiIsInRvcEhhbGZTdXJmYWNlRGlzdGFuY2UiLCJzaW4iLCJmYXJaIiwicGVyc3BlY3RpdmUiLCJ2bSIsInRyYW5zbGF0ZSIsInJvdGF0ZVgiLCJyb3RhdGVaIiwiY2VudGVyWCIsImNlbnRlclkiLCJjZW50ZXIiLCJ0cmFuc2Zvcm1NYXQ0Iiwidm1DZW50ZXJlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxPQUFPQSxRQUFQLElBQWtCQyxVQUFsQixRQUFtQyxZQUFuQztBQUNBLFNBQVFDLElBQVIsRUFBY0MsSUFBZCxFQUFvQkMsSUFBcEIsUUFBK0IsV0FBL0I7O0FBRUE7QUFDQSxJQUFNQyxLQUFLQyxLQUFLRCxFQUFoQjtBQUNBLElBQU1FLE9BQU9GLEtBQUssQ0FBbEI7QUFDQSxJQUFNRyxxQkFBcUJILEtBQUssR0FBaEM7QUFDQSxJQUFNSSxxQkFBcUIsTUFBTUosRUFBakM7QUFDQSxJQUFNSyxZQUFZLEdBQWxCO0FBQ0EsSUFBTUMsY0FBY0QsYUFBYSxJQUFJTCxFQUFqQixDQUFwQjs7QUFFQSxJQUFNTyxvQkFBb0I7QUFDeEJDLFlBQVUsRUFEYztBQUV4QkMsYUFBVyxDQUFDLEdBRlk7QUFHeEJDLFFBQU0sRUFIa0I7QUFJeEJDLFNBQU8sQ0FKaUI7QUFLeEJDLFdBQVMsQ0FMZTtBQU14QkMsWUFBVTtBQU5jLENBQTFCOztJQVNxQkMsbUI7OztBQUNuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDQTtBQUNBLGlDQVdRO0FBQUEsbUZBQUosRUFBSTtBQUFBLFFBVE5DLEtBU00sUUFUTkEsS0FTTTtBQUFBLFFBUk5DLE1BUU0sUUFSTkEsTUFRTTtBQUFBLFFBUE5SLFFBT00sUUFQTkEsUUFPTTtBQUFBLFFBTk5DLFNBTU0sUUFOTkEsU0FNTTtBQUFBLFFBTE5DLElBS00sUUFMTkEsSUFLTTtBQUFBLFFBSk5DLEtBSU0sUUFKTkEsS0FJTTtBQUFBLFFBSE5DLE9BR00sUUFITkEsT0FHTTtBQUFBLFFBRk5DLFFBRU0sUUFGTkEsUUFFTTtBQUFBLFFBRE5JLGVBQ00sUUFETkEsZUFDTTs7QUFBQTs7QUFDTjtBQUNBRixZQUFRQSxVQUFVRyxTQUFWLEdBQXNCSCxLQUF0QixHQUE4QlIsa0JBQWtCUSxLQUF4RDtBQUNBQyxhQUFTQSxXQUFXRSxTQUFYLEdBQXVCRixNQUF2QixHQUFnQ1Qsa0JBQWtCUyxNQUEzRDtBQUNBTixXQUFPQSxTQUFTUSxTQUFULEdBQXFCUixJQUFyQixHQUE0Qkgsa0JBQWtCRyxJQUFyRDtBQUNBRixlQUFXQSxhQUFhVSxTQUFiLEdBQXlCVixRQUF6QixHQUFvQ0Qsa0JBQWtCQyxRQUFqRTtBQUNBQyxnQkFBWUEsY0FBY1MsU0FBZCxHQUEwQlQsU0FBMUIsR0FBc0NGLGtCQUFrQkUsU0FBcEU7QUFDQUcsY0FBVUEsWUFBWU0sU0FBWixHQUF3Qk4sT0FBeEIsR0FBa0NMLGtCQUFrQkssT0FBOUQ7QUFDQUQsWUFBUUEsVUFBVU8sU0FBVixHQUFzQlAsS0FBdEIsR0FBOEJKLGtCQUFrQkksS0FBeEQ7QUFDQUUsZUFBV0EsYUFBYUssU0FBYixHQUF5QkwsUUFBekIsR0FBb0NOLGtCQUFrQk0sUUFBakU7O0FBRUE7QUFDQUUsWUFBUUEsU0FBUyxDQUFqQjtBQUNBQyxhQUFTQSxVQUFVLENBQW5COztBQUVBLFFBQU1HLFFBQVFsQixLQUFLbUIsR0FBTCxDQUFTLENBQVQsRUFBWVYsSUFBWixDQUFkO0FBQ0E7QUFDQTtBQUNBRyxlQUFXWixLQUFLb0IsR0FBTCxDQUFTLElBQVQsRUFBZVIsUUFBZixDQUFYOztBQUVBLFFBQU1TLGlCQUFpQkMsd0JBQXdCLEVBQUNmLGtCQUFELEVBQVdDLG9CQUFYLEVBQXNCVSxZQUF0QixFQUF4QixDQUF2Qjs7QUFFQSxRQUFNSyxtQkFBbUJDLHVDQUF1QztBQUM5RFYsa0JBRDhEO0FBRTlEQyxvQkFGOEQ7QUFHOURMLGtCQUg4RDtBQUk5REMsc0JBSjhEO0FBSzlEQztBQUw4RCxLQUF2QyxDQUF6Qjs7QUF0Qk0sZ0NBK0JKYSxpQ0FBaUM7QUFDL0JYLGtCQUQrQjtBQUUvQkMsb0JBRitCO0FBRy9CUCwwQkFIK0I7QUFJL0JELHdCQUorQjtBQUsvQkUsZ0JBTCtCO0FBTS9CQyxrQkFOK0I7QUFPL0JDLHNCQVArQjtBQVEvQkMsd0JBUitCO0FBUy9CUztBQVQrQixLQUFqQyxDQS9CSTtBQUFBLFFBOEJDSyxVQTlCRCx5QkE4QkNBLFVBOUJEO0FBQUEsUUE4QmFDLG9CQTlCYix5QkE4QmFBLG9CQTlCYjtBQUFBLFFBOEJtQ0MsVUE5Qm5DLHlCQThCbUNBLFVBOUJuQzs7QUE2Q047QUE3Q00sMElBMkNBLEVBQUNkLFlBQUQsRUFBUUMsY0FBUixFQUFnQlcsc0JBQWhCLEVBQTRCSCxrQ0FBNUIsRUEzQ0E7O0FBOENOLFVBQUtJLG9CQUFMLEdBQTRCQSxvQkFBNUI7QUFDQSxVQUFLQyxVQUFMLEdBQWtCQSxVQUFsQjs7QUFFQTtBQUNBLFVBQUtyQixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFVBQUtDLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0EsVUFBS0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsVUFBS0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsVUFBS0MsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsVUFBS0MsUUFBTCxHQUFnQkEsUUFBaEI7O0FBRUEsVUFBS00sS0FBTCxHQUFhQSxLQUFiOztBQUVBLFVBQUtXLGVBQUwsR0FBdUJSLGNBQXZCOztBQUVBLFVBQUtTLGlCQUFMLEdBQXlCLE1BQUtBLGlCQUFMLENBQXVCQyxJQUF2QixPQUF6QjtBQUNBLFVBQUtDLG1CQUFMLEdBQTJCLE1BQUtBLG1CQUFMLENBQXlCRCxJQUF6QixPQUEzQjtBQUNBLFVBQUtFLG1CQUFMLEdBQTJCLE1BQUtBLG1CQUFMLENBQXlCRixJQUF6QixPQUEzQjtBQUNBLFVBQUtHLGlCQUFMLEdBQXlCLE1BQUtBLGlCQUFMLENBQXVCSCxJQUF2QixPQUF6QjtBQWhFTTtBQWlFUDtBQUNEOztBQUVBOzs7Ozs7Ozs7Ozs7OztpQ0FVYUksTSxFQUE0QjtBQUFBLFVBQXBCakIsS0FBb0IsdUVBQVosS0FBS0EsS0FBTzs7QUFDdkMsYUFBT2tCLFlBQVlELE1BQVosRUFBb0JqQixLQUFwQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7OzttQ0FTZW1CLEUsRUFBd0I7QUFBQSxVQUFwQm5CLEtBQW9CLHVFQUFaLEtBQUtBLEtBQU87O0FBQ3JDLGFBQU9vQixjQUFjRCxFQUFkLEVBQWtCbkIsS0FBbEIsQ0FBUDtBQUNEOzs7d0NBRW1CO0FBQ2xCLGFBQU8sS0FBS1csZUFBWjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7d0NBU29CVSxHLEVBQUs7QUFBQSxnQ0FDREEsR0FEQztBQUFBLFVBQ2hCQyxDQURnQjtBQUFBLFVBQ2JDLENBRGE7QUFBQTtBQUFBLFVBQ1ZDLENBRFUseUJBQ04sQ0FETTs7QUFBQSw0QkFFbUIsS0FBS2IsZUFGeEI7QUFBQSxVQUVoQmMsY0FGZ0IsbUJBRWhCQSxjQUZnQjtBQUFBLFVBRUFDLGVBRkEsbUJBRUFBLGVBRkE7O0FBR3ZCLFVBQU1DLFdBQVdMLElBQUlHLGVBQWUsQ0FBZixDQUFKLEdBQXdCQyxnQkFBZ0IsQ0FBaEIsQ0FBekM7QUFDQSxVQUFNRSxXQUFXTCxJQUFJRSxlQUFlLENBQWYsQ0FBSixHQUF3QkMsZ0JBQWdCLENBQWhCLENBQXpDO0FBQ0EsYUFBT0wsSUFBSVEsTUFBSixLQUFlLENBQWYsR0FBbUIsQ0FBQ0YsUUFBRCxFQUFXQyxRQUFYLENBQW5CLEdBQTBDLENBQUNELFFBQUQsRUFBV0MsUUFBWCxFQUFxQkosQ0FBckIsQ0FBakQ7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O3dDQVNvQk0sWSxFQUFjO0FBQUEseUNBQ1NBLFlBRFQ7QUFBQSxVQUN6QkgsUUFEeUI7QUFBQSxVQUNmQyxRQURlO0FBQUE7QUFBQSxVQUNMRyxNQURLLGtDQUNJLENBREo7O0FBQUEsNkJBRVUsS0FBS3BCLGVBRmY7QUFBQSxVQUV6QnFCLGVBRnlCLG9CQUV6QkEsZUFGeUI7QUFBQSxVQUVSQyxjQUZRLG9CQUVSQSxjQUZROztBQUdoQyxVQUFNQyxTQUFTUCxXQUFXSyxnQkFBZ0IsQ0FBaEIsQ0FBWCxHQUFnQ0MsZUFBZSxDQUFmLENBQS9DO0FBQ0EsVUFBTUUsU0FBU1AsV0FBV0ksZ0JBQWdCLENBQWhCLENBQVgsR0FBZ0NDLGVBQWUsQ0FBZixDQUEvQztBQUNBLGFBQU9ILGFBQWFELE1BQWIsS0FBd0IsQ0FBeEIsR0FBNEIsQ0FBQ0ssTUFBRCxFQUFTQyxNQUFULENBQTVCLEdBQStDLENBQUNELE1BQUQsRUFBU0MsTUFBVCxFQUFpQkosTUFBakIsQ0FBdEQ7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7OztzQ0FVa0JLLE8sRUFBU2YsRyxFQUFLO0FBQUEsb0NBQ0plLE9BREk7QUFBQSxVQUN2QkMsR0FEdUI7QUFBQSxVQUNsQkMsR0FEa0I7QUFBQTtBQUFBLFVBQ2JDLENBRGEsNkJBQ1QsQ0FEUzs7QUFBQSxpQ0FFVyxLQUFLekIsbUJBQUwsQ0FBeUJPLEdBQXpCLENBRlg7QUFBQTtBQUFBLFVBRXZCTSxRQUZ1QjtBQUFBLFVBRWJDLFFBRmE7QUFBQTtBQUFBLFVBRUhHLE1BRkcseUNBRU0sQ0FGTjs7QUFHOUIsYUFBT0ssUUFBUVAsTUFBUixLQUFtQixDQUFuQixHQUNMLENBQUNRLE1BQU1WLFFBQVAsRUFBaUJXLE1BQU1WLFFBQXZCLENBREssR0FFTCxDQUFDUyxNQUFNVixRQUFQLEVBQWlCVyxNQUFNVixRQUF2QixFQUFpQ1csSUFBSVIsTUFBckMsQ0FGRjtBQUdEOztBQUVEOzs7O2lDQUVhO0FBQ1gsYUFBTyxLQUFLcEIsZUFBWjtBQUNEOzs7O0VBeE04Q25DLFE7O0FBMk1qRDs7Ozs7Ozs7Ozs7O2VBM01xQm1CLG1CO0FBcU5yQixTQUFTdUIsV0FBVCxRQUFpQ2xCLEtBQWpDLEVBQXdDO0FBQUE7QUFBQSxNQUFsQnFDLEdBQWtCO0FBQUEsTUFBYkMsR0FBYTs7QUFDdEN0QyxVQUFRQSxRQUFRYixXQUFoQjtBQUNBLE1BQU1xRCxVQUFVSCxNQUFNckQsa0JBQXRCO0FBQ0EsTUFBTXlELE9BQU9ILE1BQU10RCxrQkFBbkI7QUFDQSxNQUFNc0MsSUFBSXRCLFNBQVN3QyxVQUFVM0QsRUFBbkIsQ0FBVjtBQUNBLE1BQU0wQyxJQUFJdkIsU0FBU25CLEtBQUtDLEtBQUs0RCxHQUFMLENBQVM1RCxLQUFLNkQsR0FBTCxDQUFTNUQsT0FBTzBELE9BQU8sR0FBdkIsQ0FBVCxDQUFkLENBQVY7QUFDQSxTQUFPLENBQUNuQixDQUFELEVBQUlDLENBQUosQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTSCxhQUFULFFBQStCcEIsS0FBL0IsRUFBc0M7QUFBQTtBQUFBLE1BQWRzQixDQUFjO0FBQUEsTUFBWEMsQ0FBVzs7QUFDcEN2QixVQUFRQSxRQUFRYixXQUFoQjtBQUNBLE1BQU1xRCxVQUFVbEIsSUFBSXRCLEtBQUosR0FBWW5CLEVBQTVCO0FBQ0EsTUFBTTRELE9BQU8sS0FBSzNELEtBQUs4RCxJQUFMLENBQVU5RCxLQUFLK0QsR0FBTCxDQUFTaEUsS0FBSzBDLElBQUl2QixLQUFsQixDQUFWLElBQXNDakIsSUFBM0MsQ0FBYjtBQUNBLFNBQU8sQ0FBQ3lELFVBQVV2RCxrQkFBWCxFQUErQndELE9BQU94RCxrQkFBdEMsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTbUIsdUJBQVQsUUFBK0Q7QUFBQSxNQUE3QmYsUUFBNkIsU0FBN0JBLFFBQTZCO0FBQUEsTUFBbkJDLFNBQW1CLFNBQW5CQSxTQUFtQjtBQUFBLE1BQVJVLEtBQVEsU0FBUkEsS0FBUTs7QUFDN0Q7QUFDQSxNQUFNOEMsb0JBQW9CLE1BQTFCOztBQUVBLE1BQU1DLFlBQVlqRSxLQUFLa0UsR0FBTCxDQUFTM0QsV0FBV1AsS0FBS0QsRUFBaEIsR0FBcUIsR0FBOUIsQ0FBbEI7O0FBRUEsTUFBTW9FLGtCQUFrQkgsb0JBQW9CQyxTQUE1Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBTUcsbUJBQW1CdEUsS0FBS3VFLFFBQUwsQ0FDdkJqQyxZQUFZLENBQUM1QixZQUFZLEdBQWIsRUFBa0JELFFBQWxCLENBQVosQ0FEdUIsRUFFdkI2QixZQUFZLENBQUM1QixZQUFZLEdBQWIsRUFBa0JELFFBQWxCLENBQVosQ0FGdUIsQ0FBekI7QUFJQTtBQUNBO0FBQ0EsTUFBTStELG1CQUFtQnhFLEtBQUt1RSxRQUFMLENBQ3ZCakMsWUFBWSxDQUFDNUIsU0FBRCxFQUFZRCxXQUFXLEdBQXZCLENBQVosQ0FEdUIsRUFFdkI2QixZQUFZLENBQUM1QixTQUFELEVBQVlELFdBQVcsR0FBdkIsQ0FBWixDQUZ1QixDQUF6Qjs7QUFLQSxNQUFNZ0Usa0JBQWtCSCxtQkFBbUJELGVBQTNDO0FBQ0EsTUFBTUssa0JBQWtCRixtQkFBbUJILGVBQTNDO0FBQ0EsTUFBTU0sa0JBQWtCLENBQUNGLGtCQUFrQkMsZUFBbkIsSUFBc0MsQ0FBOUQ7QUFDQTs7QUFFQSxNQUFNRSxZQUFZdEUsWUFBWWMsS0FBOUI7QUFDQSxNQUFNeUQsb0JBQW9CRCxhQUFhLE1BQU1ULFNBQW5CLENBQTFCO0FBQ0EsTUFBTXRCLGlCQUFpQixDQUFDZ0MsaUJBQUQsRUFBb0JBLGlCQUFwQixFQUF1Q0EsaUJBQXZDLENBQXZCO0FBQ0EsTUFBTXhCLGlCQUFpQixDQUFDLElBQUl3QixpQkFBTCxFQUF3QixJQUFJQSxpQkFBNUIsRUFBK0MsSUFBSUYsZUFBbkQsQ0FBdkI7O0FBRUEsTUFBTXZCLGtCQUFrQixDQUFDa0IsZ0JBQUQsRUFBbUJFLGdCQUFuQixFQUFxQ0csZUFBckMsQ0FBeEI7QUFDQSxNQUFNN0Isa0JBQWtCLENBQUMsSUFBSXdCLGdCQUFMLEVBQXVCLElBQUlFLGdCQUEzQixFQUE2QyxJQUFJRyxlQUFqRCxDQUF4Qjs7QUFFQTtBQUNBLFNBQU87QUFDTDlCLGtDQURLO0FBRUxRLGtDQUZLO0FBR0xELG9DQUhLO0FBSUxOO0FBSkssR0FBUDtBQU1EOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU3BCLHNDQUFULFFBS0c7QUFBQSxNQUpEVixLQUlDLFNBSkRBLEtBSUM7QUFBQSxNQUhEQyxNQUdDLFNBSERBLE1BR0M7QUFBQSxNQUZETCxLQUVDLFNBRkRBLEtBRUM7QUFBQSxNQURERSxRQUNDLFNBRERBLFFBQ0M7O0FBQ0QsTUFBTWdFLGVBQWVsRSxRQUFRUixrQkFBN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTJFLFVBQVU3RSxLQUFLOEQsSUFBTCxDQUFVLE1BQU1sRCxRQUFoQixDQUFoQjtBQUNBLE1BQU1rRSx5QkFDSjlFLEtBQUsrRSxHQUFMLENBQVNGLE9BQVQsSUFBb0JqRSxRQUFwQixHQUErQlosS0FBSytFLEdBQUwsQ0FBUy9FLEtBQUtELEVBQUwsR0FBVSxDQUFWLEdBQWM2RSxZQUFkLEdBQTZCQyxPQUF0QyxDQURqQzs7QUFHQTtBQUNBLE1BQU1HLE9BQU9oRixLQUFLa0UsR0FBTCxDQUFTbEUsS0FBS0QsRUFBTCxHQUFVLENBQVYsR0FBYzZFLFlBQXZCLElBQXVDRSxzQkFBdkMsR0FBZ0VsRSxRQUE3RTs7QUFFQSxNQUFNVyxtQkFBbUIzQixLQUFLcUYsV0FBTCxDQUN2QnRGLFlBRHVCLEVBRXZCLElBQUlLLEtBQUs4RCxJQUFMLENBQVcvQyxTQUFTLENBQVYsR0FBZUgsUUFBekIsQ0FGbUIsRUFFaUI7QUFDeENFLFVBQVFDLE1BSGUsRUFHaUI7QUFDeEMsS0FKdUIsRUFJaUI7QUFDeENpRSxTQUFPLElBTGdCLENBS2lCO0FBTGpCLEdBQXpCOztBQVFBLFNBQU96RCxnQkFBUDtBQUNEOztBQUVELFNBQVNFLGdDQUFULFFBU0c7QUFBQSxNQVJEWCxLQVFDLFNBUkRBLEtBUUM7QUFBQSxNQVBEQyxNQU9DLFNBUERBLE1BT0M7QUFBQSxNQU5EUCxTQU1DLFNBTkRBLFNBTUM7QUFBQSxNQUxERCxRQUtDLFNBTERBLFFBS0M7QUFBQSxNQUpERSxJQUlDLFNBSkRBLElBSUM7QUFBQSxNQUhEQyxLQUdDLFNBSERBLEtBR0M7QUFBQSxNQUZEQyxPQUVDLFNBRkRBLE9BRUM7QUFBQSxNQUREQyxRQUNDLFNBRERBLFFBQ0M7O0FBQ0Q7QUFDQSxNQUFNTSxRQUFRbEIsS0FBS21CLEdBQUwsQ0FBUyxDQUFULEVBQVlWLElBQVosQ0FBZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU15RSxLQUFLdkYsWUFBWDs7QUFFQTtBQUNBQyxPQUFLdUYsU0FBTCxDQUFlRCxFQUFmLEVBQW1CQSxFQUFuQixFQUF1QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQ3RFLFFBQVIsQ0FBdkI7O0FBRUE7QUFDQTtBQUNBaEIsT0FBS3NCLEtBQUwsQ0FBV2dFLEVBQVgsRUFBZUEsRUFBZixFQUFtQixDQUFDLENBQUQsRUFBSSxDQUFDLENBQUwsRUFBUSxJQUFJbkUsTUFBWixDQUFuQjs7QUFFQTtBQUNBbkIsT0FBS3dGLE9BQUwsQ0FBYUYsRUFBYixFQUFpQkEsRUFBakIsRUFBcUJ4RSxRQUFRUixrQkFBN0I7QUFDQU4sT0FBS3lGLE9BQUwsQ0FBYUgsRUFBYixFQUFpQkEsRUFBakIsRUFBcUIsQ0FBQ3ZFLE9BQUQsR0FBV1Qsa0JBQWhDOztBQWpCQyxzQkFtQjBCa0MsWUFBWSxDQUFDNUIsU0FBRCxFQUFZRCxRQUFaLENBQVosRUFBbUNXLEtBQW5DLENBbkIxQjtBQUFBO0FBQUEsTUFtQk1vRSxPQW5CTjtBQUFBLE1BbUJlQyxPQW5CZjs7QUFxQkQsTUFBTUMsU0FBUyxDQUFDLENBQUNGLE9BQUYsRUFBVyxDQUFDQyxPQUFaLEVBQXFCLENBQXJCLEVBQXdCLENBQXhCLENBQWY7QUFDQSxNQUFNM0QsYUFBYS9CLEtBQUs0RixhQUFMLENBQW1CLEVBQW5CLEVBQXVCRCxNQUF2QixFQUErQk4sRUFBL0IsQ0FBbkI7O0FBRUEsTUFBTVEsYUFBYTlGLEtBQUt1RixTQUFMLENBQWUsRUFBZixFQUFtQkQsRUFBbkIsRUFBdUIsQ0FBQyxDQUFDSSxPQUFGLEVBQVcsQ0FBQ0MsT0FBWixFQUFxQixDQUFyQixDQUF2QixDQUFuQjs7QUFFQSxTQUFPO0FBQ0w3RCxnQkFBWWdFLFVBRFA7QUFFTC9ELDBCQUFzQnVELEVBRmpCO0FBR0x0RDtBQUhLLEdBQVA7QUFLRCIsImZpbGUiOiJ3ZWItbWVyY2F0b3Itdmlld3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBjYWxjdWxhdGlvbnMgZm9yIG1hcGJveC1qcyBzdHlsZVxuLy8gbWFwIHZpZXcgcHJvcGVydGllc1xuaW1wb3J0IFZpZXdwb3J0LCB7Y3JlYXRlTWF0NH0gZnJvbSAnLi92aWV3cG9ydCc7XG5pbXBvcnQge21hdDQsIHZlYzQsIHZlYzJ9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbi8vIENPTlNUQU5UU1xuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG5jb25zdCBXT1JMRF9TQ0FMRSA9IFRJTEVfU0laRSAvICgyICogUEkpO1xuXG5jb25zdCBERUZBVUxUX01BUF9TVEFURSA9IHtcbiAgbGF0aXR1ZGU6IDM3LFxuICBsb25naXR1ZGU6IC0xMjIsXG4gIHpvb206IDExLFxuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViTWVyY2F0b3JWaWV3cG9ydCBleHRlbmRzIFZpZXdwb3J0IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQ3JlYXRlcyB2aWV3L3Byb2plY3Rpb24gbWF0cmljZXMgZnJvbSBtZXJjYXRvciBwYXJhbXNcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWVyY2F0b3I9dHJ1ZSAtIFdoZXRoZXIgdG8gdXNlIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC53aWR0aD0xIC0gV2lkdGggb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmhlaWdodD0xIC0gSGVpZ2h0IG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtBcnJheX0gb3B0LmNlbnRlcj1bMCwgMF0gLSBDZW50ZXIgb2Ygdmlld3BvcnRcbiAgICogICBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gb3IgW3gsIHldXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuc2NhbGU9MSAtIEVpdGhlciB1c2Ugc2NhbGUgb3Igem9vbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnBpdGNoPTAgLSBDYW1lcmEgYW5nbGUgaW4gZGVncmVlcyAoMCBpcyBzdHJhaWdodCBkb3duKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmJlYXJpbmc9MCAtIE1hcCByb3RhdGlvbiBpbiBkZWdyZWVzICgwIG1lYW5zIG5vcnRoIGlzIHVwKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmFsdGl0dWRlPSAtIEFsdGl0dWRlIG9mIGNhbWVyYSBpbiBzY3JlZW4gdW5pdHNcbiAgICpcbiAgICogV2ViIG1lcmNhdG9yIHByb2plY3Rpb24gc2hvcnQtaGFuZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubGF0aXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxvbmdpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuem9vbSAtIFNjYWxlID0gTWF0aC5wb3coMix6b29tKSBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5zY2FsZSlcblxuICAgKiBOb3RlczpcbiAgICogIC0gT25seSBvbmUgb2YgY2VudGVyIG9yIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBjYW4gYmUgc3BlY2lmaWVkXG4gICAqICAtIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBjYW4gb25seSBiZSBzcGVjaWZpZWQgd2hlbiBcIm1lcmNhdG9yXCIgaXMgdHJ1ZVxuICAgKiAgLSBBbHRpdHVkZSBoYXMgYSBkZWZhdWx0IHZhbHVlIHRoYXQgbWF0Y2hlcyBhc3N1bXB0aW9ucyBpbiBtYXBib3gtZ2xcbiAgICogIC0gd2lkdGggYW5kIGhlaWdodCBhcmUgZm9yY2VkIHRvIDEgaWYgc3VwcGxpZWQgYXMgMCwgdG8gYXZvaWRcbiAgICogICAgZGl2aXNpb24gYnkgemVyby4gVGhpcyBpcyBpbnRlbmRlZCB0byByZWR1Y2UgdGhlIGJ1cmRlbiBvZiBhcHBzIHRvXG4gICAqICAgIHRvIGNoZWNrIHZhbHVlcyBiZWZvcmUgaW5zdGFudGlhdGluZyBhIFZpZXdwb3J0LlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIE1hcCBzdGF0ZVxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsYXRpdHVkZSxcbiAgICBsb25naXR1ZGUsXG4gICAgem9vbSxcbiAgICBwaXRjaCxcbiAgICBiZWFyaW5nLFxuICAgIGFsdGl0dWRlLFxuICAgIG1lcmNhdG9yRW5hYmxlZFxuICB9ID0ge30pIHtcbiAgICAvLyBWaWV3cG9ydCAtIHN1cHBvcnQgdW5kZWZpbmVkIGFyZ3VtZW50c1xuICAgIHdpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogREVGQVVMVF9NQVBfU1RBVEUud2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiBERUZBVUxUX01BUF9TVEFURS5oZWlnaHQ7XG4gICAgem9vbSA9IHpvb20gIT09IHVuZGVmaW5lZCA/IHpvb20gOiBERUZBVUxUX01BUF9TVEFURS56b29tO1xuICAgIGxhdGl0dWRlID0gbGF0aXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxhdGl0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUubGF0aXR1ZGU7XG4gICAgbG9uZ2l0dWRlID0gbG9uZ2l0dWRlICE9PSB1bmRlZmluZWQgPyBsb25naXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sb25naXR1ZGU7XG4gICAgYmVhcmluZyA9IGJlYXJpbmcgIT09IHVuZGVmaW5lZCA/IGJlYXJpbmcgOiBERUZBVUxUX01BUF9TVEFURS5iZWFyaW5nO1xuICAgIHBpdGNoID0gcGl0Y2ggIT09IHVuZGVmaW5lZCA/IHBpdGNoIDogREVGQVVMVF9NQVBfU1RBVEUucGl0Y2g7XG4gICAgYWx0aXR1ZGUgPSBhbHRpdHVkZSAhPT0gdW5kZWZpbmVkID8gYWx0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5hbHRpdHVkZTtcblxuICAgIC8vIFNpbGVudGx5IGFsbG93IGFwcHMgdG8gc2VuZCBpbiAwLDAgdG8gZmFjaWxpdGF0ZSBpc29tb3JwaGljIHJlbmRlciBldGNcbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgIC8vIEFsdGl0dWRlIC0gcHJldmVudCBkaXZpc2lvbiBieSAwXG4gICAgLy8gVE9ETyAtIGp1c3QgdGhyb3cgYW4gRXJyb3IgaW5zdGVhZD9cbiAgICBhbHRpdHVkZSA9IE1hdGgubWF4KDAuNzUsIGFsdGl0dWRlKTtcblxuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGVzID0gY2FsY3VsYXRlRGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHNjYWxlfSk7XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZVxuICAgIH0pO1xuXG4gICAgY29uc3Qge3ZpZXdNYXRyaXgsIHZpZXdNYXRyaXhVbmNlbnRlcmVkLCB2aWV3Q2VudGVyfSA9XG4gICAgICBtYWtlVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGxvbmdpdHVkZSxcbiAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgIHpvb20sXG4gICAgICAgIHBpdGNoLFxuICAgICAgICBiZWFyaW5nLFxuICAgICAgICBhbHRpdHVkZSxcbiAgICAgICAgZGlzdGFuY2VTY2FsZXNcbiAgICAgIH0pO1xuXG4gICAgc3VwZXIoe3dpZHRoLCBoZWlnaHQsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXh9KTtcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIG1hdHJpY2VzXG4gICAgdGhpcy52aWV3TWF0cml4VW5jZW50ZXJlZCA9IHZpZXdNYXRyaXhVbmNlbnRlcmVkO1xuICAgIHRoaXMudmlld0NlbnRlciA9IHZpZXdDZW50ZXI7XG5cbiAgICAvLyBTYXZlIHBhcmFtZXRlcnNcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICB0aGlzLmFsdGl0dWRlID0gYWx0aXR1ZGU7XG5cbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG5cbiAgICB0aGlzLl9kaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzO1xuXG4gICAgdGhpcy5nZXREaXN0YW5jZVNjYWxlcyA9IHRoaXMuZ2V0RGlzdGFuY2VTY2FsZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEgPSB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLmxuZ0xhdERlbHRhVG9NZXRlcnMgPSB0aGlzLmxuZ0xhdERlbHRhVG9NZXRlcnMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZE1ldGVyc1RvTG5nTGF0ID0gdGhpcy5hZGRNZXRlcnNUb0xuZ0xhdC5iaW5kKHRoaXMpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvKipcbiAgICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAgICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICogcGVyc3BlY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gICAqL1xuICBfcHJvamVjdEZsYXQobG5nTGF0LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gcHJvamVjdEZsYXQobG5nTGF0LCBzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fFZlY3Rvcn0geHkgLSBvYmplY3Qgd2l0aCB7eCx5fSBtZW1iZXJzXG4gICAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICAgKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICAgKiAgIEhhcyB0b0FycmF5IG1ldGhvZCBpZiB5b3UgbmVlZCBhIEdlb0pTT04gQXJyYXkuXG4gICAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAgICovXG4gIF91bnByb2plY3RGbGF0KHh5LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdW5wcm9qZWN0RmxhdCh4eSwgc2NhbGUpO1xuICB9XG5cbiAgZ2V0RGlzdGFuY2VTY2FsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbWV0ZXIgb2Zmc2V0IHRvIGEgbG5nbGF0IG9mZnNldFxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIHh5eiAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgLSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICovXG4gIG1ldGVyc1RvTG5nTGF0RGVsdGEoeHl6KSB7XG4gICAgY29uc3QgW3gsIHksIHogPSAwXSA9IHh5ejtcbiAgICBjb25zdCB7cGl4ZWxzUGVyTWV0ZXIsIGRlZ3JlZXNQZXJQaXhlbH0gPSB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgICBjb25zdCBkZWx0YUxuZyA9IHggKiBwaXhlbHNQZXJNZXRlclswXSAqIGRlZ3JlZXNQZXJQaXhlbFswXTtcbiAgICBjb25zdCBkZWx0YUxhdCA9IHkgKiBwaXhlbHNQZXJNZXRlclsxXSAqIGRlZ3JlZXNQZXJQaXhlbFsxXTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFtkZWx0YUxuZywgZGVsdGFMYXRdIDogW2RlbHRhTG5nLCBkZWx0YUxhdCwgel07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBsbmdsYXQgb2Zmc2V0IHRvIGEgbWV0ZXIgb2Zmc2V0XG4gICAqXG4gICAqIE5vdGU6IFVzZXMgc2ltcGxlIGxpbmVhciBhcHByb3hpbWF0aW9uIGFyb3VuZCB0aGUgdmlld3BvcnQgY2VudGVyXG4gICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICpcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgZGVsdGFMbmdMYXRaIC0gYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKi9cbiAgbG5nTGF0RGVsdGFUb01ldGVycyhkZWx0YUxuZ0xhdFopIHtcbiAgICBjb25zdCBbZGVsdGFMbmcsIGRlbHRhTGF0LCBkZWx0YVogPSAwXSA9IGRlbHRhTG5nTGF0WjtcbiAgICBjb25zdCB7cGl4ZWxzUGVyRGVncmVlLCBtZXRlcnNQZXJQaXhlbH0gPSB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgICBjb25zdCBkZWx0YVggPSBkZWx0YUxuZyAqIHBpeGVsc1BlckRlZ3JlZVswXSAqIG1ldGVyc1BlclBpeGVsWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IGRlbHRhTGF0ICogcGl4ZWxzUGVyRGVncmVlWzFdICogbWV0ZXJzUGVyUGl4ZWxbMV07XG4gICAgcmV0dXJuIGRlbHRhTG5nTGF0Wi5sZW5ndGggPT09IDIgPyBbZGVsdGFYLCBkZWx0YVldIDogW2RlbHRhWCwgZGVsdGFZLCBkZWx0YVpdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1ldGVyIGRlbHRhIHRvIGEgYmFzZSBsbmdsYXQgY29vcmRpbmF0ZSwgcmV0dXJuaW5nIGEgbmV3IGxuZ2xhdCBhcnJheVxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGxuZ0xhdFogLSBiYXNlIGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgeHl6IC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICovXG4gIGFkZE1ldGVyc1RvTG5nTGF0KGxuZ0xhdFosIHh5eikge1xuICAgIGNvbnN0IFtsbmcsIGxhdCwgWiA9IDBdID0gbG5nTGF0WjtcbiAgICBjb25zdCBbZGVsdGFMbmcsIGRlbHRhTGF0LCBkZWx0YVogPSAwXSA9IHRoaXMubWV0ZXJzVG9MbmdMYXREZWx0YSh4eXopO1xuICAgIHJldHVybiBsbmdMYXRaLmxlbmd0aCA9PT0gMiA/XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0XSA6XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0LCBaICsgZGVsdGFaXTtcbiAgfVxuXG4gIC8vIElOVEVSTkFMIE1FVEhPRFNcblxuICBfZ2V0UGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgfVxufVxuXG4vKipcbiAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAqIHBlcnNwZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAqL1xuZnVuY3Rpb24gcHJvamVjdEZsYXQoW2xuZywgbGF0XSwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSAqIFdPUkxEX1NDQUxFO1xuICBjb25zdCBsYW1iZGEyID0gbG5nICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBwaGkyID0gbGF0ICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCB4ID0gc2NhbGUgKiAobGFtYmRhMiArIFBJKTtcbiAgY29uc3QgeSA9IHNjYWxlICogKFBJIC0gTWF0aC5sb2coTWF0aC50YW4oUElfNCArIHBoaTIgKiAwLjUpKSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gKlxuICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAqL1xuZnVuY3Rpb24gdW5wcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgKiBXT1JMRF9TQ0FMRTtcbiAgY29uc3QgbGFtYmRhMiA9IHggLyBzY2FsZSAtIFBJO1xuICBjb25zdCBwaGkyID0gMiAqIChNYXRoLmF0YW4oTWF0aC5leHAoUEkgLSB5IC8gc2NhbGUpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaW4gbWV0ZXJzIGFyb3VuZCBjdXJyZW50IGxhdC9sb24sIGJvdGggZm9yXG4gKiBkZWdyZWVzIGFuZCBwaXhlbHMuXG4gKiBJbiBtZXJjYXRvciBwcm9qZWN0aW9uIG1vZGUsIHRoZSBkaXN0YW5jZSBzY2FsZXMgdmFyeSBzaWduaWZpY2FudGx5XG4gKiB3aXRoIGxhdGl0dWRlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZVNjYWxlcyh7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgc2NhbGV9KSB7XG4gIC8vIEFwcHJveGltYXRlbHkgMTExa20gcGVyIGRlZ3JlZSBhdCBlcXVhdG9yXG4gIGNvbnN0IE1FVEVSU19QRVJfREVHUkVFID0gMTExMDAwO1xuXG4gIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogTWF0aC5QSSAvIDE4MCk7XG5cbiAgY29uc3QgbWV0ZXJzUGVyRGVncmVlID0gTUVURVJTX1BFUl9ERUdSRUUgKiBsYXRDb3NpbmU7XG5cbiAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIGRlZ3JlZSBsb25naXR1ZGVcbiAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICBjb25zdCBwaXhlbHNQZXJEZWdyZWVYID0gdmVjMi5kaXN0YW5jZShcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlICsgMC41LCBsYXRpdHVkZV0pLFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUgLSAwLjUsIGxhdGl0dWRlXSlcbiAgKTtcbiAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIGRlZ3JlZSBsYXRpdHVkZVxuICAvLyBhcm91bmQgY3VycmVudCBsYXQvbG9uXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVkgPSB2ZWMyLmRpc3RhbmNlKFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUsIGxhdGl0dWRlICsgMC41XSksXG4gICAgcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGUgLSAwLjVdKVxuICApO1xuXG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWCA9IHBpeGVsc1BlckRlZ3JlZVggLyBtZXRlcnNQZXJEZWdyZWU7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWSA9IHBpeGVsc1BlckRlZ3JlZVkgLyBtZXRlcnNQZXJEZWdyZWU7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyWiA9IChwaXhlbHNQZXJNZXRlclggKyBwaXhlbHNQZXJNZXRlclkpIC8gMjtcbiAgLy8gY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbcGl4ZWxzUGVyTWV0ZXJYLCBwaXhlbHNQZXJNZXRlclksIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgY29uc3Qgd29ybGRTaXplID0gVElMRV9TSVpFICogc2NhbGU7XG4gIGNvbnN0IGFsdFBpeGVsc1Blck1ldGVyID0gd29ybGRTaXplIC8gKDRlNyAqIGxhdENvc2luZSk7XG4gIGNvbnN0IHBpeGVsc1Blck1ldGVyID0gW2FsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXJdO1xuICBjb25zdCBtZXRlcnNQZXJQaXhlbCA9IFsxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBhbHRQaXhlbHNQZXJNZXRlciwgMSAvIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlID0gW3BpeGVsc1BlckRlZ3JlZVgsIHBpeGVsc1BlckRlZ3JlZVksIHBpeGVsc1Blck1ldGVyWl07XG4gIGNvbnN0IGRlZ3JlZXNQZXJQaXhlbCA9IFsxIC8gcGl4ZWxzUGVyRGVncmVlWCwgMSAvIHBpeGVsc1BlckRlZ3JlZVksIDEgLyBwaXhlbHNQZXJNZXRlclpdO1xuXG4gIC8vIE1haW4gcmVzdWx0cywgdXNlZCBmb3IgY29udmVydGluZyBtZXRlcnMgdG8gbGF0bG5nIGRlbHRhcyBhbmQgc2NhbGluZyBvZmZzZXRzXG4gIHJldHVybiB7XG4gICAgcGl4ZWxzUGVyTWV0ZXIsXG4gICAgbWV0ZXJzUGVyUGl4ZWwsXG4gICAgcGl4ZWxzUGVyRGVncmVlLFxuICAgIGRlZ3JlZXNQZXJQaXhlbFxuICB9O1xufVxuXG4vLyBBVFRSSUJVVElPTjpcbi8vIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cml4IGNyZWF0aW9uIGlzIGludGVudGlvbmFsbHkga2VwdCBjb21wYXRpYmxlIHdpdGhcbi8vIG1hcGJveC1nbCdzIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSB0aGF0IHNlYW1sZXNzIGludGVyb3BlcmF0aW9uXG4vLyB3aXRoIG1hcGJveCBhbmQgcmVhY3QtbWFwLWdsLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzXG5mdW5jdGlvbiBtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIHBpdGNoLFxuICBhbHRpdHVkZVxufSkge1xuICBjb25zdCBwaXRjaFJhZGlhbnMgPSBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUztcblxuICAvLyBQUk9KRUNUSU9OIE1BVFJJWDogUFJPSkVDVFMgRlJPTSBDQU1FUkEgU1BBQ0UgVE8gQ0xJUFNQQUNFXG4gIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBwb2ludCB0byB0aGUgY2VudGVyIHRvcFxuICAvLyBpbiBhbHRpdHVkZSB1bml0cyB1c2luZyBsYXcgb2Ygc2luZXMuXG4gIGNvbnN0IGhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gYWx0aXR1ZGUpO1xuICBjb25zdCB0b3BIYWxmU3VyZmFjZURpc3RhbmNlID1cbiAgICBNYXRoLnNpbihoYWxmRm92KSAqIGFsdGl0dWRlIC8gTWF0aC5zaW4oTWF0aC5QSSAvIDIgLSBwaXRjaFJhZGlhbnMgLSBoYWxmRm92KTtcblxuICAvLyBDYWxjdWxhdGUgeiB2YWx1ZSBvZiB0aGUgZmFydGhlc3QgZnJhZ21lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gIGNvbnN0IGZhclogPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucykgKiB0b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgYWx0aXR1ZGU7XG5cbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDQucGVyc3BlY3RpdmUoXG4gICAgY3JlYXRlTWF0NCgpLFxuICAgIDIgKiBNYXRoLmF0YW4oKGhlaWdodCAvIDIpIC8gYWx0aXR1ZGUpLCAvLyBmb3YgaW4gcmFkaWFuc1xuICAgIHdpZHRoIC8gaGVpZ2h0LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3BlY3QgcmF0aW9cbiAgICAwLjEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVhciBwbGFuZVxuICAgIGZhclogKiAxMC4wICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYXIgcGxhbmVcbiAgKTtcblxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cblxuZnVuY3Rpb24gbWFrZVZpZXdNYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBsb25naXR1ZGUsXG4gIGxhdGl0dWRlLFxuICB6b29tLFxuICBwaXRjaCxcbiAgYmVhcmluZyxcbiAgYWx0aXR1ZGVcbn0pIHtcbiAgLy8gQ2VudGVyIHgsIHlcbiAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tKTtcbiAgLy8gVklFVyBNQVRSSVg6IFBST0pFQ1RTIEZST00gVklSVFVBTCBQSVhFTFMgVE8gQ0FNRVJBIFNQQUNFXG4gIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9uIG9yZGVycyBzaG91bGQgYmUgcmVhZCBpbiByZXZlcnNlXG4gIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICBjb25zdCB2bSA9IGNyZWF0ZU1hdDQoKTtcblxuICAvLyBNb3ZlIGNhbWVyYSB0byBhbHRpdHVkZVxuICBtYXQ0LnRyYW5zbGF0ZSh2bSwgdm0sIFswLCAwLCAtYWx0aXR1ZGVdKTtcblxuICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICBtYXQ0LnNjYWxlKHZtLCB2bSwgWzEsIC0xLCAxIC8gaGVpZ2h0XSk7XG5cbiAgLy8gUm90YXRlIGJ5IGJlYXJpbmcsIGFuZCB0aGVuIGJ5IHBpdGNoICh3aGljaCB0aWx0cyB0aGUgdmlldylcbiAgbWF0NC5yb3RhdGVYKHZtLCB2bSwgcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0LnJvdGF0ZVoodm0sIHZtLCAtYmVhcmluZyAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG5cbiAgY29uc3QgW2NlbnRlclgsIGNlbnRlclldID0gcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGVdLCBzY2FsZSk7XG5cbiAgY29uc3QgY2VudGVyID0gWy1jZW50ZXJYLCAtY2VudGVyWSwgMCwgMV07XG4gIGNvbnN0IHZpZXdDZW50ZXIgPSB2ZWM0LnRyYW5zZm9ybU1hdDQoW10sIGNlbnRlciwgdm0pO1xuXG4gIGNvbnN0IHZtQ2VudGVyZWQgPSBtYXQ0LnRyYW5zbGF0ZShbXSwgdm0sIFstY2VudGVyWCwgLWNlbnRlclksIDBdKTtcblxuICByZXR1cm4ge1xuICAgIHZpZXdNYXRyaXg6IHZtQ2VudGVyZWQsXG4gICAgdmlld01hdHJpeFVuY2VudGVyZWQ6IHZtLFxuICAgIHZpZXdDZW50ZXJcbiAgfTtcbn1cbiJdfQ==