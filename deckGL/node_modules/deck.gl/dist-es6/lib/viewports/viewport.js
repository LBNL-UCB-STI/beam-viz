var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// eslint-disable
// View and Projection Matrix management

// gl-matrix is a large dependency for a small module.
// However since it is used by mapbox etc, it should already be present
// in most target application bundles.
import { mat4, vec4 } from 'gl-matrix';

var IDENTITY = createMat4();

var Viewport = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
   */
  /* eslint-disable complexity */
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$width = _ref.width,
        width = _ref$width === undefined ? 1 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? 1 : _ref$height,
        _ref$viewMatrix = _ref.viewMatrix,
        viewMatrix = _ref$viewMatrix === undefined ? IDENTITY : _ref$viewMatrix,
        _ref$projectionMatrix = _ref.projectionMatrix,
        projectionMatrix = _ref$projectionMatrix === undefined ? IDENTITY : _ref$projectionMatrix;

    _classCallCheck(this, Viewport);

    // Silently allow apps to send in 0,0
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;

    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;

    // Note: As usual, matrix operations should be applied in "reverse" order
    // since vectors will be multiplied in from the right during transformation
    var vpm = createMat4();
    mat4.multiply(vpm, vpm, this.projectionMatrix);
    mat4.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;

    // Calculate matrices and scales needed for projection
    /**
     * Builds matrices that converts preprojected lngLats to screen pixels
     * and vice versa.
     * Note: Currently returns bottom-left coordinates!
     * Note: Starts with the GL projection matrix and adds steps to the
     *       scale and translate that matrix onto the window.
     * Note: WebGL controls clip space to screen projection with gl.viewport
     *       and does not need this step.
     */
    var m = createMat4();

    // Scale with viewport window's width and height in pixels
    mat4.scale(m, m, [this.width, this.height, 1]);
    // Convert to (0, 1)
    mat4.translate(m, m, [0.5, 0.5, 0]);
    mat4.scale(m, m, [0.5, 0.5, 1]);
    // Project to clip space (-1, 1)
    mat4.multiply(m, m, this.viewProjectionMatrix);

    var mInverse = mat4.invert(createMat4(), m);
    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;

    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
    this.getMatrices = this.getMatrices.bind(this);
    this.getDistanceScales = this.getDistanceScales.bind(this);
  }
  /* eslint-enable complexity */

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? true : _ref2$topLeft;

      var Z = xyz[2] || 0;
      // console.error('projecting non-linear', xyz);

      var _projectFlat2 = this.projectFlat(xyz),
          _projectFlat3 = _slicedToArray(_projectFlat2, 2),
          X = _projectFlat3[0],
          Y = _projectFlat3[1];

      var v = [X, Y, Z, 1];
      // console.error('projecting linear', v);
      // vec4.sub(v, v, [this.centerX, this.centerY, 0, 0]);
      vec4.transformMat4(v, v, this.pixelProjectionMatrix);
      // Divide by w
      var scale = 1 / v[3];
      vec4.multiply(v, v, [scale, scale, scale, scale]);
      // console.error('projected', v);
      var x = v[0],
          z = v[2];

      var y = topLeft ? this.height - v[1] : v[1];
      return xyz.length === 2 ? [x, y] : [x, y, z];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$topLeft = _ref3.topLeft,
          topLeft = _ref3$topLeft === undefined ? true : _ref3$topLeft;

      // console.error('unprojecting linear', xyz);
      var _xyz = _slicedToArray(xyz, 3),
          _xyz$ = _xyz[0],
          x = _xyz$ === undefined ? 0 : _xyz$,
          _xyz$2 = _xyz[1],
          y = _xyz$2 === undefined ? 0 : _xyz$2,
          _xyz$3 = _xyz[2],
          z = _xyz$3 === undefined ? 0 : _xyz$3;
      // const y2 = topLeft ? this.height - 1 - y : y;


      var y2 = topLeft ? this.height - y : y;
      var v = [x, y2, z, 1];
      vec4.transformMat4(v, v, this.pixelUnprojectionMatrix);
      var scale = 1 / v[3];
      vec4.multiply(v, v, [scale, scale, scale, scale]);
      // console.error('unprojecting non-linear', v);

      var _unprojectFlat2 = this.unprojectFlat(v),
          _unprojectFlat3 = _slicedToArray(_unprojectFlat2, 2),
          x0 = _unprojectFlat3[0],
          y0 = _unprojectFlat3[1];
      // console.error('unprojected', [x0, y0]);


      var z0 = v[2];

      return xyz.length === 2 ? [x0, y0] : [x0, y0, z0];
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          x = _ref5[0],
          y = _ref5[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._projectFlat.apply(this, arguments);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._unprojectFlat.apply(this, arguments);
    }
  }, {
    key: '_projectFlat',
    value: function _projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }, {
    key: 'getMatrices',
    value: function getMatrices() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$modelMatrix = _ref6.modelMatrix,
          modelMatrix = _ref6$modelMatrix === undefined ? null : _ref6$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = mat4.multiply([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = mat4.multiply([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = mat4.invert([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,

        // project/unproject between pixels and world
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,

        width: this.width,
        height: this.height,
        scale: this.scale
      },

      // Subclass can add additional params
      // TODO - Fragile: better to make base Viewport class aware of all params
      this._getParams());

      return matrices;
    }
  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return {
        pixelsPerMeter: [1, 1, 1],
        metersPerPixel: [1, 1, 1],
        pixelsPerDegree: [1, 1, 1],
        degreesPerPixel: [1, 1, 1]
      };
    }

    // INTERNAL METHODS

    // Can be subclassed to add additional fields to `getMatrices`

  }, {
    key: '_getParams',
    value: function _getParams() {
      return {};
    }
  }]);

  return Viewport;
}();

// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()


export default Viewport;
export function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdmlld3BvcnRzL3ZpZXdwb3J0LmpzIl0sIm5hbWVzIjpbIm1hdDQiLCJ2ZWM0IiwiSURFTlRJVFkiLCJjcmVhdGVNYXQ0IiwiVmlld3BvcnQiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdNYXRyaXgiLCJwcm9qZWN0aW9uTWF0cml4Iiwic2NhbGUiLCJ2cG0iLCJtdWx0aXBseSIsInZpZXdQcm9qZWN0aW9uTWF0cml4IiwibSIsInRyYW5zbGF0ZSIsIm1JbnZlcnNlIiwiaW52ZXJ0IiwiRXJyb3IiLCJwaXhlbFByb2plY3Rpb25NYXRyaXgiLCJwaXhlbFVucHJvamVjdGlvbk1hdHJpeCIsInByb2plY3QiLCJiaW5kIiwidW5wcm9qZWN0IiwicHJvamVjdEZsYXQiLCJ1bnByb2plY3RGbGF0IiwiZ2V0TWF0cmljZXMiLCJnZXREaXN0YW5jZVNjYWxlcyIsInZpZXdwb3J0IiwiZXF1YWxzIiwieHl6IiwidG9wTGVmdCIsIloiLCJYIiwiWSIsInYiLCJ0cmFuc2Zvcm1NYXQ0IiwieCIsInoiLCJ5IiwibGVuZ3RoIiwieTIiLCJ4MCIsInkwIiwiejAiLCJfcHJvamVjdEZsYXQiLCJhcmd1bWVudHMiLCJfdW5wcm9qZWN0RmxhdCIsIm1vZGVsTWF0cml4IiwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCIsIm1hdHJpY2VzIiwiT2JqZWN0IiwiYXNzaWduIiwiX2dldFBhcmFtcyIsInBpeGVsc1Blck1ldGVyIiwibWV0ZXJzUGVyUGl4ZWwiLCJwaXhlbHNQZXJEZWdyZWUiLCJkZWdyZWVzUGVyUGl4ZWwiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUUEsSUFBUixFQUFjQyxJQUFkLFFBQXlCLFdBQXpCOztBQUVBLElBQU1DLFdBQVdDLFlBQWpCOztJQUVxQkMsUTtBQUNuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBLHNCQU9RO0FBQUEsbUZBQUosRUFBSTtBQUFB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SCxRQUFQO0FBQ0Q7Ozt3Q0FFbUI7QUFDbEIsYUFBTztBQUNMSSx3QkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FEWDtBQUVMQyx3QkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FGWDtBQUdMQyx5QkFBaUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FIWjtBQUlMQyx5QkFBaUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVA7QUFKWixPQUFQO0FBTUQ7O0FBRUQ7O0FBRUE7Ozs7aUNBQ2E7QUFDWCxhQUFPLEVBQVA7QUFDRDs7Ozs7O0FBR0g7OztlQWhQcUJwRCxRO0FBaVByQixPQUFPLFNBQVNELFVBQVQsR0FBc0I7QUFDM0IsU0FBTyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLENBQXhDLEVBQTJDLENBQTNDLEVBQThDLENBQTlDLENBQVA7QUFDRCIsImZpbGUiOiJ2aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlXG4vLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBtYW5hZ2VtZW50XG5cbi8vIGdsLW1hdHJpeCBpcyBhIGxhcmdlIGRlcGVuZGVuY3kgZm9yIGEgc21hbGwgbW9kdWxlLlxuLy8gSG93ZXZlciBzaW5jZSBpdCBpcyB1c2VkIGJ5IG1hcGJveCBldGMsIGl0IHNob3VsZCBhbHJlYWR5IGJlIHByZXNlbnRcbi8vIGluIG1vc3QgdGFyZ2V0IGFwcGxpY2F0aW9uIGJ1bmRsZXMuXG5pbXBvcnQge21hdDQsIHZlYzR9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IElERU5USVRZID0gY3JlYXRlTWF0NCgpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3cG9ydCB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIE1hbmFnZXMgY29vcmRpbmF0ZSBzeXN0ZW0gdHJhbnNmb3JtYXRpb25zIGZvciBkZWNrLmdsLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgVmlld3BvcnQgaXMgaW1tdXRhYmxlIGluIHRoZSBzZW5zZSB0aGF0IGl0IG9ubHkgaGFzIGFjY2Vzc29ycy5cbiAgICogQSBuZXcgdmlld3BvcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQgaWYgYW55IHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdCAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBtZXJjYXRvcj10cnVlIC0gV2hldGhlciB0byB1c2UgbWVyY2F0b3IgcHJvamVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LndpZHRoPTEgLSBXaWR0aCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuaGVpZ2h0PTEgLSBIZWlnaHQgb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge0FycmF5fSBvcHQuY2VudGVyPVswLCAwXSAtIENlbnRlciBvZiB2aWV3cG9ydFxuICAgKiAgIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBvciBbeCwgeV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5zY2FsZT0xIC0gRWl0aGVyIHVzZSBzY2FsZSBvciB6b29tXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQucGl0Y2g9MCAtIENhbWVyYSBhbmdsZSBpbiBkZWdyZWVzICgwIGlzIHN0cmFpZ2h0IGRvd24pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYmVhcmluZz0wIC0gTWFwIHJvdGF0aW9uIGluIGRlZ3JlZXMgKDAgbWVhbnMgbm9ydGggaXMgdXApXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYWx0aXR1ZGU9IC0gQWx0aXR1ZGUgb2YgY2FtZXJhIGluIHNjcmVlbiB1bml0c1xuICAgKlxuICAgKiBXZWIgbWVyY2F0b3IgcHJvamVjdGlvbiBzaG9ydC1oYW5kIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sYXRpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubG9uZ2l0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC56b29tIC0gU2NhbGUgPSBNYXRoLnBvdygyLHpvb20pIG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LnNjYWxlKVxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gV2luZG93IHdpZHRoL2hlaWdodCBpbiBwaXhlbHMgKGZvciBwaXhlbCBwcm9qZWN0aW9uKVxuICAgIHdpZHRoID0gMSxcbiAgICBoZWlnaHQgPSAxLFxuICAgIC8vIERlc2NcbiAgICB2aWV3TWF0cml4ID0gSURFTlRJVFksXG4gICAgcHJvamVjdGlvbk1hdHJpeCA9IElERU5USVRZXG4gIH0gPSB7fSkge1xuICAgIC8vIFNpbGVudGx5IGFsbG93IGFwcHMgdG8gc2VuZCBpbiAwLDBcbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMTtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAxO1xuICAgIHRoaXMuc2NhbGUgPSAxO1xuXG4gICAgdGhpcy52aWV3TWF0cml4ID0gdmlld01hdHJpeDtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBwcm9qZWN0aW9uTWF0cml4O1xuXG4gICAgLy8gTm90ZTogQXMgdXN1YWwsIG1hdHJpeCBvcGVyYXRpb25zIHNob3VsZCBiZSBhcHBsaWVkIGluIFwicmV2ZXJzZVwiIG9yZGVyXG4gICAgLy8gc2luY2UgdmVjdG9ycyB3aWxsIGJlIG11bHRpcGxpZWQgaW4gZnJvbSB0aGUgcmlnaHQgZHVyaW5nIHRyYW5zZm9ybWF0aW9uXG4gICAgY29uc3QgdnBtID0gY3JlYXRlTWF0NCgpO1xuICAgIG1hdDQubXVsdGlwbHkodnBtLCB2cG0sIHRoaXMucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgbWF0NC5tdWx0aXBseSh2cG0sIHZwbSwgdGhpcy52aWV3TWF0cml4KTtcbiAgICB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdnBtO1xuXG4gICAgLy8gQ2FsY3VsYXRlIG1hdHJpY2VzIGFuZCBzY2FsZXMgbmVlZGVkIGZvciBwcm9qZWN0aW9uXG4gICAgLyoqXG4gICAgICogQnVpbGRzIG1hdHJpY2VzIHRoYXQgY29udmVydHMgcHJlcHJvamVjdGVkIGxuZ0xhdHMgdG8gc2NyZWVuIHBpeGVsc1xuICAgICAqIGFuZCB2aWNlIHZlcnNhLlxuICAgICAqIE5vdGU6IEN1cnJlbnRseSByZXR1cm5zIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzIVxuICAgICAqIE5vdGU6IFN0YXJ0cyB3aXRoIHRoZSBHTCBwcm9qZWN0aW9uIG1hdHJpeCBhbmQgYWRkcyBzdGVwcyB0byB0aGVcbiAgICAgKiAgICAgICBzY2FsZSBhbmQgdHJhbnNsYXRlIHRoYXQgbWF0cml4IG9udG8gdGhlIHdpbmRvdy5cbiAgICAgKiBOb3RlOiBXZWJHTCBjb250cm9scyBjbGlwIHNwYWNlIHRvIHNjcmVlbiBwcm9qZWN0aW9uIHdpdGggZ2wudmlld3BvcnRcbiAgICAgKiAgICAgICBhbmQgZG9lcyBub3QgbmVlZCB0aGlzIHN0ZXAuXG4gICAgICovXG4gICAgY29uc3QgbSA9IGNyZWF0ZU1hdDQoKTtcblxuICAgIC8vIFNjYWxlIHdpdGggdmlld3BvcnQgd2luZG93J3Mgd2lkdGggYW5kIGhlaWdodCBpbiBwaXhlbHNcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMV0pO1xuICAgIC8vIENvbnZlcnQgdG8gKDAsIDEpXG4gICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzAuNSwgMC41LCAwXSk7XG4gICAgbWF0NC5zY2FsZShtLCBtLCBbMC41LCAwLjUsIDFdKTtcbiAgICAvLyBQcm9qZWN0IHRvIGNsaXAgc3BhY2UgKC0xLCAxKVxuICAgIG1hdDQubXVsdGlwbHkobSwgbSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICBjb25zdCBtSW52ZXJzZSA9IG1hdDQuaW52ZXJ0KGNyZWF0ZU1hdDQoKSwgbSk7XG4gICAgaWYgKCFtSW52ZXJzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXhlbCBwcm9qZWN0IG1hdHJpeCBub3QgaW52ZXJ0aWJsZScpO1xuICAgIH1cblxuICAgIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbTtcbiAgICB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbUludmVyc2U7XG5cbiAgICB0aGlzLnByb2plY3QgPSB0aGlzLnByb2plY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVucHJvamVjdCA9IHRoaXMudW5wcm9qZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9qZWN0RmxhdCA9IHRoaXMucHJvamVjdEZsYXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVucHJvamVjdEZsYXQgPSB0aGlzLnVucHJvamVjdEZsYXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldE1hdHJpY2VzID0gdGhpcy5nZXRNYXRyaWNlcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0RGlzdGFuY2VTY2FsZXMgPSB0aGlzLmdldERpc3RhbmNlU2NhbGVzLmJpbmQodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgLy8gVHdvIHZpZXdwb3J0cyBhcmUgZXF1YWwgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgaWRlbnRpY2FsLCBhbmQgaWZcbiAgLy8gdGhlaXIgdmlldyBhbmQgcHJvamVjdGlvbiBtYXRyaWNlcyBhcmUgKGFwcHJveGltYXRlbHkpIGVxdWFsLlxuICBlcXVhbHModmlld3BvcnQpIHtcbiAgICBpZiAoISh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB2aWV3cG9ydC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJlxuICAgICAgdmlld3BvcnQuaGVpZ2h0ID09PSB0aGlzLmhlaWdodCAmJlxuICAgICAgbWF0NC5lcXVhbHModmlld3BvcnQucHJvamVjdGlvbk1hdHJpeCwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KSAmJlxuICAgICAgbWF0NC5lcXVhbHModmlld3BvcnQudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9qZWN0cyB4eXogKHBvc3NpYmx5IGxhdGl0dWRlIGFuZCBsb25naXR1ZGUpIHRvIHBpeGVsIGNvb3JkaW5hdGVzIGluIHdpbmRvd1xuICAgKiB1c2luZyB2aWV3cG9ydCBwcm9qZWN0aW9uIHBhcmFtZXRlcnNcbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gdG8gW3gsIHldXG4gICAqIC0gW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIFpdID0+IFt4LCB5LCB6XVxuICAgKiBOb3RlOiBCeSBkZWZhdWx0LCByZXR1cm5zIHRvcC1sZWZ0IGNvb3JkaW5hdGVzIGZvciBjYW52YXMvU1ZHIHR5cGUgcmVuZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdFogLSBbbG5nLCBsYXRdIG9yIFtsbmcsIGxhdCwgWl1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnRvcExlZnQ9dHJ1ZSAtIFdoZXRoZXIgcHJvamVjdGVkIGNvb3JkcyBhcmUgdG9wIGxlZnRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gW3gsIHldIG9yIFt4LCB5LCB6XSBpbiB0b3AgbGVmdCBjb29yZHNcbiAgICovXG4gIHByb2plY3QoeHl6LCB7dG9wTGVmdCA9IHRydWV9ID0ge30pIHtcbiAgICBjb25zdCBaID0geHl6WzJdIHx8IDA7XG4gICAgLy8gY29uc29sZS5lcnJvcigncHJvamVjdGluZyBub24tbGluZWFyJywgeHl6KTtcbiAgICBjb25zdCBbWCwgWV0gPSB0aGlzLnByb2plY3RGbGF0KHh5eik7XG4gICAgY29uc3QgdiA9IFtYLCBZLCBaLCAxXTtcbiAgICAvLyBjb25zb2xlLmVycm9yKCdwcm9qZWN0aW5nIGxpbmVhcicsIHYpO1xuICAgIC8vIHZlYzQuc3ViKHYsIHYsIFt0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgMCwgMF0pO1xuICAgIHZlYzQudHJhbnNmb3JtTWF0NCh2LCB2LCB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgLy8gRGl2aWRlIGJ5IHdcbiAgICBjb25zdCBzY2FsZSA9IDEgLyB2WzNdO1xuICAgIHZlYzQubXVsdGlwbHkodiwgdiwgW3NjYWxlLCBzY2FsZSwgc2NhbGUsIHNjYWxlXSk7XG4gICAgLy8gY29uc29sZS5lcnJvcigncHJvamVjdGVkJywgdik7XG4gICAgY29uc3QgW3gsICwgel0gPSB2O1xuICAgIGNvbnN0IHkgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSB2WzFdIDogdlsxXTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFt4LCB5XSA6IFt4LCB5LCB6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3QgcGl4ZWwgY29vcmRpbmF0ZXMgb24gc2NyZWVuIG9udG8gd29ybGQgY29vcmRpbmF0ZXMsXG4gICAqIChwb3NzaWJseSBbbG9uLCBsYXRdKSBvbiBtYXAuXG4gICAqIC0gW3gsIHldID0+IFtsbmcsIGxhdF1cbiAgICogLSBbeCwgeSwgel0gPT4gW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge0FycmF5fSB4eXogLVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbbG5nLCBsYXQsIFpdIG9yIFtYLCBZLCBaXVxuICAgKi9cbiAgdW5wcm9qZWN0KHh5eiwge3RvcExlZnQgPSB0cnVlfSA9IHt9KSB7XG4gICAgLy8gY29uc29sZS5lcnJvcigndW5wcm9qZWN0aW5nIGxpbmVhcicsIHh5eik7XG4gICAgY29uc3QgW3ggPSAwLCB5ID0gMCwgeiA9IDBdID0geHl6O1xuICAgIC8vIGNvbnN0IHkyID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0gMSAtIHkgOiB5O1xuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0geSA6IHk7XG4gICAgY29uc3QgdiA9IFt4LCB5MiwgeiwgMV07XG4gICAgdmVjNC50cmFuc2Zvcm1NYXQ0KHYsIHYsIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgpO1xuICAgIGNvbnN0IHNjYWxlID0gMSAvIHZbM107XG4gICAgdmVjNC5tdWx0aXBseSh2LCB2LCBbc2NhbGUsIHNjYWxlLCBzY2FsZSwgc2NhbGVdKTtcbiAgICAvLyBjb25zb2xlLmVycm9yKCd1bnByb2plY3Rpbmcgbm9uLWxpbmVhcicsIHYpO1xuICAgIGNvbnN0IFt4MCwgeTBdID0gdGhpcy51bnByb2plY3RGbGF0KHYpO1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3VucHJvamVjdGVkJywgW3gwLCB5MF0pO1xuICAgIGNvbnN0IFssICwgejBdID0gdjtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFt4MCwgeTBdIDogW3gwLCB5MCwgejBdO1xuICB9XG5cbiAgLy8gTk9OX0xJTkVBUiBQUk9KRUNUSU9OIEhPT0tTXG4gIC8vIFVzZWQgZm9yIHdlYiBtZXJhY3RvciBwcm9qZWN0aW9uXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvamVjdEZsYXQoW3gsIHldLCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvamVjdEZsYXQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gICAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICAgKi9cbiAgdW5wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB0aGlzLl91bnByb2plY3RGbGF0KC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICBfcHJvamVjdEZsYXQoeHl6LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4geHl6O1xuICB9XG5cbiAgX3VucHJvamVjdEZsYXQoeHl6LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4geHl6O1xuICB9XG5cbiAgZ2V0TWF0cmljZXMoe21vZGVsTWF0cml4ID0gbnVsbH0gPSB7fSkge1xuICAgIGxldCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeDtcbiAgICBsZXQgcGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXg7XG4gICAgbGV0IHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeDtcblxuICAgIGlmIChtb2RlbE1hdHJpeCkge1xuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICAgIHBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4LCBtb2RlbE1hdHJpeCk7XG4gICAgICBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1hdDQuaW52ZXJ0KFtdLCBwaXhlbFByb2plY3Rpb25NYXRyaXgpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdHJpY2VzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgdmlld1Byb2plY3Rpb25NYXRyaXg6IHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgICB2aWV3TWF0cml4OiB0aGlzLnZpZXdNYXRyaXgsXG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiB0aGlzLnByb2plY3Rpb25NYXRyaXgsXG5cbiAgICAgIC8vIHByb2plY3QvdW5wcm9qZWN0IGJldHdlZW4gcGl4ZWxzIGFuZCB3b3JsZFxuICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsXG5cbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIHNjYWxlOiB0aGlzLnNjYWxlXG4gICAgfSxcblxuICAgICAgLy8gU3ViY2xhc3MgY2FuIGFkZCBhZGRpdGlvbmFsIHBhcmFtc1xuICAgICAgLy8gVE9ETyAtIEZyYWdpbGU6IGJldHRlciB0byBtYWtlIGJhc2UgVmlld3BvcnQgY2xhc3MgYXdhcmUgb2YgYWxsIHBhcmFtc1xuICAgICAgdGhpcy5fZ2V0UGFyYW1zKClcbiAgICApO1xuXG4gICAgcmV0dXJuIG1hdHJpY2VzO1xuICB9XG5cbiAgZ2V0RGlzdGFuY2VTY2FsZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBpeGVsc1Blck1ldGVyOiBbMSwgMSwgMV0sXG4gICAgICBtZXRlcnNQZXJQaXhlbDogWzEsIDEsIDFdLFxuICAgICAgcGl4ZWxzUGVyRGVncmVlOiBbMSwgMSwgMV0sXG4gICAgICBkZWdyZWVzUGVyUGl4ZWw6IFsxLCAxLCAxXVxuICAgIH07XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgLy8gQ2FuIGJlIHN1YmNsYXNzZWQgdG8gYWRkIGFkZGl0aW9uYWwgZmllbGRzIHRvIGBnZXRNYXRyaWNlc2BcbiAgX2dldFBhcmFtcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuLy8gSGVscGVyLCBhdm9pZHMgbG93LXByZWNpc2lvbiAzMiBiaXQgbWF0cmljZXMgZnJvbSBnbC1tYXRyaXggbWF0NC5jcmVhdGUoKVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hdDQoKSB7XG4gIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG59XG4iXX0=