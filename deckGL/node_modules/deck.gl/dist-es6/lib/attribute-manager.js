var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-disable guard-for-in */
import { GL } from 'luma.gl';
import { log } from './utils';
import assert from 'assert';

function noop() {}

/* eslint-disable complexity */
export function glArrayFromType(glType) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clamped = _ref.clamped,
      clamped = _ref$clamped === undefined ? true : _ref$clamped;

  // Sorted in some order of likelihood to reduce amount of comparisons
  switch (glType) {
    case GL.FLOAT:
      return Float32Array;
    case GL.UNSIGNED_SHORT:
    case GL.UNSIGNED_SHORT_5_6_5:
    case GL.UNSIGNED_SHORT_4_4_4_4:
    case GL.UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;
    case GL.UNSIGNED_INT:
      return Uint32Array;
    case GL.UNSIGNED_BYTE:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case GL.BYTE:
      return Int8Array;
    case GL.SHORT:
      return Int16Array;
    case GL.INT:
      return Int32Array;
    default:
      throw new Error('Failed to deduce type from array');
  }
}
/* eslint-enable complexity */

var AttributeManager = function () {
  /**
   * @classdesc
   * Automated attribute generation and management. Suitable when a set of
   * vertex shader attributes are generated by iteration over a data array,
   * and updates to these attributes are needed either when the data itself
   * changes, or when other data relevant to the calculations change.
   *
   * - First the application registers descriptions of its dynamic vertex
   *   attributes using AttributeManager.add().
   * - Then, when any change that affects attributes is detected by the
   *   application, the app will call AttributeManager.invalidate().
   * - Finally before it renders, it calls AttributeManager.update() to
   *   ensure that attributes are automatically rebuilt if anything has been
   *   invalidated.
   *
   * The application provided update functions describe how attributes
   * should be updated from a data array and are expected to traverse
   * that data array (or iterable) and fill in the attribute's typed array.
   *
   * Note that the attribute manager intentionally does not do advanced
   * change detection, but instead makes it easy to build such detection
   * by offering the ability to "invalidate" each attribute separately.
   *
   * Summary:
   * - keeps track of valid state for each attribute
   * - auto reallocates attributes when needed
   * - auto updates attributes with registered updater functions
   * - allows overriding with application supplied buffers
   *
   * Limitations:
   * - There are currently no provisions for only invalidating a range of
   *   indices in an attribute.
   *
   * @class
   * @param {Object} [props]
   * @param {String} [props.id] - identifier (for debugging)
   */
  function AttributeManager() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$id = _ref2.id,
        id = _ref2$id === undefined ? 'attribute-manager' : _ref2$id;

    _classCallCheck(this, AttributeManager);

    this.id = id;
    this.attributes = {};
    this.updateTriggers = {};
    this.allocedInstances = -1;
    this.needsRedraw = true;
    this.userData = {};

    this.onUpdateStart = noop;
    this.onUpdateEnd = noop;
    this.onLog = this._defaultLog;

    // For debugging sanity, prevent uninitialized members
    Object.seal(this);
  }

  /**
   * Adds attributes
   * Takes a map of attribute descriptor objects
   * - keys are attribute names
   * - values are objects with attribute fields
   *
   * attribute.size - number of elements per object
   * attribute.updater - number of elements
   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)
   * attribute.noAlloc=false - if this attribute should not be allocated
   *
   * @example
   * attributeManager.add({
   *   positions: {size: 2, update: calculatePositions}
   *   colors: {size: 3, update: calculateColors}
   * });
   *
   * @param {Object} attributes - attribute map (see above)
   * @param {Object} updaters - separate map of update functions (deprecated)
   */


  _createClass(AttributeManager, [{
    key: 'add',
    value: function add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    /**
      * Removes attributes
      * Takes an array of attribute names and delete them from
      * the attribute map if they exists
      *
      * @example
      * attributeManager.remove(['position']);
      *
      * @param {Object} attributeNameArray - attribute name array (see above)
      */

  }, {
    key: 'remove',
    value: function remove(attributeNameArray) {
      for (var i = 0; i < attributeNameArray.length; i++) {
        var name = attributeNameArray[i];
        if (this.attributes[name] !== undefined) {
          delete this.attributes[name];
        }
      }
    }

    /* Marks an attribute for update
     * @param {string} triggerName: attribute or accessor name
     */

  }, {
    key: 'invalidate',
    value: function invalidate(triggerName) {
      var attributes = this.attributes,
          updateTriggers = this.updateTriggers;

      var attributesToUpdate = updateTriggers[triggerName];

      if (!attributesToUpdate) {
        var message = 'invalidating non-existent attribute ' + triggerName + ' for ' + this.id + '\n';
        message += 'Valid attributes: ' + Object.keys(attributes).join(', ');
        assert(attributesToUpdate, message);
      }
      attributesToUpdate.forEach(function (name) {
        var attribute = attributes[name];
        if (attribute) {
          attribute.needsUpdate = true;
        }
      });
      // For performance tuning
      this.onLog(1, 'invalidated attribute ' + attributesToUpdate + ' for ' + this.id);
    }
  }, {
    key: 'invalidateAll',
    value: function invalidateAll() {
      var attributes = this.attributes;

      for (var attributeName in attributes) {
        this.invalidate(attributeName);
      }
    }

    /**
     * Ensure all attribute buffers are updated from props or data.
     *
     * Note: Any preallocated buffers in "buffers" matching registered attribute
     * names will be used. No update will happen in this case.
     * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */

  }, {
    key: 'update',
    value: function update() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref3.data,
          numInstances = _ref3.numInstances,
          _ref3$props = _ref3.props,
          props = _ref3$props === undefined ? {} : _ref3$props,
          _ref3$buffers = _ref3.buffers,
          buffers = _ref3$buffers === undefined ? {} : _ref3$buffers,
          _ref3$context = _ref3.context,
          context = _ref3$context === undefined ? {} : _ref3$context,
          _ref3$ignoreUnknownAt = _ref3.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref3$ignoreUnknownAt === undefined ? false : _ref3$ignoreUnknownAt;

      // First apply any application provided buffers
      this._checkExternalBuffers({ buffers: buffers, ignoreUnknownAttributes: ignoreUnknownAttributes });
      this._setExternalBuffers(buffers);

      // Only initiate alloc/update (and logging) if actually needed
      if (this._analyzeBuffers({ numInstances: numInstances })) {
        this.onUpdateStart(this.id);
        this._updateBuffers({ numInstances: numInstances, data: data, props: props, context: context });
        this.onUpdateEnd(this.id);
      }
    }

    /**
     * Sets log functions to help trace or time attribute updates.
     * Default logging uses luma logger.
     *
     * Note that the app may not be in control of when update is called,
     * so hooks are provided for update start and end.
     *
     * @param {Object} [opts]
     * @param {String} [opts.onLog=] - called to print
     * @param {String} [opts.onUpdateStart=] - called before update() starts
     * @param {String} [opts.onUpdateEnd=] - called after update() ends
     */

  }, {
    key: 'setLogFunctions',
    value: function setLogFunctions() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref4.onLog,
          onUpdateStart = _ref4.onUpdateStart,
          onUpdateEnd = _ref4.onUpdateEnd;

      this.onLog = onLog !== undefined ? onLog : this.onLog;
      this.onUpdateStart = onUpdateStart !== undefined ? onUpdateStart : this.onUpdateStart;
      this.onUpdateEnd = onUpdateEnd !== undefined ? onUpdateEnd : this.onUpdateEnd;
    }

    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getAttributes',
    value: function getAttributes() {
      return this.attributes;
    }

    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuggers need to be updated
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getChangedAttributes',
    value: function getChangedAttributes(_ref5) {
      var _ref5$clearChangedFla = _ref5.clearChangedFlags,
          clearChangedFlags = _ref5$clearChangedFla === undefined ? false : _ref5$clearChangedFla;
      var attributes = this.attributes;

      var changedAttributes = {};
      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (attribute.changed) {
          attribute.changed = attribute.changed && !clearChangedFlags;
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }

    /**
     * Returns the redraw flag, optionally clearing it.
     * Redraw flag will be set if any attributes attributes changed since
     * flag was last cleared.
     *
     * @param {Object} [opts]
     * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag
     * @return {Boolean} - whether a redraw is needed.
     */

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$clearRedrawFlag = _ref6.clearRedrawFlags,
          clearRedrawFlags = _ref6$clearRedrawFlag === undefined ? false : _ref6$clearRedrawFlag;

      var redraw = this.needsRedraw;
      redraw = redraw || this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw;
    }

    /**
     * Sets the redraw flag.
     * @param {Boolean} redraw=true
     * @return {AttributeManager} - for chaining
     */

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = true;
      return this;
    }

    // DEPRECATED METHODS

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addDynamic',
    value: function addDynamic(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addInstanced',
    value: function addInstanced(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters, { instanced: 1 });
    }

    // PRIVATE METHODS

    // Default logger

  }, {
    key: '_defaultLog',
    value: function _defaultLog(level, message) {
      log.log(level, message);
    }

    // Used to register an attribute

  }, {
    key: '_add',
    value: function _add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var newAttributes = {};

      for (var attributeName in attributes) {
        // support for separate update function map
        // For now, just copy any attributes from that map into the main map
        // TODO - Attribute maps are a deprecated feature, remove
        if (attributeName in updaters) {
          attributes[attributeName] = Object.assign({}, attributes[attributeName], updaters[attributeName]);
        }

        var attribute = attributes[attributeName];

        var isIndexed = attribute.isIndexed || attribute.elements;
        var size = attribute.elements && 1 || attribute.size;
        var value = attribute.value || null;

        // Initialize the attribute descriptor, with WebGL and metadata fields
        var attributeData = Object.assign({
          // Ensure that fields are present before Object.seal()
          target: undefined,
          userData: {} // Reserved for application
        },
        // Metadata
        attribute, {
          // State
          isExternalBuffer: false,
          needsAlloc: false,
          needsUpdate: false,
          changed: false,

          // Luma fields
          isIndexed: isIndexed,
          size: size,
          value: value
        }, _extraProps);
        // Sanity - no app fields on our attributes. Use userData instead.
        Object.seal(attributeData);

        // Check all fields and generate helpful error messages
        this._validateAttributeDefinition(attributeName, attributeData);

        // Add to both attributes list (for registration with model)
        newAttributes[attributeName] = attributeData;
      }

      Object.assign(this.attributes, newAttributes);

      this._mapUpdateTriggersToAttributes();
    }

    // build updateTrigger name to attribute name mapping

  }, {
    key: '_mapUpdateTriggersToAttributes',
    value: function _mapUpdateTriggersToAttributes() {
      var _this = this;

      var triggers = {};

      var _loop = function _loop(attributeName) {
        var attribute = _this.attributes[attributeName];
        var accessor = attribute.accessor;

        // use attribute name as update trigger key

        triggers[attributeName] = [attributeName];

        // use accessor name as update trigger key
        if (typeof accessor === 'string') {
          accessor = [accessor];
        }
        if (Array.isArray(accessor)) {
          accessor.forEach(function (accessorName) {
            if (!triggers[accessorName]) {
              triggers[accessorName] = [];
            }
            triggers[accessorName].push(attributeName);
          });
        }
      };

      for (var attributeName in this.attributes) {
        _loop(attributeName);
      }

      this.updateTriggers = triggers;
    }
  }, {
    key: '_validateAttributeDefinition',
    value: function _validateAttributeDefinition(attributeName, attribute) {
      assert(attribute.size >= 1 && attribute.size <= 4, 'Attribute definition for ' + attributeName + ' invalid size');

      // Check that either 'accessor' or 'update' is a valid function
      var hasUpdater = attribute.noAlloc || typeof attribute.update === 'function' || typeof attribute.accessor === 'string';
      if (!hasUpdater) {
        throw new Error('Attribute ' + attributeName + ' missing update or accessor');
      }
    }

    // Checks that any attribute buffers in props are valid
    // Note: This is just to help app catch mistakes

  }, {
    key: '_checkExternalBuffers',
    value: function _checkExternalBuffers() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$buffers = _ref7.buffers,
          buffers = _ref7$buffers === undefined ? {} : _ref7$buffers,
          _ref7$ignoreUnknownAt = _ref7.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref7$ignoreUnknownAt === undefined ? false : _ref7$ignoreUnknownAt;

      var attributes = this.attributes;

      for (var attributeName in buffers) {
        var attribute = attributes[attributeName];
        if (!attribute && !ignoreUnknownAttributes) {
          throw new Error('Unknown attribute prop ' + attributeName);
        }
        // const buffer = buffers[attributeName];
        // TODO - check buffer type
      }
    }

    // Set the buffers for the supplied attributes
    // Update attribute buffers from any attributes in props
    // Detach any previously set buffers, marking all
    // Attributes for auto allocation
    /* eslint-disable max-statements */

  }, {
    key: '_setExternalBuffers',
    value: function _setExternalBuffers(bufferMap) {
      var attributes = this.attributes,
          numInstances = this.numInstances;

      // Copy the refs of any supplied buffers in the props

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        var buffer = bufferMap[attributeName];
        attribute.isExternalBuffer = false;
        if (buffer) {
          if (!(buffer instanceof Float32Array)) {
            throw new Error('Attribute properties must be of type Float32Array');
          }
          if (attribute.auto && buffer.length <= numInstances * attribute.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          attribute.isExternalBuffer = true;
          attribute.needsUpdate = false;
          if (attribute.value !== buffer) {
            attribute.value = buffer;
            attribute.changed = true;
            this.needsRedraw = true;
          }
        }
      }
    }
    /* eslint-enable max-statements */

    /* Checks that typed arrays for attributes are big enough
     * sets alloc flag if not
     * @return {Boolean} whether any updates are needed
     */

  }, {
    key: '_analyzeBuffers',
    value: function _analyzeBuffers(_ref8) {
      var numInstances = _ref8.numInstances;
      var attributes = this.attributes;

      assert(numInstances !== undefined, 'numInstances not defined');

      // Track whether any allocations or updates are needed
      var needsUpdate = false;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (!attribute.isExternalBuffer) {
          // Do we need to reallocate the attribute's typed array?
          var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;
          if (needsAlloc && (attribute.update || attribute.accessor)) {
            attribute.needsAlloc = true;
            needsUpdate = true;
          }
          if (attribute.needsUpdate) {
            needsUpdate = true;
          }
        }
      }

      return needsUpdate;
    }

    /**
     * @private
     * Calls update on any buffers that need update
     * TODO? - If app supplied all attributes, no need to iterate over data
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */
    /* eslint-disable max-statements, complexity */

  }, {
    key: '_updateBuffers',
    value: function _updateBuffers(_ref9) {
      var numInstances = _ref9.numInstances,
          data = _ref9.data,
          props = _ref9.props,
          context = _ref9.context;
      var attributes = this.attributes;

      // Allocate at least one element to ensure a valid buffer

      var allocCount = Math.max(numInstances, 1);

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        // Allocate a new typed array if needed
        if (attribute.needsAlloc) {
          var ArrayType = glArrayFromType(attribute.type || GL.FLOAT);
          attribute.value = new ArrayType(attribute.size * allocCount);
          this.onLog(2, this.id + ':' + attributeName + ' allocated ' + allocCount);
          attribute.needsAlloc = false;
          attribute.needsUpdate = true;
        }

        // Call updater function if needed
        if (attribute.needsUpdate) {
          this._updateBuffer({ attribute: attribute, attributeName: attributeName, numInstances: numInstances, data: data, props: props, context: context });
        }
      }

      this.allocedInstances = allocCount;
    }
  }, {
    key: '_updateBuffer',
    value: function _updateBuffer(_ref10) {
      var attribute = _ref10.attribute,
          attributeName = _ref10.attributeName,
          numInstances = _ref10.numInstances,
          data = _ref10.data,
          props = _ref10.props,
          context = _ref10.context;
      var update = attribute.update,
          accessor = attribute.accessor;

      if (update) {
        // Custom updater - typically for non-instanced layers
        this.onLog(2, this.id + ':' + attributeName + ' updating ' + numInstances);
        update.call(context, attribute, { data: data, props: props, numInstances: numInstances });
        this._checkAttributeArray(attribute, attributeName);
      } else if (accessor) {
        // Standard updater
        this._updateBufferViaStandardAccessor({ attribute: attribute, data: data, props: props });
        this._checkAttributeArray(attribute, attributeName);
      } else {
        this.onLog(2, this.id + ':' + attributeName + ' missing update function');
      }

      attribute.needsUpdate = false;
      attribute.changed = true;
      this.needsRedraw = true;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_updateBufferViaStandardAccessor',
    value: function _updateBufferViaStandardAccessor(_ref11) {
      var attribute = _ref11.attribute,
          data = _ref11.data,
          props = _ref11.props;
      var accessor = attribute.accessor,
          value = attribute.value,
          size = attribute.size;

      var accessorFunc = props[accessor];

      assert(typeof accessorFunc === 'function', 'accessor "' + accessor + '" is not a function');

      var _attribute$defaultVal = attribute.defaultValue,
          defaultValue = _attribute$defaultVal === undefined ? [0, 0, 0, 0] : _attribute$defaultVal;

      defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var objectValue = accessorFunc(object);
          objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];
          /* eslint-disable no-fallthrough, default-case */
          switch (size) {
            case 4:
              value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];
            case 3:
              value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];
            case 2:
              value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];
            case 1:
              value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];
          }
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: '_checkAttributeArray',
    value: function _checkAttributeArray(attribute, attributeName) {
      var value = attribute.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);
        if (!valid) {
          throw new Error('Illegal attribute generated for ' + attributeName);
        }
      }
    }
  }]);

  return AttributeManager;
}();

export default AttributeManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXR0cmlidXRlLW1hbmFnZXIuanMiXSwibmFtZXMiOlsiR0wiLCJsb2ciLCJhc3NlcnQiLCJub29wIiwiZ2xBcnJheUZyb21UeXBlIiwiZ2xUeXBlIiwiY2xhbXBlZCIsIkZMT0FUIiwiRmxvYXQzMkFycmF5IiwiVU5TSUdORURfU0hPUlQiLCJVTlNJR05FRF9TSE9SVF81XzZfNSIsIlVOU0lHTkVEX1NIT1JUXzRfNF80XzQiLCJVTlNJR05FRF9TSE9SVF81XzVfNV8xIiwiVWludDE2QXJyYXkiLCJVTlNJR05FRF9JTlQiLCJVaW50MzJBcnJheSIsIlVOU0lHTkVEX0JZVEUiLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQ4QXJyYXkiLCJCWVRFIiwiSW50OEFycmF5IiwiU0hPUlQiLCJJbnQxNkFycmF5IiwiSU5UIiwiSW50MzJBcnJheSIsIkVycm9yIiwiQXR0cmlidXRlTWFuYWdlciIsImlkIiwiYXR0cmlidXRlcyIsInVwZGF0ZVRyaWdnZXJzIiwiYWxsb2NlZEluc3RhbmNlcyIsIm5lZWRzUmVkcmF3IiwidXNlckRhdGEiLCJvblVwZGF0ZVN0YXJ0Iiwib25VcGRhdGVFbmQiLCJvbkxvZyIsIl9kZWZhdWx0TG9nIiwiT2JqZWN0Iiwic2VhbCIsInVwZGF0ZXJzIiwiX2FkZCIsImF0dHJpYnV0ZU5hbWVBcnJheSIsImkiLCJsZW5ndGgiLCJuYW1lIiwidW5kZWZpbmVkIiwidHJpZ2dlck5hbWUiLCJhdHRyaWJ1dGVzVG9VcGRhdGUiLCJtZXNzYWdlIiwia2V5cyIsImpvaW4iLCJmb3JFYWNoIiwiYXR0cmlidXRlIiwibmVlZHNVcGRhdGUiLCJhdHRyaWJ1dGVOYW1lIiwiaW52YWxpZGF0ZSIsImRhdGEiLCJudW1JbnN0YW5jZXMiLCJwcm9wcyIsImJ1ZmZlcnMiLCJjb250ZXh0IiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJfY2hlY2tFeHRlcm5hbEJ1ZmZlcnMiLCJfc2V0RXh0ZXJuYWxCdWZmZXJzIiwiX2FuYWx5emVCdWZmZXJzIiwiX3VwZGF0ZUJ1ZmZlcnMiLCJjbGVhckNoYW5nZWRGbGFncyIsImNoYW5nZWRBdHRyaWJ1dGVzIiwiY2hhbmdlZCIsImNsZWFyUmVkcmF3RmxhZ3MiLCJyZWRyYXciLCJpbnN0YW5jZWQiLCJsZXZlbCIsIl9leHRyYVByb3BzIiwibmV3QXR0cmlidXRlcyIsImFzc2lnbiIsImlzSW5kZXhlZCIsImVsZW1lbnRzIiwic2l6ZSIsInZhbHVlIiwiYXR0cmlidXRlRGF0YSIsInRhcmdldCIsImlzRXh0ZXJuYWxCdWZmZXIiLCJuZWVkc0FsbG9jIiwiX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbiIsIl9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcyIsInRyaWdnZXJzIiwiYWNjZXNzb3IiLCJBcnJheSIsImlzQXJyYXkiLCJhY2Nlc3Nvck5hbWUiLCJwdXNoIiwiaGFzVXBkYXRlciIsIm5vQWxsb2MiLCJ1cGRhdGUiLCJidWZmZXJNYXAiLCJidWZmZXIiLCJhdXRvIiwiYWxsb2NDb3VudCIsIk1hdGgiLCJtYXgiLCJBcnJheVR5cGUiLCJ0eXBlIiwiX3VwZGF0ZUJ1ZmZlciIsImNhbGwiLCJfY2hlY2tBdHRyaWJ1dGVBcnJheSIsIl91cGRhdGVCdWZmZXJWaWFTdGFuZGFyZEFjY2Vzc29yIiwiYWNjZXNzb3JGdW5jIiwiZGVmYXVsdFZhbHVlIiwib2JqZWN0Iiwib2JqZWN0VmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInZhbGlkIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxTQUFRQSxFQUFSLFFBQWlCLFNBQWpCO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixTQUFsQjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUEsU0FBU0MsSUFBVCxHQUFnQixDQUFFOztBQUVsQjtBQUNBLE9BQU8sU0FBU0MsZUFBVCxDQUF5QkMsTUFBekIsRUFBd0Q7QUFBQSxpRkFBSixFQUFJO0FBQUEsMEJBQXRCQyxPQUFzQjtBQUFBLE1BQXRCQSxPQUFzQixnQ0FBWixJQUFZOztBQUM3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QUNBZ0MsT0FBT0MsUUFBUCxDQUFnQmpDLE1BQU0sQ0FBTixDQUFoQixDQURBLElBQzZCZ0MsT0FBT0MsUUFBUCxDQUFnQmpDLE1BQU0sQ0FBTixDQUFoQixDQUYvQjtBQUdBLFlBQUksQ0FBQ2tDLEtBQUwsRUFBWTtBQUNWLGdCQUFNLElBQUl4RixLQUFKLHNDQUE2QzZCLGFBQTdDLENBQU47QUFDRDtBQUNGO0FBQ0Y7Ozs7OztlQTdoQmtCNUIsZ0IiLCJmaWxlIjoiYXR0cmlidXRlLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbmltcG9ydCB7R0x9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdsQXJyYXlGcm9tVHlwZShnbFR5cGUsIHtjbGFtcGVkID0gdHJ1ZX0gPSB7fSkge1xuICAvLyBTb3J0ZWQgaW4gc29tZSBvcmRlciBvZiBsaWtlbGlob29kIHRvIHJlZHVjZSBhbW91bnQgb2YgY29tcGFyaXNvbnNcbiAgc3dpdGNoIChnbFR5cGUpIHtcbiAgY2FzZSBHTC5GTE9BVDpcbiAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICBjYXNlIEdMLlVOU0lHTkVEX1NIT1JUOlxuICBjYXNlIEdMLlVOU0lHTkVEX1NIT1JUXzVfNl81OlxuICBjYXNlIEdMLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ6XG4gIGNhc2UgR0wuVU5TSUdORURfU0hPUlRfNV81XzVfMTpcbiAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gIGNhc2UgR0wuVU5TSUdORURfSU5UOlxuICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgY2FzZSBHTC5VTlNJR05FRF9CWVRFOlxuICAgIHJldHVybiBjbGFtcGVkID8gVWludDhDbGFtcGVkQXJyYXkgOiBVaW50OEFycmF5O1xuICBjYXNlIEdMLkJZVEU6XG4gICAgcmV0dXJuIEludDhBcnJheTtcbiAgY2FzZSBHTC5TSE9SVDpcbiAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgY2FzZSBHTC5JTlQ6XG4gICAgcmV0dXJuIEludDMyQXJyYXk7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVkdWNlIHR5cGUgZnJvbSBhcnJheScpO1xuICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlTWFuYWdlciB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEF1dG9tYXRlZCBhdHRyaWJ1dGUgZ2VuZXJhdGlvbiBhbmQgbWFuYWdlbWVudC4gU3VpdGFibGUgd2hlbiBhIHNldCBvZlxuICAgKiB2ZXJ0ZXggc2hhZGVyIGF0dHJpYnV0ZXMgYXJlIGdlbmVyYXRlZCBieSBpdGVyYXRpb24gb3ZlciBhIGRhdGEgYXJyYXksXG4gICAqIGFuZCB1cGRhdGVzIHRvIHRoZXNlIGF0dHJpYnV0ZXMgYXJlIG5lZWRlZCBlaXRoZXIgd2hlbiB0aGUgZGF0YSBpdHNlbGZcbiAgICogY2hhbmdlcywgb3Igd2hlbiBvdGhlciBkYXRhIHJlbGV2YW50IHRvIHRoZSBjYWxjdWxhdGlvbnMgY2hhbmdlLlxuICAgKlxuICAgKiAtIEZpcnN0IHRoZSBhcHBsaWNhdGlvbiByZWdpc3RlcnMgZGVzY3JpcHRpb25zIG9mIGl0cyBkeW5hbWljIHZlcnRleFxuICAgKiAgIGF0dHJpYnV0ZXMgdXNpbmcgQXR0cmlidXRlTWFuYWdlci5hZGQoKS5cbiAgICogLSBUaGVuLCB3aGVuIGFueSBjaGFuZ2UgdGhhdCBhZmZlY3RzIGF0dHJpYnV0ZXMgaXMgZGV0ZWN0ZWQgYnkgdGhlXG4gICAqICAgYXBwbGljYXRpb24sIHRoZSBhcHAgd2lsbCBjYWxsIEF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgpLlxuICAgKiAtIEZpbmFsbHkgYmVmb3JlIGl0IHJlbmRlcnMsIGl0IGNhbGxzIEF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKCkgdG9cbiAgICogICBlbnN1cmUgdGhhdCBhdHRyaWJ1dGVzIGFyZSBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgaWYgYW55dGhpbmcgaGFzIGJlZW5cbiAgICogICBpbnZhbGlkYXRlZC5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIHByb3ZpZGVkIHVwZGF0ZSBmdW5jdGlvbnMgZGVzY3JpYmUgaG93IGF0dHJpYnV0ZXNcbiAgICogc2hvdWxkIGJlIHVwZGF0ZWQgZnJvbSBhIGRhdGEgYXJyYXkgYW5kIGFyZSBleHBlY3RlZCB0byB0cmF2ZXJzZVxuICAgKiB0aGF0IGRhdGEgYXJyYXkgKG9yIGl0ZXJhYmxlKSBhbmQgZmlsbCBpbiB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgYXR0cmlidXRlIG1hbmFnZXIgaW50ZW50aW9uYWxseSBkb2VzIG5vdCBkbyBhZHZhbmNlZFxuICAgKiBjaGFuZ2UgZGV0ZWN0aW9uLCBidXQgaW5zdGVhZCBtYWtlcyBpdCBlYXN5IHRvIGJ1aWxkIHN1Y2ggZGV0ZWN0aW9uXG4gICAqIGJ5IG9mZmVyaW5nIHRoZSBhYmlsaXR5IHRvIFwiaW52YWxpZGF0ZVwiIGVhY2ggYXR0cmlidXRlIHNlcGFyYXRlbHkuXG4gICAqXG4gICAqIFN1bW1hcnk6XG4gICAqIC0ga2VlcHMgdHJhY2sgb2YgdmFsaWQgc3RhdGUgZm9yIGVhY2ggYXR0cmlidXRlXG4gICAqIC0gYXV0byByZWFsbG9jYXRlcyBhdHRyaWJ1dGVzIHdoZW4gbmVlZGVkXG4gICAqIC0gYXV0byB1cGRhdGVzIGF0dHJpYnV0ZXMgd2l0aCByZWdpc3RlcmVkIHVwZGF0ZXIgZnVuY3Rpb25zXG4gICAqIC0gYWxsb3dzIG92ZXJyaWRpbmcgd2l0aCBhcHBsaWNhdGlvbiBzdXBwbGllZCBidWZmZXJzXG4gICAqXG4gICAqIExpbWl0YXRpb25zOlxuICAgKiAtIFRoZXJlIGFyZSBjdXJyZW50bHkgbm8gcHJvdmlzaW9ucyBmb3Igb25seSBpbnZhbGlkYXRpbmcgYSByYW5nZSBvZlxuICAgKiAgIGluZGljZXMgaW4gYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wcy5pZF0gLSBpZGVudGlmaWVyIChmb3IgZGVidWdnaW5nKVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe2lkID0gJ2F0dHJpYnV0ZS1tYW5hZ2VyJ30gPSB7fSkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJzID0ge307XG4gICAgdGhpcy5hbGxvY2VkSW5zdGFuY2VzID0gLTE7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuXG4gICAgdGhpcy5vblVwZGF0ZVN0YXJ0ID0gbm9vcDtcbiAgICB0aGlzLm9uVXBkYXRlRW5kID0gbm9vcDtcbiAgICB0aGlzLm9uTG9nID0gdGhpcy5fZGVmYXVsdExvZztcblxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgc2FuaXR5LCBwcmV2ZW50IHVuaW5pdGlhbGl6ZWQgbWVtYmVyc1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYXR0cmlidXRlc1xuICAgKiBUYWtlcyBhIG1hcCBvZiBhdHRyaWJ1dGUgZGVzY3JpcHRvciBvYmplY3RzXG4gICAqIC0ga2V5cyBhcmUgYXR0cmlidXRlIG5hbWVzXG4gICAqIC0gdmFsdWVzIGFyZSBvYmplY3RzIHdpdGggYXR0cmlidXRlIGZpZWxkc1xuICAgKlxuICAgKiBhdHRyaWJ1dGUuc2l6ZSAtIG51bWJlciBvZiBlbGVtZW50cyBwZXIgb2JqZWN0XG4gICAqIGF0dHJpYnV0ZS51cGRhdGVyIC0gbnVtYmVyIG9mIGVsZW1lbnRzXG4gICAqIGF0dHJpYnV0ZS5pbnN0YW5jZWQ9MCAtIGlzIHRoaXMgaXMgYW4gaW5zdGFuY2VkIGF0dHJpYnV0ZSAoYS5rLmEuIGRpdmlzb3IpXG4gICAqIGF0dHJpYnV0ZS5ub0FsbG9jPWZhbHNlIC0gaWYgdGhpcyBhdHRyaWJ1dGUgc2hvdWxkIG5vdCBiZSBhbGxvY2F0ZWRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgKiAgIHBvc2l0aW9uczoge3NpemU6IDIsIHVwZGF0ZTogY2FsY3VsYXRlUG9zaXRpb25zfVxuICAgKiAgIGNvbG9yczoge3NpemU6IDMsIHVwZGF0ZTogY2FsY3VsYXRlQ29sb3JzfVxuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMpO1xuICB9XG5cbiAvKipcbiAgICogUmVtb3ZlcyBhdHRyaWJ1dGVzXG4gICAqIFRha2VzIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcyBhbmQgZGVsZXRlIHRoZW0gZnJvbVxuICAgKiB0aGUgYXR0cmlidXRlIG1hcCBpZiB0aGV5IGV4aXN0c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbJ3Bvc2l0aW9uJ10pO1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlTmFtZUFycmF5IC0gYXR0cmlidXRlIG5hbWUgYXJyYXkgKHNlZSBhYm92ZSlcbiAgICovXG4gIHJlbW92ZShhdHRyaWJ1dGVOYW1lQXJyYXkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZU5hbWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVBcnJheVtpXTtcbiAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qIE1hcmtzIGFuIGF0dHJpYnV0ZSBmb3IgdXBkYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0cmlnZ2VyTmFtZTogYXR0cmlidXRlIG9yIGFjY2Vzc29yIG5hbWVcbiAgICovXG4gIGludmFsaWRhdGUodHJpZ2dlck5hbWUpIHtcbiAgICBjb25zdCB7YXR0cmlidXRlcywgdXBkYXRlVHJpZ2dlcnN9ID0gdGhpcztcbiAgICBjb25zdCBhdHRyaWJ1dGVzVG9VcGRhdGUgPSB1cGRhdGVUcmlnZ2Vyc1t0cmlnZ2VyTmFtZV07XG5cbiAgICBpZiAoIWF0dHJpYnV0ZXNUb1VwZGF0ZSkge1xuICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICBgaW52YWxpZGF0aW5nIG5vbi1leGlzdGVudCBhdHRyaWJ1dGUgJHt0cmlnZ2VyTmFtZX0gZm9yICR7dGhpcy5pZH1cXG5gO1xuICAgICAgbWVzc2FnZSArPSBgVmFsaWQgYXR0cmlidXRlczogJHtPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5qb2luKCcsICcpfWA7XG4gICAgICBhc3NlcnQoYXR0cmlidXRlc1RvVXBkYXRlLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgYXR0cmlidXRlc1RvVXBkYXRlLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgaWYgKGF0dHJpYnV0ZSkge1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEZvciBwZXJmb3JtYW5jZSB0dW5pbmdcbiAgICB0aGlzLm9uTG9nKDEsIGBpbnZhbGlkYXRlZCBhdHRyaWJ1dGUgJHthdHRyaWJ1dGVzVG9VcGRhdGV9IGZvciAke3RoaXMuaWR9YCk7XG4gIH1cblxuICBpbnZhbGlkYXRlQWxsKCkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGFsbCBhdHRyaWJ1dGUgYnVmZmVycyBhcmUgdXBkYXRlZCBmcm9tIHByb3BzIG9yIGRhdGEuXG4gICAqXG4gICAqIE5vdGU6IEFueSBwcmVhbGxvY2F0ZWQgYnVmZmVycyBpbiBcImJ1ZmZlcnNcIiBtYXRjaGluZyByZWdpc3RlcmVkIGF0dHJpYnV0ZVxuICAgKiBuYW1lcyB3aWxsIGJlIHVzZWQuIE5vIHVwZGF0ZSB3aWxsIGhhcHBlbiBpbiB0aGlzIGNhc2UuXG4gICAqIE5vdGU6IENhbGxzIG9uVXBkYXRlU3RhcnQgYW5kIG9uVXBkYXRlRW5kIGxvZyBjYWxsYmFja3MgYmVmb3JlIGFuZCBhZnRlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmRhdGEgLSBkYXRhIChpdGVyYWJsZSBvYmplY3QpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLm51bUluc3RhbmNlcyAtIGNvdW50IG9mIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYnVmZmVycyA9IHt9IC0gcHJlLWFsbG9jYXRlZCBidWZmZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnByb3BzIC0gcGFzc2VkIHRvIHVwZGF0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmNvbnRleHQgLSBVc2VkIGFzIFwidGhpc1wiIGNvbnRleHQgZm9yIHVwZGF0ZXJzXG4gICAqL1xuICB1cGRhdGUoe1xuICAgIGRhdGEsXG4gICAgbnVtSW5zdGFuY2VzLFxuICAgIHByb3BzID0ge30sXG4gICAgYnVmZmVycyA9IHt9LFxuICAgIGNvbnRleHQgPSB7fSxcbiAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlcyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIC8vIEZpcnN0IGFwcGx5IGFueSBhcHBsaWNhdGlvbiBwcm92aWRlZCBidWZmZXJzXG4gICAgdGhpcy5fY2hlY2tFeHRlcm5hbEJ1ZmZlcnMoe2J1ZmZlcnMsIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzfSk7XG4gICAgdGhpcy5fc2V0RXh0ZXJuYWxCdWZmZXJzKGJ1ZmZlcnMpO1xuXG4gICAgLy8gT25seSBpbml0aWF0ZSBhbGxvYy91cGRhdGUgKGFuZCBsb2dnaW5nKSBpZiBhY3R1YWxseSBuZWVkZWRcbiAgICBpZiAodGhpcy5fYW5hbHl6ZUJ1ZmZlcnMoe251bUluc3RhbmNlc30pKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlU3RhcnQodGhpcy5pZCk7XG4gICAgICB0aGlzLl91cGRhdGVCdWZmZXJzKHtudW1JbnN0YW5jZXMsIGRhdGEsIHByb3BzLCBjb250ZXh0fSk7XG4gICAgICB0aGlzLm9uVXBkYXRlRW5kKHRoaXMuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGxvZyBmdW5jdGlvbnMgdG8gaGVscCB0cmFjZSBvciB0aW1lIGF0dHJpYnV0ZSB1cGRhdGVzLlxuICAgKiBEZWZhdWx0IGxvZ2dpbmcgdXNlcyBsdW1hIGxvZ2dlci5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBhcHAgbWF5IG5vdCBiZSBpbiBjb250cm9sIG9mIHdoZW4gdXBkYXRlIGlzIGNhbGxlZCxcbiAgICogc28gaG9va3MgYXJlIHByb3ZpZGVkIGZvciB1cGRhdGUgc3RhcnQgYW5kIGVuZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25Mb2c9XSAtIGNhbGxlZCB0byBwcmludFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25VcGRhdGVTdGFydD1dIC0gY2FsbGVkIGJlZm9yZSB1cGRhdGUoKSBzdGFydHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLm9uVXBkYXRlRW5kPV0gLSBjYWxsZWQgYWZ0ZXIgdXBkYXRlKCkgZW5kc1xuICAgKi9cbiAgc2V0TG9nRnVuY3Rpb25zKHtcbiAgICBvbkxvZyxcbiAgICBvblVwZGF0ZVN0YXJ0LFxuICAgIG9uVXBkYXRlRW5kXG4gIH0gPSB7fSkge1xuICAgIHRoaXMub25Mb2cgPSBvbkxvZyAhPT0gdW5kZWZpbmVkID8gb25Mb2cgOiB0aGlzLm9uTG9nO1xuICAgIHRoaXMub25VcGRhdGVTdGFydCA9XG4gICAgICBvblVwZGF0ZVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBvblVwZGF0ZVN0YXJ0IDogdGhpcy5vblVwZGF0ZVN0YXJ0O1xuICAgIHRoaXMub25VcGRhdGVFbmQgPVxuICAgICAgb25VcGRhdGVFbmQgIT09IHVuZGVmaW5lZCA/IG9uVXBkYXRlRW5kIDogdGhpcy5vblVwZGF0ZUVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbiAgICogTm90ZTogRm9ybWF0IG1hdGNoZXMgbHVtYS5nbCBNb2RlbC9Qcm9ncmFtLnNldEF0dHJpYnV0ZXMoKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBkZXNjcmlwdG9yc1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY2hhbmdlZCBhdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbiAgICogVGhpcyBpbmRpY2F0ZXMgd2hpY2ggV2ViR0xCdWdnZXJzIG5lZWQgdG8gYmUgdXBkYXRlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBkZXNjcmlwdG9yc1xuICAgKi9cbiAgZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoe2NsZWFyQ2hhbmdlZEZsYWdzID0gZmFsc2V9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VkQXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5jaGFuZ2VkKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5jaGFuZ2VkID0gYXR0cmlidXRlLmNoYW5nZWQgJiYgIWNsZWFyQ2hhbmdlZEZsYWdzO1xuICAgICAgICBjaGFuZ2VkQXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWRBdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlZHJhdyBmbGFnLCBvcHRpb25hbGx5IGNsZWFyaW5nIGl0LlxuICAgKiBSZWRyYXcgZmxhZyB3aWxsIGJlIHNldCBpZiBhbnkgYXR0cmlidXRlcyBhdHRyaWJ1dGVzIGNoYW5nZWQgc2luY2VcbiAgICogZmxhZyB3YXMgbGFzdCBjbGVhcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5jbGVhclJlZHJhd0ZsYWdzPWZhbHNlXSAtIHdoZXRoZXIgdG8gY2xlYXIgdGhlIGZsYWdcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gLSB3aGV0aGVyIGEgcmVkcmF3IGlzIG5lZWRlZC5cbiAgICovXG4gIGdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2V9ID0ge30pIHtcbiAgICBsZXQgcmVkcmF3ID0gdGhpcy5uZWVkc1JlZHJhdztcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgdGhpcy5uZWVkc1JlZHJhdztcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdGhpcy5uZWVkc1JlZHJhdyAmJiAhY2xlYXJSZWRyYXdGbGFncztcbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlZHJhdyBmbGFnLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlZHJhdz10cnVlXG4gICAqIEByZXR1cm4ge0F0dHJpYnV0ZU1hbmFnZXJ9IC0gZm9yIGNoYWluaW5nXG4gICAqL1xuICBzZXROZWVkc1JlZHJhdyhyZWRyYXcgPSB0cnVlKSB7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBERVBSRUNBVEVEIE1FVEhPRFNcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUsIHVzZSBhZGQoKSBpbnN0ZWFkXG4gICAqIEFkZHMgYXR0cmlidXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIGF0dHJpYnV0ZSBtYXAgKHNlZSBhYm92ZSlcbiAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXJzIC0gc2VwYXJhdGUgbWFwIG9mIHVwZGF0ZSBmdW5jdGlvbnMgKGRlcHJlY2F0ZWQpXG4gICAqL1xuICBhZGREeW5hbWljKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LCB1c2UgYWRkKCkgaW5zdGVhZFxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVycyAtIHNlcGFyYXRlIG1hcCBvZiB1cGRhdGUgZnVuY3Rpb25zIChkZXByZWNhdGVkKVxuICAgKi9cbiAgYWRkSW5zdGFuY2VkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30pIHtcbiAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMsIHtpbnN0YW5jZWQ6IDF9KTtcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIERlZmF1bHQgbG9nZ2VyXG4gIF9kZWZhdWx0TG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgbG9nLmxvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICAvLyBVc2VkIHRvIHJlZ2lzdGVyIGFuIGF0dHJpYnV0ZVxuICBfYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30sIF9leHRyYVByb3BzID0ge30pIHtcblxuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAvLyBzdXBwb3J0IGZvciBzZXBhcmF0ZSB1cGRhdGUgZnVuY3Rpb24gbWFwXG4gICAgICAvLyBGb3Igbm93LCBqdXN0IGNvcHkgYW55IGF0dHJpYnV0ZXMgZnJvbSB0aGF0IG1hcCBpbnRvIHRoZSBtYWluIG1hcFxuICAgICAgLy8gVE9ETyAtIEF0dHJpYnV0ZSBtYXBzIGFyZSBhIGRlcHJlY2F0ZWQgZmVhdHVyZSwgcmVtb3ZlXG4gICAgICBpZiAoYXR0cmlidXRlTmFtZSBpbiB1cGRhdGVycykge1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID1cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdLCB1cGRhdGVyc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgIGNvbnN0IGlzSW5kZXhlZCA9IGF0dHJpYnV0ZS5pc0luZGV4ZWQgfHwgYXR0cmlidXRlLmVsZW1lbnRzO1xuICAgICAgY29uc3Qgc2l6ZSA9IChhdHRyaWJ1dGUuZWxlbWVudHMgJiYgMSkgfHwgYXR0cmlidXRlLnNpemU7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZSB8fCBudWxsO1xuXG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBhdHRyaWJ1dGUgZGVzY3JpcHRvciwgd2l0aCBXZWJHTCBhbmQgbWV0YWRhdGEgZmllbGRzXG4gICAgICBjb25zdCBhdHRyaWJ1dGVEYXRhID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGZpZWxkcyBhcmUgcHJlc2VudCBiZWZvcmUgT2JqZWN0LnNlYWwoKVxuICAgICAgICAgIHRhcmdldDogdW5kZWZpbmVkLFxuICAgICAgICAgIHVzZXJEYXRhOiB7fSAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIGFwcGxpY2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1ldGFkYXRhXG4gICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIFN0YXRlXG4gICAgICAgICAgaXNFeHRlcm5hbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgbmVlZHNBbGxvYzogZmFsc2UsXG4gICAgICAgICAgbmVlZHNVcGRhdGU6IGZhbHNlLFxuICAgICAgICAgIGNoYW5nZWQ6IGZhbHNlLFxuXG4gICAgICAgICAgLy8gTHVtYSBmaWVsZHNcbiAgICAgICAgICBpc0luZGV4ZWQsXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBfZXh0cmFQcm9wc1xuICAgICAgKTtcbiAgICAgIC8vIFNhbml0eSAtIG5vIGFwcCBmaWVsZHMgb24gb3VyIGF0dHJpYnV0ZXMuIFVzZSB1c2VyRGF0YSBpbnN0ZWFkLlxuICAgICAgT2JqZWN0LnNlYWwoYXR0cmlidXRlRGF0YSk7XG5cbiAgICAgIC8vIENoZWNrIGFsbCBmaWVsZHMgYW5kIGdlbmVyYXRlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZXNcbiAgICAgIHRoaXMuX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbihhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVEYXRhKTtcblxuICAgICAgLy8gQWRkIHRvIGJvdGggYXR0cmlidXRlcyBsaXN0IChmb3IgcmVnaXN0cmF0aW9uIHdpdGggbW9kZWwpXG4gICAgICBuZXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlRGF0YTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcywgbmV3QXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLl9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcygpO1xuICB9XG5cbiAgLy8gYnVpbGQgdXBkYXRlVHJpZ2dlciBuYW1lIHRvIGF0dHJpYnV0ZSBuYW1lIG1hcHBpbmdcbiAgX21hcFVwZGF0ZVRyaWdnZXJzVG9BdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBsZXQge2FjY2Vzc29yfSA9IGF0dHJpYnV0ZTtcblxuICAgICAgLy8gdXNlIGF0dHJpYnV0ZSBuYW1lIGFzIHVwZGF0ZSB0cmlnZ2VyIGtleVxuICAgICAgdHJpZ2dlcnNbYXR0cmlidXRlTmFtZV0gPSBbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgIC8vIHVzZSBhY2Nlc3NvciBuYW1lIGFzIHVwZGF0ZSB0cmlnZ2VyIGtleVxuICAgICAgaWYgKHR5cGVvZiBhY2Nlc3NvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWNjZXNzb3IgPSBbYWNjZXNzb3JdO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWNjZXNzb3IpKSB7XG4gICAgICAgIGFjY2Vzc29yLmZvckVhY2goYWNjZXNzb3JOYW1lID0+IHtcbiAgICAgICAgICBpZiAoIXRyaWdnZXJzW2FjY2Vzc29yTmFtZV0pIHtcbiAgICAgICAgICAgIHRyaWdnZXJzW2FjY2Vzc29yTmFtZV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJpZ2dlcnNbYWNjZXNzb3JOYW1lXS5wdXNoKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJzID0gdHJpZ2dlcnM7XG4gIH1cblxuICBfdmFsaWRhdGVBdHRyaWJ1dGVEZWZpbml0aW9uKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZSkge1xuICAgIGFzc2VydChhdHRyaWJ1dGUuc2l6ZSA+PSAxICYmIGF0dHJpYnV0ZS5zaXplIDw9IDQsXG4gICAgICBgQXR0cmlidXRlIGRlZmluaXRpb24gZm9yICR7YXR0cmlidXRlTmFtZX0gaW52YWxpZCBzaXplYCk7XG5cbiAgICAvLyBDaGVjayB0aGF0IGVpdGhlciAnYWNjZXNzb3InIG9yICd1cGRhdGUnIGlzIGEgdmFsaWQgZnVuY3Rpb25cbiAgICBjb25zdCBoYXNVcGRhdGVyID0gYXR0cmlidXRlLm5vQWxsb2MgfHxcbiAgICAgIHR5cGVvZiBhdHRyaWJ1dGUudXBkYXRlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXR0cmlidXRlLmFjY2Vzc29yID09PSAnc3RyaW5nJztcbiAgICBpZiAoIWhhc1VwZGF0ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0cmlidXRlICR7YXR0cmlidXRlTmFtZX0gbWlzc2luZyB1cGRhdGUgb3IgYWNjZXNzb3JgKTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVja3MgdGhhdCBhbnkgYXR0cmlidXRlIGJ1ZmZlcnMgaW4gcHJvcHMgYXJlIHZhbGlkXG4gIC8vIE5vdGU6IFRoaXMgaXMganVzdCB0byBoZWxwIGFwcCBjYXRjaCBtaXN0YWtlc1xuICBfY2hlY2tFeHRlcm5hbEJ1ZmZlcnMoe1xuICAgIGJ1ZmZlcnMgPSB7fSxcbiAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlcyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGJ1ZmZlcnMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoIWF0dHJpYnV0ZSAmJiAhaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGF0dHJpYnV0ZSBwcm9wICR7YXR0cmlidXRlTmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbYXR0cmlidXRlTmFtZV07XG4gICAgICAvLyBUT0RPIC0gY2hlY2sgYnVmZmVyIHR5cGVcbiAgICB9XG4gIH1cblxuICAvLyBTZXQgdGhlIGJ1ZmZlcnMgZm9yIHRoZSBzdXBwbGllZCBhdHRyaWJ1dGVzXG4gIC8vIFVwZGF0ZSBhdHRyaWJ1dGUgYnVmZmVycyBmcm9tIGFueSBhdHRyaWJ1dGVzIGluIHByb3BzXG4gIC8vIERldGFjaCBhbnkgcHJldmlvdXNseSBzZXQgYnVmZmVycywgbWFya2luZyBhbGxcbiAgLy8gQXR0cmlidXRlcyBmb3IgYXV0byBhbGxvY2F0aW9uXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF9zZXRFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVyTWFwKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXMsIG51bUluc3RhbmNlc30gPSB0aGlzO1xuXG4gICAgLy8gQ29weSB0aGUgcmVmcyBvZiBhbnkgc3VwcGxpZWQgYnVmZmVycyBpbiB0aGUgcHJvcHNcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlck1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyID0gZmFsc2U7XG4gICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSBwcm9wZXJ0aWVzIG11c3QgYmUgb2YgdHlwZSBGbG9hdDMyQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLmF1dG8gJiYgYnVmZmVyLmxlbmd0aCA8PSBudW1JbnN0YW5jZXMgKiBhdHRyaWJ1dGUuc2l6ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHByb3AgYXJyYXkgbXVzdCBtYXRjaCBsZW5ndGggYW5kIHNpemUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgIT09IGJ1ZmZlcikge1xuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IGJ1ZmZlcjtcbiAgICAgICAgICBhdHRyaWJ1dGUuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8qIENoZWNrcyB0aGF0IHR5cGVkIGFycmF5cyBmb3IgYXR0cmlidXRlcyBhcmUgYmlnIGVub3VnaFxuICAgKiBzZXRzIGFsbG9jIGZsYWcgaWYgbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgYW55IHVwZGF0ZXMgYXJlIG5lZWRlZFxuICAgKi9cbiAgX2FuYWx5emVCdWZmZXJzKHtudW1JbnN0YW5jZXN9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcbiAgICBhc3NlcnQobnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQsICdudW1JbnN0YW5jZXMgbm90IGRlZmluZWQnKTtcblxuICAgIC8vIFRyYWNrIHdoZXRoZXIgYW55IGFsbG9jYXRpb25zIG9yIHVwZGF0ZXMgYXJlIG5lZWRlZFxuICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoIWF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyKSB7XG4gICAgICAgIC8vIERvIHdlIG5lZWQgdG8gcmVhbGxvY2F0ZSB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXk/XG4gICAgICAgIGNvbnN0IG5lZWRzQWxsb2MgPVxuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZSA8IG51bUluc3RhbmNlcztcbiAgICAgICAgaWYgKG5lZWRzQWxsb2MgJiYgKGF0dHJpYnV0ZS51cGRhdGUgfHwgYXR0cmlidXRlLmFjY2Vzc29yKSkge1xuICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc0FsbG9jID0gdHJ1ZTtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSkge1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWVkc1VwZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBDYWxscyB1cGRhdGUgb24gYW55IGJ1ZmZlcnMgdGhhdCBuZWVkIHVwZGF0ZVxuICAgKiBUT0RPPyAtIElmIGFwcCBzdXBwbGllZCBhbGwgYXR0cmlidXRlcywgbm8gbmVlZCB0byBpdGVyYXRlIG92ZXIgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSAtIGRhdGEgKGl0ZXJhYmxlIG9iamVjdClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMubnVtSW5zdGFuY2VzIC0gY291bnQgb2YgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5idWZmZXJzID0ge30gLSBwcmUtYWxsb2NhdGVkIGJ1ZmZlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvcHMgLSBwYXNzZWQgdG8gdXBkYXRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY29udGV4dCAtIFVzZWQgYXMgXCJ0aGlzXCIgY29udGV4dCBmb3IgdXBkYXRlcnNcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG4gIF91cGRhdGVCdWZmZXJzKHtudW1JbnN0YW5jZXMsIGRhdGEsIHByb3BzLCBjb250ZXh0fSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG5cbiAgICAvLyBBbGxvY2F0ZSBhdCBsZWFzdCBvbmUgZWxlbWVudCB0byBlbnN1cmUgYSB2YWxpZCBidWZmZXJcbiAgICBjb25zdCBhbGxvY0NvdW50ID0gTWF0aC5tYXgobnVtSW5zdGFuY2VzLCAxKTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAvLyBBbGxvY2F0ZSBhIG5ldyB0eXBlZCBhcnJheSBpZiBuZWVkZWRcbiAgICAgIGlmIChhdHRyaWJ1dGUubmVlZHNBbGxvYykge1xuICAgICAgICBjb25zdCBBcnJheVR5cGUgPSBnbEFycmF5RnJvbVR5cGUoYXR0cmlidXRlLnR5cGUgfHwgR0wuRkxPQVQpO1xuICAgICAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgQXJyYXlUeXBlKGF0dHJpYnV0ZS5zaXplICogYWxsb2NDb3VudCk7XG4gICAgICAgIHRoaXMub25Mb2coMiwgYCR7dGhpcy5pZH06JHthdHRyaWJ1dGVOYW1lfSBhbGxvY2F0ZWQgJHthbGxvY0NvdW50fWApO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNBbGxvYyA9IGZhbHNlO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxsIHVwZGF0ZXIgZnVuY3Rpb24gaWYgbmVlZGVkXG4gICAgICBpZiAoYXR0cmlidXRlLm5lZWRzVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlcih7YXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lLCBudW1JbnN0YW5jZXMsIGRhdGEsIHByb3BzLCBjb250ZXh0fSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbGxvY2VkSW5zdGFuY2VzID0gYWxsb2NDb3VudDtcbiAgfVxuXG4gIF91cGRhdGVCdWZmZXIoe2F0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSwgbnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pIHtcbiAgICBjb25zdCB7dXBkYXRlLCBhY2Nlc3Nvcn0gPSBhdHRyaWJ1dGU7XG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgLy8gQ3VzdG9tIHVwZGF0ZXIgLSB0eXBpY2FsbHkgZm9yIG5vbi1pbnN0YW5jZWQgbGF5ZXJzXG4gICAgICB0aGlzLm9uTG9nKDIsIGAke3RoaXMuaWR9OiR7YXR0cmlidXRlTmFtZX0gdXBkYXRpbmcgJHtudW1JbnN0YW5jZXN9YCk7XG4gICAgICB1cGRhdGUuY2FsbChjb250ZXh0LCBhdHRyaWJ1dGUsIHtkYXRhLCBwcm9wcywgbnVtSW5zdGFuY2VzfSk7XG4gICAgICB0aGlzLl9jaGVja0F0dHJpYnV0ZUFycmF5KGF0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgfSBlbHNlIGlmIChhY2Nlc3Nvcikge1xuICAgICAgLy8gU3RhbmRhcmQgdXBkYXRlclxuICAgICAgdGhpcy5fdXBkYXRlQnVmZmVyVmlhU3RhbmRhcmRBY2Nlc3Nvcih7YXR0cmlidXRlLCBkYXRhLCBwcm9wc30pO1xuICAgICAgdGhpcy5fY2hlY2tBdHRyaWJ1dGVBcnJheShhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uTG9nKDIsIGAke3RoaXMuaWR9OiR7YXR0cmlidXRlTmFtZX0gbWlzc2luZyB1cGRhdGUgZnVuY3Rpb25gKTtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICBhdHRyaWJ1dGUuY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIF91cGRhdGVCdWZmZXJWaWFTdGFuZGFyZEFjY2Vzc29yKHthdHRyaWJ1dGUsIGRhdGEsIHByb3BzfSkge1xuICAgIGNvbnN0IHthY2Nlc3NvciwgdmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGNvbnN0IGFjY2Vzc29yRnVuYyA9IHByb3BzW2FjY2Vzc29yXTtcblxuICAgIGFzc2VydCh0eXBlb2YgYWNjZXNzb3JGdW5jID09PSAnZnVuY3Rpb24nLCBgYWNjZXNzb3IgXCIke2FjY2Vzc29yfVwiIGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG5cbiAgICBsZXQge2RlZmF1bHRWYWx1ZSA9IFswLCAwLCAwLCAwXX0gPSBhdHRyaWJ1dGU7XG4gICAgZGVmYXVsdFZhbHVlID0gQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlIDogW2RlZmF1bHRWYWx1ZV07XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGxldCBvYmplY3RWYWx1ZSA9IGFjY2Vzc29yRnVuYyhvYmplY3QpO1xuICAgICAgb2JqZWN0VmFsdWUgPSBBcnJheS5pc0FycmF5KG9iamVjdFZhbHVlKSA/IG9iamVjdFZhbHVlIDogW29iamVjdFZhbHVlXTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoLCBkZWZhdWx0LWNhc2UgKi9cbiAgICAgIHN3aXRjaCAoc2l6ZSkge1xuICAgICAgY2FzZSA0OiB2YWx1ZVtpICsgM10gPSBOdW1iZXIuaXNGaW5pdGUob2JqZWN0VmFsdWVbM10pID8gb2JqZWN0VmFsdWVbM10gOiBkZWZhdWx0VmFsdWVbM107XG4gICAgICBjYXNlIDM6IHZhbHVlW2kgKyAyXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVsyXSkgPyBvYmplY3RWYWx1ZVsyXSA6IGRlZmF1bHRWYWx1ZVsyXTtcbiAgICAgIGNhc2UgMjogdmFsdWVbaSArIDFdID0gTnVtYmVyLmlzRmluaXRlKG9iamVjdFZhbHVlWzFdKSA/IG9iamVjdFZhbHVlWzFdIDogZGVmYXVsdFZhbHVlWzFdO1xuICAgICAgY2FzZSAxOiB2YWx1ZVtpICsgMF0gPSBOdW1iZXIuaXNGaW5pdGUob2JqZWN0VmFsdWVbMF0pID8gb2JqZWN0VmFsdWVbMF0gOiBkZWZhdWx0VmFsdWVbMF07XG4gICAgICB9XG4gICAgICBpICs9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrQXR0cmlidXRlQXJyYXkoYXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3Qge3ZhbHVlfSA9IGF0dHJpYnV0ZTtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoID49IDQpIHtcbiAgICAgIGNvbnN0IHZhbGlkID1cbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzBdKSAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWVbMV0pICYmXG4gICAgICAgIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVsyXSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzNdKTtcbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgZm9yICR7YXR0cmlidXRlTmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==