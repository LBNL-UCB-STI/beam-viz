var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* global window */
import { GL, glContextWithState } from 'luma.gl';
import { getUniformsFromViewport } from './viewport-uniforms';
import { log, getBlendMode, setBlendMode } from './utils';

var EMPTY_PIXEL = new Uint8Array(4);
var renderCount = 0;

export function drawLayers(_ref) {
  var layers = _ref.layers,
      pass = _ref.pass;

  log.log(2, 'DRAWING ' + layers.length + ' layers');

  // render layers in normal colors
  var visibleCount = 0;
  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (layer.props.visible) {
      layer.drawLayer({
        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, getUniformsFromViewport(layer.context.viewport, layer.props), { layerIndex: layerIndex })
      });
      visibleCount++;
    }
  });

  log.log(1, 'RENDER PASS ' + pass + ': ' + renderCount++ + ' \n    ' + visibleCount + ' visible, ' + layers.length + ' total');
}

/* eslint-disable max-depth, max-statements */
export function pickLayers(gl, _ref2) {
  var layers = _ref2.layers,
      pickingFBO = _ref2.pickingFBO,
      _ref2$uniforms = _ref2.uniforms,
      uniforms = _ref2$uniforms === undefined ? {} : _ref2$uniforms,
      x = _ref2.x,
      y = _ref2.y,
      viewport = _ref2.viewport,
      mode = _ref2.mode,
      lastPickedInfo = _ref2.lastPickedInfo;

  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = x * pixelRatio;
  var deviceY = gl.canvas.height - y * pixelRatio;

  // TODO - just return glContextWithState once luma updates
  var unhandledPickInfos = [];

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  glContextWithState(gl, {
    frameBuffer: pickingFBO,
    framebuffer: pickingFBO,
    scissorTest: { x: deviceX, y: deviceY, w: 1, h: 1 }
  }, function () {

    // Picking process start
    // Clear the frame buffer
    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
    // Save current blend settings
    var oldBlendMode = getBlendMode(gl);
    // Set blend mode for picking
    // always overwrite existing pixel with [r,g,b,layerIndex]
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO);
    gl.blendEquation(gl.FUNC_ADD);

    // Render all pickable layers in picking colors
    layers.forEach(function (layer, layerIndex) {
      if (layer.props.visible && layer.props.pickable) {

        // Encode layerIndex with alpha
        gl.blendColor(0, 0, 0, (layerIndex + 1) / 255);

        layer.drawLayer({
          uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, getUniformsFromViewport(layer.context.viewport, layer.props), { layerIndex: layerIndex })
        });
      }
    });

    // Read color in the central pixel, to be mapped with picking colors
    var pickedColor = new Uint8Array(4);
    gl.readPixels(deviceX, deviceY, 1, 1, GL.RGBA, GL.UNSIGNED_BYTE, pickedColor);

    // restore blend mode
    setBlendMode(gl, oldBlendMode);
    // Picking process end

    // Process picked info start
    // Decode picked color
    var pickedLayerIndex = pickedColor[3] - 1;
    var pickedLayer = pickedLayerIndex >= 0 ? layers[pickedLayerIndex] : null;
    var pickedObjectIndex = pickedLayer ? pickedLayer.decodePickingColor(pickedColor) : -1;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;
    var affectedLayers = pickedLayer ? [pickedLayer] : [];

    if (mode === 'hover') {
      var _ret = function () {
        // only invoke onHover events if picked object has changed
        var lastPickedObjectIndex = lastPickedInfo.index;
        var lastPickedLayerId = lastPickedInfo.layerId;

        if (pickedLayerId === lastPickedLayerId && pickedObjectIndex === lastPickedObjectIndex) {
          // picked object did not change, no need to proceed
          return {
            v: void 0
          };
        }

        if (pickedLayerId !== lastPickedLayerId) {
          // We cannot store a ref to lastPickedLayer in the context because
          // the state of an outdated layer is no longer valid
          // and the props may have changed
          var lastPickedLayer = layers.find(function (l) {
            return l.props.id === lastPickedLayerId;
          });
          if (lastPickedLayer) {
            // Let leave event fire before enter event
            affectedLayers.unshift(lastPickedLayer);
          }
        }

        // Update layer manager context
        lastPickedInfo.layerId = pickedLayerId;
        lastPickedInfo.index = pickedObjectIndex;
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }

    var baseInfo = createInfo([x, y], viewport);
    baseInfo.devicePixel = [deviceX, deviceY];
    baseInfo.pixelRatio = pixelRatio;

    affectedLayers.forEach(function (layer) {
      var info = Object.assign({}, baseInfo);
      info.layer = layer;

      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }

      // Let layers populate its own info object
      info = layer.pickLayer({ info: info, mode: mode });

      // If layer.getPickingInfo() returns null, do not proceed
      if (info) {
        var handled = false;

        // Calling callbacks can have async interactions with React
        // which nullifies layer.state.
        switch (mode) {
          case 'click':
            handled = layer.props.onClick(info);break;
          case 'hover':
            handled = layer.props.onHover(info);break;
          default:
            throw new Error('unknown pick type');
        }

        if (!handled) {
          unhandledPickInfos.push(info);
        }
      }
    });
  });

  return unhandledPickInfos;
}
/* eslint-enable max-depth, max-statements */

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1hbmQtcGljay5qcyJdLCJuYW1lcyI6WyJHTCIsImdsQ29udGV4dFdpdGhTdGF0ZSIsImdldFVuaWZvcm1zRnJvbVZpZXdwb3J0IiwibG9nIiwiZ2V0QmxlbmRNb2RlIiwic2V0QmxlbmRNb2RlIiwiRU1QVFlfUElYRUwiLCJVaW50OEFycmF5IiwicmVuZGVyQ291bnQiLCJkcmF3TGF5ZXJzIiwibGF5ZXJzIiwicGFzcyIsImxlbmd0aCIsInZpc2libGVDb3VudCIsImZvckVhY2giLCJsYXllciIsImxheWVySW5kZXgiLCJwcm9wcyIsInZpc2libGUiLCJkcmF3TGF5ZXIiLCJ1bmlmb3JtcyIsIk9iamVjdCIsImFzc2lnbiIsInJlbmRlclBpY2tpbmdCdWZmZXIiLCJwaWNraW5nRW5hYmxlZCIsImNvbnRleHQiLCJ2aWV3cG9ydCIsInBpY2tMYXllcnMiLCJnbCIsInBpY2tpbmdGQk8iLCJ4IiwieSIsIm1vZGUiLCJsYXN0UGlja2VkSW5mbyIsInBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiZGV2aWNlWCIsImRldmljZVkiLCJjYW52YXMiLCJoZWlnaHQiLCJ1bmhhbmRsZWRQaWNrSW5mb3MiLCJmcmFtZUJ1ZmZlciIsImZyYW1lYnVmZmVyIiwic2Npc3NvclRlc3QiLCJ3IiwiaCIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJvbGRCbGVuZE1vZGUiLCJlbmFibGUiLCJCTEVORCIsImJsZW5kRnVuY1NlcGFyYXRlIiwiT05FIiwiWkVSTyIsIkNPTlNUQU5UX0FMUEhBIiwiYmxlbmRFcXVhdGlvbiIsIkZVTkNfQUREIiwicGlja2FibGUiLCJibGVuZENvbG9yIiwicGlja2VkQ29sb3IiLCJyZWFkUGl4ZWxzIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJwaWNrZWRMYXllckluZGV4IiwicGlja2VkTGF5ZXIiLCJwaWNrZWRPYmplY3RJbmRleCIsImRlY29kZVBpY2tpbmdDb2xvciIsInBpY2tlZExheWVySWQiLCJpZCIsImFmZmVjdGVkTGF5ZXJzIiwibGFzdFBpY2tlZE9iamVjdEluZGV4IiwiaW5kZXgiLCJsYXN0UGlja2VkTGF5ZXJJZCIsImxheWVySWQiLCJsYXN0UGlja2VkTGF5ZXIiLCJmaW5kIiwibCIsInVuc2hpZnQiLCJiYXNlSW5mbyIsImNyZWF0ZUluZm8iLCJkZXZpY2VQaXhlbCIsImluZm8iLCJjb2xvciIsInBpY2tlZCIsInBpY2tMYXllciIsImhhbmRsZWQiLCJvbkNsaWNrIiwib25Ib3ZlciIsIkVycm9yIiwicHVzaCIsInBpeGVsIiwibG5nTGF0IiwidW5wcm9qZWN0Il0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0EsU0FBUUEsRUFBUixFQUFZQyxrQkFBWixRQUFxQyxTQUFyQztBQUNBLFNBQVFDLHVCQUFSLFFBQXNDLHFCQUF0QztBQUNBLFNBQVFDLEdBQVIsRUFBYUMsWUFBYixFQUEyQkMsWUFBM0IsUUFBOEMsU0FBOUM7O0FBRUEsSUFBTUMsY0FBYyxJQUFJQyxVQUFKLENBQWUsQ0FBZixDQUFwQjtBQUNBLElBQUlDLGNBQWMsQ0FBbEI7O0FBRUEsT0FBTyxTQUFTQyxVQUFULE9BQW9DO0FBQUEsTUFBZkMsTUFBZSxRQUFmQSxNQUFlO0FBQUEsTUFBUEMsSUFBTyxRQUFQQSxJQUFPOztBQUN6Q1IsTUFBSUEsR0FBSixDQUFRLENBQVIsZUFBc0JPLE9BQU9FLE1BQTdCOztBQUVBO0FBQ0EsTUFBSUMsZUFBZSxDQUFuQjtBQUNBO0FBQ0FILFNBQU9JLE9BQVAsQ0FBZSxVQUFDQyxLQUFELEVBQVFDLFVBQVIsRUFBdUI7QUFDcEMsUUFBSUQsTUFBTUUsS0FBTixDQUFZQyxPQUFoQixFQUF5QjtBQUN2QkgsWUFBTUksU0FBTixDQUFnQjtBQUNkQyxrQkFBVUMsT0FBT0MsTUFBUCxDQUNSLEVBQUNDLHFCQUFxQixDQUF0QixFQUF5QkMsZ0JBQWdCLENBQXpDLEVBRFEsRUFFUlQsTUFBTVUsT0FBTixDQUFjTCxRQUZOLEVBR1JsQix3QkFB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RUxtRSxXQUFPLENBQUMsQ0FGSDtBQUdMWSxZQUFRLEtBSEg7QUFJTHZELE9BQUc4RCxNQUFNLENBQU4sQ0FKRTtBQUtMN0QsT0FBRzZELE1BQU0sQ0FBTixDQUxFO0FBTUxBLGdCQU5LO0FBT0xDLFlBQVFuRSxTQUFTb0UsU0FBVCxDQUFtQkYsS0FBbkI7QUFQSCxHQUFQO0FBU0QiLCJmaWxlIjoiZHJhdy1hbmQtcGljay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7R0wsIGdsQ29udGV4dFdpdGhTdGF0ZX0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQge2dldFVuaWZvcm1zRnJvbVZpZXdwb3J0fSBmcm9tICcuL3ZpZXdwb3J0LXVuaWZvcm1zJztcbmltcG9ydCB7bG9nLCBnZXRCbGVuZE1vZGUsIHNldEJsZW5kTW9kZX0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IEVNUFRZX1BJWEVMID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG5sZXQgcmVuZGVyQ291bnQgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gZHJhd0xheWVycyh7bGF5ZXJzLCBwYXNzfSkge1xuICBsb2cubG9nKDIsIGBEUkFXSU5HICR7bGF5ZXJzLmxlbmd0aH0gbGF5ZXJzYCk7XG5cbiAgLy8gcmVuZGVyIGxheWVycyBpbiBub3JtYWwgY29sb3JzXG4gIGxldCB2aXNpYmxlQ291bnQgPSAwO1xuICAvLyByZW5kZXIgbGF5ZXJzIGluIG5vcm1hbCBjb2xvcnNcbiAgbGF5ZXJzLmZvckVhY2goKGxheWVyLCBsYXllckluZGV4KSA9PiB7XG4gICAgaWYgKGxheWVyLnByb3BzLnZpc2libGUpIHtcbiAgICAgIGxheWVyLmRyYXdMYXllcih7XG4gICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHtyZW5kZXJQaWNraW5nQnVmZmVyOiAwLCBwaWNraW5nRW5hYmxlZDogMH0sXG4gICAgICAgICAgbGF5ZXIuY29udGV4dC51bmlmb3JtcyxcbiAgICAgICAgICBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydChsYXllci5jb250ZXh0LnZpZXdwb3J0LCBsYXllci5wcm9wcyksXG4gICAgICAgICAge2xheWVySW5kZXh9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgdmlzaWJsZUNvdW50Kys7XG4gICAgfVxuICB9KTtcblxuICBsb2cubG9nKDEsIGBSRU5ERVIgUEFTUyAke3Bhc3N9OiAke3JlbmRlckNvdW50Kyt9IFxuICAgICR7dmlzaWJsZUNvdW50fSB2aXNpYmxlLCAke2xheWVycy5sZW5ndGh9IHRvdGFsYCk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWNrTGF5ZXJzKGdsLCB7XG4gIGxheWVycyxcbiAgcGlja2luZ0ZCTyxcbiAgdW5pZm9ybXMgPSB7fSxcbiAgeCxcbiAgeSxcbiAgdmlld3BvcnQsXG4gIG1vZGUsXG4gIGxhc3RQaWNrZWRJbmZvXG59KSB7XG4gIC8vIENvbnZlcnQgZnJvbSBjYW52YXMgdG9wLWxlZnQgdG8gV2ViR0wgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXNcbiAgLy8gQW5kIGNvbXBlbnNhdGUgZm9yIHBpeGVsUmF0aW9cbiAgY29uc3QgcGl4ZWxSYXRpbyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID9cbiAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gIGNvbnN0IGRldmljZVggPSB4ICogcGl4ZWxSYXRpbztcbiAgY29uc3QgZGV2aWNlWSA9IGdsLmNhbnZhcy5oZWlnaHQgLSB5ICogcGl4ZWxSYXRpbztcblxuICAvLyBUT0RPIC0ganVzdCByZXR1cm4gZ2xDb250ZXh0V2l0aFN0YXRlIG9uY2UgbHVtYSB1cGRhdGVzXG4gIGNvbnN0IHVuaGFuZGxlZFBpY2tJbmZvcyA9IFtdO1xuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciBzY2lzc29yIHRlc3QgYW5kIGZibyBiaW5kaW5ncyBpbiBjYXNlIG9mIGV4Y2VwdGlvbnNcbiAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBvbmUgcGl4ZWwsIG5vIG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nIGVsc2VcbiAgZ2xDb250ZXh0V2l0aFN0YXRlKGdsLCB7XG4gICAgZnJhbWVCdWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgZnJhbWVidWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgc2Npc3NvclRlc3Q6IHt4OiBkZXZpY2VYLCB5OiBkZXZpY2VZLCB3OiAxLCBoOiAxfVxuICB9LCAoKSA9PiB7XG5cbiAgICAvLyBQaWNraW5nIHByb2Nlc3Mgc3RhcnRcbiAgICAvLyBDbGVhciB0aGUgZnJhbWUgYnVmZmVyXG4gICAgZ2wuY2xlYXIoR0wuQ09MT1JfQlVGRkVSX0JJVCB8IEdMLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgIC8vIFNhdmUgY3VycmVudCBibGVuZCBzZXR0aW5nc1xuICAgIGNvbnN0IG9sZEJsZW5kTW9kZSA9IGdldEJsZW5kTW9kZShnbCk7XG4gICAgLy8gU2V0IGJsZW5kIG1vZGUgZm9yIHBpY2tpbmdcbiAgICAvLyBhbHdheXMgb3ZlcndyaXRlIGV4aXN0aW5nIHBpeGVsIHdpdGggW3IsZyxiLGxheWVySW5kZXhdXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5PTkUsIGdsLlpFUk8sIGdsLkNPTlNUQU5UX0FMUEhBLCBnbC5aRVJPKTtcbiAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcGlja2FibGUgbGF5ZXJzIGluIHBpY2tpbmcgY29sb3JzXG4gICAgbGF5ZXJzLmZvckVhY2goKGxheWVyLCBsYXllckluZGV4KSA9PiB7XG4gICAgICBpZiAobGF5ZXIucHJvcHMudmlzaWJsZSAmJiBsYXllci5wcm9wcy5waWNrYWJsZSkge1xuXG4gICAgICAgIC8vIEVuY29kZSBsYXllckluZGV4IHdpdGggYWxwaGFcbiAgICAgICAgZ2wuYmxlbmRDb2xvcigwLCAwLCAwLCAobGF5ZXJJbmRleCArIDEpIC8gMjU1KTtcblxuICAgICAgICBsYXllci5kcmF3TGF5ZXIoe1xuICAgICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge3JlbmRlclBpY2tpbmdCdWZmZXI6IDEsIHBpY2tpbmdFbmFibGVkOiAxfSxcbiAgICAgICAgICAgIGxheWVyLmNvbnRleHQudW5pZm9ybXMsXG4gICAgICAgICAgICBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydChsYXllci5jb250ZXh0LnZpZXdwb3J0LCBsYXllci5wcm9wcyksXG4gICAgICAgICAgICB7bGF5ZXJJbmRleH1cbiAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVhZCBjb2xvciBpbiB0aGUgY2VudHJhbCBwaXhlbCwgdG8gYmUgbWFwcGVkIHdpdGggcGlja2luZyBjb2xvcnNcbiAgICBjb25zdCBwaWNrZWRDb2xvciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoZGV2aWNlWCwgZGV2aWNlWSwgMSwgMSwgR0wuUkdCQSwgR0wuVU5TSUdORURfQllURSwgcGlja2VkQ29sb3IpO1xuXG4gICAgLy8gcmVzdG9yZSBibGVuZCBtb2RlXG4gICAgc2V0QmxlbmRNb2RlKGdsLCBvbGRCbGVuZE1vZGUpO1xuICAgIC8vIFBpY2tpbmcgcHJvY2VzcyBlbmRcblxuICAgIC8vIFByb2Nlc3MgcGlja2VkIGluZm8gc3RhcnRcbiAgICAvLyBEZWNvZGUgcGlja2VkIGNvbG9yXG4gICAgY29uc3QgcGlja2VkTGF5ZXJJbmRleCA9IHBpY2tlZENvbG9yWzNdIC0gMTtcbiAgICBjb25zdCBwaWNrZWRMYXllciA9IHBpY2tlZExheWVySW5kZXggPj0gMCA/IGxheWVyc1twaWNrZWRMYXllckluZGV4XSA6IG51bGw7XG4gICAgY29uc3QgcGlja2VkT2JqZWN0SW5kZXggPSBwaWNrZWRMYXllciA/IHBpY2tlZExheWVyLmRlY29kZVBpY2tpbmdDb2xvcihwaWNrZWRDb2xvcikgOiAtMTtcbiAgICBjb25zdCBwaWNrZWRMYXllcklkID0gcGlja2VkTGF5ZXIgJiYgcGlja2VkTGF5ZXIucHJvcHMuaWQ7XG4gICAgY29uc3QgYWZmZWN0ZWRMYXllcnMgPSBwaWNrZWRMYXllciA/IFtwaWNrZWRMYXllcl0gOiBbXTtcblxuICAgIGlmIChtb2RlID09PSAnaG92ZXInKSB7XG4gICAgICAvLyBvbmx5IGludm9rZSBvbkhvdmVyIGV2ZW50cyBpZiBwaWNrZWQgb2JqZWN0IGhhcyBjaGFuZ2VkXG4gICAgICBjb25zdCBsYXN0UGlja2VkT2JqZWN0SW5kZXggPSBsYXN0UGlja2VkSW5mby5pbmRleDtcbiAgICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllcklkID0gbGFzdFBpY2tlZEluZm8ubGF5ZXJJZDtcblxuICAgICAgaWYgKHBpY2tlZExheWVySWQgPT09IGxhc3RQaWNrZWRMYXllcklkICYmIHBpY2tlZE9iamVjdEluZGV4ID09PSBsYXN0UGlja2VkT2JqZWN0SW5kZXgpIHtcbiAgICAgICAgLy8gcGlja2VkIG9iamVjdCBkaWQgbm90IGNoYW5nZSwgbm8gbmVlZCB0byBwcm9jZWVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpY2tlZExheWVySWQgIT09IGxhc3RQaWNrZWRMYXllcklkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCBzdG9yZSBhIHJlZiB0byBsYXN0UGlja2VkTGF5ZXIgaW4gdGhlIGNvbnRleHQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgc3RhdGUgb2YgYW4gb3V0ZGF0ZWQgbGF5ZXIgaXMgbm8gbG9uZ2VyIHZhbGlkXG4gICAgICAgIC8vIGFuZCB0aGUgcHJvcHMgbWF5IGhhdmUgY2hhbmdlZFxuICAgICAgICBjb25zdCBsYXN0UGlja2VkTGF5ZXIgPSBsYXllcnMuZmluZChsID0+IGwucHJvcHMuaWQgPT09IGxhc3RQaWNrZWRMYXllcklkKTtcbiAgICAgICAgaWYgKGxhc3RQaWNrZWRMYXllcikge1xuICAgICAgICAgIC8vIExldCBsZWF2ZSBldmVudCBmaXJlIGJlZm9yZSBlbnRlciBldmVudFxuICAgICAgICAgIGFmZmVjdGVkTGF5ZXJzLnVuc2hpZnQobGFzdFBpY2tlZExheWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgbGF5ZXIgbWFuYWdlciBjb250ZXh0XG4gICAgICBsYXN0UGlja2VkSW5mby5sYXllcklkID0gcGlja2VkTGF5ZXJJZDtcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZUluZm8gPSBjcmVhdGVJbmZvKFt4LCB5XSwgdmlld3BvcnQpO1xuICAgIGJhc2VJbmZvLmRldmljZVBpeGVsID0gW2RldmljZVgsIGRldmljZVldO1xuICAgIGJhc2VJbmZvLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG4gICAgYWZmZWN0ZWRMYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBsZXQgaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VJbmZvKTtcbiAgICAgIGluZm8ubGF5ZXIgPSBsYXllcjtcblxuICAgICAgaWYgKGxheWVyID09PSBwaWNrZWRMYXllcikge1xuICAgICAgICBpbmZvLmNvbG9yID0gcGlja2VkQ29sb3I7XG4gICAgICAgIGluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICAgICAgaW5mby5waWNrZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBMZXQgbGF5ZXJzIHBvcHVsYXRlIGl0cyBvd24gaW5mbyBvYmplY3RcbiAgICAgIGluZm8gPSBsYXllci5waWNrTGF5ZXIoe2luZm8sIG1vZGV9KTtcblxuICAgICAgLy8gSWYgbGF5ZXIuZ2V0UGlja2luZ0luZm8oKSByZXR1cm5zIG51bGwsIGRvIG5vdCBwcm9jZWVkXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENhbGxpbmcgY2FsbGJhY2tzIGNhbiBoYXZlIGFzeW5jIGludGVyYWN0aW9ucyB3aXRoIFJlYWN0XG4gICAgICAgIC8vIHdoaWNoIG51bGxpZmllcyBsYXllci5zdGF0ZS5cbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgJ2NsaWNrJzogaGFuZGxlZCA9IGxheWVyLnByb3BzLm9uQ2xpY2soaW5mbyk7IGJyZWFrO1xuICAgICAgICBjYXNlICdob3Zlcic6IGhhbmRsZWQgPSBsYXllci5wcm9wcy5vbkhvdmVyKGluZm8pOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBpY2sgdHlwZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYW5kbGVkKSB7XG4gICAgICAgICAgdW5oYW5kbGVkUGlja0luZm9zLnB1c2goaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHVuaGFuZGxlZFBpY2tJbmZvcztcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJbmZvKHBpeGVsLCB2aWV3cG9ydCkge1xuICAvLyBBc3NpZ24gYSBudW1iZXIgb2YgcG90ZW50aWFsbHkgdXNlZnVsIHByb3BzIHRvIHRoZSBcImluZm9cIiBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICBjb2xvcjogRU1QVFlfUElYRUwsXG4gICAgaW5kZXg6IC0xLFxuICAgIHBpY2tlZDogZmFsc2UsXG4gICAgeDogcGl4ZWxbMF0sXG4gICAgeTogcGl4ZWxbMV0sXG4gICAgcGl4ZWwsXG4gICAgbG5nTGF0OiB2aWV3cG9ydC51bnByb2plY3QocGl4ZWwpXG4gIH07XG59XG4iXX0=