var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

import { Matrix4 } from 'luma.gl';

import assert from 'assert';
import { COORDINATE_SYSTEM } from './constants';

function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - Math.fround(a);
  return [hiPart, loPart];
}

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];

function calculateMatrixAndOffset(_ref) {
  var projectionMode = _ref.projectionMode,
      positionOrigin = _ref.positionOrigin,
      viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix;
  var viewMatrixUncentered = viewport.viewMatrixUncentered,
      viewMatrix = viewport.viewMatrix,
      projectionMatrix = viewport.projectionMatrix;


  var projectionCenter = void 0;
  var modelViewProjectionMatrix = void 0;

  var modelViewMatrixInv = new Matrix4(viewMatrix);
  var viewProjectionMatrix = new Matrix4(projectionMatrix).multiplyRight(viewMatrix);

  switch (projectionMode) {

    case COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      modelViewProjectionMatrix = viewProjectionMatrix;
      if (modelMatrix) {
        // Apply model matrix if supplied
        // modelViewProjectionMatrix = modelViewProjectionMatrix.clone();
        modelViewProjectionMatrix.multiplyRight(modelMatrix);
        modelViewMatrixInv.multiplyRight(modelMatrix);
      }
      modelViewMatrixInv.invert();
      break;

    // TODO: make lighitng work for meter offset mode
    case COORDINATE_SYSTEM.METER_OFFSETS:
      // Calculate transformed projectionCenter (in 64 bit precision)
      // This is the key to offset mode precision (avoids doing this
      // addition in 32 bit precision)
      var positionPixels = viewport.projectFlat(positionOrigin);
      projectionCenter = viewProjectionMatrix.transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);

      modelViewProjectionMatrix = new Matrix4(projectionMatrix)
      // Always apply uncentered projection matrix (shader adds center)
      .multiplyRight(viewMatrixUncentered)
      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      .multiplyRight(VECTOR_TO_POINT_MATRIX);

      if (modelMatrix) {
        // Apply model matrix if supplied
        modelViewProjectionMatrix.multiplyRight(modelMatrix);
      }
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  var cameraPos = [modelViewMatrixInv[12], modelViewMatrixInv[13], modelViewMatrixInv[14]];

  return {
    modelViewProjectionMatrix: modelViewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: cameraPos
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
export function getUniformsFromViewport(viewport) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,
      _ref2$projectionMode = _ref2.projectionMode,
      projectionMode = _ref2$projectionMode === undefined ? COORDINATE_SYSTEM.LNGLAT : _ref2$projectionMode,
      _ref2$positionOrigin = _ref2.positionOrigin,
      positionOrigin = _ref2$positionOrigin === undefined ? [0, 0] : _ref2$positionOrigin;

  assert(viewport.scale, 'Viewport scale missing');

  var _calculateMatrixAndOf = calculateMatrixAndOffset({ projectionMode: projectionMode, positionOrigin: positionOrigin, modelMatrix: modelMatrix, viewport: viewport }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      modelViewProjectionMatrix = _calculateMatrixAndOf.modelViewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  assert(modelViewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var projectionPixelsPerUnit = viewport.getDistanceScales().pixelsPerMeter;
  assert(projectionPixelsPerUnit, 'Viewport missing pixelsPerMeter');

  // calculate WebGL matrices

  // Convert to Float32
  var glProjectionMatrix = new Float32Array(modelViewProjectionMatrix);

  // "Float64Array"
  // Transpose the projection matrix to column major for GLSL.
  var glProjectionMatrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var _fp64ify = fp64ify(modelViewProjectionMatrix[j * 4 + i]);

      var _fp64ify2 = _slicedToArray(_fp64ify, 2);

      glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];
      glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];
    }
  }

  return {
    // Projection mode values
    projectionMode: projectionMode,
    projectionCenter: projectionCenter,

    // modelMatrix: modelMatrix || new Matrix4().identity(),

    // Main projection matrices
    projectionMatrix: glProjectionMatrix,
    projectionMatrixUncentered: glProjectionMatrix,
    projectionFP64: glProjectionMatrixFP64,
    projectionPixelsPerUnit: projectionPixelsPerUnit,

    // This is the mercator scale (2 ** zoom)
    projectionScale: viewport.scale,

    // Deprecated?
    projectionScaleFP64: fp64ify(viewport.scale),

    // This is for lighting calculations
    cameraPos: new Float32Array(cameraPos)

  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdmlld3BvcnQtdW5pZm9ybXMuanMiXSwibmFtZXMiOlsiTWF0cml4NCIsImFzc2VydCIsIkNPT1JESU5BVEVfU1lTVEVNIiwiZnA2NGlmeSIsImEiLCJoaVBhcnQiLCJNYXRoIiwiZnJvdW5kIiwibG9QYXJ0IiwiWkVST19WRUNUT1IiLCJWRUNUT1JfVE9fUE9JTlRfTUFUUklYIiwiY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0IiwicHJvamVjdGlvbk1vZGUiLCJwb3NpdGlvbk9yaWdpbiIsInZpZXdwb3J0IiwibW9kZWxNYXRyaXgiLCJ2aWV3TWF0cml4VW5jZW50ZXJlZCIsInZpZXdNYXRyaXgiLCJwcm9qZWN0aW9uTWF0cml4IiwicHJvamVjdGlvbkNlbnRlciIsIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgiLCJtb2RlbFZpZXdNYXRyaXhJbnYiLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsIm11bHRpcGx5UmlnaHQiLCJMTkdMQVQiLCJpbnZlcnQiLCJNRVRFUl9PRkZTRVRTIiwicG9zaXRpb25QaXhlbHMiLCJwcm9qZWN0RmxhdCIsInRyYW5zZm9ybVZlY3RvciIsIkVycm9yIiwiY2FtZXJhUG9zIiwiZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQiLCJzY2FsZSIsInByb2plY3Rpb25QaXhlbHNQZXJVbml0IiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJwaXhlbHNQZXJNZXRlciIsImdsUHJvamVjdGlvbk1hdHJpeCIsIkZsb2F0MzJBcnJheSIsImdsUHJvamVjdGlvbk1hdHJpeEZQNjQiLCJpIiwiaiIsInByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkIiwicHJvamVjdGlvbkZQNjQiLCJwcm9qZWN0aW9uU2NhbGUiLCJwcm9qZWN0aW9uU2NhbGVGUDY0Il0sIm1hcHBpbmdzIjoiOztBQUFBLFNBQVFBLE9BQVIsUUFBc0IsU0FBdEI7O0FBRUEsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjtBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLGFBQWhD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Q0FBZCxHQUFrQixDQUF6QyxDQUh3QjtBQUszQjtBQUNGOztBQUVELFNBQU87QUFDTDtBQUNBN0Isa0NBRks7QUFHTE8sc0NBSEs7O0FBS0w7O0FBRUE7QUFDQUQsc0JBQWtCbUIsa0JBUmI7QUFTTEssZ0NBQTRCTCxrQkFUdkI7QUFVTE0sb0JBQWdCSixzQkFWWDtBQVdMTCxvREFYSzs7QUFhTDtBQUNBVSxxQkFBaUI5QixTQUFTbUIsS0FkckI7O0FBZ0JMO0FBQ0FZLHlCQUFxQjFDLFFBQVFXLFNBQVNtQixLQUFqQixDQWpCaEI7O0FBbUJMO0FBQ0FGLGVBQVcsSUFBSU8sWUFBSixDQUFpQlAsU0FBakI7O0FBcEJOLEdBQVA7QUF1QkQiLCJmaWxlIjoidmlld3BvcnQtdW5pZm9ybXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01hdHJpeDR9IGZyb20gJ2x1bWEuZ2wnO1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmZ1bmN0aW9uIGZwNjRpZnkoYSkge1xuICBjb25zdCBoaVBhcnQgPSBNYXRoLmZyb3VuZChhKTtcbiAgY29uc3QgbG9QYXJ0ID0gYSAtIE1hdGguZnJvdW5kKGEpO1xuICByZXR1cm4gW2hpUGFydCwgbG9QYXJ0XTtcbn1cblxuLy8gVG8gcXVpY2tseSBzZXQgYSB2ZWN0b3IgdG8gemVyb1xuY29uc3QgWkVST19WRUNUT1IgPSBbMCwgMCwgMCwgMF07XG4vLyA0eDQgbWF0cml4IHRoYXQgZHJvcHMgNHRoIGNvbXBvbmVudCBvZiB2ZWN0b3JcbmNvbnN0IFZFQ1RPUl9UT19QT0lOVF9NQVRSSVggPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMF07XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCh7XG4gIHByb2plY3Rpb25Nb2RlLFxuICBwb3NpdGlvbk9yaWdpbixcbiAgdmlld3BvcnQsXG4gIG1vZGVsTWF0cml4XG59KSB7XG4gIGNvbnN0IHt2aWV3TWF0cml4VW5jZW50ZXJlZCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeH0gPSB2aWV3cG9ydDtcblxuICBsZXQgcHJvamVjdGlvbkNlbnRlcjtcbiAgbGV0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg7XG5cbiAgY29uc3QgbW9kZWxWaWV3TWF0cml4SW52ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeCk7XG4gIGNvbnN0IHZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQocHJvamVjdGlvbk1hdHJpeCkubXVsdGlwbHlSaWdodCh2aWV3TWF0cml4KTtcblxuICBzd2l0Y2ggKHByb2plY3Rpb25Nb2RlKSB7XG5cbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQ6XG4gICAgcHJvamVjdGlvbkNlbnRlciA9IFpFUk9fVkVDVE9SO1xuICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSB2aWV3UHJvamVjdGlvbk1hdHJpeDtcbiAgICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAgIC8vIEFwcGx5IG1vZGVsIG1hdHJpeCBpZiBzdXBwbGllZFxuICAgICAgLy8gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXguY2xvbmUoKTtcbiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgubXVsdGlwbHlSaWdodChtb2RlbE1hdHJpeCk7XG4gICAgICBtb2RlbFZpZXdNYXRyaXhJbnYubXVsdGlwbHlSaWdodChtb2RlbE1hdHJpeCk7XG4gICAgfVxuICAgIG1vZGVsVmlld01hdHJpeEludi5pbnZlcnQoKTtcbiAgICBicmVhaztcblxuICAvLyBUT0RPOiBtYWtlIGxpZ2hpdG5nIHdvcmsgZm9yIG1ldGVyIG9mZnNldCBtb2RlXG4gIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uTUVURVJfT0ZGU0VUUzpcbiAgICAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtZWQgcHJvamVjdGlvbkNlbnRlciAoaW4gNjQgYml0IHByZWNpc2lvbilcbiAgICAvLyBUaGlzIGlzIHRoZSBrZXkgdG8gb2Zmc2V0IG1vZGUgcHJlY2lzaW9uIChhdm9pZHMgZG9pbmcgdGhpc1xuICAgIC8vIGFkZGl0aW9uIGluIDMyIGJpdCBwcmVjaXNpb24pXG4gICAgY29uc3QgcG9zaXRpb25QaXhlbHMgPSB2aWV3cG9ydC5wcm9qZWN0RmxhdChwb3NpdGlvbk9yaWdpbik7XG4gICAgcHJvamVjdGlvbkNlbnRlciA9IHZpZXdQcm9qZWN0aW9uTWF0cml4XG4gICAgICAudHJhbnNmb3JtVmVjdG9yKFtwb3NpdGlvblBpeGVsc1swXSwgcG9zaXRpb25QaXhlbHNbMV0sIDAuMCwgMS4wXSk7XG5cbiAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQocHJvamVjdGlvbk1hdHJpeClcbiAgICAgIC8vIEFsd2F5cyBhcHBseSB1bmNlbnRlcmVkIHByb2plY3Rpb24gbWF0cml4IChzaGFkZXIgYWRkcyBjZW50ZXIpXG4gICAgICAubXVsdGlwbHlSaWdodCh2aWV3TWF0cml4VW5jZW50ZXJlZClcbiAgICAgIC8vIFplcm8gb3V0IDR0aCBjb29yZGluYXRlIChcImFmdGVyXCIgbW9kZWwgbWF0cml4KSAtIGF2b2lkcyBmdXJ0aGVyIHRyYW5zbGF0aW9uc1xuICAgICAgLm11bHRpcGx5UmlnaHQoVkVDVE9SX1RPX1BPSU5UX01BVFJJWCk7XG5cbiAgICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAgIC8vIEFwcGx5IG1vZGVsIG1hdHJpeCBpZiBzdXBwbGllZFxuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeC5tdWx0aXBseVJpZ2h0KG1vZGVsTWF0cml4KTtcbiAgICB9XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvamVjdGlvbiBtb2RlJyk7XG4gIH1cblxuICBjb25zdCBjYW1lcmFQb3MgPSBbbW9kZWxWaWV3TWF0cml4SW52WzEyXSwgbW9kZWxWaWV3TWF0cml4SW52WzEzXSwgbW9kZWxWaWV3TWF0cml4SW52WzE0XV07XG5cbiAgcmV0dXJuIHtcbiAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG4gICAgY2FtZXJhUG9zXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh2aWV3cG9ydCwge1xuICBtb2RlbE1hdHJpeCA9IG51bGwsXG4gIHByb2plY3Rpb25Nb2RlID0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICBwb3NpdGlvbk9yaWdpbiA9IFswLCAwXVxufSA9IHt9KSB7XG4gIGFzc2VydCh2aWV3cG9ydC5zY2FsZSwgJ1ZpZXdwb3J0IHNjYWxlIG1pc3NpbmcnKTtcblxuICBjb25zdCB7cHJvamVjdGlvbkNlbnRlciwgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhUG9zfSA9XG4gICAgY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0KHtwcm9qZWN0aW9uTW9kZSwgcG9zaXRpb25PcmlnaW4sIG1vZGVsTWF0cml4LCB2aWV3cG9ydH0pO1xuXG4gIGFzc2VydChtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LCAnVmlld3BvcnQgbWlzc2luZyBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4Jyk7XG5cbiAgLy8gQ2FsY3VsYXRlIHByb2plY3Rpb24gcGl4ZWxzIHBlciB1bml0XG4gIGNvbnN0IHByb2plY3Rpb25QaXhlbHNQZXJVbml0ID0gdmlld3BvcnQuZ2V0RGlzdGFuY2VTY2FsZXMoKS5waXhlbHNQZXJNZXRlcjtcbiAgYXNzZXJ0KHByb2plY3Rpb25QaXhlbHNQZXJVbml0LCAnVmlld3BvcnQgbWlzc2luZyBwaXhlbHNQZXJNZXRlcicpO1xuXG4gIC8vIGNhbGN1bGF0ZSBXZWJHTCBtYXRyaWNlc1xuXG4gIC8vIENvbnZlcnQgdG8gRmxvYXQzMlxuICBjb25zdCBnbFByb2plY3Rpb25NYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgpO1xuXG4gIC8vIFwiRmxvYXQ2NEFycmF5XCJcbiAgLy8gVHJhbnNwb3NlIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCB0byBjb2x1bW4gbWFqb3IgZm9yIEdMU0wuXG4gIGNvbnN0IGdsUHJvamVjdGlvbk1hdHJpeEZQNjQgPSBuZXcgRmxvYXQzMkFycmF5KDMyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7ICsraikge1xuICAgICAgW1xuICAgICAgICBnbFByb2plY3Rpb25NYXRyaXhGUDY0WyhpICogNCArIGopICogMl0sXG4gICAgICAgIGdsUHJvamVjdGlvbk1hdHJpeEZQNjRbKGkgKiA0ICsgaikgKiAyICsgMV1cbiAgICAgIF0gPSBmcDY0aWZ5KG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhbaiAqIDQgKyBpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBQcm9qZWN0aW9uIG1vZGUgdmFsdWVzXG4gICAgcHJvamVjdGlvbk1vZGUsXG4gICAgcHJvamVjdGlvbkNlbnRlcixcblxuICAgIC8vIG1vZGVsTWF0cml4OiBtb2RlbE1hdHJpeCB8fCBuZXcgTWF0cml4NCgpLmlkZW50aXR5KCksXG5cbiAgICAvLyBNYWluIHByb2plY3Rpb24gbWF0cmljZXNcbiAgICBwcm9qZWN0aW9uTWF0cml4OiBnbFByb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbk1hdHJpeFVuY2VudGVyZWQ6IGdsUHJvamVjdGlvbk1hdHJpeCxcbiAgICBwcm9qZWN0aW9uRlA2NDogZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCxcbiAgICBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdCxcblxuICAgIC8vIFRoaXMgaXMgdGhlIG1lcmNhdG9yIHNjYWxlICgyICoqIHpvb20pXG4gICAgcHJvamVjdGlvblNjYWxlOiB2aWV3cG9ydC5zY2FsZSxcblxuICAgIC8vIERlcHJlY2F0ZWQ/XG4gICAgcHJvamVjdGlvblNjYWxlRlA2NDogZnA2NGlmeSh2aWV3cG9ydC5zY2FsZSksXG5cbiAgICAvLyBUaGlzIGlzIGZvciBsaWdodGluZyBjYWxjdWxhdGlvbnNcbiAgICBjYW1lcmFQb3M6IG5ldyBGbG9hdDMyQXJyYXkoY2FtZXJhUG9zKVxuXG4gIH07XG59XG4iXX0=