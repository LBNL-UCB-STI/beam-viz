var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

import assert from 'assert';

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * @param {Object} opt.oldProps - object with old key/value pairs
 * @param {Object} opt.newProps - object with new key/value pairs
 * @param {Object} opt.ignoreProps={} - object, keys that should not be compared
 * @returns {null|String} - null when values of all keys are strictly equal.
 *   if unequal, returns a string explaining what changed.
 */
/* eslint-disable max-statements, complexity */
export function compareProps() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      oldProps = _ref.oldProps,
      newProps = _ref.newProps,
      _ref$ignoreProps = _ref.ignoreProps,
      ignoreProps = _ref$ignoreProps === undefined ? {} : _ref$ignoreProps;

  assert(oldProps !== undefined && newProps !== undefined, 'compareProps args');

  if (oldProps === newProps) {
    return null;
  }

  if ((typeof oldProps === 'undefined' ? 'undefined' : _typeof(oldProps)) !== 'object' || oldProps === null) {
    return 'old props is not an object';
  }
  if ((typeof newProps === 'undefined' ? 'undefined' : _typeof(newProps)) !== 'object' || newProps === null) {
    return 'new props is not an object';
  }

  // Test if new props different from old props
  for (var key in oldProps) {
    if (!(key in ignoreProps)) {
      if (!newProps.hasOwnProperty(key)) {
        return 'prop ' + key + ' dropped: ' + oldProps[key] + ' -> (undefined)';
      } else if (oldProps[key] !== newProps[key]) {
        return 'prop ' + key + ' changed: ' + oldProps[key] + ' -> ' + newProps[key];
      }
    }
  }

  // Test if any new props have been added
  for (var _key in newProps) {
    if (!(_key in ignoreProps)) {
      if (!oldProps.hasOwnProperty(_key)) {
        return 'prop ' + _key + ' added: (undefined) -> ' + newProps[_key];
      }
    }
  }

  return null;
}
/* eslint-enable max-statements, complexity */

// Shallow compare
/* eslint-disable complexity */
export function areEqualShallow(a, b) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$ignore = _ref2.ignore,
      ignore = _ref2$ignore === undefined ? {} : _ref2$ignore;

  if (a === b) {
    return true;
  }

  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== 'object' || a === null || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) !== 'object' || b === null) {
    return false;
  }

  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }

  for (var key in a) {
    if (!(key in ignore) && (!(key in b) || a[key] !== b[key])) {
      return false;
    }
  }
  for (var _key2 in b) {
    if (!(_key2 in ignore) && !(_key2 in a)) {
      return false;
    }
  }
  return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvY29tcGFyZS1vYmplY3RzLmpzIl0sIm5hbWVzIjpbImFzc2VydCIsImNvbXBhcmVQcm9wcyIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJpZ25vcmVQcm9wcyIsInVuZGVmaW5lZCIsImtleSIsImhhc093blByb3BlcnR5IiwiYXJlRXF1YWxTaGFsbG93IiwiYSIsImIiLCJpZ25vcmUiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOztBQUFBLE9BQU9BLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0EsT0FBTyxTQUFTQyxZQUFULEdBQW1FO0FBQUEsaUZBQUosRUFBSTtBQUFBLE1BQTVDQyxRQUE0QyxRQUE1Q0EsUUFBNEM7QUFBQSxNQUFsQ0MsUUFBa0MsUUFBbENBLFFBQWtDO0FBQUEsOEJBQXhCQyxXQUF3QjtBQUFBLE1BQXhCQSxXQUF3QixvQ0FBVixFQUFVOztBQUN4RUosU0FBT0UsYUFBYUcsU0FBYixJQUEwQkYsYUFBYUUsU0FBOUMsRUFBeUQsbUJBQXpEOztBQUVBLE1BQUlILGFBQWFDLFFBQWpCLEVBQTJCO0FBQ3pCLFdBQU8sSUFBUDtBQUNEOztBQUVELE1BQUksUUFBT0QsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUFwQixJQUFnQ0EsYUFBYSxJQUFqRCxFQUF1RDtBQUNyRCxXQUFPLDRCQUFQO0FBQ0Q7QUFDRCxNQUFJLFFBQU9DLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBcEIsSUFBZ0NBLGFBQWEsSUFBakQsRUFBdUQ7QUFDckQsV0FBTyw0QkFBUDtBQUNEOztBQUVEO0FBQ0EsT0FBSyxJQUFNRyxHQUFYLElBQWtCSixRQUFsQixFQUE0QjtBQUMxQixRQUFJLEVBQUVJLE9BQU9GLFdBQVQsQ0FBSixFQUEyQjtBQUN6QixVQUFJLENBQUNELFNBQVNJLGNBQVQsQ0FBd0JELEdBQXhCLENBQUwsRUFBbUM7QUFDakMseUJBQWVBLEdBQWYsa0JBQStCSixTQUFTSSxHQUFULENBQS9CO0FBQ0QsT0FGRCxNQUVPLElBQUlKLFNBQVNJLEdBQVQsTUFBa0JILFNBQVNHLEdBQVQsQ0FBdEIsRUFBcUM7QUFDMUMseUJBQWVBLEdBQWYsa0JBQStCSixTQUFTSSxHQUFULENBQS9CLFlBQW1ESCxTQUFTRyxHQUFULENBQW5EO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0EsT0FBSyxJQUFNQSxJQUFYLElBQWtCSCxRQUFsQixFQUE0QjtBQUMxQixRQUFJLEVBQUVHLFFBQU9GLFdBQVQsQ0FBSixFQUEyQjtBQUN6QixVQUFJLENBQUNGLFNBQVNLLGNBQVQsQ0FBd0JELElBQXhCLENBQUwsRUFBbUM7QUFDakMseUJBQWVBLElBQWYsK0JBQTRDSCxTQUFTRyxJQUFULENBQTVDO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNEO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLE9BQU8sU0FBU0UsZUFBVCxDQUF5QkMsQ0FBekIsRUFBNEJDLENBQTVCLEVBQW1EO0FBQUEsa0ZBQUosRUFBSTtBQUFBLDJCQUFuQkMsTUFBbUI7QUFBQSxNQUFuQkEsTUFBbUIsZ0NBQVYsRUFBVTs7QUFFeEQsTUFBSUYsTUFBTUMsQ0FBVixFQUFhO0FBQ1gsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSSxRQUFPRCxDQUFQLHlDQUFPQSxDQUFQLE9BQWEsUUFBYixJQUF5QkEsTUFBTSxJQUEvQixJQUNGLFFBQU9DLENBQVAseUNBQU9BLENBQVAsT0FBYSxRQURYLElBQ3VCQSxNQUFNLElBRGpDLEVBQ3VDO0FBQ3JDLFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUlFLE9BQU9DLElBQVAsQ0FBWUosQ0FBWixFQUFlSyxNQUFmLEtBQTBCRixPQUFPQyxJQUFQLENBQVlILENBQVosRUFBZUksTUFBN0MsRUFBcUQ7QUFDbkQsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsT0FBSyxJQUFNUixHQUFYLElBQWtCRyxDQUFsQixFQUFxQjtBQUNuQixRQUFJLEVBQUVILE9BQU9LLE1BQVQsTUFBcUIsRUFBRUwsT0FBT0ksQ0FBVCxLQUFlRCxFQUFFSCxHQUFGLE1BQVdJLEVBQUVKLEdBQUYsQ0FBL0MsQ0FBSixFQUE0RDtBQUMxRCxhQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsT0FBSyxJQUFNQSxLQUFYLElBQWtCSSxDQUFsQixFQUFxQjtBQUNuQixRQUFJLEVBQUVKLFNBQU9LLE1BQVQsS0FBcUIsRUFBRUwsU0FBT0csQ0FBVCxDQUF6QixFQUF1QztBQUNyQyxhQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsU0FBTyxJQUFQO0FBQ0QiLCJmaWxlIjoiY29tcGFyZS1vYmplY3RzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdC5vbGRQcm9wcyAtIG9iamVjdCB3aXRoIG9sZCBrZXkvdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQubmV3UHJvcHMgLSBvYmplY3Qgd2l0aCBuZXcga2V5L3ZhbHVlIHBhaXJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0Lmlnbm9yZVByb3BzPXt9IC0gb2JqZWN0LCBrZXlzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb21wYXJlZFxuICogQHJldHVybnMge251bGx8U3RyaW5nfSAtIG51bGwgd2hlbiB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICogICBpZiB1bmVxdWFsLCByZXR1cm5zIGEgc3RyaW5nIGV4cGxhaW5pbmcgd2hhdCBjaGFuZ2VkLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVQcm9wcyh7b2xkUHJvcHMsIG5ld1Byb3BzLCBpZ25vcmVQcm9wcyA9IHt9fSA9IHt9KSB7XG4gIGFzc2VydChvbGRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIG5ld1Byb3BzICE9PSB1bmRlZmluZWQsICdjb21wYXJlUHJvcHMgYXJncycpO1xuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2xkUHJvcHMgIT09ICdvYmplY3QnIHx8IG9sZFByb3BzID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdvbGQgcHJvcHMgaXMgbm90IGFuIG9iamVjdCc7XG4gIH1cbiAgaWYgKHR5cGVvZiBuZXdQcm9wcyAhPT0gJ29iamVjdCcgfHwgbmV3UHJvcHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ25ldyBwcm9wcyBpcyBub3QgYW4gb2JqZWN0JztcbiAgfVxuXG4gIC8vIFRlc3QgaWYgbmV3IHByb3BzIGRpZmZlcmVudCBmcm9tIG9sZCBwcm9wc1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBpZ25vcmVQcm9wcykpIHtcbiAgICAgIGlmICghbmV3UHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gYHByb3AgJHtrZXl9IGRyb3BwZWQ6ICR7b2xkUHJvcHNba2V5XX0gLT4gKHVuZGVmaW5lZClgO1xuICAgICAgfSBlbHNlIGlmIChvbGRQcm9wc1trZXldICE9PSBuZXdQcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBgcHJvcCAke2tleX0gY2hhbmdlZDogJHtvbGRQcm9wc1trZXldfSAtPiAke25ld1Byb3BzW2tleV19YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUZXN0IGlmIGFueSBuZXcgcHJvcHMgaGF2ZSBiZWVuIGFkZGVkXG4gIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgaWYgKCEoa2V5IGluIGlnbm9yZVByb3BzKSkge1xuICAgICAgaWYgKCFvbGRQcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBgcHJvcCAke2tleX0gYWRkZWQ6ICh1bmRlZmluZWQpIC0+ICR7bmV3UHJvcHNba2V5XX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuXG4vLyBTaGFsbG93IGNvbXBhcmVcbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhcmVFcXVhbFNoYWxsb3coYSwgYiwge2lnbm9yZSA9IHt9fSA9IHt9KSB7XG5cbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcgfHwgYSA9PT0gbnVsbCB8fFxuICAgIHR5cGVvZiBiICE9PSAnb2JqZWN0JyB8fCBiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgIGlmICghKGtleSBpbiBpZ25vcmUpICYmICghKGtleSBpbiBiKSB8fCBhW2tleV0gIT09IGJba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gYikge1xuICAgIGlmICghKGtleSBpbiBpZ25vcmUpICYmICghKGtleSBpbiBhKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iXX0=