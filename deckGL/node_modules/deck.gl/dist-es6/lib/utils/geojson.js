function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import * as Container from './container';

/**
 * "Normalizes" complete or partial GeoJSON data into iterable list of features
 * Can accept GeoJSON geometry or "Feature", "FeatureCollection" in addition
 * to plain arrays and iterables.
 * Works by extracting the feature array or wrapping single objects in an array,
 * so that subsequent code can simply iterate over features.
 *
 * @param {object} geojson - geojson data
 * @param {Object|Array} data - geojson object (FeatureCollection, Feature or
 *  Geometry) or array of features
 * @return {Array|"iteratable"} - iterable list of features
 */
export function getGeojsonFeatures(geojson) {
  // If array, assume this is a list of features
  if (Array.isArray(geojson)) {
    return geojson;
  }

  var type = Container.get(geojson, 'type');
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'Polygon':
    case 'MultiPolygon':
    case 'GeometryCollection':
      // Wrap the geometry object in a 'Feature' object and wrap in an array
      return [{ type: 'Feature', properties: {}, geometry: geojson }];
    case 'Feature':
      // Wrap the feature in a 'Features' array
      return [geojson];
    case 'FeatureCollection':
      // Just return the 'Features' array from the collection
      return Container.get(geojson, 'features');
    default:
      throw new Error('Unknown geojson type');
  }
}

/*
 * converts a GeoJSON "Feature" object to a list of GeoJSON polygon-style coordinates
 * @param {Object | Array} data - geojson object or array of feature
 * @returns {[Number,Number,Number][][][]} array of choropleths
 */
export function featureToPolygons(feature) {
  var geometry = Container.get(feature, 'geometry');
  // If no geometry field, assume that "feature" is the polygon list
  if (geometry === undefined) {
    return feature;
  }

  var type = Container.get(geometry, 'type');
  var coordinates = Container.get(geometry, 'coordinates');

  var polygons = void 0;
  switch (type) {
    case 'MultiPolygon':
      polygons = coordinates;
      break;
    case 'Polygon':
      polygons = [coordinates];
      break;
    case 'LineString':
      // TODO - should lines really be handled in this switch?
      polygons = [[coordinates]];
      break;
    case 'MultiLineString':
      // TODO - should lines really be handled in this switch?
      polygons = Container.map(coordinates, function (coords) {
        return [coords];
      });
      break;
    default:
      polygons = [];
  }
  return polygons;
}

// DEPRECATED - USED BY OLD CHOROPLETH LAYERS

/*
 * converts list of features from a GeoJSON object to a list of GeoJSON
 * polygon-style coordinates
 * @param {Object} data - geojson object
 * @returns {[Number,Number,Number][][][]} array of choropleths
 */
export function extractPolygons(data) {
  var normalizedGeojson = normalizeGeojson(data);
  var features = Container.get(normalizedGeojson, 'features');

  var result = [];
  features.forEach(function (feature, featureIndex) {
    var choropleths = featureToPolygons(feature);

    /* eslint-disable max-nested-callbacks */
    choropleths = Container.map(choropleths, function (choropleth) {
      return Container.map(choropleth, function (polygon) {
        return Container.map(polygon, function (coord) {
          return [Container.get(coord, 0), Container.get(coord, 1), Container.get(coord, 2) || 0];
        });
      });
    });
    /* eslint-enable max-nested-callbacks */

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = choropleths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var choropleth = _step.value;

        choropleth.featureIndex = featureIndex;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    result.push.apply(result, _toConsumableArray(choropleths));
  });
  return result;
}

/**
 * "Normalizes" a GeoJSON geometry or "Feature" into a "FeatureCollection",
 * by wrapping it in an extra object/array.
 *
 * @param {object} geojson - geojson data
 * @return {object} - normalized geojson data
 */
export function normalizeGeojson(geojson) {
  var type = Container.get(geojson, 'type');
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'Polygon':
    case 'MultiPolygon':
    case 'GeometryCollection':
      // Wrap the geometry object in a "Feature" and add the feature to a "FeatureCollection"
      return {
        type: 'FeatureCollection',
        features: [{ type: 'Feature', properties: {}, geometry: geojson }]
      };
    case 'Feature':
      // Add the feature to a "FeatureCollection"
      return {
        type: 'FeatureCollection',
        features: [geojson]
      };
    case 'FeatureCollection':
      // Just return the feature collection
      return geojson;
    default:
      throw new Error('Unknown geojson type');
  }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbHMvZ2VvanNvbi5qcyJdLCJuYW1lcyI6WyJDb250YWluZXIiLCJnZXRHZW9qc29uRmVhdHVyZXMiLCJnZW9qc29uIiwiQXJyYXkiLCJpc0FycmF5IiwidHlwZSIsImdldCIsInByb3BlcnRpZXMiLCJnZW9tZXRyeSIsIkVycm9yIiwiZmVhdHVyZVRvUG9seWdvbnMiLCJmZWF0dXJlIiwidW5kZWZpbmVkIiwiY29vcmRpbmF0ZXMiLCJwb2x5Z29ucyIsIm1hcCIsImNvb3JkcyIsImV4dHJhY3RQb2x5Z29ucyIsImRhdGEiLCJub3JtYWxpemVkR2VvanNvbiIsIm5vcm1hbGl6ZUdlb2pzb24iLCJmZWF0dXJlcyIsInJlc3VsdCIsImZvckVhY2giLCJmZWF0dXJlSW5kZXgiLCJjaG9yb3BsZXRocyIsImNob3JvcGxldGgiLCJwb2x5Z29uIiwiY29vcmQiLCJwdXNoIl0sIm1hcHBpbmdzIjoiOztBQUFBLE9BQU8sS0FBS0EsU0FBWixNQUEyQixhQUEzQjs7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUEsT0FBTyxTQUFTQyxrQkFBVCxDQUE0QkMsT0FBNUIsRUFBcUM7QUFDMUM7QUFDQSxNQUFJQyxNQUFNQyxPQUFOLENBQWNGLE9BQWQsQ0FBSixFQUE0QjtBQUMxQixXQUFPQSxPQUFQO0FBQ0Q7O0FBRUQsTUFBTUcsT0FBT0wsVUFBVU0sR0FBVixDQUFjSixPQUFkLEVBQXVCLE1BQXZCLENBQWI7QUFDQSxVQUFRRyxJQUFSO0FBQ0EsU0FBSyxPQUFMO0FBQ0EsU0FBSyxZQUFMO0FBQ0EsU0FBSyxZQUFMO0FBQ0EsU0FBSyxpQkFBTDtBQUNBLFNBQUssU0FBTDtBQUNBLFNBQUssY0FBTDtBQUNBLFNBQUssb0JBQUw7QUFDRTtBQUNBLGFBQU8sQ0FDTCxFQUFDQSxNQUFNLFNBQVAsRUFBa0JFLFlBQVksRUFBOUIsRUFBa0NDLFVBQVVOLE9BQTVDLEVBREssQ0FBUDtBQUdGLFNBQUssU0FBTDtBQUNFO0FBQ0EsYUFBTyxDQUFDQSxPQUFE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U0FBTDtBQUNBLFNBQUssY0FBTDtBQUNBLFNBQUssb0JBQUw7QUFDRTtBQUNBLGFBQU87QUFDTEEsY0FBTSxtQkFERDtBQUVMZ0Isa0JBQVUsQ0FDUixFQUFDaEIsTUFBTSxTQUFQLEVBQWtCRSxZQUFZLEVBQTlCLEVBQWtDQyxVQUFVTixPQUE1QyxFQURRO0FBRkwsT0FBUDtBQU1GLFNBQUssU0FBTDtBQUNFO0FBQ0EsYUFBTztBQUNMRyxjQUFNLG1CQUREO0FBRUxnQixrQkFBVSxDQUFDbkIsT0FBRDtBQUZMLE9BQVA7QUFJRixTQUFLLG1CQUFMO0FBQ0U7QUFDQSxhQUFPQSxPQUFQO0FBQ0Y7QUFDRSxZQUFNLElBQUlPLEtBQUosQ0FBVSxzQkFBVixDQUFOO0FBekJGO0FBMkJEIiwiZmlsZSI6Imdlb2pzb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBDb250YWluZXIgZnJvbSAnLi9jb250YWluZXInO1xuXG4vKipcbiAqIFwiTm9ybWFsaXplc1wiIGNvbXBsZXRlIG9yIHBhcnRpYWwgR2VvSlNPTiBkYXRhIGludG8gaXRlcmFibGUgbGlzdCBvZiBmZWF0dXJlc1xuICogQ2FuIGFjY2VwdCBHZW9KU09OIGdlb21ldHJ5IG9yIFwiRmVhdHVyZVwiLCBcIkZlYXR1cmVDb2xsZWN0aW9uXCIgaW4gYWRkaXRpb25cbiAqIHRvIHBsYWluIGFycmF5cyBhbmQgaXRlcmFibGVzLlxuICogV29ya3MgYnkgZXh0cmFjdGluZyB0aGUgZmVhdHVyZSBhcnJheSBvciB3cmFwcGluZyBzaW5nbGUgb2JqZWN0cyBpbiBhbiBhcnJheSxcbiAqIHNvIHRoYXQgc3Vic2VxdWVudCBjb2RlIGNhbiBzaW1wbHkgaXRlcmF0ZSBvdmVyIGZlYXR1cmVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBnZW9qc29uIC0gZ2VvanNvbiBkYXRhXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZGF0YSAtIGdlb2pzb24gb2JqZWN0IChGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZSBvclxuICogIEdlb21ldHJ5KSBvciBhcnJheSBvZiBmZWF0dXJlc1xuICogQHJldHVybiB7QXJyYXl8XCJpdGVyYXRhYmxlXCJ9IC0gaXRlcmFibGUgbGlzdCBvZiBmZWF0dXJlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2VvanNvbkZlYXR1cmVzKGdlb2pzb24pIHtcbiAgLy8gSWYgYXJyYXksIGFzc3VtZSB0aGlzIGlzIGEgbGlzdCBvZiBmZWF0dXJlc1xuICBpZiAoQXJyYXkuaXNBcnJheShnZW9qc29uKSkge1xuICAgIHJldHVybiBnZW9qc29uO1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IENvbnRhaW5lci5nZXQoZ2VvanNvbiwgJ3R5cGUnKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgJ1BvaW50JzpcbiAgY2FzZSAnTXVsdGlQb2ludCc6XG4gIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICBjYXNlICdQb2x5Z29uJzpcbiAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAvLyBXcmFwIHRoZSBnZW9tZXRyeSBvYmplY3QgaW4gYSAnRmVhdHVyZScgb2JqZWN0IGFuZCB3cmFwIGluIGFuIGFycmF5XG4gICAgcmV0dXJuIFtcbiAgICAgIHt0eXBlOiAnRmVhdHVyZScsIHByb3BlcnRpZXM6IHt9LCBnZW9tZXRyeTogZ2VvanNvbn1cbiAgICBdO1xuICBjYXNlICdGZWF0dXJlJzpcbiAgICAvLyBXcmFwIHRoZSBmZWF0dXJlIGluIGEgJ0ZlYXR1cmVzJyBhcnJheVxuICAgIHJldHVybiBbZ2VvanNvbl07XG4gIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAvLyBKdXN0IHJldHVybiB0aGUgJ0ZlYXR1cmVzJyBhcnJheSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAgcmV0dXJuIENvbnRhaW5lci5nZXQoZ2VvanNvbiwgJ2ZlYXR1cmVzJyk7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGdlb2pzb24gdHlwZScpO1xuICB9XG59XG5cbi8qXG4gKiBjb252ZXJ0cyBhIEdlb0pTT04gXCJGZWF0dXJlXCIgb2JqZWN0IHRvIGEgbGlzdCBvZiBHZW9KU09OIHBvbHlnb24tc3R5bGUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IGRhdGEgLSBnZW9qc29uIG9iamVjdCBvciBhcnJheSBvZiBmZWF0dXJlXG4gKiBAcmV0dXJucyB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW11bXX0gYXJyYXkgb2YgY2hvcm9wbGV0aHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZlYXR1cmVUb1BvbHlnb25zKGZlYXR1cmUpIHtcbiAgY29uc3QgZ2VvbWV0cnkgPSBDb250YWluZXIuZ2V0KGZlYXR1cmUsICdnZW9tZXRyeScpO1xuICAvLyBJZiBubyBnZW9tZXRyeSBmaWVsZCwgYXNzdW1lIHRoYXQgXCJmZWF0dXJlXCIgaXMgdGhlIHBvbHlnb24gbGlzdFxuICBpZiAoZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmZWF0dXJlO1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IENvbnRhaW5lci5nZXQoZ2VvbWV0cnksICd0eXBlJyk7XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0gQ29udGFpbmVyLmdldChnZW9tZXRyeSwgJ2Nvb3JkaW5hdGVzJyk7XG5cbiAgbGV0IHBvbHlnb25zO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICBwb2x5Z29ucyA9IGNvb3JkaW5hdGVzO1xuICAgIGJyZWFrO1xuICBjYXNlICdQb2x5Z29uJzpcbiAgICBwb2x5Z29ucyA9IFtjb29yZGluYXRlc107XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIC8vIFRPRE8gLSBzaG91bGQgbGluZXMgcmVhbGx5IGJlIGhhbmRsZWQgaW4gdGhpcyBzd2l0Y2g/XG4gICAgcG9seWdvbnMgPSBbW2Nvb3JkaW5hdGVzXV07XG4gICAgYnJlYWs7XG4gIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgLy8gVE9ETyAtIHNob3VsZCBsaW5lcyByZWFsbHkgYmUgaGFuZGxlZCBpbiB0aGlzIHN3aXRjaD9cbiAgICBwb2x5Z29ucyA9IENvbnRhaW5lci5tYXAoY29vcmRpbmF0ZXMsIGNvb3JkcyA9PiBbY29vcmRzXSk7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgcG9seWdvbnMgPSBbXTtcbiAgfVxuICByZXR1cm4gcG9seWdvbnM7XG59XG5cbi8vIERFUFJFQ0FURUQgLSBVU0VEIEJZIE9MRCBDSE9ST1BMRVRIIExBWUVSU1xuXG4vKlxuICogY29udmVydHMgbGlzdCBvZiBmZWF0dXJlcyBmcm9tIGEgR2VvSlNPTiBvYmplY3QgdG8gYSBsaXN0IG9mIEdlb0pTT05cbiAqIHBvbHlnb24tc3R5bGUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZ2VvanNvbiBvYmplY3RcbiAqIEByZXR1cm5zIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXVtdfSBhcnJheSBvZiBjaG9yb3BsZXRoc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBvbHlnb25zKGRhdGEpIHtcbiAgY29uc3Qgbm9ybWFsaXplZEdlb2pzb24gPSBub3JtYWxpemVHZW9qc29uKGRhdGEpO1xuICBjb25zdCBmZWF0dXJlcyA9IENvbnRhaW5lci5nZXQobm9ybWFsaXplZEdlb2pzb24sICdmZWF0dXJlcycpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlLCBmZWF0dXJlSW5kZXgpID0+IHtcbiAgICBsZXQgY2hvcm9wbGV0aHMgPSBmZWF0dXJlVG9Qb2x5Z29ucyhmZWF0dXJlKTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1uZXN0ZWQtY2FsbGJhY2tzICovXG4gICAgY2hvcm9wbGV0aHMgPSBDb250YWluZXIubWFwKGNob3JvcGxldGhzLFxuICAgICAgY2hvcm9wbGV0aCA9PiBDb250YWluZXIubWFwKGNob3JvcGxldGgsXG4gICAgICAgIHBvbHlnb24gPT4gQ29udGFpbmVyLm1hcChwb2x5Z29uLFxuICAgICAgICAgIGNvb3JkID0+IFtcbiAgICAgICAgICAgIENvbnRhaW5lci5nZXQoY29vcmQsIDApLFxuICAgICAgICAgICAgQ29udGFpbmVyLmdldChjb29yZCwgMSksXG4gICAgICAgICAgICBDb250YWluZXIuZ2V0KGNvb3JkLCAyKSB8fCAwXG4gICAgICAgICAgXVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1uZXN0ZWQtY2FsbGJhY2tzICovXG5cbiAgICBmb3IgKGNvbnN0IGNob3JvcGxldGggb2YgY2hvcm9wbGV0aHMpIHtcbiAgICAgIGNob3JvcGxldGguZmVhdHVyZUluZGV4ID0gZmVhdHVyZUluZGV4O1xuICAgIH1cbiAgICByZXN1bHQucHVzaCguLi5jaG9yb3BsZXRocyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFwiTm9ybWFsaXplc1wiIGEgR2VvSlNPTiBnZW9tZXRyeSBvciBcIkZlYXR1cmVcIiBpbnRvIGEgXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogYnkgd3JhcHBpbmcgaXQgaW4gYW4gZXh0cmEgb2JqZWN0L2FycmF5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBnZW9qc29uIC0gZ2VvanNvbiBkYXRhXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gbm9ybWFsaXplZCBnZW9qc29uIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUdlb2pzb24oZ2VvanNvbikge1xuICBjb25zdCB0eXBlID0gQ29udGFpbmVyLmdldChnZW9qc29uLCAndHlwZScpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnUG9pbnQnOlxuICBjYXNlICdNdWx0aVBvaW50JzpcbiAgY2FzZSAnTGluZVN0cmluZyc6XG4gIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gIGNhc2UgJ1BvbHlnb24nOlxuICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxuICAgIC8vIFdyYXAgdGhlIGdlb21ldHJ5IG9iamVjdCBpbiBhIFwiRmVhdHVyZVwiIGFuZCBhZGQgdGhlIGZlYXR1cmUgdG8gYSBcIkZlYXR1cmVDb2xsZWN0aW9uXCJcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgIHt0eXBlOiAnRmVhdHVyZScsIHByb3BlcnRpZXM6IHt9LCBnZW9tZXRyeTogZ2VvanNvbn1cbiAgICAgIF1cbiAgICB9O1xuICBjYXNlICdGZWF0dXJlJzpcbiAgICAvLyBBZGQgdGhlIGZlYXR1cmUgdG8gYSBcIkZlYXR1cmVDb2xsZWN0aW9uXCJcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgIGZlYXR1cmVzOiBbZ2VvanNvbl1cbiAgICB9O1xuICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgLy8gSnVzdCByZXR1cm4gdGhlIGZlYXR1cmUgY29sbGVjdGlvblxuICAgIHJldHVybiBnZW9qc29uO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBnZW9qc29uIHR5cGUnKTtcbiAgfVxufVxuIl19