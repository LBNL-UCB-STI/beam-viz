'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* global window */


exports.drawLayers = drawLayers;
exports.pickLayers = pickLayers;

var _luma = require('luma.gl');

var _viewportUniforms = require('./viewport-uniforms');

var _utils = require('./utils');

var EMPTY_PIXEL = new Uint8Array(4);
var renderCount = 0;

function drawLayers(_ref) {
  var layers = _ref.layers,
      pass = _ref.pass;

  _utils.log.log(2, 'DRAWING ' + layers.length + ' layers');

  // render layers in normal colors
  var visibleCount = 0;
  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (layer.props.visible) {
      layer.drawLayer({
        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, (0, _viewportUniforms.getUniformsFromViewport)(layer.context.viewport, layer.props), { layerIndex: layerIndex })
      });
      visibleCount++;
    }
  });

  _utils.log.log(1, 'RENDER PASS ' + pass + ': ' + renderCount++ + ' \n    ' + visibleCount + ' visible, ' + layers.length + ' total');
}

/* eslint-disable max-depth, max-statements */
function pickLayers(gl, _ref2) {
  var layers = _ref2.layers,
      pickingFBO = _ref2.pickingFBO,
      _ref2$uniforms = _ref2.uniforms,
      uniforms = _ref2$uniforms === undefined ? {} : _ref2$uniforms,
      x = _ref2.x,
      y = _ref2.y,
      viewport = _ref2.viewport,
      mode = _ref2.mode,
      lastPickedInfo = _ref2.lastPickedInfo;

  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = x * pixelRatio;
  var deviceY = gl.canvas.height - y * pixelRatio;

  // TODO - just return glContextWithState once luma updates
  var unhandledPickInfos = [];

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  (0, _luma.glContextWithState)(gl, {
    frameBuffer: pickingFBO,
    framebuffer: pickingFBO,
    scissorTest: { x: deviceX, y: deviceY, w: 1, h: 1 }
  }, function () {

    // Picking process start
    // Clear the frame buffer
    gl.clear(_luma.GL.COLOR_BUFFER_BIT | _luma.GL.DEPTH_BUFFER_BIT);
    // Save current blend settings
    var oldBlendMode = (0, _utils.getBlendMode)(gl);
    // Set blend mode for picking
    // always overwrite existing pixel with [r,g,b,layerIndex]
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO);
    gl.blendEquation(gl.FUNC_ADD);

    // Render all pickable layers in picking colors
    layers.forEach(function (layer, layerIndex) {
      if (layer.props.visible && layer.props.pickable) {

        // Encode layerIndex with alpha
        gl.blendColor(0, 0, 0, (layerIndex + 1) / 255);

        layer.drawLayer({
          uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, (0, _viewportUniforms.getUniformsFromViewport)(layer.context.viewport, layer.props), { layerIndex: layerIndex })
        });
      }
    });

    // Read color in the central pixel, to be mapped with picking colors
    var pickedColor = new Uint8Array(4);
    gl.readPixels(deviceX, deviceY, 1, 1, _luma.GL.RGBA, _luma.GL.UNSIGNED_BYTE, pickedColor);

    // restore blend mode
    (0, _utils.setBlendMode)(gl, oldBlendMode);
    // Picking process end

    // Process picked info start
    // Decode picked color
    var pickedLayerIndex = pickedColor[3] - 1;
    var pickedLayer = pickedLayerIndex >= 0 ? layers[pickedLayerIndex] : null;
    var pickedObjectIndex = pickedLayer ? pickedLayer.decodePickingColor(pickedColor) : -1;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;
    var affectedLayers = pickedLayer ? [pickedLayer] : [];

    if (mode === 'hover') {
      var _ret = function () {
        // only invoke onHover events if picked object has changed
        var lastPickedObjectIndex = lastPickedInfo.index;
        var lastPickedLayerId = lastPickedInfo.layerId;

        if (pickedLayerId === lastPickedLayerId && pickedObjectIndex === lastPickedObjectIndex) {
          // picked object did not change, no need to proceed
          return {
            v: void 0
          };
        }

        if (pickedLayerId !== lastPickedLayerId) {
          // We cannot store a ref to lastPickedLayer in the context because
          // the state of an outdated layer is no longer valid
          // and the props may have changed
          var lastPickedLayer = layers.find(function (l) {
            return l.props.id === lastPickedLayerId;
          });
          if (lastPickedLayer) {
            // Let leave event fire before enter event
            affectedLayers.unshift(lastPickedLayer);
          }
        }

        // Update layer manager context
        lastPickedInfo.layerId = pickedLayerId;
        lastPickedInfo.index = pickedObjectIndex;
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }

    var baseInfo = createInfo([x, y], viewport);
    baseInfo.devicePixel = [deviceX, deviceY];
    baseInfo.pixelRatio = pixelRatio;

    affectedLayers.forEach(function (layer) {
      var info = Object.assign({}, baseInfo);
      info.layer = layer;

      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }

      // Let layers populate its own info object
      info = layer.pickLayer({ info: info, mode: mode });

      // If layer.getPickingInfo() returns null, do not proceed
      if (info) {
        var handled = false;

        // Calling callbacks can have async interactions with React
        // which nullifies layer.state.
        switch (mode) {
          case 'click':
            handled = layer.props.onClick(info);break;
          case 'hover':
            handled = layer.props.onHover(info);break;
          default:
            throw new Error('unknown pick type');
        }

        if (!handled) {
          unhandledPickInfos.push(info);
        }
      }
    });
  });

  return unhandledPickInfos;
}
/* eslint-enable max-depth, max-statements */

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1hbmQtcGljay5qcyJdLCJuYW1lcyI6WyJkcmF3TGF5ZXJzIiwicGlja0xheWVycyIsIkVNUFRZX1BJWEVMIiwiVWludDhBcnJheSIsInJlbmRlckNvdW50IiwibGF5ZXJzIiwicGFzcyIsImxvZyIsImxlbmd0aCIsInZpc2libGVDb3VudCIsImZvckVhY2giLCJsYXllciIsImxheWVySW5kZXgiLCJwcm9wcyIsInZpc2libGUiLCJkcmF3TGF5ZXIiLCJ1bmlmb3JtcyIsIk9iamVjdCIsImFzc2lnbiIsInJlbmRlclBpY2tpbmdCdWZmZXIiLCJwaWNraW5nRW5hYmxlZCIsImNvbnRleHQiLCJ2aWV3cG9ydCIsImdsIiwicGlja2luZ0ZCTyIsIngiLCJ5IiwibW9kZSIsImxhc3RQaWNrZWRJbmZvIiwicGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJkZXZpY2VYIiwiZGV2aWNlWSIsImNhbnZhcyIsImhlaWdodCIsInVuaGFuZGxlZFBpY2tJbmZvcyIsImZyYW1lQnVmZmVyIiwiZnJhbWVidWZmZXIiLCJzY2lzc29yVGVzdCIsInciLCJoIiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiREVQVEhfQlVGRkVSX0JJVCIsIm9sZEJsZW5kTW9kZSIsImVuYWJsZSIsIkJMRU5EIiwiYmxlbmRGdW5jU2VwYXJhdGUiLCJPTkUiLCJaRVJPIiwiQ09OU1RBTlRfQUxQSEEiLCJibGVuZEVxdWF0aW9uIiwiRlVOQ19BREQiLCJwaWNrYWJsZSIsImJsZW5kQ29sb3IiLCJwaWNrZWRDb2xvciIsInJlYWRQaXhlbHMiLCJSR0JBIiwiVU5TSUdORURfQllURSIsInBpY2tlZExheWVySW5kZXgiLCJwaWNrZWRMYXllciIsInBpY2tlZE9iamVjdEluZGV4IiwiZGVjb2RlUGlja2luZ0NvbG9yIiwicGlja2VkTGF5ZXJJZCIsImlkIiwiYWZmZWN0ZWRMYXllcnMiLCJsYXN0UGlja2VkT2JqZWN0SW5kZXgiLCJpbmRleCIsImxhc3RQaWNrZWRMYXllcklkIiwibGF5ZXJJZCIsImxhc3RQaWNrZWRMYXllciIsImZpbmQiLCJsIiwidW5zaGlmdCIsImJhc2VJbmZvIiwiY3JlYXRlSW5mbyIsImRldmljZVBpeGVsIiwiaW5mbyIsImNvbG9yIiwicGlja2VkIiwicGlja0xheWVyIiwiaGFuZGxlZCIsIm9uQ2xpY2siLCJvbkhvdmVyIiwiRXJyb3IiLCJwdXNoIiwicGl4ZWwiLCJsbmdMYXQiLCJ1bnByb2plY3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs4UUFBQTs7O1FBUWdCQSxVLEdBQUFBLFU7UUF5QkFDLFUsR0FBQUEsVTs7QUFoQ2hCOztBQUNBOztBQUNBOztBQUVBLElBQU1DLGNBQWMsSUFBSUMsVUFBSixDQUFlLENBQWYsQ0FBcEI7QUFDQSxJQUFJQyxjQUFjLENBQWxCOztBQUVPLFNBQVNKLFVBQVQsT0FBb0M7QUFBQSxNQUFmSyxNQUFlLFFBQWZBLE1BQWU7QUFBQSxNQUFQQyxJQUFPLFFBQVBBLElBQU87O0FBQ3pDLGFBQUlDLEdBQUosQ0FBUSxDQUFSLGVBQXNCRixPQUFPRyxNQUE3Qjs7QUFFQTtBQUNBLE1BQUlDLGVBQWUsQ0FBbkI7QUFDQTtBQUNBSixTQUFPSyxPQUFQLENBQWUsVUFBQ0MsS0FBRCxFQUFRQyxVQUFSLEVBQXVCO0FBQ3BDLFFBQUlELE1BQU1FLEtBQU4sQ0FBWUMsT0FBaEIsRUFBeUI7QUFDdkJILFlBQU1JLFNBQU4sQ0FBZ0I7QUFDZEMsa0JBQVVDLE9BQU9DLE1BQVAsQ0FDUixFQUFDQyxxQkFBcUIsQ0FBdEIsRUFBeUJDLGdCQUFnQixDQUF6QyxFQURRLEVBRVJULE1BQU1VLE9BQU4sQ0FBY0wsUUFGTixFQUdSLCtDQUF3QkwsTUFBTVUsT0FBTixDQUFjQyxRQUF0QyxFQUFnRFgsTUFBTUUsS0FBdEQsQ0FIUSxFQUlSLEVBQUNELHNCQUFELEVBSlE7QUFESSxPQUFoQjtBQVFBSDtBQUNEO0FBQ0YsR0FaRDs7QUFjQSxhQUFJRixHQUFKLENBQVEsQ0FBUixtQkFBMEJELElBQTFCLFVBQW1D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ZC1waWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHtHTCwgZ2xDb250ZXh0V2l0aFN0YXRlfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7Z2V0VW5pZm9ybXNGcm9tVmlld3BvcnR9IGZyb20gJy4vdmlld3BvcnQtdW5pZm9ybXMnO1xuaW1wb3J0IHtsb2csIGdldEJsZW5kTW9kZSwgc2V0QmxlbmRNb2RlfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgRU1QVFlfUElYRUwgPSBuZXcgVWludDhBcnJheSg0KTtcbmxldCByZW5kZXJDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3TGF5ZXJzKHtsYXllcnMsIHBhc3N9KSB7XG4gIGxvZy5sb2coMiwgYERSQVdJTkcgJHtsYXllcnMubGVuZ3RofSBsYXllcnNgKTtcblxuICAvLyByZW5kZXIgbGF5ZXJzIGluIG5vcm1hbCBjb2xvcnNcbiAgbGV0IHZpc2libGVDb3VudCA9IDA7XG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICBsYXllcnMuZm9yRWFjaCgobGF5ZXIsIGxheWVySW5kZXgpID0+IHtcbiAgICBpZiAobGF5ZXIucHJvcHMudmlzaWJsZSkge1xuICAgICAgbGF5ZXIuZHJhd0xheWVyKHtcbiAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge3JlbmRlclBpY2tpbmdCdWZmZXI6IDAsIHBpY2tpbmdFbmFibGVkOiAwfSxcbiAgICAgICAgICBsYXllci5jb250ZXh0LnVuaWZvcm1zLFxuICAgICAgICAgIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KGxheWVyLmNvbnRleHQudmlld3BvcnQsIGxheWVyLnByb3BzKSxcbiAgICAgICAgICB7bGF5ZXJJbmRleH1cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICB2aXNpYmxlQ291bnQrKztcbiAgICB9XG4gIH0pO1xuXG4gIGxvZy5sb2coMSwgYFJFTkRFUiBQQVNTICR7cGFzc306ICR7cmVuZGVyQ291bnQrK30gXG4gICAgJHt2aXNpYmxlQ291bnR9IHZpc2libGUsICR7bGF5ZXJzLmxlbmd0aH0gdG90YWxgKTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpY2tMYXllcnMoZ2wsIHtcbiAgbGF5ZXJzLFxuICBwaWNraW5nRkJPLFxuICB1bmlmb3JtcyA9IHt9LFxuICB4LFxuICB5LFxuICB2aWV3cG9ydCxcbiAgbW9kZSxcbiAgbGFzdFBpY2tlZEluZm9cbn0pIHtcbiAgLy8gQ29udmVydCBmcm9tIGNhbnZhcyB0b3AtbGVmdCB0byBXZWJHTCBib3R0b20tbGVmdCBjb29yZGluYXRlc1xuICAvLyBBbmQgY29tcGVuc2F0ZSBmb3IgcGl4ZWxSYXRpb1xuICBjb25zdCBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgY29uc3QgZGV2aWNlWCA9IHggKiBwaXhlbFJhdGlvO1xuICBjb25zdCBkZXZpY2VZID0gZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvO1xuXG4gIC8vIFRPRE8gLSBqdXN0IHJldHVybiBnbENvbnRleHRXaXRoU3RhdGUgb25jZSBsdW1hIHVwZGF0ZXNcbiAgY29uc3QgdW5oYW5kbGVkUGlja0luZm9zID0gW107XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGNsZWFyIHNjaXNzb3IgdGVzdCBhbmQgZmJvIGJpbmRpbmdzIGluIGNhc2Ugb2YgZXhjZXB0aW9uc1xuICAvLyBXZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIG9uZSBwaXhlbCwgbm8gbmVlZCB0byByZW5kZXIgYW55dGhpbmcgZWxzZVxuICBnbENvbnRleHRXaXRoU3RhdGUoZ2wsIHtcbiAgICBmcmFtZUJ1ZmZlcjogcGlja2luZ0ZCTyxcbiAgICBmcmFtZWJ1ZmZlcjogcGlja2luZ0ZCTyxcbiAgICBzY2lzc29yVGVzdDoge3g6IGRldmljZVgsIHk6IGRldmljZVksIHc6IDEsIGg6IDF9XG4gIH0sICgpID0+IHtcblxuICAgIC8vIFBpY2tpbmcgcHJvY2VzcyBzdGFydFxuICAgIC8vIENsZWFyIHRoZSBmcmFtZSBidWZmZXJcbiAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgLy8gU2F2ZSBjdXJyZW50IGJsZW5kIHNldHRpbmdzXG4gICAgY29uc3Qgb2xkQmxlbmRNb2RlID0gZ2V0QmxlbmRNb2RlKGdsKTtcbiAgICAvLyBTZXQgYmxlbmQgbW9kZSBmb3IgcGlja2luZ1xuICAgIC8vIGFsd2F5cyBvdmVyd3JpdGUgZXhpc3RpbmcgcGl4ZWwgd2l0aCBbcixnLGIsbGF5ZXJJbmRleF1cbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLk9ORSwgZ2wuWkVSTywgZ2wuQ09OU1RBTlRfQUxQSEEsIGdsLlpFUk8pO1xuICAgIGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xuXG4gICAgLy8gUmVuZGVyIGFsbCBwaWNrYWJsZSBsYXllcnMgaW4gcGlja2luZyBjb2xvcnNcbiAgICBsYXllcnMuZm9yRWFjaCgobGF5ZXIsIGxheWVySW5kZXgpID0+IHtcbiAgICAgIGlmIChsYXllci5wcm9wcy52aXNpYmxlICYmIGxheWVyLnByb3BzLnBpY2thYmxlKSB7XG5cbiAgICAgICAgLy8gRW5jb2RlIGxheWVySW5kZXggd2l0aCBhbHBoYVxuICAgICAgICBnbC5ibGVuZENvbG9yKDAsIDAsIDAsIChsYXllckluZGV4ICsgMSkgLyAyNTUpO1xuXG4gICAgICAgIGxheWVyLmRyYXdMYXllcih7XG4gICAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7cmVuZGVyUGlja2luZ0J1ZmZlcjogMSwgcGlja2luZ0VuYWJsZWQ6IDF9LFxuICAgICAgICAgICAgbGF5ZXIuY29udGV4dC51bmlmb3JtcyxcbiAgICAgICAgICAgIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KGxheWVyLmNvbnRleHQudmlld3BvcnQsIGxheWVyLnByb3BzKSxcbiAgICAgICAgICAgIHtsYXllckluZGV4fVxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWFkIGNvbG9yIGluIHRoZSBjZW50cmFsIHBpeGVsLCB0byBiZSBtYXBwZWQgd2l0aCBwaWNraW5nIGNvbG9yc1xuICAgIGNvbnN0IHBpY2tlZENvbG9yID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgZ2wucmVhZFBpeGVscyhkZXZpY2VYLCBkZXZpY2VZLCAxLCAxLCBHTC5SR0JBLCBHTC5VTlNJR05FRF9CWVRFLCBwaWNrZWRDb2xvcik7XG5cbiAgICAvLyByZXN0b3JlIGJsZW5kIG1vZGVcbiAgICBzZXRCbGVuZE1vZGUoZ2wsIG9sZEJsZW5kTW9kZSk7XG4gICAgLy8gUGlja2luZyBwcm9jZXNzIGVuZFxuXG4gICAgLy8gUHJvY2VzcyBwaWNrZWQgaW5mbyBzdGFydFxuICAgIC8vIERlY29kZSBwaWNrZWQgY29sb3JcbiAgICBjb25zdCBwaWNrZWRMYXllckluZGV4ID0gcGlja2VkQ29sb3JbM10gLSAxO1xuICAgIGNvbnN0IHBpY2tlZExheWVyID0gcGlja2VkTGF5ZXJJbmRleCA+PSAwID8gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdIDogbnVsbDtcbiAgICBjb25zdCBwaWNrZWRPYmplY3RJbmRleCA9IHBpY2tlZExheWVyID8gcGlja2VkTGF5ZXIuZGVjb2RlUGlja2luZ0NvbG9yKHBpY2tlZENvbG9yKSA6IC0xO1xuICAgIGNvbnN0IHBpY2tlZExheWVySWQgPSBwaWNrZWRMYXllciAmJiBwaWNrZWRMYXllci5wcm9wcy5pZDtcbiAgICBjb25zdCBhZmZlY3RlZExheWVycyA9IHBpY2tlZExheWVyID8gW3BpY2tlZExheWVyXSA6IFtdO1xuXG4gICAgaWYgKG1vZGUgPT09ICdob3ZlcicpIHtcbiAgICAgIC8vIG9ubHkgaW52b2tlIG9uSG92ZXIgZXZlbnRzIGlmIHBpY2tlZCBvYmplY3QgaGFzIGNoYW5nZWRcbiAgICAgIGNvbnN0IGxhc3RQaWNrZWRPYmplY3RJbmRleCA9IGxhc3RQaWNrZWRJbmZvLmluZGV4O1xuICAgICAgY29uc3QgbGFzdFBpY2tlZExheWVySWQgPSBsYXN0UGlja2VkSW5mby5sYXllcklkO1xuXG4gICAgICBpZiAocGlja2VkTGF5ZXJJZCA9PT0gbGFzdFBpY2tlZExheWVySWQgJiYgcGlja2VkT2JqZWN0SW5kZXggPT09IGxhc3RQaWNrZWRPYmplY3RJbmRleCkge1xuICAgICAgICAvLyBwaWNrZWQgb2JqZWN0IGRpZCBub3QgY2hhbmdlLCBubyBuZWVkIHRvIHByb2NlZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGlja2VkTGF5ZXJJZCAhPT0gbGFzdFBpY2tlZExheWVySWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHN0b3JlIGEgcmVmIHRvIGxhc3RQaWNrZWRMYXllciBpbiB0aGUgY29udGV4dCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBzdGF0ZSBvZiBhbiBvdXRkYXRlZCBsYXllciBpcyBubyBsb25nZXIgdmFsaWRcbiAgICAgICAgLy8gYW5kIHRoZSBwcm9wcyBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllciA9IGxheWVycy5maW5kKGwgPT4gbC5wcm9wcy5pZCA9PT0gbGFzdFBpY2tlZExheWVySWQpO1xuICAgICAgICBpZiAobGFzdFBpY2tlZExheWVyKSB7XG4gICAgICAgICAgLy8gTGV0IGxlYXZlIGV2ZW50IGZpcmUgYmVmb3JlIGVudGVyIGV2ZW50XG4gICAgICAgICAgYWZmZWN0ZWRMYXllcnMudW5zaGlmdChsYXN0UGlja2VkTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBsYXllciBtYW5hZ2VyIGNvbnRleHRcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmxheWVySWQgPSBwaWNrZWRMYXllcklkO1xuICAgICAgbGFzdFBpY2tlZEluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlSW5mbyA9IGNyZWF0ZUluZm8oW3gsIHldLCB2aWV3cG9ydCk7XG4gICAgYmFzZUluZm8uZGV2aWNlUGl4ZWwgPSBbZGV2aWNlWCwgZGV2aWNlWV07XG4gICAgYmFzZUluZm8ucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cbiAgICBhZmZlY3RlZExheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgIGxldCBpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUluZm8pO1xuICAgICAgaW5mby5sYXllciA9IGxheWVyO1xuXG4gICAgICBpZiAobGF5ZXIgPT09IHBpY2tlZExheWVyKSB7XG4gICAgICAgIGluZm8uY29sb3IgPSBwaWNrZWRDb2xvcjtcbiAgICAgICAgaW5mby5pbmRleCA9IHBpY2tlZE9iamVjdEluZGV4O1xuICAgICAgICBpbmZvLnBpY2tlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIExldCBsYXllcnMgcG9wdWxhdGUgaXRzIG93biBpbmZvIG9iamVjdFxuICAgICAgaW5mbyA9IGxheWVyLnBpY2tMYXllcih7aW5mbywgbW9kZX0pO1xuXG4gICAgICAvLyBJZiBsYXllci5nZXRQaWNraW5nSW5mbygpIHJldHVybnMgbnVsbCwgZG8gbm90IHByb2NlZWRcbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ2FsbGluZyBjYWxsYmFja3MgY2FuIGhhdmUgYXN5bmMgaW50ZXJhY3Rpb25zIHdpdGggUmVhY3RcbiAgICAgICAgLy8gd2hpY2ggbnVsbGlmaWVzIGxheWVyLnN0YXRlLlxuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSAnY2xpY2snOiBoYW5kbGVkID0gbGF5ZXIucHJvcHMub25DbGljayhpbmZvKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hvdmVyJzogaGFuZGxlZCA9IGxheWVyLnByb3BzLm9uSG92ZXIoaW5mbyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGljayB0eXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhbmRsZWQpIHtcbiAgICAgICAgICB1bmhhbmRsZWRQaWNrSW5mb3MucHVzaChpbmZvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdW5oYW5kbGVkUGlja0luZm9zO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUluZm8ocGl4ZWwsIHZpZXdwb3J0KSB7XG4gIC8vIEFzc2lnbiBhIG51bWJlciBvZiBwb3RlbnRpYWxseSB1c2VmdWwgcHJvcHMgdG8gdGhlIFwiaW5mb1wiIG9iamVjdFxuICByZXR1cm4ge1xuICAgIGNvbG9yOiBFTVBUWV9QSVhFTCxcbiAgICBpbmRleDogLTEsXG4gICAgcGlja2VkOiBmYWxzZSxcbiAgICB4OiBwaXhlbFswXSxcbiAgICB5OiBwaXhlbFsxXSxcbiAgICBwaXhlbCxcbiAgICBsbmdMYXQ6IHZpZXdwb3J0LnVucHJvamVjdChwaXhlbClcbiAgfTtcbn1cbiJdfQ==