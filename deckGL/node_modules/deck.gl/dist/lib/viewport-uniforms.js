'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.getUniformsFromViewport = getUniformsFromViewport;

var _luma = require('luma.gl');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - Math.fround(a);
  return [hiPart, loPart];
}

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];

function calculateMatrixAndOffset(_ref) {
  var projectionMode = _ref.projectionMode,
      positionOrigin = _ref.positionOrigin,
      viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix;
  var viewMatrixUncentered = viewport.viewMatrixUncentered,
      viewMatrix = viewport.viewMatrix,
      projectionMatrix = viewport.projectionMatrix;


  var projectionCenter = void 0;
  var modelViewProjectionMatrix = void 0;

  var modelViewMatrixInv = new _luma.Matrix4(viewMatrix);
  var viewProjectionMatrix = new _luma.Matrix4(projectionMatrix).multiplyRight(viewMatrix);

  switch (projectionMode) {

    case _constants.COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      modelViewProjectionMatrix = viewProjectionMatrix;
      if (modelMatrix) {
        // Apply model matrix if supplied
        // modelViewProjectionMatrix = modelViewProjectionMatrix.clone();
        modelViewProjectionMatrix.multiplyRight(modelMatrix);
        modelViewMatrixInv.multiplyRight(modelMatrix);
      }
      modelViewMatrixInv.invert();
      break;

    // TODO: make lighitng work for meter offset mode
    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      // Calculate transformed projectionCenter (in 64 bit precision)
      // This is the key to offset mode precision (avoids doing this
      // addition in 32 bit precision)
      var positionPixels = viewport.projectFlat(positionOrigin);
      projectionCenter = viewProjectionMatrix.transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);

      modelViewProjectionMatrix = new _luma.Matrix4(projectionMatrix)
      // Always apply uncentered projection matrix (shader adds center)
      .multiplyRight(viewMatrixUncentered)
      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      .multiplyRight(VECTOR_TO_POINT_MATRIX);

      if (modelMatrix) {
        // Apply model matrix if supplied
        modelViewProjectionMatrix.multiplyRight(modelMatrix);
      }
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  var cameraPos = [modelViewMatrixInv[12], modelViewMatrixInv[13], modelViewMatrixInv[14]];

  return {
    modelViewProjectionMatrix: modelViewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: cameraPos
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
function getUniformsFromViewport(viewport) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,
      _ref2$projectionMode = _ref2.projectionMode,
      projectionMode = _ref2$projectionMode === undefined ? _constants.COORDINATE_SYSTEM.LNGLAT : _ref2$projectionMode,
      _ref2$positionOrigin = _ref2.positionOrigin,
      positionOrigin = _ref2$positionOrigin === undefined ? [0, 0] : _ref2$positionOrigin;

  (0, _assert2.default)(viewport.scale, 'Viewport scale missing');

  var _calculateMatrixAndOf = calculateMatrixAndOffset({ projectionMode: projectionMode, positionOrigin: positionOrigin, modelMatrix: modelMatrix, viewport: viewport }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      modelViewProjectionMatrix = _calculateMatrixAndOf.modelViewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  (0, _assert2.default)(modelViewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var projectionPixelsPerUnit = viewport.getDistanceScales().pixelsPerMeter;
  (0, _assert2.default)(projectionPixelsPerUnit, 'Viewport missing pixelsPerMeter');

  // calculate WebGL matrices

  // Convert to Float32
  var glProjectionMatrix = new Float32Array(modelViewProjectionMatrix);

  // "Float64Array"
  // Transpose the projection matrix to column major for GLSL.
  var glProjectionMatrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var _fp64ify = fp64ify(modelViewProjectionMatrix[j * 4 + i]);

      var _fp64ify2 = _slicedToArray(_fp64ify, 2);

      glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];
      glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];
    }
  }

  return {
    // Projection mode values
    projectionMode: projectionMode,
    projectionCenter: projectionCenter,

    // modelMatrix: modelMatrix || new Matrix4().identity(),

    // Main projection matrices
    projectionMatrix: glProjectionMatrix,
    projectionMatrixUncentered: glProjectionMatrix,
    projectionFP64: glProjectionMatrixFP64,
    projectionPixelsPerUnit: projectionPixelsPerUnit,

    // This is the mercator scale (2 ** zoom)
    projectionScale: viewport.scale,

    // Deprecated?
    projectionScaleFP64: fp64ify(viewport.scale),

    // This is for lighting calculations
    cameraPos: new Float32Array(cameraPos)

  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdmlld3BvcnQtdW5pZm9ybXMuanMiXSwibmFtZXMiOlsiZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQiLCJmcDY0aWZ5IiwiYSIsImhpUGFydCIsIk1hdGgiLCJmcm91bmQiLCJsb1BhcnQiLCJaRVJPX1ZFQ1RPUiIsIlZFQ1RPUl9UT19QT0lOVF9NQVRSSVgiLCJjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQiLCJwcm9qZWN0aW9uTW9kZSIsInBvc2l0aW9uT3JpZ2luIiwidmlld3BvcnQiLCJtb2RlbE1hdHJpeCIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJwcm9qZWN0aW9uQ2VudGVyIiwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCIsIm1vZGVsVmlld01hdHJpeEludiIsInZpZXdQcm9qZWN0aW9uTWF0cml4IiwibXVsdGlwbHlSaWdodCIsIkxOR0xBVCIsImludmVydCIsIk1FVEVSX09GRlNFVFMiLCJwb3NpdGlvblBpeGVscyIsInByb2plY3RGbGF0IiwidHJhbnNmb3JtVmVjdG9yIiwiRXJyb3IiLCJjYW1lcmFQb3MiLCJzY2FsZSIsInByb2plY3Rpb25QaXhlbHNQZXJVbml0IiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJwaXhlbHNQZXJNZXRlciIsImdsUHJvamVjdGlvbk1hdHJpeCIsIkZsb2F0MzJBcnJheSIsImdsUHJvamVjdGlvbk1hdHJpeEZQNjQiLCJpIiwiaiIsInByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkIiwicHJvamVjdGlvbkZQNjQiLCJwcm9qZWN0aW9uU2NhbGUiLCJwcm9qZWN0aW9uU2NhbGVGUDY0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztRQXVGZ0JBLHVCLEdBQUFBLHVCOztBQXZGaEI7O0FBRUE7Ozs7QUFDQTs7OztBQUVBLFNBQVNDLE9BQVQsQ0FBaUJDLENBQWpCLEVBQW9CO0FBQ2xCLE1BQU1DLFNBQVNDLEtBQUtDLE1BQUwsQ0FBWUgsQ0FB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QjtBQVVMTSxvQkFBZ0JKLHNCQVZYO0FBV0xMLG9EQVhLOztBQWFMO0FBQ0FVLHFCQUFpQjdCLFNBQVNrQixLQWRyQjs7QUFnQkw7QUFDQVkseUJBQXFCekMsUUFBUVcsU0FBU2tCLEtBQWpCLENBakJoQjs7QUFtQkw7QUFDQUQsZUFBVyxJQUFJTSxZQUFKLENBQWlCTixTQUFqQjs7QUFwQk4sR0FBUDtBQXVCRCIsImZpbGUiOiJ2aWV3cG9ydC11bmlmb3Jtcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TWF0cml4NH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4vY29uc3RhbnRzJztcblxuZnVuY3Rpb24gZnA2NGlmeShhKSB7XG4gIGNvbnN0IGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICBjb25zdCBsb1BhcnQgPSBhIC0gTWF0aC5mcm91bmQoYSk7XG4gIHJldHVybiBbaGlQYXJ0LCBsb1BhcnRdO1xufVxuXG4vLyBUbyBxdWlja2x5IHNldCBhIHZlY3RvciB0byB6ZXJvXG5jb25zdCBaRVJPX1ZFQ1RPUiA9IFswLCAwLCAwLCAwXTtcbi8vIDR4NCBtYXRyaXggdGhhdCBkcm9wcyA0dGggY29tcG9uZW50IG9mIHZlY3RvclxuY29uc3QgVkVDVE9SX1RPX1BPSU5UX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwXTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0KHtcbiAgcHJvamVjdGlvbk1vZGUsXG4gIHBvc2l0aW9uT3JpZ2luLFxuICB2aWV3cG9ydCxcbiAgbW9kZWxNYXRyaXhcbn0pIHtcbiAgY29uc3Qge3ZpZXdNYXRyaXhVbmNlbnRlcmVkLCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4fSA9IHZpZXdwb3J0O1xuXG4gIGxldCBwcm9qZWN0aW9uQ2VudGVyO1xuICBsZXQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcblxuICBjb25zdCBtb2RlbFZpZXdNYXRyaXhJbnYgPSBuZXcgTWF0cml4NCh2aWV3TWF0cml4KTtcbiAgY29uc3Qgdmlld1Byb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NChwcm9qZWN0aW9uTWF0cml4KS5tdWx0aXBseVJpZ2h0KHZpZXdNYXRyaXgpO1xuXG4gIHN3aXRjaCAocHJvamVjdGlvbk1vZGUpIHtcblxuICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVDpcbiAgICBwcm9qZWN0aW9uQ2VudGVyID0gWkVST19WRUNUT1I7XG4gICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IHZpZXdQcm9qZWN0aW9uTWF0cml4O1xuICAgIGlmIChtb2RlbE1hdHJpeCkge1xuICAgICAgLy8gQXBwbHkgbW9kZWwgbWF0cml4IGlmIHN1cHBsaWVkXG4gICAgICAvLyBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeC5jbG9uZSgpO1xuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeC5tdWx0aXBseVJpZ2h0KG1vZGVsTWF0cml4KTtcbiAgICAgIG1vZGVsVmlld01hdHJpeEludi5tdWx0aXBseVJpZ2h0KG1vZGVsTWF0cml4KTtcbiAgICB9XG4gICAgbW9kZWxWaWV3TWF0cml4SW52LmludmVydCgpO1xuICAgIGJyZWFrO1xuXG4gIC8vIFRPRE86IG1ha2UgbGlnaGl0bmcgd29yayBmb3IgbWV0ZXIgb2Zmc2V0IG1vZGVcbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5NRVRFUl9PRkZTRVRTOlxuICAgIC8vIENhbGN1bGF0ZSB0cmFuc2Zvcm1lZCBwcm9qZWN0aW9uQ2VudGVyIChpbiA2NCBiaXQgcHJlY2lzaW9uKVxuICAgIC8vIFRoaXMgaXMgdGhlIGtleSB0byBvZmZzZXQgbW9kZSBwcmVjaXNpb24gKGF2b2lkcyBkb2luZyB0aGlzXG4gICAgLy8gYWRkaXRpb24gaW4gMzIgYml0IHByZWNpc2lvbilcbiAgICBjb25zdCBwb3NpdGlvblBpeGVscyA9IHZpZXdwb3J0LnByb2plY3RGbGF0KHBvc2l0aW9uT3JpZ2luKTtcbiAgICBwcm9qZWN0aW9uQ2VudGVyID0gdmlld1Byb2plY3Rpb25NYXRyaXhcbiAgICAgIC50cmFuc2Zvcm1WZWN0b3IoW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdKTtcblxuICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NChwcm9qZWN0aW9uTWF0cml4KVxuICAgICAgLy8gQWx3YXlzIGFwcGx5IHVuY2VudGVyZWQgcHJvamVjdGlvbiBtYXRyaXggKHNoYWRlciBhZGRzIGNlbnRlcilcbiAgICAgIC5tdWx0aXBseVJpZ2h0KHZpZXdNYXRyaXhVbmNlbnRlcmVkKVxuICAgICAgLy8gWmVybyBvdXQgNHRoIGNvb3JkaW5hdGUgKFwiYWZ0ZXJcIiBtb2RlbCBtYXRyaXgpIC0gYXZvaWRzIGZ1cnRoZXIgdHJhbnNsYXRpb25zXG4gICAgICAubXVsdGlwbHlSaWdodChWRUNUT1JfVE9fUE9JTlRfTUFUUklYKTtcblxuICAgIGlmIChtb2RlbE1hdHJpeCkge1xuICAgICAgLy8gQXBwbHkgbW9kZWwgbWF0cml4IGlmIHN1cHBsaWVkXG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4Lm11bHRpcGx5UmlnaHQobW9kZWxNYXRyaXgpO1xuICAgIH1cbiAgICBicmVhaztcblxuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcm9qZWN0aW9uIG1vZGUnKTtcbiAgfVxuXG4gIGNvbnN0IGNhbWVyYVBvcyA9IFttb2RlbFZpZXdNYXRyaXhJbnZbMTJdLCBtb2RlbFZpZXdNYXRyaXhJbnZbMTNdLCBtb2RlbFZpZXdNYXRyaXhJbnZbMTRdXTtcblxuICByZXR1cm4ge1xuICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkNlbnRlcixcbiAgICBjYW1lcmFQb3NcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHVuaWZvcm1zIGZvciBzaGFkZXJzIGJhc2VkIG9uIGN1cnJlbnQgcHJvamVjdGlvblxuICogaW5jbHVkZXM6IHByb2plY3Rpb24gbWF0cml4IHN1aXRhYmxlIGZvciBzaGFkZXJzXG4gKlxuICogVE9ETyAtIEVuc3VyZSB0aGlzIHdvcmtzIHdpdGggYW55IHZpZXdwb3J0LCBub3QganVzdCBXZWJNZXJjYXRvclZpZXdwb3J0c1xuICpcbiAqIEBwYXJhbSB7V2ViTWVyY2F0b3JWaWV3cG9ydH0gdmlld3BvcnQgLVxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAtIDR4NCBwcm9qZWN0aW9uIG1hdHJpeCB0aGF0IGNhbiBiZSB1c2VkIGluIHNoYWRlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KHZpZXdwb3J0LCB7XG4gIG1vZGVsTWF0cml4ID0gbnVsbCxcbiAgcHJvamVjdGlvbk1vZGUgPSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQsXG4gIHBvc2l0aW9uT3JpZ2luID0gWzAsIDBdXG59ID0ge30pIHtcbiAgYXNzZXJ0KHZpZXdwb3J0LnNjYWxlLCAnVmlld3BvcnQgc2NhbGUgbWlzc2luZycpO1xuXG4gIGNvbnN0IHtwcm9qZWN0aW9uQ2VudGVyLCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LCBjYW1lcmFQb3N9ID1cbiAgICBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe3Byb2plY3Rpb25Nb2RlLCBwb3NpdGlvbk9yaWdpbiwgbW9kZWxNYXRyaXgsIHZpZXdwb3J0fSk7XG5cbiAgYXNzZXJ0KG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsICdWaWV3cG9ydCBtaXNzaW5nIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgnKTtcblxuICAvLyBDYWxjdWxhdGUgcHJvamVjdGlvbiBwaXhlbHMgcGVyIHVuaXRcbiAgY29uc3QgcHJvamVjdGlvblBpeGVsc1BlclVuaXQgPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpLnBpeGVsc1Blck1ldGVyO1xuICBhc3NlcnQocHJvamVjdGlvblBpeGVsc1BlclVuaXQsICdWaWV3cG9ydCBtaXNzaW5nIHBpeGVsc1Blck1ldGVyJyk7XG5cbiAgLy8gY2FsY3VsYXRlIFdlYkdMIG1hdHJpY2VzXG5cbiAgLy8gQ29udmVydCB0byBGbG9hdDMyXG4gIGNvbnN0IGdsUHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgLy8gXCJGbG9hdDY0QXJyYXlcIlxuICAvLyBUcmFuc3Bvc2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHRvIGNvbHVtbiBtYWpvciBmb3IgR0xTTC5cbiAgY29uc3QgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCA9IG5ldyBGbG9hdDMyQXJyYXkoMzIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgKytqKSB7XG4gICAgICBbXG4gICAgICAgIGdsUHJvamVjdGlvbk1hdHJpeEZQNjRbKGkgKiA0ICsgaikgKiAyXSxcbiAgICAgICAgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NFsoaSAqIDQgKyBqKSAqIDIgKyAxXVxuICAgICAgXSA9IGZwNjRpZnkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFtqICogNCArIGldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFByb2plY3Rpb24gbW9kZSB2YWx1ZXNcbiAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgLy8gbW9kZWxNYXRyaXg6IG1vZGVsTWF0cml4IHx8IG5ldyBNYXRyaXg0KCkuaWRlbnRpdHkoKSxcblxuICAgIC8vIE1haW4gcHJvamVjdGlvbiBtYXRyaWNlc1xuICAgIHByb2plY3Rpb25NYXRyaXg6IGdsUHJvamVjdGlvbk1hdHJpeCxcbiAgICBwcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZDogZ2xQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25GUDY0OiBnbFByb2plY3Rpb25NYXRyaXhGUDY0LFxuICAgIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LFxuXG4gICAgLy8gVGhpcyBpcyB0aGUgbWVyY2F0b3Igc2NhbGUgKDIgKiogem9vbSlcbiAgICBwcm9qZWN0aW9uU2NhbGU6IHZpZXdwb3J0LnNjYWxlLFxuXG4gICAgLy8gRGVwcmVjYXRlZD9cbiAgICBwcm9qZWN0aW9uU2NhbGVGUDY0OiBmcDY0aWZ5KHZpZXdwb3J0LnNjYWxlKSxcblxuICAgIC8vIFRoaXMgaXMgZm9yIGxpZ2h0aW5nIGNhbGN1bGF0aW9uc1xuICAgIGNhbWVyYVBvczogbmV3IEZsb2F0MzJBcnJheShjYW1lcmFQb3MpXG5cbiAgfTtcbn1cbiJdfQ==