(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("luma.gl"), require("path"), require("assert"), require("gl-matrix"), require("earcut"), require("lodash.flattendeep"), require("react"), require("d3-hexbin"));
	else if(typeof define === 'function' && define.amd)
		define(["luma.gl", "path", "assert", "gl-matrix", "earcut", "lodash.flattendeep", "react", "d3-hexbin"], factory);
	else if(typeof exports === 'object')
		exports["deck.gl"] = factory(require("luma.gl"), require("path"), require("assert"), require("gl-matrix"), require("earcut"), require("lodash.flattendeep"), require("react"), require("d3-hexbin"));
	else
		root["deck.gl"] = factory(root["luma.gl"], root["path"], root["assert"], root["gl-matrix"], root["earcut"], root["lodash.flattendeep"], root["react"], root["d3-hexbin"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_10__, __WEBPACK_EXTERNAL_MODULE_34__, __WEBPACK_EXTERNAL_MODULE_35__, __WEBPACK_EXTERNAL_MODULE_78__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 79);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* exports used: Model, Geometry, GL, Framebuffer, addEvents, createGLContext, FramebufferObject, glContextWithState, Matrix4, Texture2D, loadTextures, CylinderGeometry, CubeGeometry, glGetDebugInfo */
/*!**************************!*\
  !*** external "luma.gl" ***!
  \**************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_0__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImx1bWEuZ2xcIj9lNWFiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJsdW1hLmdsXCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/* unknown exports provided */
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInBhdGhcIj81YjJhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJwYXRoXCJcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/* exports provided: COORDINATE_SYSTEM, Layer, CompositeLayer, AttributeManager, LayerManager, get, count, values, isKeyedContainer, keys, entries */
/* exports used: Layer, CompositeLayer, LayerManager, AttributeManager, COORDINATE_SYSTEM, get */
/*!**************************!*\
  !*** ./src/lib/index.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__init__ = __webpack_require__(/*! ./init */ 59);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(/*! ./constants */ 28);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return __WEBPACK_IMPORTED_MODULE_1__constants__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__layer__ = __webpack_require__(/*! ./layer */ 14);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_2__layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__composite_layer__ = __webpack_require__(/*! ./composite-layer */ 57);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_3__composite_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__attribute_manager__ = __webpack_require__(/*! ./attribute-manager */ 27);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return __WEBPACK_IMPORTED_MODULE_4__attribute_manager__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__layer_manager__ = __webpack_require__(/*! ./layer-manager */ 60);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return __WEBPACK_IMPORTED_MODULE_5__layer_manager__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_container__ = __webpack_require__(/*! ./utils/container */ 8);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return __WEBPACK_IMPORTED_MODULE_6__utils_container__[\"get\"]; });\n/* unused harmony reexport count */\n/* unused harmony reexport values */\n/* unused harmony reexport isKeyedContainer */\n/* unused harmony reexport keys */\n/* unused harmony reexport entries */\n// Set up deck.gl global state\n\n\n\n\n// Export core objects\n\n\n\n\n\n// Ability to extract data from ES6 containers (Maps, Immutable.maps etc)\n\n\n// Object iteration helper\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9saWIvaW5kZXguanM/ODE2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZXQgdXAgZGVjay5nbCBnbG9iYWwgc3RhdGVcbmltcG9ydCAnLi9pbml0JztcblxuZXhwb3J0IHsgQ09PUkRJTkFURV9TWVNURU0gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8vIEV4cG9ydCBjb3JlIG9iamVjdHNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGF5ZXIgfSBmcm9tICcuL2xheWVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29tcG9zaXRlTGF5ZXIgfSBmcm9tICcuL2NvbXBvc2l0ZS1sYXllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEF0dHJpYnV0ZU1hbmFnZXIgfSBmcm9tICcuL2F0dHJpYnV0ZS1tYW5hZ2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGF5ZXJNYW5hZ2VyIH0gZnJvbSAnLi9sYXllci1tYW5hZ2VyJztcblxuLy8gQWJpbGl0eSB0byBleHRyYWN0IGRhdGEgZnJvbSBFUzYgY29udGFpbmVycyAoTWFwcywgSW1tdXRhYmxlLm1hcHMgZXRjKVxuZXhwb3J0IHsgZ2V0IH0gZnJvbSAnLi91dGlscy9jb250YWluZXInO1xuXG4vLyBPYmplY3QgaXRlcmF0aW9uIGhlbHBlclxuZXhwb3J0IHsgY291bnQsIHZhbHVlcywgaXNLZXllZENvbnRhaW5lciwga2V5cywgZW50cmllcyB9IGZyb20gJy4vdXRpbHMvY29udGFpbmVyJztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/* exports provided: parseColor, Container, count, get, flatten, flattenVertices, fillArray, compareArrays, checkArray, log, compareProps, areEqualShallow, fp64ify, getBlendMode, setBlendMode */
/* exports used: log, flatten, Container, getBlendMode, setBlendMode, count, compareProps, get, flattenVertices, fillArray */
/*!********************************!*\
  !*** ./src/lib/utils/index.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__color__ = __webpack_require__(/*! ./color */ 62);\n/* unused harmony reexport parseColor */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__container__ = __webpack_require__(/*! ./container */ 8);\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return __WEBPACK_IMPORTED_MODULE_1__container__; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return __WEBPACK_IMPORTED_MODULE_1__container__[\"count\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return __WEBPACK_IMPORTED_MODULE_1__container__[\"get\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__flatten__ = __webpack_require__(/*! ./flatten */ 65);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_2__flatten__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return __WEBPACK_IMPORTED_MODULE_2__flatten__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return __WEBPACK_IMPORTED_MODULE_2__flatten__[\"c\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__compare_objects__ = __webpack_require__(/*! ./compare-objects */ 64);\n/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return __WEBPACK_IMPORTED_MODULE_3__compare_objects__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__compare_arrays__ = __webpack_require__(/*! ./compare-arrays */ 63);\n/* unused harmony reexport compareArrays */\n/* unused harmony reexport checkArray */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__log__ = __webpack_require__(/*! ./log */ 29);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_5__log__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__fp64__ = __webpack_require__(/*! ./fp64 */ 5);\n/* unused harmony namespace reexport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__blend__ = __webpack_require__(/*! ./blend */ 61);\n/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return __WEBPACK_IMPORTED_MODULE_7__blend__[\"a\"]; });\n/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return __WEBPACK_IMPORTED_MODULE_7__blend__[\"b\"]; });\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9saWIvdXRpbHMvaW5kZXguanM/NGE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBwYXJzZUNvbG9yIH0gZnJvbSAnLi9jb2xvcic7XG5pbXBvcnQgKiBhcyBDb250YWluZXIgZnJvbSAnLi9jb250YWluZXInO1xuZXhwb3J0IHsgQ29udGFpbmVyIH07XG5leHBvcnQgeyBjb3VudCwgZ2V0IH0gZnJvbSAnLi9jb250YWluZXInO1xuZXhwb3J0IHsgZmxhdHRlbiwgZmxhdHRlblZlcnRpY2VzLCBmaWxsQXJyYXkgfSBmcm9tICcuL2ZsYXR0ZW4nO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wYXJlLW9iamVjdHMnO1xuZXhwb3J0IHsgY29tcGFyZUFycmF5cywgY2hlY2tBcnJheSB9IGZyb20gJy4vY29tcGFyZS1hcnJheXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsb2cgfSBmcm9tICcuL2xvZyc7XG5leHBvcnQgKiBmcm9tICcuL2ZwNjQnO1xuZXhwb3J0ICogZnJvbSAnLi9ibGVuZCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL3V0aWxzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/* exports provided: checkRendererVendor, getPlatformShaderDefines, assembleShaders, fp64, project, project64, lighting */
/* exports used: assembleShaders */
/*!***********************************!*\
  !*** ./src/shader-utils/index.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assemble_shaders__ = __webpack_require__(/*! ./assemble-shaders */ 71);\n/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__assemble_shaders__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_chunks__ = __webpack_require__(/*! ./shader-chunks */ 31);\n/* unused harmony namespace reexport */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zaGFkZXItdXRpbHMvaW5kZXguanM/NDRiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2Fzc2VtYmxlLXNoYWRlcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9zaGFkZXItY2h1bmtzJztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXItdXRpbHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/* exports provided: fp64ify */
/* exports used: fp64ify */
/*!*******************************!*\
  !*** ./src/lib/utils/fp64.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = fp64ify;\n// TODO - move to shaderlib utilities\nfunction fp64ify(a) {\n  var hiPart = Math.fround(a);\n  var loPart = a - Math.fround(a);\n  return [hiPart, loPart];\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9saWIvdXRpbHMvZnA2NC5qcz9lZDg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE8gLSBtb3ZlIHRvIHNoYWRlcmxpYiB1dGlsaXRpZXNcbmV4cG9ydCBmdW5jdGlvbiBmcDY0aWZ5KGEpIHtcbiAgdmFyIGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICB2YXIgbG9QYXJ0ID0gYSAtIE1hdGguZnJvdW5kKGEpO1xuICByZXR1cm4gW2hpUGFydCwgbG9QYXJ0XTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdXRpbHMvZnA2NC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 6 */
/* unknown exports provided */
/* exports used: default */
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_6__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImFzc2VydFwiPzFlNDEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImFzc2VydFwiXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/* unknown exports provided */
/* exports used: vec2, mat4, vec4, vec3 */
/*!****************************!*\
  !*** external "gl-matrix" ***!
  \****************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_7__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImdsLW1hdHJpeFwiP2I5NWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImdsLW1hdHJpeFwiXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/* exports provided: isObject, isPlainObject, isContainer, count, values, isKeyedContainer, keys, entries, get, forEach, map, reduce, toJS */
/* all exports used */
/*!************************************!*\
  !*** ./src/lib/utils/container.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"isObject\"] = isObject;\n/* harmony export (immutable) */ __webpack_exports__[\"isPlainObject\"] = isPlainObject;\n/* harmony export (immutable) */ __webpack_exports__[\"isContainer\"] = isContainer;\n/* harmony export (immutable) */ __webpack_exports__[\"count\"] = count;\n/* harmony export (immutable) */ __webpack_exports__[\"values\"] = values;\n/* harmony export (immutable) */ __webpack_exports__[\"isKeyedContainer\"] = isKeyedContainer;\n/* harmony export (immutable) */ __webpack_exports__[\"keys\"] = keys;\n/* harmony export (immutable) */ __webpack_exports__[\"entries\"] = entries;\n/* harmony export (immutable) */ __webpack_exports__[\"get\"] = get;\n/* harmony export (immutable) */ __webpack_exports__[\"forEach\"] = forEach;\n/* harmony export (immutable) */ __webpack_exports__[\"map\"] = map;\n/* harmony export (immutable) */ __webpack_exports__[\"reduce\"] = reduce;\n/* harmony export (immutable) */ __webpack_exports__[\"toJS\"] = toJS;\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// ES6 includes iteration and iterable protocols, and new standard containers\n// Influential libraries like Immutable.js provide useful containers that\n// adopt these conventions.\n//\n// So, is it possible to write generic JavaScript code that works with any\n// well-written container class? And is it possible to write generic container\n// classes that work with any well-written code.\n//\n// Almost. But it is not trivial. Importantly the standard JavaScript `Object`s\n// lack even basic iteration support and even standard JavaScript `Array`s\n// differ in minor but important aspects from the new classes.\n//\n// The bad news is that it does not appear that these things are going to be\n// solved soon, even in an actively evolving language like JavaScript. The\n// reason is concerns.\n//\n// The good news is that it is not overly hard to \"paper over\" the differences\n// with a set of small efficient functions. And voila, container.js.\n//\n// Different types of containers provide different types of access.\n// A random access container\n// A keyed container\n\nvar ERR_NOT_CONTAINER = 'Expected a container';\nvar ERR_NOT_KEYED_CONTAINER = 'Expected a \"keyed\" container';\n\n/**\n * Checks if argument is an indexable object (not a primitive value, nor null)\n * @param {*} value - JavaScript value to be tested\n * @return {Boolean} - true if argument is a JavaScript object\n */\nfunction isObject(value) {\n  return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n}\n\n/**\n * Checks if argument is a plain object (not a class or array etc)\n * @param {*} value - JavaScript value to be tested\n * @return {Boolean} - true if argument is a plain JavaScript object\n */\nfunction isPlainObject(value) {\n  return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Object;\n}\n\nfunction isContainer(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value) || isObject(value);\n}\n\n/**\n * Deduces numer of elements in a JavaScript container.\n * - Auto-deduction for ES6 containers that define a count() method\n * - Auto-deduction for ES6 containers that define a size member\n * - Auto-deduction for Classic Arrays via the built-in length attribute\n * - Also handles objects, although note that this an O(N) operation\n */\nfunction count(container) {\n  // Check if ES6 collection \"count\" function is available\n  if (typeof container.count === 'function') {\n    return container.count();\n  }\n\n  // Check if ES6 collection \"size\" attribute is set\n  if (Number.isFinite(container.size)) {\n    return container.size;\n  }\n\n  // Check if array length attribute is set\n  // Note: checking this last since some ES6 collections (Immutable.js)\n  // emit profuse warnings when trying to access `length` attribute\n  if (Number.isFinite(container.length)) {\n    return container.length;\n  }\n\n  // Note that getting the count of an object is O(N)\n  if (isPlainObject(container)) {\n    var counter = 0;\n    for (var key in container) {\n      // eslint-disable-line\n      counter++;\n    }\n    return counter;\n  }\n\n  throw new Error(ERR_NOT_CONTAINER);\n}\n\n// Returns an iterator over all **values** of a container\n//\n// Note: Keyed containers are expected to provide an `values()` method,\n// with the exception of plain objects which get special handling\n\nfunction values(container) {\n  // HACK - Needed to make buble compiler work\n  if (Array.isArray(container)) {\n    return container;\n  }\n\n  var prototype = Object.getPrototypeOf(container);\n  if (typeof prototype.values === 'function') {\n    return container.values();\n  }\n\n  if (typeof container.constructor.values === 'function') {\n    return container.constructor.values(container);\n  }\n\n  var iterator = container[Symbol.iterator];\n  if (iterator) {\n    return container;\n  }\n\n  throw new Error(ERR_NOT_CONTAINER);\n}\n\n// /////////////////////////////////////////////////////////\n// KEYED CONTAINERS\n// Examples: objects, Map, Immutable.Map, ...\n\nfunction isKeyedContainer(container) {\n  if (Array.isArray(container)) {\n    return false;\n  }\n  var prototype = Object.getPrototypeOf(container);\n  // HACK to classify Immutable.List as non keyed container\n  if (typeof prototype.shift === 'function') {\n    return false;\n  }\n  var hasKeyedMethods = typeof prototype.get === 'function';\n  return hasKeyedMethods || isPlainObject(container);\n}\n\n// Returns an iterator over all **entries** of a \"keyed container\"\n// Keyed containers are expected to provide a `keys()` method,\n// with the exception of plain objects.\n//\nfunction keys(keyedContainer) {\n  var prototype = Object.getPrototypeOf(keyedContainer);\n  if (typeof prototype.keys === 'function') {\n    return keyedContainer.keys();\n  }\n\n  if (typeof keyedContainer.constructor.keys === 'function') {\n    return keyedContainer.constructor.keys(keyedContainer);\n  }\n\n  throw new Error(ERR_NOT_KEYED_CONTAINER);\n}\n\n// Returns an iterator over all **entries** of a \"keyed container\"\n//\n// Keyed containers are expected to provide an `entries()` method,\n// with the exception of plain objects.\n//\nfunction entries(keyedContainer) {\n  var prototype = Object.getPrototypeOf(keyedContainer);\n  if (typeof prototype.entries === 'function') {\n    return keyedContainer.entries();\n  }\n\n  // if (typeof prototype.constructor.entries === 'function') {\n  //   return prototype.constructor.entries(keyedContainer);\n  // }\n\n  if (typeof keyedContainer.constructor.entries === 'function') {\n    return keyedContainer.constructor.entries(keyedContainer);\n  }\n\n  return null;\n}\n\n/**\n * Access properties of nested containers using dot-path notation\n * - Supports plain objects and arrays, as well as classes with `get` methods\n *   such as ES6 Maps, Immutable.js objects etc\n * - Returns undefined if any container is not valid, instead of throwing\n *\n * @param {Object} container - container that supports get\n * @param {String|*} compositeKey - key to access, can be '.'-separated string\n * @return {*} - value in the final key of the nested container\n */\nfunction get(container, compositeKey) {\n  // Split the key into subkeys\n  var keyList = getKeys(compositeKey);\n  // Recursively get the value of each key;\n  var value = container;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = keyList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      // If any intermediate subfield is not a container, return undefined\n      if (!isObject(value)) {\n        return undefined;\n      }\n      // Get the `getter` for this container\n      var getter = getGetter(value);\n      // Use the getter to get the value for the key\n      value = getter(value, key);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return value;\n}\n\n// Default getter is container indexing\nvar squareBracketGetter = function squareBracketGetter(container, key) {\n  return container[key];\n};\nvar getMethodGetter = function getMethodGetter(obj, key) {\n  return obj.get(key);\n};\n// Cache key to key arrays for speed\nvar keyMap = {};\n\n// Looks for a `get` function on the prototype\n// TODO - follow prototype chain?\n// @private\n// @return {Function} - get function: (container, key) => value\nfunction getGetter(container) {\n  // Check if container has a special get method\n  var prototype = Object.getPrototypeOf(container);\n  return prototype.get ? getMethodGetter : squareBracketGetter;\n}\n\n// Takes a string of '.' separated keys and returns an array of keys\n// E.g. 'feature.geometry.type' => 'feature', 'geometry', 'type'\n// @private\nfunction getKeys(compositeKey) {\n  if (typeof compositeKey === 'string') {\n    // else assume string and split around dots\n    var keyList = keyMap[compositeKey];\n    if (!keyList) {\n      keyList = compositeKey.split('.');\n      keyMap[compositeKey] = keyList;\n    }\n    return keyList;\n  }\n  // Wrap in array if needed\n  return Array.isArray(compositeKey) ? compositeKey : [compositeKey];\n}\n\n// \"Generic\" forEach that first attempts to call a\nfunction forEach(container, visitor) {\n  // Hack to work around limitations in buble compiler\n  var prototype = Object.getPrototypeOf(container);\n  if (prototype.forEach) {\n    container.forEach(visitor);\n    return;\n  }\n\n  var isKeyed = isKeyedContainer(container);\n  if (isKeyed) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = entries(container)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            key = _step2$value[0],\n            value = _step2$value[1];\n\n        visitor(value, key, container);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return;\n  }\n\n  var index = 0;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = values(container)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var element = _step3.value;\n\n      // result[index] = visitor(element, index, container);\n      visitor(element, index, container);\n      index++;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n}\n\nfunction map(container, visitor) {\n  // Hack to work around limitations in buble compiler\n  var prototype = Object.getPrototypeOf(container);\n  if (prototype.forEach) {\n    var _ret = function () {\n      var result = [];\n      container.forEach(function (x, i, e) {\n        return result.push(visitor(x, i, e));\n      });\n      return {\n        v: result\n      };\n    }();\n\n    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n  }\n\n  var isKeyed = isKeyedContainer(container);\n  // const result = new Array(count(container));\n  var result = [];\n  if (isKeyed) {\n    // TODO - should this create an object?\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = entries(container)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _step4$value = _slicedToArray(_step4.value, 2),\n            key = _step4$value[0],\n            value = _step4$value[1];\n\n        // result[index] = visitor(element, index, container);\n        result.push(visitor(value, key, container));\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  } else {\n    var index = 0;\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = values(container)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var element = _step5.value;\n\n        // result[index] = visitor(element, index, container);\n        result.push(visitor(element, index, container));\n        index++;\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n  }\n  return result;\n}\n\nfunction reduce(container, visitor) {\n  // Hack to work around limitations in buble compiler\n  var prototype = Object.getPrototypeOf(container);\n  if (prototype.forEach) {\n    var _ret2 = function () {\n      var result = [];\n      container.forEach(function (x, i, e) {\n        return result.push(visitor(x, i, e));\n      });\n      return {\n        v: result\n      };\n    }();\n\n    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n  }\n\n  var isKeyed = isKeyedContainer(container);\n  // const result = new Array(count(container));\n  var result = [];\n  if (isKeyed) {\n    // TODO - should this create an object?\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = entries(container)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var _step6$value = _slicedToArray(_step6.value, 2),\n            key = _step6$value[0],\n            value = _step6$value[1];\n\n        // result[index] = visitor(element, index, container);\n        result.push(visitor(value, key, container));\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  } else {\n    var index = 0;\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = values(container)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var element = _step7.value;\n\n        // result[index] = visitor(element, index, container);\n        result.push(visitor(element, index, container));\n        index++;\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// Attempt to create a simple (array, plain object) representation of\n// a nested structure of ES6 iterable classes.\n// Assumption is that if an entries() method is available, the iterable object\n// should be represented as an object, if not as an array.\nfunction toJS(container) {\n  if (!isObject(container)) {\n    return container;\n  }\n\n  if (isKeyedContainer(container)) {\n    var _result = {};\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      for (var _iterator8 = entries(container)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _step8$value = _slicedToArray(_step8.value, 2),\n            key = _step8$value[0],\n            value = _step8$value[1];\n\n        _result[key] = toJS(value);\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n\n    return _result;\n  }\n\n  var result = [];\n  var _iteratorNormalCompletion9 = true;\n  var _didIteratorError9 = false;\n  var _iteratorError9 = undefined;\n\n  try {\n    for (var _iterator9 = values(container)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n      var value = _step9.value;\n\n      result.push(toJS(value));\n    }\n  } catch (err) {\n    _didIteratorError9 = true;\n    _iteratorError9 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion9 && _iterator9.return) {\n        _iterator9.return();\n      }\n    } finally {\n      if (_didIteratorError9) {\n        throw _iteratorError9;\n      }\n    }\n  }\n\n  return result;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9saWIvdXRpbHMvY29udGFpbmVyLmpzPzMyNzAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8vIEVTNiBpbmNsdWRlcyBpdGVyYXRpb24gYW5kIGl0ZXJhYmxlIHByb3RvY29scywgYW5kIG5ldyBzdGFuZGFyZCBjb250YWluZXJzXG4vLyBJbmZsdWVudGlhbCBsaWJyYXJpZXMgbGlrZSBJbW11dGFibGUuanMgcHJvdmlkZSB1c2VmdWwgY29udGFpbmVycyB0aGF0XG4vLyBhZG9wdCB0aGVzZSBjb252ZW50aW9ucy5cbi8vXG4vLyBTbywgaXMgaXQgcG9zc2libGUgdG8gd3JpdGUgZ2VuZXJpYyBKYXZhU2NyaXB0IGNvZGUgdGhhdCB3b3JrcyB3aXRoIGFueVxuLy8gd2VsbC13cml0dGVuIGNvbnRhaW5lciBjbGFzcz8gQW5kIGlzIGl0IHBvc3NpYmxlIHRvIHdyaXRlIGdlbmVyaWMgY29udGFpbmVyXG4vLyBjbGFzc2VzIHRoYXQgd29yayB3aXRoIGFueSB3ZWxsLXdyaXR0ZW4gY29kZS5cbi8vXG4vLyBBbG1vc3QuIEJ1dCBpdCBpcyBub3QgdHJpdmlhbC4gSW1wb3J0YW50bHkgdGhlIHN0YW5kYXJkIEphdmFTY3JpcHQgYE9iamVjdGBzXG4vLyBsYWNrIGV2ZW4gYmFzaWMgaXRlcmF0aW9uIHN1cHBvcnQgYW5kIGV2ZW4gc3RhbmRhcmQgSmF2YVNjcmlwdCBgQXJyYXlgc1xuLy8gZGlmZmVyIGluIG1pbm9yIGJ1dCBpbXBvcnRhbnQgYXNwZWN0cyBmcm9tIHRoZSBuZXcgY2xhc3Nlcy5cbi8vXG4vLyBUaGUgYmFkIG5ld3MgaXMgdGhhdCBpdCBkb2VzIG5vdCBhcHBlYXIgdGhhdCB0aGVzZSB0aGluZ3MgYXJlIGdvaW5nIHRvIGJlXG4vLyBzb2x2ZWQgc29vbiwgZXZlbiBpbiBhbiBhY3RpdmVseSBldm9sdmluZyBsYW5ndWFnZSBsaWtlIEphdmFTY3JpcHQuIFRoZVxuLy8gcmVhc29uIGlzIGNvbmNlcm5zLlxuLy9cbi8vIFRoZSBnb29kIG5ld3MgaXMgdGhhdCBpdCBpcyBub3Qgb3Zlcmx5IGhhcmQgdG8gXCJwYXBlciBvdmVyXCIgdGhlIGRpZmZlcmVuY2VzXG4vLyB3aXRoIGEgc2V0IG9mIHNtYWxsIGVmZmljaWVudCBmdW5jdGlvbnMuIEFuZCB2b2lsYSwgY29udGFpbmVyLmpzLlxuLy9cbi8vIERpZmZlcmVudCB0eXBlcyBvZiBjb250YWluZXJzIHByb3ZpZGUgZGlmZmVyZW50IHR5cGVzIG9mIGFjY2Vzcy5cbi8vIEEgcmFuZG9tIGFjY2VzcyBjb250YWluZXJcbi8vIEEga2V5ZWQgY29udGFpbmVyXG5cbnZhciBFUlJfTk9UX0NPTlRBSU5FUiA9ICdFeHBlY3RlZCBhIGNvbnRhaW5lcic7XG52YXIgRVJSX05PVF9LRVlFRF9DT05UQUlORVIgPSAnRXhwZWN0ZWQgYSBcImtleWVkXCIgY29udGFpbmVyJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYXJndW1lbnQgaXMgYW4gaW5kZXhhYmxlIG9iamVjdCAobm90IGEgcHJpbWl0aXZlIHZhbHVlLCBub3IgbnVsbClcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBKYXZhU2NyaXB0IHZhbHVlIHRvIGJlIHRlc3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIGFyZ3VtZW50IGlzIGEgSmF2YVNjcmlwdCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYXJndW1lbnQgaXMgYSBwbGFpbiBvYmplY3QgKG5vdCBhIGNsYXNzIG9yIGFycmF5IGV0YylcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBKYXZhU2NyaXB0IHZhbHVlIHRvIGJlIHRlc3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIGFyZ3VtZW50IGlzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbnRhaW5lcih2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogRGVkdWNlcyBudW1lciBvZiBlbGVtZW50cyBpbiBhIEphdmFTY3JpcHQgY29udGFpbmVyLlxuICogLSBBdXRvLWRlZHVjdGlvbiBmb3IgRVM2IGNvbnRhaW5lcnMgdGhhdCBkZWZpbmUgYSBjb3VudCgpIG1ldGhvZFxuICogLSBBdXRvLWRlZHVjdGlvbiBmb3IgRVM2IGNvbnRhaW5lcnMgdGhhdCBkZWZpbmUgYSBzaXplIG1lbWJlclxuICogLSBBdXRvLWRlZHVjdGlvbiBmb3IgQ2xhc3NpYyBBcnJheXMgdmlhIHRoZSBidWlsdC1pbiBsZW5ndGggYXR0cmlidXRlXG4gKiAtIEFsc28gaGFuZGxlcyBvYmplY3RzLCBhbHRob3VnaCBub3RlIHRoYXQgdGhpcyBhbiBPKE4pIG9wZXJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY291bnQoY29udGFpbmVyKSB7XG4gIC8vIENoZWNrIGlmIEVTNiBjb2xsZWN0aW9uIFwiY291bnRcIiBmdW5jdGlvbiBpcyBhdmFpbGFibGVcbiAgaWYgKHR5cGVvZiBjb250YWluZXIuY291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmNvdW50KCk7XG4gIH1cblxuICAvLyBDaGVjayBpZiBFUzYgY29sbGVjdGlvbiBcInNpemVcIiBhdHRyaWJ1dGUgaXMgc2V0XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoY29udGFpbmVyLnNpemUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5zaXplO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgYXJyYXkgbGVuZ3RoIGF0dHJpYnV0ZSBpcyBzZXRcbiAgLy8gTm90ZTogY2hlY2tpbmcgdGhpcyBsYXN0IHNpbmNlIHNvbWUgRVM2IGNvbGxlY3Rpb25zIChJbW11dGFibGUuanMpXG4gIC8vIGVtaXQgcHJvZnVzZSB3YXJuaW5ncyB3aGVuIHRyeWluZyB0byBhY2Nlc3MgYGxlbmd0aGAgYXR0cmlidXRlXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoY29udGFpbmVyLmxlbmd0aCkpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmxlbmd0aDtcbiAgfVxuXG4gIC8vIE5vdGUgdGhhdCBnZXR0aW5nIHRoZSBjb3VudCBvZiBhbiBvYmplY3QgaXMgTyhOKVxuICBpZiAoaXNQbGFpbk9iamVjdChjb250YWluZXIpKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIGZvciAodmFyIGtleSBpbiBjb250YWluZXIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGNvdW50ZXIrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX05PVF9DT05UQUlORVIpO1xufVxuXG4vLyBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgYWxsICoqdmFsdWVzKiogb2YgYSBjb250YWluZXJcbi8vXG4vLyBOb3RlOiBLZXllZCBjb250YWluZXJzIGFyZSBleHBlY3RlZCB0byBwcm92aWRlIGFuIGB2YWx1ZXMoKWAgbWV0aG9kLFxuLy8gd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHBsYWluIG9iamVjdHMgd2hpY2ggZ2V0IHNwZWNpYWwgaGFuZGxpbmdcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlcyhjb250YWluZXIpIHtcbiAgLy8gSEFDSyAtIE5lZWRlZCB0byBtYWtlIGJ1YmxlIGNvbXBpbGVyIHdvcmtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29udGFpbmVyKSkge1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnRhaW5lcik7XG4gIGlmICh0eXBlb2YgcHJvdG90eXBlLnZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjb250YWluZXIudmFsdWVzKCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRhaW5lci5jb25zdHJ1Y3Rvci52YWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmNvbnN0cnVjdG9yLnZhbHVlcyhjb250YWluZXIpO1xuICB9XG5cbiAgdmFyIGl0ZXJhdG9yID0gY29udGFpbmVyW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmIChpdGVyYXRvcikge1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX05PVF9DT05UQUlORVIpO1xufVxuXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEtFWUVEIENPTlRBSU5FUlNcbi8vIEV4YW1wbGVzOiBvYmplY3RzLCBNYXAsIEltbXV0YWJsZS5NYXAsIC4uLlxuXG5leHBvcnQgZnVuY3Rpb24gaXNLZXllZENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29udGFpbmVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnRhaW5lcik7XG4gIC8vIEhBQ0sgdG8gY2xhc3NpZnkgSW1tdXRhYmxlLkxpc3QgYXMgbm9uIGtleWVkIGNvbnRhaW5lclxuICBpZiAodHlwZW9mIHByb3RvdHlwZS5zaGlmdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaGFzS2V5ZWRNZXRob2RzID0gdHlwZW9mIHByb3RvdHlwZS5nZXQgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiBoYXNLZXllZE1ldGhvZHMgfHwgaXNQbGFpbk9iamVjdChjb250YWluZXIpO1xufVxuXG4vLyBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgYWxsICoqZW50cmllcyoqIG9mIGEgXCJrZXllZCBjb250YWluZXJcIlxuLy8gS2V5ZWQgY29udGFpbmVycyBhcmUgZXhwZWN0ZWQgdG8gcHJvdmlkZSBhIGBrZXlzKClgIG1ldGhvZCxcbi8vIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBwbGFpbiBvYmplY3RzLlxuLy9cbmV4cG9ydCBmdW5jdGlvbiBrZXlzKGtleWVkQ29udGFpbmVyKSB7XG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoa2V5ZWRDb250YWluZXIpO1xuICBpZiAodHlwZW9mIHByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGtleWVkQ29udGFpbmVyLmtleXMoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5ZWRDb250YWluZXIuY29uc3RydWN0b3Iua2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBrZXllZENvbnRhaW5lci5jb25zdHJ1Y3Rvci5rZXlzKGtleWVkQ29udGFpbmVyKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihFUlJfTk9UX0tFWUVEX0NPTlRBSU5FUik7XG59XG5cbi8vIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciBhbGwgKiplbnRyaWVzKiogb2YgYSBcImtleWVkIGNvbnRhaW5lclwiXG4vL1xuLy8gS2V5ZWQgY29udGFpbmVycyBhcmUgZXhwZWN0ZWQgdG8gcHJvdmlkZSBhbiBgZW50cmllcygpYCBtZXRob2QsXG4vLyB3aXRoIHRoZSBleGNlcHRpb24gb2YgcGxhaW4gb2JqZWN0cy5cbi8vXG5leHBvcnQgZnVuY3Rpb24gZW50cmllcyhrZXllZENvbnRhaW5lcikge1xuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGtleWVkQ29udGFpbmVyKTtcbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBrZXllZENvbnRhaW5lci5lbnRyaWVzKCk7XG4gIH1cblxuICAvLyBpZiAodHlwZW9mIHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5lbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgcmV0dXJuIHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5lbnRyaWVzKGtleWVkQ29udGFpbmVyKTtcbiAgLy8gfVxuXG4gIGlmICh0eXBlb2Yga2V5ZWRDb250YWluZXIuY29uc3RydWN0b3IuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBrZXllZENvbnRhaW5lci5jb25zdHJ1Y3Rvci5lbnRyaWVzKGtleWVkQ29udGFpbmVyKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEFjY2VzcyBwcm9wZXJ0aWVzIG9mIG5lc3RlZCBjb250YWluZXJzIHVzaW5nIGRvdC1wYXRoIG5vdGF0aW9uXG4gKiAtIFN1cHBvcnRzIHBsYWluIG9iamVjdHMgYW5kIGFycmF5cywgYXMgd2VsbCBhcyBjbGFzc2VzIHdpdGggYGdldGAgbWV0aG9kc1xuICogICBzdWNoIGFzIEVTNiBNYXBzLCBJbW11dGFibGUuanMgb2JqZWN0cyBldGNcbiAqIC0gUmV0dXJucyB1bmRlZmluZWQgaWYgYW55IGNvbnRhaW5lciBpcyBub3QgdmFsaWQsIGluc3RlYWQgb2YgdGhyb3dpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyIC0gY29udGFpbmVyIHRoYXQgc3VwcG9ydHMgZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ3wqfSBjb21wb3NpdGVLZXkgLSBrZXkgdG8gYWNjZXNzLCBjYW4gYmUgJy4nLXNlcGFyYXRlZCBzdHJpbmdcbiAqIEByZXR1cm4geyp9IC0gdmFsdWUgaW4gdGhlIGZpbmFsIGtleSBvZiB0aGUgbmVzdGVkIGNvbnRhaW5lclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGNvbnRhaW5lciwgY29tcG9zaXRlS2V5KSB7XG4gIC8vIFNwbGl0IHRoZSBrZXkgaW50byBzdWJrZXlzXG4gIHZhciBrZXlMaXN0ID0gZ2V0S2V5cyhjb21wb3NpdGVLZXkpO1xuICAvLyBSZWN1cnNpdmVseSBnZXQgdGhlIHZhbHVlIG9mIGVhY2gga2V5O1xuICB2YXIgdmFsdWUgPSBjb250YWluZXI7XG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGtleUxpc3RbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIC8vIElmIGFueSBpbnRlcm1lZGlhdGUgc3ViZmllbGQgaXMgbm90IGEgY29udGFpbmVyLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgLy8gR2V0IHRoZSBgZ2V0dGVyYCBmb3IgdGhpcyBjb250YWluZXJcbiAgICAgIHZhciBnZXR0ZXIgPSBnZXRHZXR0ZXIodmFsdWUpO1xuICAgICAgLy8gVXNlIHRoZSBnZXR0ZXIgdG8gZ2V0IHRoZSB2YWx1ZSBmb3IgdGhlIGtleVxuICAgICAgdmFsdWUgPSBnZXR0ZXIodmFsdWUsIGtleSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gRGVmYXVsdCBnZXR0ZXIgaXMgY29udGFpbmVyIGluZGV4aW5nXG52YXIgc3F1YXJlQnJhY2tldEdldHRlciA9IGZ1bmN0aW9uIHNxdWFyZUJyYWNrZXRHZXR0ZXIoY29udGFpbmVyLCBrZXkpIHtcbiAgcmV0dXJuIGNvbnRhaW5lcltrZXldO1xufTtcbnZhciBnZXRNZXRob2RHZXR0ZXIgPSBmdW5jdGlvbiBnZXRNZXRob2RHZXR0ZXIob2JqLCBrZXkpIHtcbiAgcmV0dXJuIG9iai5nZXQoa2V5KTtcbn07XG4vLyBDYWNoZSBrZXkgdG8ga2V5IGFycmF5cyBmb3Igc3BlZWRcbnZhciBrZXlNYXAgPSB7fTtcblxuLy8gTG9va3MgZm9yIGEgYGdldGAgZnVuY3Rpb24gb24gdGhlIHByb3RvdHlwZVxuLy8gVE9ETyAtIGZvbGxvdyBwcm90b3R5cGUgY2hhaW4/XG4vLyBAcHJpdmF0ZVxuLy8gQHJldHVybiB7RnVuY3Rpb259IC0gZ2V0IGZ1bmN0aW9uOiAoY29udGFpbmVyLCBrZXkpID0+IHZhbHVlXG5mdW5jdGlvbiBnZXRHZXR0ZXIoY29udGFpbmVyKSB7XG4gIC8vIENoZWNrIGlmIGNvbnRhaW5lciBoYXMgYSBzcGVjaWFsIGdldCBtZXRob2RcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb250YWluZXIpO1xuICByZXR1cm4gcHJvdG90eXBlLmdldCA/IGdldE1ldGhvZEdldHRlciA6IHNxdWFyZUJyYWNrZXRHZXR0ZXI7XG59XG5cbi8vIFRha2VzIGEgc3RyaW5nIG9mICcuJyBzZXBhcmF0ZWQga2V5cyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBrZXlzXG4vLyBFLmcuICdmZWF0dXJlLmdlb21ldHJ5LnR5cGUnID0+ICdmZWF0dXJlJywgJ2dlb21ldHJ5JywgJ3R5cGUnXG4vLyBAcHJpdmF0ZVxuZnVuY3Rpb24gZ2V0S2V5cyhjb21wb3NpdGVLZXkpIHtcbiAgaWYgKHR5cGVvZiBjb21wb3NpdGVLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZWxzZSBhc3N1bWUgc3RyaW5nIGFuZCBzcGxpdCBhcm91bmQgZG90c1xuICAgIHZhciBrZXlMaXN0ID0ga2V5TWFwW2NvbXBvc2l0ZUtleV07XG4gICAgaWYgKCFrZXlMaXN0KSB7XG4gICAgICBrZXlMaXN0ID0gY29tcG9zaXRlS2V5LnNwbGl0KCcuJyk7XG4gICAgICBrZXlNYXBbY29tcG9zaXRlS2V5XSA9IGtleUxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBrZXlMaXN0O1xuICB9XG4gIC8vIFdyYXAgaW4gYXJyYXkgaWYgbmVlZGVkXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGNvbXBvc2l0ZUtleSkgPyBjb21wb3NpdGVLZXkgOiBbY29tcG9zaXRlS2V5XTtcbn1cblxuLy8gXCJHZW5lcmljXCIgZm9yRWFjaCB0aGF0IGZpcnN0IGF0dGVtcHRzIHRvIGNhbGwgYVxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2goY29udGFpbmVyLCB2aXNpdG9yKSB7XG4gIC8vIEhhY2sgdG8gd29yayBhcm91bmQgbGltaXRhdGlvbnMgaW4gYnVibGUgY29tcGlsZXJcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb250YWluZXIpO1xuICBpZiAocHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICBjb250YWluZXIuZm9yRWFjaCh2aXNpdG9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaXNLZXllZCA9IGlzS2V5ZWRDb250YWluZXIoY29udGFpbmVyKTtcbiAgaWYgKGlzS2V5ZWQpIHtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBlbnRyaWVzKGNvbnRhaW5lcilbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICBrZXkgPSBfc3RlcDIkdmFsdWVbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IF9zdGVwMiR2YWx1ZVsxXTtcblxuICAgICAgICB2aXNpdG9yKHZhbHVlLCBrZXksIGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSB2YWx1ZXMoY29udGFpbmVyKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgIC8vIHJlc3VsdFtpbmRleF0gPSB2aXNpdG9yKGVsZW1lbnQsIGluZGV4LCBjb250YWluZXIpO1xuICAgICAgdmlzaXRvcihlbGVtZW50LCBpbmRleCwgY29udGFpbmVyKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcChjb250YWluZXIsIHZpc2l0b3IpIHtcbiAgLy8gSGFjayB0byB3b3JrIGFyb3VuZCBsaW1pdGF0aW9ucyBpbiBidWJsZSBjb21waWxlclxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnRhaW5lcik7XG4gIGlmIChwcm90b3R5cGUuZm9yRWFjaCkge1xuICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgY29udGFpbmVyLmZvckVhY2goZnVuY3Rpb24gKHgsIGksIGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5wdXNoKHZpc2l0b3IoeCwgaSwgZSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiByZXN1bHRcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgaWYgKCh0eXBlb2YgX3JldCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldCkpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICB9XG5cbiAgdmFyIGlzS2V5ZWQgPSBpc0tleWVkQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIC8vIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShjb3VudChjb250YWluZXIpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoaXNLZXllZCkge1xuICAgIC8vIFRPRE8gLSBzaG91bGQgdGhpcyBjcmVhdGUgYW4gb2JqZWN0P1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IGVudHJpZXMoY29udGFpbmVyKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA0LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIGtleSA9IF9zdGVwNCR2YWx1ZVswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX3N0ZXA0JHZhbHVlWzFdO1xuXG4gICAgICAgIC8vIHJlc3VsdFtpbmRleF0gPSB2aXNpdG9yKGVsZW1lbnQsIGluZGV4LCBjb250YWluZXIpO1xuICAgICAgICByZXN1bHQucHVzaCh2aXNpdG9yKHZhbHVlLCBrZXksIGNvbnRhaW5lcikpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybikge1xuICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSB2YWx1ZXMoY29udGFpbmVyKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IChfc3RlcDUgPSBfaXRlcmF0b3I1Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IF9zdGVwNS52YWx1ZTtcblxuICAgICAgICAvLyByZXN1bHRbaW5kZXhdID0gdmlzaXRvcihlbGVtZW50LCBpbmRleCwgY29udGFpbmVyKTtcbiAgICAgICAgcmVzdWx0LnB1c2godmlzaXRvcihlbGVtZW50LCBpbmRleCwgY29udGFpbmVyKSk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvcjUgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlKGNvbnRhaW5lciwgdmlzaXRvcikge1xuICAvLyBIYWNrIHRvIHdvcmsgYXJvdW5kIGxpbWl0YXRpb25zIGluIGJ1YmxlIGNvbXBpbGVyXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29udGFpbmVyKTtcbiAgaWYgKHByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgdmFyIF9yZXQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgY29udGFpbmVyLmZvckVhY2goZnVuY3Rpb24gKHgsIGksIGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5wdXNoKHZpc2l0b3IoeCwgaSwgZSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiByZXN1bHRcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgaWYgKCh0eXBlb2YgX3JldDIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQyKSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0Mi52O1xuICB9XG5cbiAgdmFyIGlzS2V5ZWQgPSBpc0tleWVkQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIC8vIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShjb3VudChjb250YWluZXIpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoaXNLZXllZCkge1xuICAgIC8vIFRPRE8gLSBzaG91bGQgdGhpcyBjcmVhdGUgYW4gb2JqZWN0P1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvcjYgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IGVudHJpZXMoY29udGFpbmVyKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IChfc3RlcDYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZSkge1xuICAgICAgICB2YXIgX3N0ZXA2JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA2LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIGtleSA9IF9zdGVwNiR2YWx1ZVswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX3N0ZXA2JHZhbHVlWzFdO1xuXG4gICAgICAgIC8vIHJlc3VsdFtpbmRleF0gPSB2aXNpdG9yKGVsZW1lbnQsIGluZGV4LCBjb250YWluZXIpO1xuICAgICAgICByZXN1bHQucHVzaCh2aXNpdG9yKHZhbHVlLCBrZXksIGNvbnRhaW5lcikpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yNiA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiAmJiBfaXRlcmF0b3I2LnJldHVybikge1xuICAgICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjcgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3I3ID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSB2YWx1ZXMoY29udGFpbmVyKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IChfc3RlcDcgPSBfaXRlcmF0b3I3Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IF9zdGVwNy52YWx1ZTtcblxuICAgICAgICAvLyByZXN1bHRbaW5kZXhdID0gdmlzaXRvcihlbGVtZW50LCBpbmRleCwgY29udGFpbmVyKTtcbiAgICAgICAgcmVzdWx0LnB1c2godmlzaXRvcihlbGVtZW50LCBpbmRleCwgY29udGFpbmVyKSk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3I3ID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ICYmIF9pdGVyYXRvcjcucmV0dXJuKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNy5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNykge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBBdHRlbXB0IHRvIGNyZWF0ZSBhIHNpbXBsZSAoYXJyYXksIHBsYWluIG9iamVjdCkgcmVwcmVzZW50YXRpb24gb2Zcbi8vIGEgbmVzdGVkIHN0cnVjdHVyZSBvZiBFUzYgaXRlcmFibGUgY2xhc3Nlcy5cbi8vIEFzc3VtcHRpb24gaXMgdGhhdCBpZiBhbiBlbnRyaWVzKCkgbWV0aG9kIGlzIGF2YWlsYWJsZSwgdGhlIGl0ZXJhYmxlIG9iamVjdFxuLy8gc2hvdWxkIGJlIHJlcHJlc2VudGVkIGFzIGFuIG9iamVjdCwgaWYgbm90IGFzIGFuIGFycmF5LlxuZXhwb3J0IGZ1bmN0aW9uIHRvSlMoY29udGFpbmVyKSB7XG4gIGlmICghaXNPYmplY3QoY29udGFpbmVyKSkge1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cblxuICBpZiAoaXNLZXllZENvbnRhaW5lcihjb250YWluZXIpKSB7XG4gICAgdmFyIF9yZXN1bHQgPSB7fTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjggPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3I4ID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjggPSBlbnRyaWVzKGNvbnRhaW5lcilbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDg7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSAoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWUpIHtcbiAgICAgICAgdmFyIF9zdGVwOCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOC52YWx1ZSwgMiksXG4gICAgICAgICAgICBrZXkgPSBfc3RlcDgkdmFsdWVbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IF9zdGVwOCR2YWx1ZVsxXTtcblxuICAgICAgICBfcmVzdWx0W2tleV0gPSB0b0pTKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yOCA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvcjggPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggJiYgX2l0ZXJhdG9yOC5yZXR1cm4pIHtcbiAgICAgICAgICBfaXRlcmF0b3I4LnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I4KSB7XG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXN1bHQ7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvcjkgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yOSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjkgPSB2YWx1ZXMoY29udGFpbmVyKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IChfc3RlcDkgPSBfaXRlcmF0b3I5Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZSkge1xuICAgICAgdmFyIHZhbHVlID0gX3N0ZXA5LnZhbHVlO1xuXG4gICAgICByZXN1bHQucHVzaCh0b0pTKHZhbHVlKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvcjkgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yOSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSAmJiBfaXRlcmF0b3I5LnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3I5LnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I5KSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi91dGlscy9jb250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* exports provided: default, createMat4 */
/* exports used: default, createMat4 */
/*!***************************************!*\
  !*** ./src/lib/viewports/viewport.js ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_gl_matrix__);\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = createMat4;\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// eslint-disable\n// View and Projection Matrix management\n\n// gl-matrix is a large dependency for a small module.\n// However since it is used by mapbox etc, it should already be present\n// in most target application bundles.\n\n\nvar IDENTITY = createMat4();\n\nvar Viewport = function () {\n  /**\n   * @classdesc\n   * Manages coordinate system transformations for deck.gl.\n   *\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   *\n   * @class\n   * @param {Object} opt - options\n   * @param {Boolean} mercator=true - Whether to use mercator projection\n   *\n   * @param {Number} opt.width=1 - Width of \"viewport\" or window\n   * @param {Number} opt.height=1 - Height of \"viewport\" or window\n   * @param {Array} opt.center=[0, 0] - Center of viewport\n   *   [longitude, latitude] or [x, y]\n   * @param {Number} opt.scale=1 - Either use scale or zoom\n   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)\n   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)\n   * @param {Number} opt.altitude= - Altitude of camera in screen units\n   *\n   * Web mercator projection short-hand parameters\n   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)\n   */\n  /* eslint-disable complexity */\n  function Viewport() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$width = _ref.width,\n        width = _ref$width === undefined ? 1 : _ref$width,\n        _ref$height = _ref.height,\n        height = _ref$height === undefined ? 1 : _ref$height,\n        _ref$viewMatrix = _ref.viewMatrix,\n        viewMatrix = _ref$viewMatrix === undefined ? IDENTITY : _ref$viewMatrix,\n        _ref$projectionMatrix = _ref.projectionMatrix,\n        projectionMatrix = _ref$projectionMatrix === undefined ? IDENTITY : _ref$projectionMatrix;\n\n    _classCallCheck(this, Viewport);\n\n    // Silently allow apps to send in 0,0\n    this.width = width || 1;\n    this.height = height || 1;\n    this.scale = 1;\n\n    this.viewMatrix = viewMatrix;\n    this.projectionMatrix = projectionMatrix;\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    var vpm = createMat4();\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply(vpm, vpm, this.projectionMatrix);\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // Calculate matrices and scales needed for projection\n    /**\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    var m = createMat4();\n\n    // Scale with viewport window's width and height in pixels\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].scale(m, m, [this.width, this.height, 1]);\n    // Convert to (0, 1)\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].translate(m, m, [0.5, 0.5, 0]);\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].scale(m, m, [0.5, 0.5, 1]);\n    // Project to clip space (-1, 1)\n    __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply(m, m, this.viewProjectionMatrix);\n\n    var mInverse = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n    this.getMatrices = this.getMatrices.bind(this);\n    this.getDistanceScales = this.getDistanceScales.bind(this);\n  }\n  /* eslint-enable complexity */\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n\n\n  _createClass(Viewport, [{\n    key: 'equals',\n    value: function equals(viewport) {\n      if (!(viewport instanceof Viewport)) {\n        return false;\n      }\n\n      return viewport.width === this.width && viewport.height === this.height && __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].equals(viewport.projectionMatrix, this.projectionMatrix) && __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].equals(viewport.viewMatrix, this.viewMatrix);\n    }\n\n    /**\n     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n     * using viewport projection parameters\n     * - [longitude, latitude] to [x, y]\n     * - [longitude, latitude, Z] => [x, y, z]\n     * Note: By default, returns top-left coordinates for canvas/SVG type render\n     *\n     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n     * @param {Object} opts - options\n     * @param {Object} opts.topLeft=true - Whether projected coords are top left\n     * @return {Array} - [x, y] or [x, y, z] in top left coords\n     */\n\n  }, {\n    key: 'project',\n    value: function project(xyz) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$topLeft = _ref2.topLeft,\n          topLeft = _ref2$topLeft === undefined ? true : _ref2$topLeft;\n\n      var Z = xyz[2] || 0;\n      // console.error('projecting non-linear', xyz);\n\n      var _projectFlat2 = this.projectFlat(xyz),\n          _projectFlat3 = _slicedToArray(_projectFlat2, 2),\n          X = _projectFlat3[0],\n          Y = _projectFlat3[1];\n\n      var v = [X, Y, Z, 1];\n      // console.error('projecting linear', v);\n      // vec4.sub(v, v, [this.centerX, this.centerY, 0, 0]);\n      __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].transformMat4(v, v, this.pixelProjectionMatrix);\n      // Divide by w\n      var scale = 1 / v[3];\n      __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].multiply(v, v, [scale, scale, scale, scale]);\n      // console.error('projected', v);\n      var x = v[0],\n          z = v[2];\n\n      var y = topLeft ? this.height - v[1] : v[1];\n      return xyz.length === 2 ? [x, y] : [x, y, z];\n    }\n\n    /**\n     * Unproject pixel coordinates on screen onto world coordinates,\n     * (possibly [lon, lat]) on map.\n     * - [x, y] => [lng, lat]\n     * - [x, y, z] => [lng, lat, Z]\n     * @param {Array} xyz -\n     * @return {Array} - [lng, lat, Z] or [X, Y, Z]\n     */\n\n  }, {\n    key: 'unproject',\n    value: function unproject(xyz) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref3$topLeft = _ref3.topLeft,\n          topLeft = _ref3$topLeft === undefined ? true : _ref3$topLeft;\n\n      // console.error('unprojecting linear', xyz);\n      var _xyz = _slicedToArray(xyz, 3),\n          _xyz$ = _xyz[0],\n          x = _xyz$ === undefined ? 0 : _xyz$,\n          _xyz$2 = _xyz[1],\n          y = _xyz$2 === undefined ? 0 : _xyz$2,\n          _xyz$3 = _xyz[2],\n          z = _xyz$3 === undefined ? 0 : _xyz$3;\n      // const y2 = topLeft ? this.height - 1 - y : y;\n\n\n      var y2 = topLeft ? this.height - y : y;\n      var v = [x, y2, z, 1];\n      __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].transformMat4(v, v, this.pixelUnprojectionMatrix);\n      var scale = 1 / v[3];\n      __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"vec4\"].multiply(v, v, [scale, scale, scale, scale]);\n      // console.error('unprojecting non-linear', v);\n\n      var _unprojectFlat2 = this.unprojectFlat(v),\n          _unprojectFlat3 = _slicedToArray(_unprojectFlat2, 2),\n          x0 = _unprojectFlat3[0],\n          y0 = _unprojectFlat3[1];\n      // console.error('unprojected', [x0, y0]);\n\n\n      var z0 = v[2];\n\n      return xyz.length === 2 ? [x0, y0] : [x0, y0, z0];\n    }\n\n    // NON_LINEAR PROJECTION HOOKS\n    // Used for web meractor projection\n\n    /**\n     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n     * Performs the nonlinear part of the web mercator projection.\n     * Remaining projection is done with 4x4 matrices which also handles\n     * perspective.\n     * @param {Array} lngLat - [lng, lat] coordinates\n     *   Specifies a point on the sphere to project onto the map.\n     * @return {Array} [x,y] coordinates.\n     */\n\n  }, {\n    key: 'projectFlat',\n    value: function projectFlat(_ref4) {\n      var _ref5 = _slicedToArray(_ref4, 2),\n          x = _ref5[0],\n          y = _ref5[1];\n\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n\n      return this._projectFlat.apply(this, arguments);\n    }\n\n    /**\n     * Unproject world point [x,y] on map onto {lat, lon} on sphere\n     * @param {object|Vector} xy - object with {x,y} members\n     *  representing point on projected map plane\n     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n     *   Has toArray method if you need a GeoJSON Array.\n     *   Per cartographic tradition, lat and lon are specified as degrees.\n     */\n\n  }, {\n    key: 'unprojectFlat',\n    value: function unprojectFlat(xyz) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n\n      return this._unprojectFlat.apply(this, arguments);\n    }\n  }, {\n    key: '_projectFlat',\n    value: function _projectFlat(xyz) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n\n      return xyz;\n    }\n  }, {\n    key: '_unprojectFlat',\n    value: function _unprojectFlat(xyz) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n\n      return xyz;\n    }\n  }, {\n    key: 'getMatrices',\n    value: function getMatrices() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref6$modelMatrix = _ref6.modelMatrix,\n          modelMatrix = _ref6$modelMatrix === undefined ? null : _ref6$modelMatrix;\n\n      var modelViewProjectionMatrix = this.viewProjectionMatrix;\n      var pixelProjectionMatrix = this.pixelProjectionMatrix;\n      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;\n\n      if (modelMatrix) {\n        modelViewProjectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply([], this.viewProjectionMatrix, modelMatrix);\n        pixelProjectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].multiply([], this.pixelProjectionMatrix, modelMatrix);\n        pixelUnprojectionMatrix = __WEBPACK_IMPORTED_MODULE_0_gl_matrix__[\"mat4\"].invert([], pixelProjectionMatrix);\n      }\n\n      var matrices = Object.assign({\n        modelViewProjectionMatrix: modelViewProjectionMatrix,\n        viewProjectionMatrix: this.viewProjectionMatrix,\n        viewMatrix: this.viewMatrix,\n        projectionMatrix: this.projectionMatrix,\n\n        // project/unproject between pixels and world\n        pixelProjectionMatrix: pixelProjectionMatrix,\n        pixelUnprojectionMatrix: pixelUnprojectionMatrix,\n\n        width: this.width,\n        height: this.height,\n        scale: this.scale\n      },\n\n      // Subclass can add additional params\n      // TODO - Fragile: better to make base Viewport class aware of all params\n      this._getParams());\n\n      return matrices;\n    }\n  }, {\n    key: 'getDistanceScales',\n    value: function getDistanceScales() {\n      return {\n        pixelsPerMeter: [1, 1, 1],\n        metersPerPixel: [1, 1, 1],\n        pixelsPerDegree: [1, 1, 1],\n        degreesPerPixel: [1, 1, 1]\n      };\n    }\n\n    // INTERNAL METHODS\n\n    // Can be subclassed to add additional fields to `getMatrices`\n\n  }, {\n    key: '_getParams',\n    value: function _getParams() {\n      return {};\n    }\n  }]);\n\n  return Viewport;\n}();\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = Viewport;\nfunction createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9saWIvdmlld3BvcnRzL3ZpZXdwb3J0LmpzP2E1YjAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBlc2xpbnQtZGlzYWJsZVxuLy8gVmlldyBhbmQgUHJvamVjdGlvbiBNYXRyaXggbWFuYWdlbWVudFxuXG4vLyBnbC1tYXRyaXggaXMgYSBsYXJnZSBkZXBlbmRlbmN5IGZvciBhIHNtYWxsIG1vZHVsZS5cbi8vIEhvd2V2ZXIgc2luY2UgaXQgaXMgdXNlZCBieSBtYXBib3ggZXRjLCBpdCBzaG91bGQgYWxyZWFkeSBiZSBwcmVzZW50XG4vLyBpbiBtb3N0IHRhcmdldCBhcHBsaWNhdGlvbiBidW5kbGVzLlxuaW1wb3J0IHsgbWF0NCwgdmVjNCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbnZhciBJREVOVElUWSA9IGNyZWF0ZU1hdDQoKTtcblxudmFyIFZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBNYW5hZ2VzIGNvb3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjay5nbC5cbiAgICpcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWVyY2F0b3I9dHJ1ZSAtIFdoZXRoZXIgdG8gdXNlIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC53aWR0aD0xIC0gV2lkdGggb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmhlaWdodD0xIC0gSGVpZ2h0IG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtBcnJheX0gb3B0LmNlbnRlcj1bMCwgMF0gLSBDZW50ZXIgb2Ygdmlld3BvcnRcbiAgICogICBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gb3IgW3gsIHldXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuc2NhbGU9MSAtIEVpdGhlciB1c2Ugc2NhbGUgb3Igem9vbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnBpdGNoPTAgLSBDYW1lcmEgYW5nbGUgaW4gZGVncmVlcyAoMCBpcyBzdHJhaWdodCBkb3duKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmJlYXJpbmc9MCAtIE1hcCByb3RhdGlvbiBpbiBkZWdyZWVzICgwIG1lYW5zIG5vcnRoIGlzIHVwKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmFsdGl0dWRlPSAtIEFsdGl0dWRlIG9mIGNhbWVyYSBpbiBzY3JlZW4gdW5pdHNcbiAgICpcbiAgICogV2ViIG1lcmNhdG9yIHByb2plY3Rpb24gc2hvcnQtaGFuZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubGF0aXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxvbmdpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuem9vbSAtIFNjYWxlID0gTWF0aC5wb3coMix6b29tKSBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5zY2FsZSlcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgZnVuY3Rpb24gVmlld3BvcnQoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmJHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgICAgd2lkdGggPSBfcmVmJHdpZHRoID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiR3aWR0aCxcbiAgICAgICAgX3JlZiRoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZiRoZWlnaHQgPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmJGhlaWdodCxcbiAgICAgICAgX3JlZiR2aWV3TWF0cml4ID0gX3JlZi52aWV3TWF0cml4LFxuICAgICAgICB2aWV3TWF0cml4ID0gX3JlZiR2aWV3TWF0cml4ID09PSB1bmRlZmluZWQgPyBJREVOVElUWSA6IF9yZWYkdmlld01hdHJpeCxcbiAgICAgICAgX3JlZiRwcm9qZWN0aW9uTWF0cml4ID0gX3JlZi5wcm9qZWN0aW9uTWF0cml4LFxuICAgICAgICBwcm9qZWN0aW9uTWF0cml4ID0gX3JlZiRwcm9qZWN0aW9uTWF0cml4ID09PSB1bmRlZmluZWQgPyBJREVOVElUWSA6IF9yZWYkcHJvamVjdGlvbk1hdHJpeDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3cG9ydCk7XG5cbiAgICAvLyBTaWxlbnRseSBhbGxvdyBhcHBzIHRvIHNlbmQgaW4gMCwwXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMTtcbiAgICB0aGlzLnNjYWxlID0gMTtcblxuICAgIHRoaXMudmlld01hdHJpeCA9IHZpZXdNYXRyaXg7XG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gcHJvamVjdGlvbk1hdHJpeDtcblxuICAgIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9ucyBzaG91bGQgYmUgYXBwbGllZCBpbiBcInJldmVyc2VcIiBvcmRlclxuICAgIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGluIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICAgIHZhciB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC5tdWx0aXBseSh2cG0sIHZwbSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXggPSB2cG07XG5cbiAgICAvLyBDYWxjdWxhdGUgbWF0cmljZXMgYW5kIHNjYWxlcyBuZWVkZWQgZm9yIHByb2plY3Rpb25cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgbWF0cmljZXMgdGhhdCBjb252ZXJ0cyBwcmVwcm9qZWN0ZWQgbG5nTGF0cyB0byBzY3JlZW4gcGl4ZWxzXG4gICAgICogYW5kIHZpY2UgdmVyc2EuXG4gICAgICogTm90ZTogQ3VycmVudGx5IHJldHVybnMgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXMhXG4gICAgICogTm90ZTogU3RhcnRzIHdpdGggdGhlIEdMIHByb2plY3Rpb24gbWF0cml4IGFuZCBhZGRzIHN0ZXBzIHRvIHRoZVxuICAgICAqICAgICAgIHNjYWxlIGFuZCB0cmFuc2xhdGUgdGhhdCBtYXRyaXggb250byB0aGUgd2luZG93LlxuICAgICAqIE5vdGU6IFdlYkdMIGNvbnRyb2xzIGNsaXAgc3BhY2UgdG8gc2NyZWVuIHByb2plY3Rpb24gd2l0aCBnbC52aWV3cG9ydFxuICAgICAqICAgICAgIGFuZCBkb2VzIG5vdCBuZWVkIHRoaXMgc3RlcC5cbiAgICAgKi9cbiAgICB2YXIgbSA9IGNyZWF0ZU1hdDQoKTtcblxuICAgIC8vIFNjYWxlIHdpdGggdmlld3BvcnQgd2luZG93J3Mgd2lkdGggYW5kIGhlaWdodCBpbiBwaXhlbHNcbiAgICBtYXQ0LnNjYWxlKG0sIG0sIFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMV0pO1xuICAgIC8vIENvbnZlcnQgdG8gKDAsIDEpXG4gICAgbWF0NC50cmFuc2xhdGUobSwgbSwgWzAuNSwgMC41LCAwXSk7XG4gICAgbWF0NC5zY2FsZShtLCBtLCBbMC41LCAwLjUsIDFdKTtcbiAgICAvLyBQcm9qZWN0IHRvIGNsaXAgc3BhY2UgKC0xLCAxKVxuICAgIG1hdDQubXVsdGlwbHkobSwgbSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICB2YXIgbUludmVyc2UgPSBtYXQ0LmludmVydChjcmVhdGVNYXQ0KCksIG0pO1xuICAgIGlmICghbUludmVyc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGl4ZWwgcHJvamVjdCBtYXRyaXggbm90IGludmVydGlibGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IG07XG4gICAgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1JbnZlcnNlO1xuXG4gICAgdGhpcy5wcm9qZWN0ID0gdGhpcy5wcm9qZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnByb2plY3QgPSB0aGlzLnVucHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvamVjdEZsYXQgPSB0aGlzLnByb2plY3RGbGF0LmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnByb2plY3RGbGF0ID0gdGhpcy51bnByb2plY3RGbGF0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRNYXRyaWNlcyA9IHRoaXMuZ2V0TWF0cmljZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldERpc3RhbmNlU2NhbGVzID0gdGhpcy5nZXREaXN0YW5jZVNjYWxlcy5iaW5kKHRoaXMpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIC8vIFR3byB2aWV3cG9ydHMgYXJlIGVxdWFsIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGlkZW50aWNhbCwgYW5kIGlmXG4gIC8vIHRoZWlyIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cmljZXMgYXJlIChhcHByb3hpbWF0ZWx5KSBlcXVhbC5cblxuXG4gIF9jcmVhdGVDbGFzcyhWaWV3cG9ydCwgW3tcbiAgICBrZXk6ICdlcXVhbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHModmlld3BvcnQpIHtcbiAgICAgIGlmICghKHZpZXdwb3J0IGluc3RhbmNlb2YgVmlld3BvcnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpZXdwb3J0LndpZHRoID09PSB0aGlzLndpZHRoICYmIHZpZXdwb3J0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiYgbWF0NC5lcXVhbHModmlld3BvcnQucHJvamVjdGlvbk1hdHJpeCwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KSAmJiBtYXQ0LmVxdWFscyh2aWV3cG9ydC52aWV3TWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2plY3RzIHh5eiAocG9zc2libHkgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSkgdG8gcGl4ZWwgY29vcmRpbmF0ZXMgaW4gd2luZG93XG4gICAgICogdXNpbmcgdmlld3BvcnQgcHJvamVjdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gdG8gW3gsIHldXG4gICAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgWl0gPT4gW3gsIHksIHpdXG4gICAgICogTm90ZTogQnkgZGVmYXVsdCwgcmV0dXJucyB0b3AtbGVmdCBjb29yZGluYXRlcyBmb3IgY2FudmFzL1NWRyB0eXBlIHJlbmRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0WiAtIFtsbmcsIGxhdF0gb3IgW2xuZywgbGF0LCBaXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnRvcExlZnQ9dHJ1ZSAtIFdoZXRoZXIgcHJvamVjdGVkIGNvb3JkcyBhcmUgdG9wIGxlZnRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbeCwgeV0gb3IgW3gsIHksIHpdIGluIHRvcCBsZWZ0IGNvb3Jkc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9qZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvamVjdCh4eXopIHtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgICAgX3JlZjIkdG9wTGVmdCA9IF9yZWYyLnRvcExlZnQsXG4gICAgICAgICAgdG9wTGVmdCA9IF9yZWYyJHRvcExlZnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmMiR0b3BMZWZ0O1xuXG4gICAgICB2YXIgWiA9IHh5elsyXSB8fCAwO1xuICAgICAgLy8gY29uc29sZS5lcnJvcigncHJvamVjdGluZyBub24tbGluZWFyJywgeHl6KTtcblxuICAgICAgdmFyIF9wcm9qZWN0RmxhdDIgPSB0aGlzLnByb2plY3RGbGF0KHh5eiksXG4gICAgICAgICAgX3Byb2plY3RGbGF0MyA9IF9zbGljZWRUb0FycmF5KF9wcm9qZWN0RmxhdDIsIDIpLFxuICAgICAgICAgIFggPSBfcHJvamVjdEZsYXQzWzBdLFxuICAgICAgICAgIFkgPSBfcHJvamVjdEZsYXQzWzFdO1xuXG4gICAgICB2YXIgdiA9IFtYLCBZLCBaLCAxXTtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3Byb2plY3RpbmcgbGluZWFyJywgdik7XG4gICAgICAvLyB2ZWM0LnN1Yih2LCB2LCBbdGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIDAsIDBdKTtcbiAgICAgIHZlYzQudHJhbnNmb3JtTWF0NCh2LCB2LCB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICAvLyBEaXZpZGUgYnkgd1xuICAgICAgdmFyIHNjYWxlID0gMSAvIHZbM107XG4gICAgICB2ZWM0Lm11bHRpcGx5KHYsIHYsIFtzY2FsZSwgc2NhbGUsIHNjYWxlLCBzY2FsZV0pO1xuICAgICAgLy8gY29uc29sZS5lcnJvcigncHJvamVjdGVkJywgdik7XG4gICAgICB2YXIgeCA9IHZbMF0sXG4gICAgICAgICAgeiA9IHZbMl07XG5cbiAgICAgIHZhciB5ID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0gdlsxXSA6IHZbMV07XG4gICAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFt4LCB5XSA6IFt4LCB5LCB6XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnByb2plY3QgcGl4ZWwgY29vcmRpbmF0ZXMgb24gc2NyZWVuIG9udG8gd29ybGQgY29vcmRpbmF0ZXMsXG4gICAgICogKHBvc3NpYmx5IFtsb24sIGxhdF0pIG9uIG1hcC5cbiAgICAgKiAtIFt4LCB5XSA9PiBbbG5nLCBsYXRdXG4gICAgICogLSBbeCwgeSwgel0gPT4gW2xuZywgbGF0LCBaXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHh5eiAtXG4gICAgICogQHJldHVybiB7QXJyYXl9IC0gW2xuZywgbGF0LCBaXSBvciBbWCwgWSwgWl1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5wcm9qZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5wcm9qZWN0KHh5eikge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgICBfcmVmMyR0b3BMZWZ0ID0gX3JlZjMudG9wTGVmdCxcbiAgICAgICAgICB0b3BMZWZ0ID0gX3JlZjMkdG9wTGVmdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYzJHRvcExlZnQ7XG5cbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3VucHJvamVjdGluZyBsaW5lYXInLCB4eXopO1xuICAgICAgdmFyIF94eXogPSBfc2xpY2VkVG9BcnJheSh4eXosIDMpLFxuICAgICAgICAgIF94eXokID0gX3h5elswXSxcbiAgICAgICAgICB4ID0gX3h5eiQgPT09IHVuZGVmaW5lZCA/IDAgOiBfeHl6JCxcbiAgICAgICAgICBfeHl6JDIgPSBfeHl6WzFdLFxuICAgICAgICAgIHkgPSBfeHl6JDIgPT09IHVuZGVmaW5lZCA/IDAgOiBfeHl6JDIsXG4gICAgICAgICAgX3h5eiQzID0gX3h5elsyXSxcbiAgICAgICAgICB6ID0gX3h5eiQzID09PSB1bmRlZmluZWQgPyAwIDogX3h5eiQzO1xuICAgICAgLy8gY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSAxIC0geSA6IHk7XG5cblxuICAgICAgdmFyIHkyID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0geSA6IHk7XG4gICAgICB2YXIgdiA9IFt4LCB5MiwgeiwgMV07XG4gICAgICB2ZWM0LnRyYW5zZm9ybU1hdDQodiwgdiwgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICB2YXIgc2NhbGUgPSAxIC8gdlszXTtcbiAgICAgIHZlYzQubXVsdGlwbHkodiwgdiwgW3NjYWxlLCBzY2FsZSwgc2NhbGUsIHNjYWxlXSk7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCd1bnByb2plY3Rpbmcgbm9uLWxpbmVhcicsIHYpO1xuXG4gICAgICB2YXIgX3VucHJvamVjdEZsYXQyID0gdGhpcy51bnByb2plY3RGbGF0KHYpLFxuICAgICAgICAgIF91bnByb2plY3RGbGF0MyA9IF9zbGljZWRUb0FycmF5KF91bnByb2plY3RGbGF0MiwgMiksXG4gICAgICAgICAgeDAgPSBfdW5wcm9qZWN0RmxhdDNbMF0sXG4gICAgICAgICAgeTAgPSBfdW5wcm9qZWN0RmxhdDNbMV07XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCd1bnByb2plY3RlZCcsIFt4MCwgeTBdKTtcblxuXG4gICAgICB2YXIgejAgPSB2WzJdO1xuXG4gICAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFt4MCwgeTBdIDogW3gwLCB5MCwgejBdO1xuICAgIH1cblxuICAgIC8vIE5PTl9MSU5FQVIgUFJPSkVDVElPTiBIT09LU1xuICAgIC8vIFVzZWQgZm9yIHdlYiBtZXJhY3RvciBwcm9qZWN0aW9uXG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICAgICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICAgKiBwZXJzcGVjdGl2ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvamVjdEZsYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9qZWN0RmxhdChfcmVmNCkge1xuICAgICAgdmFyIF9yZWY1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQsIDIpLFxuICAgICAgICAgIHggPSBfcmVmNVswXSxcbiAgICAgICAgICB5ID0gX3JlZjVbMV07XG5cbiAgICAgIHZhciBzY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zY2FsZTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RGbGF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gICAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICAgKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICAgICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VucHJvamVjdEZsYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnByb2plY3RGbGF0KHh5eikge1xuICAgICAgdmFyIHNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNjYWxlO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdW5wcm9qZWN0RmxhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wcm9qZWN0RmxhdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9qZWN0RmxhdCh4eXopIHtcbiAgICAgIHZhciBzY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zY2FsZTtcblxuICAgICAgcmV0dXJuIHh5ejtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfdW5wcm9qZWN0RmxhdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnByb2plY3RGbGF0KHh5eikge1xuICAgICAgdmFyIHNjYWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNjYWxlO1xuXG4gICAgICByZXR1cm4geHl6O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldE1hdHJpY2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF0cmljZXMoKSB7XG4gICAgICB2YXIgX3JlZjYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIF9yZWY2JG1vZGVsTWF0cml4ID0gX3JlZjYubW9kZWxNYXRyaXgsXG4gICAgICAgICAgbW9kZWxNYXRyaXggPSBfcmVmNiRtb2RlbE1hdHJpeCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IF9yZWY2JG1vZGVsTWF0cml4O1xuXG4gICAgICB2YXIgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXg7XG4gICAgICB2YXIgcGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXg7XG4gICAgICB2YXIgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4O1xuXG4gICAgICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5tdWx0aXBseShbXSwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICAgICAgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtYXQ0LmludmVydChbXSwgcGl4ZWxQcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdHJpY2VzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg6IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgICAgIHZpZXdQcm9qZWN0aW9uTWF0cml4OiB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgICB2aWV3TWF0cml4OiB0aGlzLnZpZXdNYXRyaXgsXG4gICAgICAgIHByb2plY3Rpb25NYXRyaXg6IHRoaXMucHJvamVjdGlvbk1hdHJpeCxcblxuICAgICAgICAvLyBwcm9qZWN0L3VucHJvamVjdCBiZXR3ZWVuIHBpeGVscyBhbmQgd29ybGRcbiAgICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4OiBwaXhlbFByb2plY3Rpb25NYXRyaXgsXG4gICAgICAgIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4OiBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCxcblxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGVcbiAgICAgIH0sXG5cbiAgICAgIC8vIFN1YmNsYXNzIGNhbiBhZGQgYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgIC8vIFRPRE8gLSBGcmFnaWxlOiBiZXR0ZXIgdG8gbWFrZSBiYXNlIFZpZXdwb3J0IGNsYXNzIGF3YXJlIG9mIGFsbCBwYXJhbXNcbiAgICAgIHRoaXMuX2dldFBhcmFtcygpKTtcblxuICAgICAgcmV0dXJuIG1hdHJpY2VzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldERpc3RhbmNlU2NhbGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2VTY2FsZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwaXhlbHNQZXJNZXRlcjogWzEsIDEsIDFdLFxuICAgICAgICBtZXRlcnNQZXJQaXhlbDogWzEsIDEsIDFdLFxuICAgICAgICBwaXhlbHNQZXJEZWdyZWU6IFsxLCAxLCAxXSxcbiAgICAgICAgZGVncmVlc1BlclBpeGVsOiBbMSwgMSwgMV1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gICAgLy8gQ2FuIGJlIHN1YmNsYXNzZWQgdG8gYWRkIGFkZGl0aW9uYWwgZmllbGRzIHRvIGBnZXRNYXRyaWNlc2BcblxuICB9LCB7XG4gICAga2V5OiAnX2dldFBhcmFtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRQYXJhbXMoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZXdwb3J0O1xufSgpO1xuXG4vLyBIZWxwZXIsIGF2b2lkcyBsb3ctcHJlY2lzaW9uIDMyIGJpdCBtYXRyaWNlcyBmcm9tIGdsLW1hdHJpeCBtYXQ0LmNyZWF0ZSgpXG5cblxuZXhwb3J0IGRlZmF1bHQgVmlld3BvcnQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWF0NCgpIHtcbiAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdmlld3BvcnRzL3ZpZXdwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 10 */
/* unknown exports provided */
/* exports used: default */
/*!*************************!*\
  !*** external "earcut" ***!
  \*************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_10__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJlYXJjdXRcIj81ZmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xMF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZWFyY3V0XCJcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 11 */
/* exports provided: Effect, EffectManager */
/* exports used: EffectManager, Effect */
/*!***************************************!*\
  !*** ./src/experimental/lib/index.js ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__effect__ = __webpack_require__(/*! ./effect */ 50);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_0__effect__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__effect_manager__ = __webpack_require__(/*! ./effect-manager */ 49);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_1__effect_manager__[\"a\"]; });\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2xpYi9pbmRleC5qcz8wMjk1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgRWZmZWN0IH0gZnJvbSAnLi9lZmZlY3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFZmZlY3RNYW5hZ2VyIH0gZnJvbSAnLi9lZmZlY3QtbWFuYWdlcic7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXhwZXJpbWVudGFsL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 12 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/scatterplot-layer/scatterplot-layer.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 5);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\n\nvar defaultProps = {\n  getPosition: function getPosition(x) {\n    return x.position;\n  },\n  getRadius: function getRadius(x) {\n    return x.radius || 30;\n  },\n  getColor: function getColor(x) {\n    return x.color || DEFAULT_COLOR;\n  },\n  radiusScale: 30, //  point radius in meters\n  radiusMinPixels: 0, //  min point radius in pixels\n  radiusMaxPixels: Number.MAX_SAFE_INTEGER, // max point radius in pixels\n  outline: false,\n  strokeWidth: 1,\n  fp64: false\n};\n\nvar ScatterplotLayer = function (_Layer) {\n  _inherits(ScatterplotLayer, _Layer);\n\n  function ScatterplotLayer() {\n    _classCallCheck(this, ScatterplotLayer);\n\n    return _possibleConstructorReturn(this, (ScatterplotLayer.__proto__ || Object.getPrototypeOf(ScatterplotLayer)).apply(this, arguments));\n  }\n\n  _createClass(ScatterplotLayer, [{\n    key: 'getShaders',\n    value: function getShaders(id) {\n\n      return this.props.fp64 ? {\n        vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME scatterplot-layer-64-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec2 instancePositions64xyLow;\\nattribute float instanceRadius;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\n// Only one-dimensional arrays may be declared in GLSL ES 1.0. specs p.24\\nuniform float opacity;\\nuniform float radiusScale;\\nuniform float radiusMinPixels;\\nuniform float radiusMaxPixels;\\nuniform float renderPickingBuffer;\\nuniform float outline;\\nuniform float strokeWidth;\\n\\nvarying vec4 vColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\n\\nvoid main(void) {\\n  // Multiply out radius and clamp to limits\\n  float outerRadiusPixels = clamp(\\n    project_scale(radiusScale * instanceRadius),\\n    radiusMinPixels, radiusMaxPixels\\n  );\\n\\n  // outline is centered at the radius\\n  // outer radius needs to offset by half stroke width\\n  outerRadiusPixels += outline * strokeWidth / 2.0;\\n\\n  // position on the containing square in [-1, 1] space\\n  unitPosition = positions.xy;\\n  // 0 - solid circle, 1 - stroke with lineWidth=0\\n  innerUnitRadius = outline * (1.0 - strokeWidth / outerRadiusPixels);\\n\\n  vec4 instancePositions64xy = vec4(instancePositions.x, instancePositions64xyLow.x, instancePositions.y, instancePositions64xyLow.y);\\n  vec2 projected_coord_xy[2];\\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\\n\\n  vec2 vertex_pos_localspace[4];\\n  vec4_fp64(vec4(positions * outerRadiusPixels, 0.0), vertex_pos_localspace);\\n\\n  vec2 vertex_pos_modelspace[4];\\n  vertex_pos_modelspace[0] = sum_fp64(vertex_pos_localspace[0], projected_coord_xy[0]);\\n  vertex_pos_modelspace[1] = sum_fp64(vertex_pos_localspace[1], projected_coord_xy[1]);\\n  vertex_pos_modelspace[2] = sum_fp64(vertex_pos_localspace[2], vec2(project_scale(positions.z), 0.0));\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\\n\\n  if (renderPickingBuffer > 0.5) {\\n    vColor = vec4(instancePickingColors / 255., 1.);\\n  } else {\\n    vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  }\\n  // // Apply opacity to instance color, or return instance picking color\\n  // vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  // vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n  // vColor = mix(color, pickingColor, renderPickingBuffer);\\n}\\n',\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME scatterplot-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\n\\nvoid main(void) {\\n\\n  float distToCenter = length(unitPosition);\\n\\n  if (distToCenter <= 1.0 && distToCenter >= innerUnitRadius) {\\n    gl_FragColor = vColor;\\n  } else {\\n    discard;\\n  }\\n}\\n',\n        modules: ['lighting', 'fp64', 'project64']\n      } : {\n        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME scatterplot-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instancePositions;\\nattribute float instanceRadius;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float opacity;\\nuniform float radiusScale;\\nuniform float radiusMinPixels;\\nuniform float radiusMaxPixels;\\nuniform float renderPickingBuffer;\\nuniform float outline;\\nuniform float strokeWidth;\\n\\nvarying vec4 vColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\n\\nvoid main(void) {\\n  // Multiply out radius and clamp to limits\\n  float outerRadiusPixels = clamp(\\n    project_scale(radiusScale * instanceRadius),\\n    radiusMinPixels, radiusMaxPixels\\n  );\\n  // outline is centered at the radius\\n  // outer radius needs to offset by half stroke width\\n  outerRadiusPixels += outline * strokeWidth / 2.0;\\n\\n  // position on the containing square in [-1, 1] space\\n  unitPosition = positions.xy;\\n  // 0 - solid circle, 1 - stroke with lineWidth=0\\n  innerUnitRadius = outline * (1.0 - strokeWidth / outerRadiusPixels);\\n\\n  // Find the center of the point and add the current vertex\\n  vec3 center = project_position(instancePositions);\\n  vec3 vertex = positions * outerRadiusPixels;\\n  gl_Position = project_to_clipspace(vec4(center + vertex, 1.0));\\n\\n  // Apply opacity to instance color, or return instance picking color\\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n  vColor = mix(color, pickingColor, renderPickingBuffer);\\n}\\n',\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME scatterplot-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\n\\nvoid main(void) {\\n\\n  float distToCenter = length(unitPosition);\\n\\n  if (distToCenter <= 1.0 && distToCenter >= innerUnitRadius) {\\n    gl_FragColor = vColor;\\n  } else {\\n    discard;\\n  }\\n}\\n',\n        modules: ['lighting']\n      };\n    }\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      var gl = this.context.gl;\n\n      this.setState({ model: this._getModel(gl) });\n\n      /* eslint-disable max-len */\n      /* deprecated props check */\n      if (this.props.radius !== undefined) {\n        __WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"a\" /* log */].once(0, 'ScatterplotLayer no longer accepts props.radius in this version of deck.gl. Please use props.radiusScale instead.');\n      }\n\n      if (this.props.drawOutline !== undefined) {\n        __WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"a\" /* log */].once(0, 'ScatterplotLayer no longer accepts props.drawOutline in this version of deck.gl. Please use props.outline instead.');\n      }\n\n      this.state.attributeManager.addInstanced({\n        instancePositions: { size: 3, accessor: 'getPosition', update: this.calculateInstancePositions },\n        instanceRadius: { size: 1, accessor: 'getRadius', defaultValue: 1, update: this.calculateInstanceRadius },\n        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }\n      });\n\n      if (this.props.fp64) {\n        this.state.attributeManager.addInstanced({\n          instancePositions64xyLow: { size: 2, accessor: 'getPosition', update: this.calculateInstancePositions64xyLow }\n        });\n      }\n      /* eslint-enable max-len */\n    }\n  }, {\n    key: 'updateModel',\n    value: function updateModel(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      if (props.fp64 !== oldProps.fp64) {\n        var gl = this.context.gl;\n\n        this.setState({ model: this._getModel(gl) });\n      }\n    }\n  }, {\n    key: 'updateAttribute',\n    value: function updateAttribute(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (props.fp64 !== oldProps.fp64) {\n        var attributeManager = this.state.attributeManager;\n\n        attributeManager.invalidateAll();\n\n        if (props.fp64 === true) {\n          attributeManager.addInstanced({\n            instancePositions64xyLow: {\n              size: 2,\n              accessor: 'getPosition',\n              update: this.calculateInstancePositions64xyLow\n            }\n          });\n        } else {\n          attributeManager.remove(['positions64xyLow']);\n        }\n      }\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref3) {\n      var props = _ref3.props,\n          oldProps = _ref3.oldProps,\n          changeFlags = _ref3.changeFlags;\n\n      this.updateModel({ props: props, oldProps: oldProps, changeFlags: changeFlags });\n      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref4) {\n      var uniforms = _ref4.uniforms;\n      var _props = this.props,\n          radiusScale = _props.radiusScale,\n          radiusMinPixels = _props.radiusMinPixels,\n          radiusMaxPixels = _props.radiusMaxPixels,\n          outline = _props.outline,\n          strokeWidth = _props.strokeWidth;\n\n      this.state.model.render(Object.assign({}, uniforms, {\n        outline: outline ? 1 : 0,\n        strokeWidth: strokeWidth,\n        radiusScale: radiusScale,\n        radiusMinPixels: radiusMinPixels,\n        radiusMaxPixels: radiusMaxPixels\n      }));\n    }\n  }, {\n    key: '_getModel',\n    value: function _getModel(gl) {\n      // a square that minimally cover the unit circle\n      var positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_FAN,\n          positions: new Float32Array(positions)\n        }),\n        isInstanced: true\n      });\n    }\n  }, {\n    key: 'calculateInstancePositions',\n    value: function calculateInstancePositions(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getPosition = _props2.getPosition;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var point = _step.value;\n\n          var position = getPosition(point);\n          value[i++] = position[0];\n          value[i++] = position[1];\n          value[i++] = position[2] || 0;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstancePositions64xyLow',\n    value: function calculateInstancePositions64xyLow(attribute) {\n      var _props3 = this.props,\n          data = _props3.data,\n          getPosition = _props3.getPosition;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var point = _step2.value;\n\n          var position = getPosition(point);\n          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__lib_utils_fp64__[\"a\" /* fp64ify */])(position[0])[1];\n          value[i++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__lib_utils_fp64__[\"a\" /* fp64ify */])(position[1])[1];\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceRadius',\n    value: function calculateInstanceRadius(attribute) {\n      var _props4 = this.props,\n          data = _props4.data,\n          getRadius = _props4.getRadius;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var point = _step3.value;\n\n          var radius = getRadius(point);\n          value[i++] = isNaN(radius) ? 1 : radius;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceColors',\n    value: function calculateInstanceColors(attribute) {\n      var _props5 = this.props,\n          data = _props5.data,\n          getColor = _props5.getColor;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var point = _step4.value;\n\n          var color = getColor(point) || DEFAULT_COLOR;\n          value[i++] = color[0];\n          value[i++] = color[1];\n          value[i++] = color[2];\n          value[i++] = isNaN(color[3]) ? 255 : color[3];\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n  }]);\n\n  return ScatterplotLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ScatterplotLayer;\n\n\nScatterplotLayer.layerName = 'ScatterplotLayer';\nScatterplotLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXIuanM/YjdlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBHTCwgTW9kZWwsIEdlb21ldHJ5IH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgeyBmcDY0aWZ5IH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuXG52YXIgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gZ2V0UG9zaXRpb24oeCkge1xuICAgIHJldHVybiB4LnBvc2l0aW9uO1xuICB9LFxuICBnZXRSYWRpdXM6IGZ1bmN0aW9uIGdldFJhZGl1cyh4KSB7XG4gICAgcmV0dXJuIHgucmFkaXVzIHx8IDMwO1xuICB9LFxuICBnZXRDb2xvcjogZnVuY3Rpb24gZ2V0Q29sb3IoeCkge1xuICAgIHJldHVybiB4LmNvbG9yIHx8IERFRkFVTFRfQ09MT1I7XG4gIH0sXG4gIHJhZGl1c1NjYWxlOiAzMCwgLy8gIHBvaW50IHJhZGl1cyBpbiBtZXRlcnNcbiAgcmFkaXVzTWluUGl4ZWxzOiAwLCAvLyAgbWluIHBvaW50IHJhZGl1cyBpbiBwaXhlbHNcbiAgcmFkaXVzTWF4UGl4ZWxzOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgLy8gbWF4IHBvaW50IHJhZGl1cyBpbiBwaXhlbHNcbiAgb3V0bGluZTogZmFsc2UsXG4gIHN0cm9rZVdpZHRoOiAxLFxuICBmcDY0OiBmYWxzZVxufTtcblxudmFyIFNjYXR0ZXJwbG90TGF5ZXIgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhTY2F0dGVycGxvdExheWVyLCBfTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIFNjYXR0ZXJwbG90TGF5ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNjYXR0ZXJwbG90TGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTY2F0dGVycGxvdExheWVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2NhdHRlcnBsb3RMYXllcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNjYXR0ZXJwbG90TGF5ZXIsIFt7XG4gICAga2V5OiAnZ2V0U2hhZGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoYWRlcnMoaWQpIHtcblxuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZnA2NCA/IHtcbiAgICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NhdHRlcnBsb3QtbGF5ZXItNjQtdmVydGV4LXNoYWRlclxcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcXG5cXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlUmFkaXVzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG4vLyBPbmx5IG9uZS1kaW1lbnNpb25hbCBhcnJheXMgbWF5IGJlIGRlY2xhcmVkIGluIEdMU0wgRVMgMS4wLiBzcGVjcyBwLjI0XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzU2NhbGU7XFxudW5pZm9ybSBmbG9hdCByYWRpdXNNaW5QaXhlbHM7XFxudW5pZm9ybSBmbG9hdCByYWRpdXNNYXhQaXhlbHM7XFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcbnVuaWZvcm0gZmxvYXQgb3V0bGluZTtcXG51bmlmb3JtIGZsb2F0IHN0cm9rZVdpZHRoO1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyB2ZWMyIHVuaXRQb3NpdGlvbjtcXG52YXJ5aW5nIGZsb2F0IGlubmVyVW5pdFJhZGl1cztcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgLy8gTXVsdGlwbHkgb3V0IHJhZGl1cyBhbmQgY2xhbXAgdG8gbGltaXRzXFxuICBmbG9hdCBvdXRlclJhZGl1c1BpeGVscyA9IGNsYW1wKFxcbiAgICBwcm9qZWN0X3NjYWxlKHJhZGl1c1NjYWxlICogaW5zdGFuY2VSYWRpdXMpLFxcbiAgICByYWRpdXNNaW5QaXhlbHMsIHJhZGl1c01heFBpeGVsc1xcbiAgKTtcXG5cXG4gIC8vIG91dGxpbmUgaXMgY2VudGVyZWQgYXQgdGhlIHJhZGl1c1xcbiAgLy8gb3V0ZXIgcmFkaXVzIG5lZWRzIHRvIG9mZnNldCBieSBoYWxmIHN0cm9rZSB3aWR0aFxcbiAgb3V0ZXJSYWRpdXNQaXhlbHMgKz0gb3V0bGluZSAqIHN0cm9rZVdpZHRoIC8gMi4wO1xcblxcbiAgLy8gcG9zaXRpb24gb24gdGhlIGNvbnRhaW5pbmcgc3F1YXJlIGluIFstMSwgMV0gc3BhY2VcXG4gIHVuaXRQb3NpdGlvbiA9IHBvc2l0aW9ucy54eTtcXG4gIC8vIDAgLSBzb2xpZCBjaXJjbGUsIDEgLSBzdHJva2Ugd2l0aCBsaW5lV2lkdGg9MFxcbiAgaW5uZXJVbml0UmFkaXVzID0gb3V0bGluZSAqICgxLjAgLSBzdHJva2VXaWR0aCAvIG91dGVyUmFkaXVzUGl4ZWxzKTtcXG5cXG4gIHZlYzQgaW5zdGFuY2VQb3NpdGlvbnM2NHh5ID0gdmVjNChpbnN0YW5jZVBvc2l0aW9ucy54LCBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cueCwgaW5zdGFuY2VQb3NpdGlvbnMueSwgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93LnkpO1xcbiAgdmVjMiBwcm9qZWN0ZWRfY29vcmRfeHlbMl07XFxuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQoaW5zdGFuY2VQb3NpdGlvbnM2NHh5LCBwcm9qZWN0ZWRfY29vcmRfeHkpO1xcblxcbiAgdmVjMiB2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbNF07XFxuICB2ZWM0X2ZwNjQodmVjNChwb3NpdGlvbnMgKiBvdXRlclJhZGl1c1BpeGVscywgMC4wKSwgdmVydGV4X3Bvc19sb2NhbHNwYWNlKTtcXG5cXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzBdLCBwcm9qZWN0ZWRfY29vcmRfeHlbMF0pO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzFdLCBwcm9qZWN0ZWRfY29vcmRfeHlbMV0pO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gc3VtX2ZwNjQodmVydGV4X3Bvc19sb2NhbHNwYWNlWzJdLCB2ZWMyKHByb2plY3Rfc2NhbGUocG9zaXRpb25zLnopLCAwLjApKTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSk7XFxuXFxuICBpZiAocmVuZGVyUGlja2luZ0J1ZmZlciA+IDAuNSkge1xcbiAgICB2Q29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKTtcXG4gIH0gZWxzZSB7XFxuICAgIHZDb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xcbiAgfVxcbiAgLy8gLy8gQXBwbHkgb3BhY2l0eSB0byBpbnN0YW5jZSBjb2xvciwgb3IgcmV0dXJuIGluc3RhbmNlIHBpY2tpbmcgY29sb3JcXG4gIC8vIHZlYzQgY29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcXG4gIC8vIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XFxuICAvLyB2Q29sb3IgPSBtaXgoY29sb3IsIHBpY2tpbmdDb2xvciwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XFxufVxcbicsXG4gICAgICAgIGZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIHNjYXR0ZXJwbG90LWxheWVyLWZyYWdtZW50LXNoYWRlclxcblxcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XFxudmFyeWluZyBmbG9hdCBpbm5lclVuaXRSYWRpdXM7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXG4gIGZsb2F0IGRpc3RUb0NlbnRlciA9IGxlbmd0aCh1bml0UG9zaXRpb24pO1xcblxcbiAgaWYgKGRpc3RUb0NlbnRlciA8PSAxLjAgJiYgZGlzdFRvQ2VudGVyID49IGlubmVyVW5pdFJhZGl1cykge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XFxuICB9IGVsc2Uge1xcbiAgICBkaXNjYXJkO1xcbiAgfVxcbn1cXG4nLFxuICAgICAgICBtb2R1bGVzOiBbJ2xpZ2h0aW5nJywgJ2ZwNjQnLCAncHJvamVjdDY0J11cbiAgICAgIH0gOiB7XG4gICAgICAgIHZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIHNjYXR0ZXJwbG90LWxheWVyLXZlcnRleC1zaGFkZXJcXG5cXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XFxuXFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlUmFkaXVzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCByYWRpdXNTY2FsZTtcXG51bmlmb3JtIGZsb2F0IHJhZGl1c01pblBpeGVscztcXG51bmlmb3JtIGZsb2F0IHJhZGl1c01heFBpeGVscztcXG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XFxudW5pZm9ybSBmbG9hdCBvdXRsaW5lO1xcbnVuaWZvcm0gZmxvYXQgc3Ryb2tlV2lkdGg7XFxuXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG52YXJ5aW5nIHZlYzIgdW5pdFBvc2l0aW9uO1xcbnZhcnlpbmcgZmxvYXQgaW5uZXJVbml0UmFkaXVzO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBNdWx0aXBseSBvdXQgcmFkaXVzIGFuZCBjbGFtcCB0byBsaW1pdHNcXG4gIGZsb2F0IG91dGVyUmFkaXVzUGl4ZWxzID0gY2xhbXAoXFxuICAgIHByb2plY3Rfc2NhbGUocmFkaXVzU2NhbGUgKiBpbnN0YW5jZVJhZGl1cyksXFxuICAgIHJhZGl1c01pblBpeGVscywgcmFkaXVzTWF4UGl4ZWxzXFxuICApO1xcbiAgLy8gb3V0bGluZSBpcyBjZW50ZXJlZCBhdCB0aGUgcmFkaXVzXFxuICAvLyBvdXRlciByYWRpdXMgbmVlZHMgdG8gb2Zmc2V0IGJ5IGhhbGYgc3Ryb2tlIHdpZHRoXFxuICBvdXRlclJhZGl1c1BpeGVscyArPSBvdXRsaW5lICogc3Ryb2tlV2lkdGggLyAyLjA7XFxuXFxuICAvLyBwb3NpdGlvbiBvbiB0aGUgY29udGFpbmluZyBzcXVhcmUgaW4gWy0xLCAxXSBzcGFjZVxcbiAgdW5pdFBvc2l0aW9uID0gcG9zaXRpb25zLnh5O1xcbiAgLy8gMCAtIHNvbGlkIGNpcmNsZSwgMSAtIHN0cm9rZSB3aXRoIGxpbmVXaWR0aD0wXFxuICBpbm5lclVuaXRSYWRpdXMgPSBvdXRsaW5lICogKDEuMCAtIHN0cm9rZVdpZHRoIC8gb3V0ZXJSYWRpdXNQaXhlbHMpO1xcblxcbiAgLy8gRmluZCB0aGUgY2VudGVyIG9mIHRoZSBwb2ludCBhbmQgYWRkIHRoZSBjdXJyZW50IHZlcnRleFxcbiAgdmVjMyBjZW50ZXIgPSBwcm9qZWN0X3Bvc2l0aW9uKGluc3RhbmNlUG9zaXRpb25zKTtcXG4gIHZlYzMgdmVydGV4ID0gcG9zaXRpb25zICogb3V0ZXJSYWRpdXNQaXhlbHM7XFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQoY2VudGVyICsgdmVydGV4LCAxLjApKTtcXG5cXG4gIC8vIEFwcGx5IG9wYWNpdHkgdG8gaW5zdGFuY2UgY29sb3IsIG9yIHJldHVybiBpbnN0YW5jZSBwaWNraW5nIGNvbG9yXFxuICB2ZWM0IGNvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XFxuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pO1xcbiAgdkNvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3IsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xcbn1cXG4nLFxuICAgICAgICBmczogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBzY2F0dGVycGxvdC1sYXllci1mcmFnbWVudC1zaGFkZXJcXG5cXG4jaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG52YXJ5aW5nIHZlYzIgdW5pdFBvc2l0aW9uO1xcbnZhcnlpbmcgZmxvYXQgaW5uZXJVbml0UmFkaXVzO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuICBmbG9hdCBkaXN0VG9DZW50ZXIgPSBsZW5ndGgodW5pdFBvc2l0aW9uKTtcXG5cXG4gIGlmIChkaXN0VG9DZW50ZXIgPD0gMS4wICYmIGRpc3RUb0NlbnRlciA+PSBpbm5lclVuaXRSYWRpdXMpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xcbiAgfSBlbHNlIHtcXG4gICAgZGlzY2FyZDtcXG4gIH1cXG59XFxuJyxcbiAgICAgICAgbW9kdWxlczogWydsaWdodGluZyddXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luaXRpYWxpemVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1vZGVsOiB0aGlzLl9nZXRNb2RlbChnbCkgfSk7XG5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgIC8qIGRlcHJlY2F0ZWQgcHJvcHMgY2hlY2sgKi9cbiAgICAgIGlmICh0aGlzLnByb3BzLnJhZGl1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsICdTY2F0dGVycGxvdExheWVyIG5vIGxvbmdlciBhY2NlcHRzIHByb3BzLnJhZGl1cyBpbiB0aGlzIHZlcnNpb24gb2YgZGVjay5nbC4gUGxlYXNlIHVzZSBwcm9wcy5yYWRpdXNTY2FsZSBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcm9wcy5kcmF3T3V0bGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsICdTY2F0dGVycGxvdExheWVyIG5vIGxvbmdlciBhY2NlcHRzIHByb3BzLmRyYXdPdXRsaW5lIGluIHRoaXMgdmVyc2lvbiBvZiBkZWNrLmdsLiBQbGVhc2UgdXNlIHByb3BzLm91dGxpbmUgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7IHNpemU6IDMsIGFjY2Vzc29yOiAnZ2V0UG9zaXRpb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMgfSxcbiAgICAgICAgaW5zdGFuY2VSYWRpdXM6IHsgc2l6ZTogMSwgYWNjZXNzb3I6ICdnZXRSYWRpdXMnLCBkZWZhdWx0VmFsdWU6IDEsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVJhZGl1cyB9LFxuICAgICAgICBpbnN0YW5jZUNvbG9yczogeyBzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5wcm9wcy5mcDY0KSB7XG4gICAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICAgIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdzogeyBzaXplOiAyLCBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvdyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlTW9kZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVNb2RlbChfcmVmKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIG9sZFByb3BzID0gX3JlZi5vbGRQcm9wcyxcbiAgICAgICAgICBjaGFuZ2VGbGFncyA9IF9yZWYuY2hhbmdlRmxhZ3M7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVBdHRyaWJ1dGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGUoX3JlZjIpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYyLnByb3BzLFxuICAgICAgICAgIG9sZFByb3BzID0gX3JlZjIub2xkUHJvcHMsXG4gICAgICAgICAgY2hhbmdlRmxhZ3MgPSBfcmVmMi5jaGFuZ2VGbGFncztcblxuICAgICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXI7XG5cbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG5cbiAgICAgICAgaWYgKHByb3BzLmZwNjQgPT09IHRydWUpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgICAgICBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgYWNjZXNzb3I6ICdnZXRQb3NpdGlvbicsXG4gICAgICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbJ3Bvc2l0aW9uczY0eHlMb3cnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKF9yZWYzKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmMy5wcm9wcyxcbiAgICAgICAgICBvbGRQcm9wcyA9IF9yZWYzLm9sZFByb3BzLFxuICAgICAgICAgIGNoYW5nZUZsYWdzID0gX3JlZjMuY2hhbmdlRmxhZ3M7XG5cbiAgICAgIHRoaXMudXBkYXRlTW9kZWwoeyBwcm9wczogcHJvcHMsIG9sZFByb3BzOiBvbGRQcm9wcywgY2hhbmdlRmxhZ3M6IGNoYW5nZUZsYWdzIH0pO1xuICAgICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUoeyBwcm9wczogcHJvcHMsIG9sZFByb3BzOiBvbGRQcm9wcywgY2hhbmdlRmxhZ3M6IGNoYW5nZUZsYWdzIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KF9yZWY0KSB7XG4gICAgICB2YXIgdW5pZm9ybXMgPSBfcmVmNC51bmlmb3JtcztcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIHJhZGl1c1NjYWxlID0gX3Byb3BzLnJhZGl1c1NjYWxlLFxuICAgICAgICAgIHJhZGl1c01pblBpeGVscyA9IF9wcm9wcy5yYWRpdXNNaW5QaXhlbHMsXG4gICAgICAgICAgcmFkaXVzTWF4UGl4ZWxzID0gX3Byb3BzLnJhZGl1c01heFBpeGVscyxcbiAgICAgICAgICBvdXRsaW5lID0gX3Byb3BzLm91dGxpbmUsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcHJvcHMuc3Ryb2tlV2lkdGg7XG5cbiAgICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICAgIG91dGxpbmU6IG91dGxpbmUgPyAxIDogMCxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICByYWRpdXNTY2FsZTogcmFkaXVzU2NhbGUsXG4gICAgICAgIHJhZGl1c01pblBpeGVsczogcmFkaXVzTWluUGl4ZWxzLFxuICAgICAgICByYWRpdXNNYXhQaXhlbHM6IHJhZGl1c01heFBpeGVsc1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19nZXRNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRNb2RlbChnbCkge1xuICAgICAgLy8gYSBzcXVhcmUgdGhhdCBtaW5pbWFsbHkgY292ZXIgdGhlIHVuaXQgY2lyY2xlXG4gICAgICB2YXIgcG9zaXRpb25zID0gWy0xLCAtMSwgMCwgLTEsIDEsIDAsIDEsIDEsIDAsIDEsIC0xLCAwXTtcbiAgICAgIHZhciBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgICBnbDogZ2wsXG4gICAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgICB2czogc2hhZGVycy52cyxcbiAgICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRV9GQU4sXG4gICAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgICAgfSksXG4gICAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHMyLmRhdGEsXG4gICAgICAgICAgZ2V0UG9zaXRpb24gPSBfcHJvcHMyLmdldFBvc2l0aW9uO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcG9zaXRpb25bMF07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBvc2l0aW9uWzFdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBwb3NpdGlvblsyXSB8fCAwO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3coYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wczMuZGF0YSxcbiAgICAgICAgICBnZXRQb3NpdGlvbiA9IF9wcm9wczMuZ2V0UG9zaXRpb247XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBwb2ludCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gZnA2NGlmeShwb3NpdGlvblswXSlbMV07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IGZwNjRpZnkocG9zaXRpb25bMV0pWzFdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VSYWRpdXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnN0YW5jZVJhZGl1cyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3Byb3BzNC5kYXRhLFxuICAgICAgICAgIGdldFJhZGl1cyA9IF9wcm9wczQuZ2V0UmFkaXVzO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICB2YXIgcmFkaXVzID0gZ2V0UmFkaXVzKHBvaW50KTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gaXNOYU4ocmFkaXVzKSA/IDEgOiByYWRpdXM7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHM1LmRhdGEsXG4gICAgICAgICAgZ2V0Q29sb3IgPSBfcHJvcHM1LmdldENvbG9yO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICB2YXIgY29sb3IgPSBnZXRDb2xvcihwb2ludCkgfHwgREVGQVVMVF9DT0xPUjtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gY29sb3JbMF07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yWzFdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBjb2xvclsyXTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gaXNOYU4oY29sb3JbM10pID8gMjU1IDogY29sb3JbM107XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2NhdHRlcnBsb3RMYXllcjtcbn0oTGF5ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBTY2F0dGVycGxvdExheWVyO1xuXG5cblNjYXR0ZXJwbG90TGF5ZXIubGF5ZXJOYW1lID0gJ1NjYXR0ZXJwbG90TGF5ZXInO1xuU2NhdHRlcnBsb3RMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 13 */
/* exports provided: default */
/* exports used: default */
/*!*****************************!*\
  !*** ./src/react/deckgl.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__autobind__ = __webpack_require__(/*! ./autobind */ 30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__webgl_renderer__ = __webpack_require__(/*! ./webgl-renderer */ 70);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib__ = __webpack_require__(/*! ../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__experimental__ = __webpack_require__(/*! ../experimental */ 48);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__lib_viewports__ = __webpack_require__(/*! ../lib/viewports */ 16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__lib_utils__ = __webpack_require__(/*! ../lib/utils */ 3);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n// import {Viewport, WebMercatorViewport} from 'viewport-mercator-project';\n\n\n\nfunction noop() {}\n\nvar propTypes = {\n  id: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].string,\n  width: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  layers: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].arrayOf(__WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].instanceOf(__WEBPACK_IMPORTED_MODULE_3__lib__[\"a\" /* Layer */])).isRequired,\n  effects: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].arrayOf(__WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].instanceOf(__WEBPACK_IMPORTED_MODULE_4__experimental__[\"a\" /* Effect */])),\n  gl: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  debug: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].bool,\n  viewport: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].instanceOf(__WEBPACK_IMPORTED_MODULE_6__lib_viewports__[\"b\" /* Viewport */]),\n  onWebGLInitialized: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onLayerClick: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onLayerHover: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onAfterRender: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func\n};\n\nvar defaultProps = {\n  id: 'deckgl-overlay',\n  debug: false,\n  gl: null,\n  effects: [],\n  onWebGLInitialized: noop,\n  onLayerClick: noop,\n  onLayerHover: noop,\n  onAfterRender: noop\n};\n\nvar DeckGL = function (_React$Component) {\n  _inherits(DeckGL, _React$Component);\n\n  function DeckGL(props) {\n    _classCallCheck(this, DeckGL);\n\n    var _this = _possibleConstructorReturn(this, (DeckGL.__proto__ || Object.getPrototypeOf(DeckGL)).call(this, props));\n\n    _this.state = {};\n    _this.needsRedraw = true;\n    _this.layerManager = null;\n    _this.effectManager = null;\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__autobind__[\"a\" /* default */])(_this);\n    return _this;\n  }\n\n  _createClass(DeckGL, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      this._updateLayers(nextProps);\n    }\n  }, {\n    key: '_updateLayers',\n    value: function _updateLayers(nextProps) {\n      var width = nextProps.width,\n          height = nextProps.height,\n          latitude = nextProps.latitude,\n          longitude = nextProps.longitude,\n          zoom = nextProps.zoom,\n          pitch = nextProps.pitch,\n          bearing = nextProps.bearing,\n          altitude = nextProps.altitude;\n      var viewport = nextProps.viewport;\n\n      // If Viewport is not supplied, create one from mercator props\n\n      viewport = viewport || new __WEBPACK_IMPORTED_MODULE_6__lib_viewports__[\"a\" /* WebMercatorViewport */]({\n        width: width, height: height, latitude: latitude, longitude: longitude, zoom: zoom, pitch: pitch, bearing: bearing, altitude: altitude\n      });\n\n      if (this.layerManager) {\n        this.layerManager.setViewport(viewport).updateLayers({ newLayers: nextProps.layers });\n      }\n    }\n  }, {\n    key: '_onRendererInitialized',\n    value: function _onRendererInitialized(_ref) {\n      var gl = _ref.gl,\n          canvas = _ref.canvas;\n\n      gl.enable(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].BLEND);\n      gl.blendFunc(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].SRC_ALPHA, __WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].ONE_MINUS_SRC_ALPHA);\n\n      this.props.onWebGLInitialized(gl);\n\n      // Note: avoid React setState due GL animation loop / setState timing issue\n      this.layerManager = new __WEBPACK_IMPORTED_MODULE_3__lib__[\"c\" /* LayerManager */]({ gl: gl });\n      this.effectManager = new __WEBPACK_IMPORTED_MODULE_4__experimental__[\"b\" /* EffectManager */]({ gl: gl, layerManager: this.layerManager });\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var effect = _step.value;\n\n          this.effectManager.addEffect(effect);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this._updateLayers(this.props);\n\n      // Check if a mouse event has been specified and that at least one of the layers is pickable\n      var hasEvent = this.props.onLayerClick !== noop || this.props.onLayerHover !== noop;\n      var hasPickableLayer = this.layerManager.layers.map(function (l) {\n        return l.props.pickable;\n      }).includes(true);\n      if (hasEvent && !hasPickableLayer) {\n        __WEBPACK_IMPORTED_MODULE_7__lib_utils__[\"a\" /* log */].once(0, 'You have supplied a mouse event handler but none of your layers got the `pickable` flag.');\n      }\n\n      this.events = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"addEvents\"])(canvas, {\n        cacheSize: false,\n        cachePosition: false,\n        centerOrigin: false,\n        onClick: this._onClick,\n        onMouseMove: this._onMouseMove\n      });\n    }\n\n    // Route events to layers\n\n  }, {\n    key: '_onClick',\n    value: function _onClick(event) {\n      var x = event.x,\n          y = event.y;\n\n      var selectedInfos = this.layerManager.pickLayer({ x: x, y: y, mode: 'click' });\n      if (selectedInfos.length) {\n        var firstInfo = selectedInfos.find(function (info) {\n          return info.index >= 0;\n        });\n        // Event.event holds the original MouseEvent object\n        this.props.onLayerClick(firstInfo, selectedInfos, event.event);\n      }\n    }\n\n    // Route events to layers\n\n  }, {\n    key: '_onMouseMove',\n    value: function _onMouseMove(event) {\n      var x = event.x,\n          y = event.y;\n\n      var selectedInfos = this.layerManager.pickLayer({ x: x, y: y, mode: 'hover' });\n      if (selectedInfos.length) {\n        var firstInfo = selectedInfos.find(function (info) {\n          return info.index >= 0;\n        });\n        // Event.event holds the original MouseEvent object\n        this.props.onLayerHover(firstInfo, selectedInfos, event.event);\n      }\n    }\n  }, {\n    key: '_onRenderFrame',\n    value: function _onRenderFrame(_ref2) {\n      var gl = _ref2.gl;\n\n      var redraw = this.layerManager.needsRedraw({ clearRedrawFlags: true });\n      if (!redraw) {\n        return;\n      }\n\n      // clear depth and color buffers\n      gl.clear(__WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"GL\"].DEPTH_BUFFER_BIT);\n\n      this.effectManager.preDraw();\n      this.layerManager.drawLayers({ pass: 'primary' });\n      this.effectManager.draw();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          width = _props.width,\n          height = _props.height,\n          gl = _props.gl,\n          debug = _props.debug;\n\n\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_react__[\"createElement\"])(__WEBPACK_IMPORTED_MODULE_2__webgl_renderer__[\"a\" /* default */], Object.assign({}, this.props, {\n        width: width,\n        height: height,\n        gl: gl,\n        debug: debug,\n        viewport: { x: 0, y: 0, width: width, height: height },\n        onRendererInitialized: this._onRendererInitialized,\n        onNeedRedraw: this._onNeedRedraw,\n        onRenderFrame: this._onRenderFrame,\n        onMouseMove: this._onMouseMove,\n        onClick: this._onClick\n      }));\n    }\n  }]);\n\n  return DeckGL;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = DeckGL;\n\n\nDeckGL.propTypes = propTypes;\nDeckGL.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVhY3QvZGVja2dsLmpzPzAxMjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuaW1wb3J0IFJlYWN0LCB7IFByb3BUeXBlcywgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuL2F1dG9iaW5kJztcbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gJy4vd2ViZ2wtcmVuZGVyZXInO1xuaW1wb3J0IHsgTGF5ZXJNYW5hZ2VyLCBMYXllciB9IGZyb20gJy4uL2xpYic7XG5pbXBvcnQgeyBFZmZlY3RNYW5hZ2VyLCBFZmZlY3QgfSBmcm9tICcuLi9leHBlcmltZW50YWwnO1xuaW1wb3J0IHsgR0wsIGFkZEV2ZW50cyB9IGZyb20gJ2x1bWEuZ2wnO1xuLy8gaW1wb3J0IHtWaWV3cG9ydCwgV2ViTWVyY2F0b3JWaWV3cG9ydH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQgeyBWaWV3cG9ydCwgV2ViTWVyY2F0b3JWaWV3cG9ydCB9IGZyb20gJy4uL2xpYi92aWV3cG9ydHMnO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi4vbGliL3V0aWxzJztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgbGF5ZXJzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuaW5zdGFuY2VPZihMYXllcikpLmlzUmVxdWlyZWQsXG4gIGVmZmVjdHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5pbnN0YW5jZU9mKEVmZmVjdCkpLFxuICBnbDogUHJvcFR5cGVzLm9iamVjdCxcbiAgZGVidWc6IFByb3BUeXBlcy5ib29sLFxuICB2aWV3cG9ydDogUHJvcFR5cGVzLmluc3RhbmNlT2YoVmlld3BvcnQpLFxuICBvbldlYkdMSW5pdGlhbGl6ZWQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbkxheWVyQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvbkxheWVySG92ZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbkFmdGVyUmVuZGVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgaWQ6ICdkZWNrZ2wtb3ZlcmxheScsXG4gIGRlYnVnOiBmYWxzZSxcbiAgZ2w6IG51bGwsXG4gIGVmZmVjdHM6IFtdLFxuICBvbldlYkdMSW5pdGlhbGl6ZWQ6IG5vb3AsXG4gIG9uTGF5ZXJDbGljazogbm9vcCxcbiAgb25MYXllckhvdmVyOiBub29wLFxuICBvbkFmdGVyUmVuZGVyOiBub29wXG59O1xuXG52YXIgRGVja0dMID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERlY2tHTCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRGVja0dMKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlY2tHTCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRGVja0dMLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGVja0dMKSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICBfdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgX3RoaXMubGF5ZXJNYW5hZ2VyID0gbnVsbDtcbiAgICBfdGhpcy5lZmZlY3RNYW5hZ2VyID0gbnVsbDtcbiAgICBhdXRvYmluZChfdGhpcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERlY2tHTCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUxheWVycyhuZXh0UHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVMYXllcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTGF5ZXJzKG5leHRQcm9wcykge1xuICAgICAgdmFyIHdpZHRoID0gbmV4dFByb3BzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IG5leHRQcm9wcy5oZWlnaHQsXG4gICAgICAgICAgbGF0aXR1ZGUgPSBuZXh0UHJvcHMubGF0aXR1ZGUsXG4gICAgICAgICAgbG9uZ2l0dWRlID0gbmV4dFByb3BzLmxvbmdpdHVkZSxcbiAgICAgICAgICB6b29tID0gbmV4dFByb3BzLnpvb20sXG4gICAgICAgICAgcGl0Y2ggPSBuZXh0UHJvcHMucGl0Y2gsXG4gICAgICAgICAgYmVhcmluZyA9IG5leHRQcm9wcy5iZWFyaW5nLFxuICAgICAgICAgIGFsdGl0dWRlID0gbmV4dFByb3BzLmFsdGl0dWRlO1xuICAgICAgdmFyIHZpZXdwb3J0ID0gbmV4dFByb3BzLnZpZXdwb3J0O1xuXG4gICAgICAvLyBJZiBWaWV3cG9ydCBpcyBub3Qgc3VwcGxpZWQsIGNyZWF0ZSBvbmUgZnJvbSBtZXJjYXRvciBwcm9wc1xuXG4gICAgICB2aWV3cG9ydCA9IHZpZXdwb3J0IHx8IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgbGF0aXR1ZGU6IGxhdGl0dWRlLCBsb25naXR1ZGU6IGxvbmdpdHVkZSwgem9vbTogem9vbSwgcGl0Y2g6IHBpdGNoLCBiZWFyaW5nOiBiZWFyaW5nLCBhbHRpdHVkZTogYWx0aXR1ZGVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5sYXllck1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5sYXllck1hbmFnZXIuc2V0Vmlld3BvcnQodmlld3BvcnQpLnVwZGF0ZUxheWVycyh7IG5ld0xheWVyczogbmV4dFByb3BzLmxheWVycyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfb25SZW5kZXJlckluaXRpYWxpemVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmVuZGVyZXJJbml0aWFsaXplZChfcmVmKSB7XG4gICAgICB2YXIgZ2wgPSBfcmVmLmdsLFxuICAgICAgICAgIGNhbnZhcyA9IF9yZWYuY2FudmFzO1xuXG4gICAgICBnbC5lbmFibGUoR0wuQkxFTkQpO1xuICAgICAgZ2wuYmxlbmRGdW5jKEdMLlNSQ19BTFBIQSwgR0wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cbiAgICAgIHRoaXMucHJvcHMub25XZWJHTEluaXRpYWxpemVkKGdsKTtcblxuICAgICAgLy8gTm90ZTogYXZvaWQgUmVhY3Qgc2V0U3RhdGUgZHVlIEdMIGFuaW1hdGlvbiBsb29wIC8gc2V0U3RhdGUgdGltaW5nIGlzc3VlXG4gICAgICB0aGlzLmxheWVyTWFuYWdlciA9IG5ldyBMYXllck1hbmFnZXIoeyBnbDogZ2wgfSk7XG4gICAgICB0aGlzLmVmZmVjdE1hbmFnZXIgPSBuZXcgRWZmZWN0TWFuYWdlcih7IGdsOiBnbCwgbGF5ZXJNYW5hZ2VyOiB0aGlzLmxheWVyTWFuYWdlciB9KTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLnByb3BzLmVmZmVjdHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGVmZmVjdCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdGhpcy5lZmZlY3RNYW5hZ2VyLmFkZEVmZmVjdChlZmZlY3QpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXBkYXRlTGF5ZXJzKHRoaXMucHJvcHMpO1xuXG4gICAgICAvLyBDaGVjayBpZiBhIG1vdXNlIGV2ZW50IGhhcyBiZWVuIHNwZWNpZmllZCBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgb2YgdGhlIGxheWVycyBpcyBwaWNrYWJsZVxuICAgICAgdmFyIGhhc0V2ZW50ID0gdGhpcy5wcm9wcy5vbkxheWVyQ2xpY2sgIT09IG5vb3AgfHwgdGhpcy5wcm9wcy5vbkxheWVySG92ZXIgIT09IG5vb3A7XG4gICAgICB2YXIgaGFzUGlja2FibGVMYXllciA9IHRoaXMubGF5ZXJNYW5hZ2VyLmxheWVycy5tYXAoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcmV0dXJuIGwucHJvcHMucGlja2FibGU7XG4gICAgICB9KS5pbmNsdWRlcyh0cnVlKTtcbiAgICAgIGlmIChoYXNFdmVudCAmJiAhaGFzUGlja2FibGVMYXllcikge1xuICAgICAgICBsb2cub25jZSgwLCAnWW91IGhhdmUgc3VwcGxpZWQgYSBtb3VzZSBldmVudCBoYW5kbGVyIGJ1dCBub25lIG9mIHlvdXIgbGF5ZXJzIGdvdCB0aGUgYHBpY2thYmxlYCBmbGFnLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmV2ZW50cyA9IGFkZEV2ZW50cyhjYW52YXMsIHtcbiAgICAgICAgY2FjaGVTaXplOiBmYWxzZSxcbiAgICAgICAgY2FjaGVQb3NpdGlvbjogZmFsc2UsXG4gICAgICAgIGNlbnRlck9yaWdpbjogZmFsc2UsXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uQ2xpY2ssXG4gICAgICAgIG9uTW91c2VNb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUm91dGUgZXZlbnRzIHRvIGxheWVyc1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfb25DbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNsaWNrKGV2ZW50KSB7XG4gICAgICB2YXIgeCA9IGV2ZW50LngsXG4gICAgICAgICAgeSA9IGV2ZW50Lnk7XG5cbiAgICAgIHZhciBzZWxlY3RlZEluZm9zID0gdGhpcy5sYXllck1hbmFnZXIucGlja0xheWVyKHsgeDogeCwgeTogeSwgbW9kZTogJ2NsaWNrJyB9KTtcbiAgICAgIGlmIChzZWxlY3RlZEluZm9zLmxlbmd0aCkge1xuICAgICAgICB2YXIgZmlyc3RJbmZvID0gc2VsZWN0ZWRJbmZvcy5maW5kKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIGluZm8uaW5kZXggPj0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEV2ZW50LmV2ZW50IGhvbGRzIHRoZSBvcmlnaW5hbCBNb3VzZUV2ZW50IG9iamVjdFxuICAgICAgICB0aGlzLnByb3BzLm9uTGF5ZXJDbGljayhmaXJzdEluZm8sIHNlbGVjdGVkSW5mb3MsIGV2ZW50LmV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSb3V0ZSBldmVudHMgdG8gbGF5ZXJzXG5cbiAgfSwge1xuICAgIGtleTogJ19vbk1vdXNlTW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgdmFyIHggPSBldmVudC54LFxuICAgICAgICAgIHkgPSBldmVudC55O1xuXG4gICAgICB2YXIgc2VsZWN0ZWRJbmZvcyA9IHRoaXMubGF5ZXJNYW5hZ2VyLnBpY2tMYXllcih7IHg6IHgsIHk6IHksIG1vZGU6ICdob3ZlcicgfSk7XG4gICAgICBpZiAoc2VsZWN0ZWRJbmZvcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGZpcnN0SW5mbyA9IHNlbGVjdGVkSW5mb3MuZmluZChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgIHJldHVybiBpbmZvLmluZGV4ID49IDA7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFdmVudC5ldmVudCBob2xkcyB0aGUgb3JpZ2luYWwgTW91c2VFdmVudCBvYmplY3RcbiAgICAgICAgdGhpcy5wcm9wcy5vbkxheWVySG92ZXIoZmlyc3RJbmZvLCBzZWxlY3RlZEluZm9zLCBldmVudC5ldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX29uUmVuZGVyRnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZW5kZXJGcmFtZShfcmVmMikge1xuICAgICAgdmFyIGdsID0gX3JlZjIuZ2w7XG5cbiAgICAgIHZhciByZWRyYXcgPSB0aGlzLmxheWVyTWFuYWdlci5uZWVkc1JlZHJhdyh7IGNsZWFyUmVkcmF3RmxhZ3M6IHRydWUgfSk7XG4gICAgICBpZiAoIXJlZHJhdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFyIGRlcHRoIGFuZCBjb2xvciBidWZmZXJzXG4gICAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgICAgIHRoaXMuZWZmZWN0TWFuYWdlci5wcmVEcmF3KCk7XG4gICAgICB0aGlzLmxheWVyTWFuYWdlci5kcmF3TGF5ZXJzKHsgcGFzczogJ3ByaW1hcnknIH0pO1xuICAgICAgdGhpcy5lZmZlY3RNYW5hZ2VyLmRyYXcoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICB3aWR0aCA9IF9wcm9wcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfcHJvcHMuaGVpZ2h0LFxuICAgICAgICAgIGdsID0gX3Byb3BzLmdsLFxuICAgICAgICAgIGRlYnVnID0gX3Byb3BzLmRlYnVnO1xuXG5cbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFdlYkdMUmVuZGVyZXIsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZ2w6IGdsLFxuICAgICAgICBkZWJ1ZzogZGVidWcsXG4gICAgICAgIHZpZXdwb3J0OiB7IHg6IDAsIHk6IDAsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSxcbiAgICAgICAgb25SZW5kZXJlckluaXRpYWxpemVkOiB0aGlzLl9vblJlbmRlcmVySW5pdGlhbGl6ZWQsXG4gICAgICAgIG9uTmVlZFJlZHJhdzogdGhpcy5fb25OZWVkUmVkcmF3LFxuICAgICAgICBvblJlbmRlckZyYW1lOiB0aGlzLl9vblJlbmRlckZyYW1lLFxuICAgICAgICBvbk1vdXNlTW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uQ2xpY2tcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGVja0dMO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBEZWNrR0w7XG5cblxuRGVja0dMLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkRlY2tHTC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcmVhY3QvZGVja2dsLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 14 */
/* exports provided: default, TEST_EXPORTS */
/* exports used: default */
/*!**************************!*\
  !*** ./src/lib/layer.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__attribute_manager__ = __webpack_require__(/*! ./attribute-manager */ 27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(/*! ./utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_assert__);\n/* unused harmony export TEST_EXPORTS */\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* global window */\n\n\n\n\n\n/*\n * @param {string} props.id - layer name\n * @param {array}  props.data - array of data instances\n * @param {bool} props.opacity - opacity of the layer\n */\nvar defaultProps = {\n  dataIterator: null,\n  dataComparator: null,\n  numInstances: undefined,\n  visible: true,\n  pickable: false,\n  opacity: 0.8,\n  onHover: function onHover() {},\n  onClick: function onClick() {},\n  // Update triggers: a key change detection mechanism in deck.gl\n  // See layer documentation\n  updateTriggers: {}\n};\n\nvar counter = 0;\n\nvar Layer = function () {\n  /**\n   * @class\n   * @param {object} props - See docs and defaults above\n   */\n  function Layer(props) {\n    _classCallCheck(this, Layer);\n\n    // If sublayer has static defaultProps member, getDefaultProps will return it\n    var mergedDefaultProps = getDefaultProps(this);\n    // Merge supplied props with pre-merged default props\n    props = Object.assign({}, mergedDefaultProps, props);\n    // Accept null as data - otherwise apps and layers need to add ugly checks\n    props.data = props.data || [];\n    // Props are immutable\n    Object.freeze(props);\n\n    // Define all members and freeze layer\n    this.id = props.id;\n    this.props = props;\n    this.oldProps = null;\n    this.state = null;\n    this.context = null;\n    this.count = counter++;\n    Object.seal(this);\n\n    this.validateRequiredProp('id', function (x) {\n      return typeof x === 'string' && x !== '';\n    });\n    this.validateRequiredProp('data');\n  }\n\n  _createClass(Layer, [{\n    key: 'toString',\n    value: function toString() {\n      var className = this.constructor.layerName || this.constructor.name;\n      return className !== this.props.id ? '<' + className + ':\\'' + this.props.id + '\\'>' : '<' + className + '>';\n    }\n\n    // //////////////////////////////////////////////////\n    // LIFECYCLE METHODS, overridden by the layer subclasses\n\n    // Called once to set up the initial state\n    // App can create WebGL resources\n\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      throw new Error('Layer ' + this + ' has not defined initializeState');\n    }\n\n    // Let's layer control if updateState should be called\n\n  }, {\n    key: 'shouldUpdateState',\n    value: function shouldUpdateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          oldContext = _ref.oldContext,\n          context = _ref.context,\n          changeFlags = _ref.changeFlags;\n\n      return changeFlags.somethingChanged;\n    }\n\n    // Default implementation, all attributes will be invalidated and updated\n    // when data changes\n\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          oldContext = _ref2.oldContext,\n          context = _ref2.context,\n          changeFlags = _ref2.changeFlags;\n\n      if (changeFlags.dataChanged) {\n        this.invalidateAttribute('all');\n      }\n    }\n\n    // Called once when layer is no longer matched and state will be discarded\n    // App can destroy WebGL resources here\n\n  }, {\n    key: 'finalizeState',\n    value: function finalizeState() {}\n\n    // Implement to generate sublayers\n\n  }, {\n    key: 'renderLayers',\n    value: function renderLayers() {\n      return null;\n    }\n\n    // If state has a model, draw it with supplied uniforms\n\n  }, {\n    key: 'draw',\n    value: function draw(_ref3) {\n      var _ref3$uniforms = _ref3.uniforms,\n          uniforms = _ref3$uniforms === undefined ? {} : _ref3$uniforms;\n\n      if (this.state.model) {\n        this.state.model.render(uniforms);\n      }\n    }\n\n    // called to populate the info object that is passed to the event handler\n    // @return null to cancel event\n\n  }, {\n    key: 'getPickingInfo',\n    value: function getPickingInfo(_ref4) {\n      var info = _ref4.info,\n          mode = _ref4.mode;\n      var color = info.color,\n          index = info.index;\n\n\n      if (index >= 0) {\n        // If props.data is an indexable array, get the object\n        if (Array.isArray(this.props.data)) {\n          info.object = this.props.data[index];\n        }\n      }\n\n      // TODO - move to the JS part of a shader picking shader package\n      if (mode === 'hover') {\n        var selectedPickingColor = new Float32Array(3);\n        selectedPickingColor[0] = color[0];\n        selectedPickingColor[1] = color[1];\n        selectedPickingColor[2] = color[2];\n        this.setUniforms({ selectedPickingColor: selectedPickingColor });\n      }\n\n      return info;\n    }\n\n    // END LIFECYCLE METHODS\n    // //////////////////////////////////////////////////\n\n    // Default implementation of attribute invalidation, can be redefine\n\n  }, {\n    key: 'invalidateAttribute',\n    value: function invalidateAttribute() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';\n\n      if (name === 'all') {\n        this.state.attributeManager.invalidateAll();\n      } else {\n        this.state.attributeManager.invalidate(name);\n      }\n    }\n\n    // Calls attribute manager to update any WebGL attributes, can be redefined\n\n  }, {\n    key: 'updateAttributes',\n    value: function updateAttributes(props) {\n      var _state = this.state,\n          attributeManager = _state.attributeManager,\n          model = _state.model;\n\n      if (!attributeManager) {\n        return;\n      }\n\n      var numInstances = this.getNumInstances(props);\n      // Figure out data length\n      attributeManager.update({\n        data: props.data,\n        numInstances: numInstances,\n        props: props,\n        buffers: props,\n        context: this,\n        // Don't worry about non-attribute props\n        ignoreUnknownAttributes: true\n      });\n      if (model) {\n        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });\n        model.setAttributes(changedAttributes);\n      }\n    }\n\n    // Public API\n\n    // Updates selected state members and marks the object for redraw\n\n  }, {\n    key: 'setState',\n    value: function setState(updateObject) {\n      Object.assign(this.state, updateObject);\n      this.state.needsRedraw = true;\n    }\n  }, {\n    key: 'setNeedsRedraw',\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this.state) {\n        this.state.needsRedraw = redraw;\n      }\n    }\n\n    // PROJECTION METHODS\n\n    /**\n     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)\n     *\n     * Note: Position conversion is done in shader, so in many cases there is no need\n     * for this function\n     * @param {Array|TypedArray} lngLat - long and lat values\n     * @return {Array|TypedArray} - x, y coordinates\n     */\n\n  }, {\n    key: 'project',\n    value: function project(lngLat) {\n      var viewport = this.context.viewport;\n\n      __WEBPACK_IMPORTED_MODULE_3_assert___default()(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');\n      return viewport.project(lngLat);\n    }\n  }, {\n    key: 'unproject',\n    value: function unproject(xy) {\n      var viewport = this.context.viewport;\n\n      __WEBPACK_IMPORTED_MODULE_3_assert___default()(Array.isArray(xy), 'Layer.unproject needs [x,y]');\n      return viewport.unproject(xy);\n    }\n  }, {\n    key: 'projectFlat',\n    value: function projectFlat(lngLat) {\n      var viewport = this.context.viewport;\n\n      __WEBPACK_IMPORTED_MODULE_3_assert___default()(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');\n      return viewport.projectFlat(lngLat);\n    }\n  }, {\n    key: 'unprojectFlat',\n    value: function unprojectFlat(xy) {\n      var viewport = this.context.viewport;\n\n      __WEBPACK_IMPORTED_MODULE_3_assert___default()(Array.isArray(xy), 'Layer.unproject needs [x,y]');\n      return viewport.unprojectFlat(xy);\n    }\n  }, {\n    key: 'screenToDevicePixels',\n    value: function screenToDevicePixels(screenPixels) {\n      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n      return screenPixels * devicePixelRatio;\n    }\n\n    /**\n     * Returns the picking color that doesn't match any subfeature\n     * Use if some graphics do not belong to any pickable subfeature\n     * @return {Array} - a black color\n     */\n\n  }, {\n    key: 'nullPickingColor',\n    value: function nullPickingColor() {\n      return [0, 0, 0];\n    }\n\n    /**\n     * Returns the picking color that doesn't match any subfeature\n     * Use if some graphics do not belong to any pickable subfeature\n     * @param {int} i - index to be decoded\n     * @return {Array} - the decoded color\n     */\n\n  }, {\n    key: 'encodePickingColor',\n    value: function encodePickingColor(i) {\n      return [(i + 1) % 256, Math.floor((i + 1) / 256) % 256, Math.floor((i + 1) / 256 / 256) % 256];\n    }\n\n    /**\n     * Returns the picking color that doesn't match any subfeature\n     * Use if some graphics do not belong to any pickable subfeature\n     * @param {Uint8Array} color - color array to be decoded\n     * @return {Array} - the decoded picking color\n     */\n\n  }, {\n    key: 'decodePickingColor',\n    value: function decodePickingColor(color) {\n      __WEBPACK_IMPORTED_MODULE_3_assert___default()(color instanceof Uint8Array);\n\n      var _color = _slicedToArray(color, 3),\n          i1 = _color[0],\n          i2 = _color[1],\n          i3 = _color[2];\n      // 1 was added to seperate from no selection\n\n\n      var index = i1 + i2 * 256 + i3 * 65536 - 1;\n      return index;\n    }\n  }, {\n    key: 'calculateInstancePickingColors',\n    value: function calculateInstancePickingColors(attribute, _ref5) {\n      var numInstances = _ref5.numInstances;\n      var value = attribute.value,\n          size = attribute.size;\n      // add 1 to index to seperate from no selection\n\n      for (var i = 0; i < numInstances; i++) {\n        var pickingColor = this.encodePickingColor(i);\n        value[i * size + 0] = pickingColor[0];\n        value[i * size + 1] = pickingColor[1];\n        value[i * size + 2] = pickingColor[2];\n      }\n    }\n\n    // DATA ACCESS API\n    // Data can use iterators and may not be random access\n\n    // Use iteration (the only required capability on data) to get first element\n\n  }, {\n    key: 'getFirstObject',\n    value: function getFirstObject() {\n      var data = this.props.data;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n\n          return object;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    // INTERNAL METHODS\n\n    // Deduces numer of instances. Intention is to support:\n    // - Explicit setting of numInstances\n    // - Auto-deduction for ES6 containers that define a size member\n    // - Auto-deduction for Classic Arrays via the built-in length attribute\n    // - Auto-deduction via arrays\n\n  }, {\n    key: 'getNumInstances',\n    value: function getNumInstances(props) {\n      props = props || this.props;\n\n      // First check if the layer has set its own value\n      if (this.state && this.state.numInstances !== undefined) {\n        return this.state.numInstances;\n      }\n\n      // Check if app has provided an explicit value\n      if (props.numInstances !== undefined) {\n        return props.numInstances;\n      }\n\n      // Use container library to get a count for any ES6 container or object\n      var _props = props,\n          data = _props.data;\n\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"f\" /* count */])(data);\n    }\n\n    // LAYER MANAGER API\n    // Should only be called by the deck.gl LayerManager class\n\n    // Called by layer manager when a new layer is found\n    /* eslint-disable max-statements */\n\n  }, {\n    key: 'initializeLayer',\n    value: function initializeLayer(updateParams) {\n      __WEBPACK_IMPORTED_MODULE_3_assert___default()(this.context.gl, 'Layer context missing gl');\n      __WEBPACK_IMPORTED_MODULE_3_assert___default()(!this.state, 'Layer missing state');\n\n      this.state = {};\n\n      // Initialize state only once\n      this.setState({\n        attributeManager: new __WEBPACK_IMPORTED_MODULE_1__attribute_manager__[\"a\" /* default */]({ id: this.props.id }),\n        model: null,\n        needsRedraw: true,\n        dataChanged: true\n      });\n\n      // Add attribute manager loggers if provided\n      this.state.attributeManager.setLogFunctions(this.props);\n\n      var attributeManager = this.state.attributeManager;\n      // All instanced layers get instancePickingColors attribute by default\n      // Their shaders can use it to render a picking scene\n      // TODO - this slows down non instanced layers\n\n      attributeManager.addInstanced({\n        instancePickingColors: {\n          type: __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n          size: 3,\n          update: this.calculateInstancePickingColors\n        }\n      });\n\n      // Call subclass lifecycle methods\n      this.initializeState();\n      this.updateState(updateParams);\n      // End subclass lifecycle methods\n\n      // Add any subclass attributes\n      this.updateAttributes(this.props);\n      this._updateBaseUniforms();\n\n      var model = this.state.model;\n\n      if (model) {\n        model.setInstanceCount(this.getNumInstances());\n        model.id = this.props.id;\n        model.program.id = this.props.id + '-program';\n        model.geometry.id = this.props.id + '-geometry';\n        model.setAttributes(attributeManager.getAttributes());\n      }\n    }\n\n    // Called by layer manager when existing layer is getting new props\n\n  }, {\n    key: 'updateLayer',\n    value: function updateLayer(updateParams) {\n      // Check for deprecated method\n      if (this.shouldUpdate) {\n        __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, 'deck.gl v3 ' + this + ': \"shouldUpdate\" deprecated, renamed to \"shouldUpdateState\"');\n      }\n\n      // Call subclass lifecycle method\n      var stateNeedsUpdate = this.shouldUpdateState(updateParams);\n      // End lifecycle method\n\n      if (stateNeedsUpdate) {\n\n        // Call deprecated lifecycle method if defined\n        var hasRedefinedMethod = this.willReceiveProps && this.willReceiveProps !== Layer.prototype.willReceiveProps;\n        if (hasRedefinedMethod) {\n          __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, 'deck.gl v3 willReceiveProps deprecated. Use updateState in ' + this);\n          var oldProps = updateParams.oldProps,\n              props = updateParams.props,\n              changeFlags = updateParams.changeFlags;\n\n          this.setState(changeFlags);\n          this.willReceiveProps(oldProps, props, changeFlags);\n          this.setState({\n            dataChanged: false,\n            viewportChanged: false\n          });\n        }\n        // End lifecycle method\n\n        // Call subclass lifecycle method\n        this.updateState(updateParams);\n        // End lifecycle method\n\n        // Run the attribute updaters\n        this.updateAttributes(updateParams.props);\n        this._updateBaseUniforms();\n\n        if (this.state.model) {\n          this.state.model.setInstanceCount(this.getNumInstances());\n        }\n      }\n    }\n    /* eslint-enable max-statements */\n\n    // Called by manager when layer is about to be disposed\n    // Note: not guaranteed to be called on application shutdown\n\n  }, {\n    key: 'finalizeLayer',\n    value: function finalizeLayer() {\n      // Call subclass lifecycle method\n      this.finalizeState();\n      // End lifecycle method\n    }\n\n    // Calculates uniforms\n\n  }, {\n    key: 'drawLayer',\n    value: function drawLayer(_ref6) {\n      var _ref6$uniforms = _ref6.uniforms,\n          uniforms = _ref6$uniforms === undefined ? {} : _ref6$uniforms;\n\n      // Call subclass lifecycle method\n      this.draw({ uniforms: uniforms });\n      // End lifecycle method\n    }\n\n    // {uniforms = {}, ...opts}\n\n  }, {\n    key: 'pickLayer',\n    value: function pickLayer(opts) {\n      // Call subclass lifecycle method\n      return this.getPickingInfo(opts);\n      // End lifecycle method\n    }\n  }, {\n    key: 'diffProps',\n    value: function diffProps(oldProps, newProps, context) {\n      // First check if any props have changed (ignore props that will be examined separately)\n      var propsChangedReason = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"g\" /* compareProps */])({\n        newProps: newProps,\n        oldProps: oldProps,\n        ignoreProps: { data: null, updateTriggers: null }\n      });\n\n      // Now check if any data related props have changed\n      var dataChangedReason = this._diffDataProps(oldProps, newProps);\n\n      var propsChanged = Boolean(propsChangedReason);\n      var dataChanged = Boolean(dataChangedReason);\n      var viewportChanged = context.viewportChanged;\n      var somethingChanged = propsChanged || dataChanged || viewportChanged;\n\n      // Check update triggers to determine if any attributes need regeneration\n      // Note - if data has changed, all attributes will need regeneration, so skip this step\n      if (!dataChanged) {\n        this._diffUpdateTriggers(oldProps, newProps);\n      } else {\n        __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, 'dataChanged: ' + dataChanged);\n      }\n\n      return {\n        propsChanged: propsChanged,\n        dataChanged: dataChanged,\n        viewportChanged: viewportChanged,\n        somethingChanged: somethingChanged,\n        reason: dataChangedReason || propsChangedReason\n      };\n    }\n\n    // Checks state of attributes and model\n    // TODO - is attribute manager needed? - Model should be enough.\n\n  }, {\n    key: 'getNeedsRedraw',\n    value: function getNeedsRedraw() {\n      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref7$clearRedrawFlag = _ref7.clearRedrawFlags,\n          clearRedrawFlags = _ref7$clearRedrawFlag === undefined ? false : _ref7$clearRedrawFlag;\n\n      // this method may be called by the render loop as soon a the layer\n      // has been created, so guard against uninitialized state\n      if (!this.state) {\n        return false;\n      }\n\n      var redraw = false;\n      redraw = redraw || this.state.needsRedraw;\n      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;\n\n      var _state2 = this.state,\n          attributeManager = _state2.attributeManager,\n          model = _state2.model;\n\n      redraw = redraw || attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });\n      redraw = redraw || model && model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });\n\n      return redraw;\n    }\n\n    // PRIVATE METHODS\n\n    // The comparison of the data prop requires special handling\n    // the dataComparator should be used if supplied\n\n  }, {\n    key: '_diffDataProps',\n    value: function _diffDataProps(oldProps, newProps) {\n      // Support optional app defined comparison of data\n      var dataComparator = newProps.dataComparator;\n\n      if (dataComparator) {\n        if (!dataComparator(newProps.data, oldProps.data)) {\n          return 'Data comparator detected a change';\n        }\n        // Otherwise, do a shallow equal on props\n      } else if (newProps.data !== oldProps.data) {\n        return 'A new data container was supplied';\n      }\n\n      return null;\n    }\n\n    // Checks if any update triggers have changed, and invalidate\n    // attributes accordingly.\n    /* eslint-disable max-statements */\n\n  }, {\n    key: '_diffUpdateTriggers',\n    value: function _diffUpdateTriggers(oldProps, newProps) {\n      // const {attributeManager} = this.state;\n      // const updateTriggerMap = attributeManager.getUpdateTriggerMap();\n\n      var change = false;\n\n      for (var propName in newProps.updateTriggers) {\n        var oldTriggers = oldProps.updateTriggers[propName] || {};\n        var newTriggers = newProps.updateTriggers[propName] || {};\n        var diffReason = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"g\" /* compareProps */])({\n          oldProps: oldTriggers,\n          newProps: newTriggers\n        });\n        if (diffReason) {\n          if (propName === 'all') {\n            __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, 'updateTriggers invalidating all attributes: ' + diffReason);\n            this.invalidateAttribute('all');\n            change = true;\n          } else {\n            __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, 'updateTriggers invalidating attribute ' + propName + ': ' + diffReason);\n            this.invalidateAttribute(propName);\n            change = true;\n          }\n        }\n      }\n\n      return change;\n    }\n    /* eslint-enable max-statements */\n\n  }, {\n    key: 'validateRequiredProp',\n    value: function validateRequiredProp(propertyName, condition) {\n      var value = this.props[propertyName];\n      if (value === undefined) {\n        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);\n      }\n      if (condition && !condition(value)) {\n        throw new Error('Bad property ' + propertyName + ' in layer ' + this);\n      }\n    }\n  }, {\n    key: '_updateBaseUniforms',\n    value: function _updateBaseUniforms() {\n      this.setUniforms({\n        // apply gamma to opacity to make it visually \"linear\"\n        opacity: Math.pow(this.props.opacity, 1 / 2.2),\n        ONE: 1.0\n      });\n    }\n\n    // DEPRECATED METHODS\n    // shouldUpdate() {}\n\n  }, {\n    key: 'willReceiveProps',\n    value: function willReceiveProps() {}\n\n    // Updates selected state members and marks the object for redraw\n\n  }, {\n    key: 'setUniforms',\n    value: function setUniforms(uniformMap) {\n      if (this.state.model) {\n        this.state.model.setUniforms(uniformMap);\n      }\n      // TODO - set needsRedraw on the model?\n      this.state.needsRedraw = true;\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */])(3, 'layer.setUniforms', uniformMap);\n    }\n  }]);\n\n  return Layer;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = Layer;\n\n\nLayer.layerName = 'Layer';\nLayer.defaultProps = defaultProps;\n\n// HELPERS\n\n// Constructors have their super class constructors as prototypes\nfunction getOwnProperty(object, prop) {\n  return object.hasOwnProperty(prop) && object[prop];\n}\n/*\n * Return merged default props stored on layers constructor, create them if needed\n */\nfunction getDefaultProps(layer) {\n  var mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');\n  if (mergedDefaultProps) {\n    return mergedDefaultProps;\n  }\n  return mergeDefaultProps(layer);\n}\n\n/*\n * Walk the prototype chain and merge all default props\n */\nfunction mergeDefaultProps(layer) {\n  var subClassConstructor = layer.constructor;\n  var layerName = getOwnProperty(subClassConstructor, 'layerName');\n  if (!layerName) {\n    __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].once(0, 'layer ' + layer.constructor.name + ' does not specify a \"layerName\"');\n  }\n  var mergedDefaultProps = {\n    id: layerName || layer.constructor.name\n  };\n\n  while (layer) {\n    var layerDefaultProps = getOwnProperty(layer.constructor, 'defaultProps');\n    Object.freeze(layerDefaultProps);\n    if (layerDefaultProps) {\n      mergedDefaultProps = Object.assign({}, layerDefaultProps, mergedDefaultProps);\n    }\n    layer = Object.getPrototypeOf(layer);\n  }\n  // Store for quick lookup\n  subClassConstructor.mergedDefaultProps = mergedDefaultProps;\n  return mergedDefaultProps;\n}\n\nvar TEST_EXPORTS = {\n  mergeDefaultProps: mergeDefaultProps\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2xheWVyLmpzPzI5MTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHsgR0wgfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCBBdHRyaWJ1dGVNYW5hZ2VyIGZyb20gJy4vYXR0cmlidXRlLW1hbmFnZXInO1xuaW1wb3J0IHsgY29tcGFyZVByb3BzLCBsb2csIGNvdW50IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8qXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuaWQgLSBsYXllciBuYW1lXG4gKiBAcGFyYW0ge2FycmF5fSAgcHJvcHMuZGF0YSAtIGFycmF5IG9mIGRhdGEgaW5zdGFuY2VzXG4gKiBAcGFyYW0ge2Jvb2x9IHByb3BzLm9wYWNpdHkgLSBvcGFjaXR5IG9mIHRoZSBsYXllclxuICovXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBkYXRhSXRlcmF0b3I6IG51bGwsXG4gIGRhdGFDb21wYXJhdG9yOiBudWxsLFxuICBudW1JbnN0YW5jZXM6IHVuZGVmaW5lZCxcbiAgdmlzaWJsZTogdHJ1ZSxcbiAgcGlja2FibGU6IGZhbHNlLFxuICBvcGFjaXR5OiAwLjgsXG4gIG9uSG92ZXI6IGZ1bmN0aW9uIG9uSG92ZXIoKSB7fSxcbiAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHt9LFxuICAvLyBVcGRhdGUgdHJpZ2dlcnM6IGEga2V5IGNoYW5nZSBkZXRlY3Rpb24gbWVjaGFuaXNtIGluIGRlY2suZ2xcbiAgLy8gU2VlIGxheWVyIGRvY3VtZW50YXRpb25cbiAgdXBkYXRlVHJpZ2dlcnM6IHt9XG59O1xuXG52YXIgY291bnRlciA9IDA7XG5cbnZhciBMYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBTZWUgZG9jcyBhbmQgZGVmYXVsdHMgYWJvdmVcbiAgICovXG4gIGZ1bmN0aW9uIExheWVyKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheWVyKTtcblxuICAgIC8vIElmIHN1YmxheWVyIGhhcyBzdGF0aWMgZGVmYXVsdFByb3BzIG1lbWJlciwgZ2V0RGVmYXVsdFByb3BzIHdpbGwgcmV0dXJuIGl0XG4gICAgdmFyIG1lcmdlZERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcyh0aGlzKTtcbiAgICAvLyBNZXJnZSBzdXBwbGllZCBwcm9wcyB3aXRoIHByZS1tZXJnZWQgZGVmYXVsdCBwcm9wc1xuICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWVyZ2VkRGVmYXVsdFByb3BzLCBwcm9wcyk7XG4gICAgLy8gQWNjZXB0IG51bGwgYXMgZGF0YSAtIG90aGVyd2lzZSBhcHBzIGFuZCBsYXllcnMgbmVlZCB0byBhZGQgdWdseSBjaGVja3NcbiAgICBwcm9wcy5kYXRhID0gcHJvcHMuZGF0YSB8fCBbXTtcbiAgICAvLyBQcm9wcyBhcmUgaW1tdXRhYmxlXG4gICAgT2JqZWN0LmZyZWV6ZShwcm9wcyk7XG5cbiAgICAvLyBEZWZpbmUgYWxsIG1lbWJlcnMgYW5kIGZyZWV6ZSBsYXllclxuICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5vbGRQcm9wcyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gY291bnRlcisrO1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuXG4gICAgdGhpcy52YWxpZGF0ZVJlcXVpcmVkUHJvcCgnaWQnLCBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJyAmJiB4ICE9PSAnJztcbiAgICB9KTtcbiAgICB0aGlzLnZhbGlkYXRlUmVxdWlyZWRQcm9wKCdkYXRhJyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGF5ZXIsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLmxheWVyTmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lICE9PSB0aGlzLnByb3BzLmlkID8gJzwnICsgY2xhc3NOYW1lICsgJzpcXCcnICsgdGhpcy5wcm9wcy5pZCArICdcXCc+JyA6ICc8JyArIGNsYXNzTmFtZSArICc+JztcbiAgICB9XG5cbiAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIExJRkVDWUNMRSBNRVRIT0RTLCBvdmVycmlkZGVuIGJ5IHRoZSBsYXllciBzdWJjbGFzc2VzXG5cbiAgICAvLyBDYWxsZWQgb25jZSB0byBzZXQgdXAgdGhlIGluaXRpYWwgc3RhdGVcbiAgICAvLyBBcHAgY2FuIGNyZWF0ZSBXZWJHTCByZXNvdXJjZXNcblxuICB9LCB7XG4gICAga2V5OiAnaW5pdGlhbGl6ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMYXllciAnICsgdGhpcyArICcgaGFzIG5vdCBkZWZpbmVkIGluaXRpYWxpemVTdGF0ZScpO1xuICAgIH1cblxuICAgIC8vIExldCdzIGxheWVyIGNvbnRyb2wgaWYgdXBkYXRlU3RhdGUgc2hvdWxkIGJlIGNhbGxlZFxuXG4gIH0sIHtcbiAgICBrZXk6ICdzaG91bGRVcGRhdGVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZFVwZGF0ZVN0YXRlKF9yZWYpIHtcbiAgICAgIHZhciBvbGRQcm9wcyA9IF9yZWYub2xkUHJvcHMsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIG9sZENvbnRleHQgPSBfcmVmLm9sZENvbnRleHQsXG4gICAgICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VGbGFncyA9IF9yZWYuY2hhbmdlRmxhZ3M7XG5cbiAgICAgIHJldHVybiBjaGFuZ2VGbGFncy5zb21ldGhpbmdDaGFuZ2VkO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24sIGFsbCBhdHRyaWJ1dGVzIHdpbGwgYmUgaW52YWxpZGF0ZWQgYW5kIHVwZGF0ZWRcbiAgICAvLyB3aGVuIGRhdGEgY2hhbmdlc1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKF9yZWYyKSB7XG4gICAgICB2YXIgb2xkUHJvcHMgPSBfcmVmMi5vbGRQcm9wcyxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYyLnByb3BzLFxuICAgICAgICAgIG9sZENvbnRleHQgPSBfcmVmMi5vbGRDb250ZXh0LFxuICAgICAgICAgIGNvbnRleHQgPSBfcmVmMi5jb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzID0gX3JlZjIuY2hhbmdlRmxhZ3M7XG5cbiAgICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLmludmFsaWRhdGVBdHRyaWJ1dGUoJ2FsbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGxlZCBvbmNlIHdoZW4gbGF5ZXIgaXMgbm8gbG9uZ2VyIG1hdGNoZWQgYW5kIHN0YXRlIHdpbGwgYmUgZGlzY2FyZGVkXG4gICAgLy8gQXBwIGNhbiBkZXN0cm95IFdlYkdMIHJlc291cmNlcyBoZXJlXG5cbiAgfSwge1xuICAgIGtleTogJ2ZpbmFsaXplU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZVN0YXRlKCkge31cblxuICAgIC8vIEltcGxlbWVudCB0byBnZW5lcmF0ZSBzdWJsYXllcnNcblxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyTGF5ZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGF5ZXJzKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSWYgc3RhdGUgaGFzIGEgbW9kZWwsIGRyYXcgaXQgd2l0aCBzdXBwbGllZCB1bmlmb3Jtc1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmMykge1xuICAgICAgdmFyIF9yZWYzJHVuaWZvcm1zID0gX3JlZjMudW5pZm9ybXMsXG4gICAgICAgICAgdW5pZm9ybXMgPSBfcmVmMyR1bmlmb3JtcyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmMyR1bmlmb3JtcztcblxuICAgICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGxlZCB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3QgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAvLyBAcmV0dXJuIG51bGwgdG8gY2FuY2VsIGV2ZW50XG5cbiAgfSwge1xuICAgIGtleTogJ2dldFBpY2tpbmdJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGlja2luZ0luZm8oX3JlZjQpIHtcbiAgICAgIHZhciBpbmZvID0gX3JlZjQuaW5mbyxcbiAgICAgICAgICBtb2RlID0gX3JlZjQubW9kZTtcbiAgICAgIHZhciBjb2xvciA9IGluZm8uY29sb3IsXG4gICAgICAgICAgaW5kZXggPSBpbmZvLmluZGV4O1xuXG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIC8vIElmIHByb3BzLmRhdGEgaXMgYW4gaW5kZXhhYmxlIGFycmF5LCBnZXQgdGhlIG9iamVjdFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnByb3BzLmRhdGEpKSB7XG4gICAgICAgICAgaW5mby5vYmplY3QgPSB0aGlzLnByb3BzLmRhdGFbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8gLSBtb3ZlIHRvIHRoZSBKUyBwYXJ0IG9mIGEgc2hhZGVyIHBpY2tpbmcgc2hhZGVyIHBhY2thZ2VcbiAgICAgIGlmIChtb2RlID09PSAnaG92ZXInKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZFBpY2tpbmdDb2xvciA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIHNlbGVjdGVkUGlja2luZ0NvbG9yWzBdID0gY29sb3JbMF07XG4gICAgICAgIHNlbGVjdGVkUGlja2luZ0NvbG9yWzFdID0gY29sb3JbMV07XG4gICAgICAgIHNlbGVjdGVkUGlja2luZ0NvbG9yWzJdID0gY29sb3JbMl07XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybXMoeyBzZWxlY3RlZFBpY2tpbmdDb2xvcjogc2VsZWN0ZWRQaWNraW5nQ29sb3IgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIEVORCBMSUZFQ1lDTEUgTUVUSE9EU1xuICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGF0dHJpYnV0ZSBpbnZhbGlkYXRpb24sIGNhbiBiZSByZWRlZmluZVxuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnZhbGlkYXRlQXR0cmlidXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZUF0dHJpYnV0ZSgpIHtcbiAgICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnYWxsJztcblxuICAgICAgaWYgKG5hbWUgPT09ICdhbGwnKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWxscyBhdHRyaWJ1dGUgbWFuYWdlciB0byB1cGRhdGUgYW55IFdlYkdMIGF0dHJpYnV0ZXMsIGNhbiBiZSByZWRlZmluZWRcblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlQXR0cmlidXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZXMocHJvcHMpIHtcbiAgICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIgPSBfc3RhdGUuYXR0cmlidXRlTWFuYWdlcixcbiAgICAgICAgICBtb2RlbCA9IF9zdGF0ZS5tb2RlbDtcblxuICAgICAgaWYgKCFhdHRyaWJ1dGVNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG51bUluc3RhbmNlcyA9IHRoaXMuZ2V0TnVtSW5zdGFuY2VzKHByb3BzKTtcbiAgICAgIC8vIEZpZ3VyZSBvdXQgZGF0YSBsZW5ndGhcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKHtcbiAgICAgICAgZGF0YTogcHJvcHMuZGF0YSxcbiAgICAgICAgbnVtSW5zdGFuY2VzOiBudW1JbnN0YW5jZXMsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgYnVmZmVyczogcHJvcHMsXG4gICAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAgIC8vIERvbid0IHdvcnJ5IGFib3V0IG5vbi1hdHRyaWJ1dGUgcHJvcHNcbiAgICAgICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXM6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkQXR0cmlidXRlcyA9IGF0dHJpYnV0ZU1hbmFnZXIuZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoeyBjbGVhckNoYW5nZWRGbGFnczogdHJ1ZSB9KTtcbiAgICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhjaGFuZ2VkQXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHVibGljIEFQSVxuXG4gICAgLy8gVXBkYXRlcyBzZWxlY3RlZCBzdGF0ZSBtZW1iZXJzIGFuZCBtYXJrcyB0aGUgb2JqZWN0IGZvciByZWRyYXdcblxuICB9LCB7XG4gICAga2V5OiAnc2V0U3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdGF0ZSh1cGRhdGVPYmplY3QpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwgdXBkYXRlT2JqZWN0KTtcbiAgICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldE5lZWRzUmVkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TmVlZHNSZWRyYXcoKSB7XG4gICAgICB2YXIgcmVkcmF3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gcmVkcmF3O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBST0pFQ1RJT04gTUVUSE9EU1xuXG4gICAgLyoqXG4gICAgICogUHJvamVjdHMgYSBwb2ludCB3aXRoIGN1cnJlbnQgbWFwIHN0YXRlIChsYXQsIGxvbiwgem9vbSwgcGl0Y2gsIGJlYXJpbmcpXG4gICAgICpcbiAgICAgKiBOb3RlOiBQb3NpdGlvbiBjb252ZXJzaW9uIGlzIGRvbmUgaW4gc2hhZGVyLCBzbyBpbiBtYW55IGNhc2VzIHRoZXJlIGlzIG5vIG5lZWRcbiAgICAgKiBmb3IgdGhpcyBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gbG5nTGF0IC0gbG9uZyBhbmQgbGF0IHZhbHVlc1xuICAgICAqIEByZXR1cm4ge0FycmF5fFR5cGVkQXJyYXl9IC0geCwgeSBjb29yZGluYXRlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9qZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvamVjdChsbmdMYXQpIHtcbiAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcblxuICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkobG5nTGF0KSwgJ0xheWVyLnByb2plY3QgbmVlZHMgW2xuZyxsYXRdJyk7XG4gICAgICByZXR1cm4gdmlld3BvcnQucHJvamVjdChsbmdMYXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VucHJvamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucHJvamVjdCh4eSkge1xuICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuXG4gICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh4eSksICdMYXllci51bnByb2plY3QgbmVlZHMgW3gseV0nKTtcbiAgICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3QoeHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Byb2plY3RGbGF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvamVjdEZsYXQobG5nTGF0KSB7XG4gICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLmNvbnRleHQudmlld3BvcnQ7XG5cbiAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgICAgcmV0dXJuIHZpZXdwb3J0LnByb2plY3RGbGF0KGxuZ0xhdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW5wcm9qZWN0RmxhdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucHJvamVjdEZsYXQoeHkpIHtcbiAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcblxuICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoeHkpLCAnTGF5ZXIudW5wcm9qZWN0IG5lZWRzIFt4LHldJyk7XG4gICAgICByZXR1cm4gdmlld3BvcnQudW5wcm9qZWN0RmxhdCh4eSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2NyZWVuVG9EZXZpY2VQaXhlbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JlZW5Ub0RldmljZVBpeGVscyhzY3JlZW5QaXhlbHMpIHtcbiAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gICAgICByZXR1cm4gc2NyZWVuUGl4ZWxzICogZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gLSBhIGJsYWNrIGNvbG9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ251bGxQaWNraW5nQ29sb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBudWxsUGlja2luZ0NvbG9yKCkge1xuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICAgKiBAcGFyYW0ge2ludH0gaSAtIGluZGV4IHRvIGJlIGRlY29kZWRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgZGVjb2RlZCBjb2xvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmNvZGVQaWNraW5nQ29sb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGVQaWNraW5nQ29sb3IoaSkge1xuICAgICAgcmV0dXJuIFsoaSArIDEpICUgMjU2LCBNYXRoLmZsb29yKChpICsgMSkgLyAyNTYpICUgMjU2LCBNYXRoLmZsb29yKChpICsgMSkgLyAyNTYgLyAyNTYpICUgMjU2XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIHRoYXQgZG9lc24ndCBtYXRjaCBhbnkgc3ViZmVhdHVyZVxuICAgICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbG9yIC0gY29sb3IgYXJyYXkgdG8gYmUgZGVjb2RlZFxuICAgICAqIEByZXR1cm4ge0FycmF5fSAtIHRoZSBkZWNvZGVkIHBpY2tpbmcgY29sb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVjb2RlUGlja2luZ0NvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlUGlja2luZ0NvbG9yKGNvbG9yKSB7XG4gICAgICBhc3NlcnQoY29sb3IgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcblxuICAgICAgdmFyIF9jb2xvciA9IF9zbGljZWRUb0FycmF5KGNvbG9yLCAzKSxcbiAgICAgICAgICBpMSA9IF9jb2xvclswXSxcbiAgICAgICAgICBpMiA9IF9jb2xvclsxXSxcbiAgICAgICAgICBpMyA9IF9jb2xvclsyXTtcbiAgICAgIC8vIDEgd2FzIGFkZGVkIHRvIHNlcGVyYXRlIGZyb20gbm8gc2VsZWN0aW9uXG5cblxuICAgICAgdmFyIGluZGV4ID0gaTEgKyBpMiAqIDI1NiArIGkzICogNjU1MzYgLSAxO1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycyhhdHRyaWJ1dGUsIF9yZWY1KSB7XG4gICAgICB2YXIgbnVtSW5zdGFuY2VzID0gX3JlZjUubnVtSW5zdGFuY2VzO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcbiAgICAgIC8vIGFkZCAxIHRvIGluZGV4IHRvIHNlcGVyYXRlIGZyb20gbm8gc2VsZWN0aW9uXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtSW5zdGFuY2VzOyBpKyspIHtcbiAgICAgICAgdmFyIHBpY2tpbmdDb2xvciA9IHRoaXMuZW5jb2RlUGlja2luZ0NvbG9yKGkpO1xuICAgICAgICB2YWx1ZVtpICogc2l6ZSArIDBdID0gcGlja2luZ0NvbG9yWzBdO1xuICAgICAgICB2YWx1ZVtpICogc2l6ZSArIDFdID0gcGlja2luZ0NvbG9yWzFdO1xuICAgICAgICB2YWx1ZVtpICogc2l6ZSArIDJdID0gcGlja2luZ0NvbG9yWzJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERBVEEgQUNDRVNTIEFQSVxuICAgIC8vIERhdGEgY2FuIHVzZSBpdGVyYXRvcnMgYW5kIG1heSBub3QgYmUgcmFuZG9tIGFjY2Vzc1xuXG4gICAgLy8gVXNlIGl0ZXJhdGlvbiAodGhlIG9ubHkgcmVxdWlyZWQgY2FwYWJpbGl0eSBvbiBkYXRhKSB0byBnZXQgZmlyc3QgZWxlbWVudFxuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRGaXJzdE9iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpcnN0T2JqZWN0KCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLnByb3BzLmRhdGE7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gICAgLy8gRGVkdWNlcyBudW1lciBvZiBpbnN0YW5jZXMuIEludGVudGlvbiBpcyB0byBzdXBwb3J0OlxuICAgIC8vIC0gRXhwbGljaXQgc2V0dGluZyBvZiBudW1JbnN0YW5jZXNcbiAgICAvLyAtIEF1dG8tZGVkdWN0aW9uIGZvciBFUzYgY29udGFpbmVycyB0aGF0IGRlZmluZSBhIHNpemUgbWVtYmVyXG4gICAgLy8gLSBBdXRvLWRlZHVjdGlvbiBmb3IgQ2xhc3NpYyBBcnJheXMgdmlhIHRoZSBidWlsdC1pbiBsZW5ndGggYXR0cmlidXRlXG4gICAgLy8gLSBBdXRvLWRlZHVjdGlvbiB2aWEgYXJyYXlzXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE51bUluc3RhbmNlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bUluc3RhbmNlcyhwcm9wcykge1xuICAgICAgcHJvcHMgPSBwcm9wcyB8fCB0aGlzLnByb3BzO1xuXG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgbGF5ZXIgaGFzIHNldCBpdHMgb3duIHZhbHVlXG4gICAgICBpZiAodGhpcy5zdGF0ZSAmJiB0aGlzLnN0YXRlLm51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLm51bUluc3RhbmNlcztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgYXBwIGhhcyBwcm92aWRlZCBhbiBleHBsaWNpdCB2YWx1ZVxuICAgICAgaWYgKHByb3BzLm51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwcm9wcy5udW1JbnN0YW5jZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSBjb250YWluZXIgbGlicmFyeSB0byBnZXQgYSBjb3VudCBmb3IgYW55IEVTNiBjb250YWluZXIgb3Igb2JqZWN0XG4gICAgICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wcy5kYXRhO1xuXG4gICAgICByZXR1cm4gY291bnQoZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gTEFZRVIgTUFOQUdFUiBBUElcbiAgICAvLyBTaG91bGQgb25seSBiZSBjYWxsZWQgYnkgdGhlIGRlY2suZ2wgTGF5ZXJNYW5hZ2VyIGNsYXNzXG5cbiAgICAvLyBDYWxsZWQgYnkgbGF5ZXIgbWFuYWdlciB3aGVuIGEgbmV3IGxheWVyIGlzIGZvdW5kXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5pdGlhbGl6ZUxheWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgICAgYXNzZXJ0KHRoaXMuY29udGV4dC5nbCwgJ0xheWVyIGNvbnRleHQgbWlzc2luZyBnbCcpO1xuICAgICAgYXNzZXJ0KCF0aGlzLnN0YXRlLCAnTGF5ZXIgbWlzc2luZyBzdGF0ZScpO1xuXG4gICAgICB0aGlzLnN0YXRlID0ge307XG5cbiAgICAgIC8vIEluaXRpYWxpemUgc3RhdGUgb25seSBvbmNlXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlcjogbmV3IEF0dHJpYnV0ZU1hbmFnZXIoeyBpZDogdGhpcy5wcm9wcy5pZCB9KSxcbiAgICAgICAgbW9kZWw6IG51bGwsXG4gICAgICAgIG5lZWRzUmVkcmF3OiB0cnVlLFxuICAgICAgICBkYXRhQ2hhbmdlZDogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBhdHRyaWJ1dGUgbWFuYWdlciBsb2dnZXJzIGlmIHByb3ZpZGVkXG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuc2V0TG9nRnVuY3Rpb25zKHRoaXMucHJvcHMpO1xuXG4gICAgICB2YXIgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlcjtcbiAgICAgIC8vIEFsbCBpbnN0YW5jZWQgbGF5ZXJzIGdldCBpbnN0YW5jZVBpY2tpbmdDb2xvcnMgYXR0cmlidXRlIGJ5IGRlZmF1bHRcbiAgICAgIC8vIFRoZWlyIHNoYWRlcnMgY2FuIHVzZSBpdCB0byByZW5kZXIgYSBwaWNraW5nIHNjZW5lXG4gICAgICAvLyBUT0RPIC0gdGhpcyBzbG93cyBkb3duIG5vbiBpbnN0YW5jZWQgbGF5ZXJzXG5cbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgICAgaW5zdGFuY2VQaWNraW5nQ29sb3JzOiB7XG4gICAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnNcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZHNcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgICAvLyBFbmQgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZHNcblxuICAgICAgLy8gQWRkIGFueSBzdWJjbGFzcyBhdHRyaWJ1dGVzXG4gICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXModGhpcy5wcm9wcyk7XG4gICAgICB0aGlzLl91cGRhdGVCYXNlVW5pZm9ybXMoKTtcblxuICAgICAgdmFyIG1vZGVsID0gdGhpcy5zdGF0ZS5tb2RlbDtcblxuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5nZXROdW1JbnN0YW5jZXMoKSk7XG4gICAgICAgIG1vZGVsLmlkID0gdGhpcy5wcm9wcy5pZDtcbiAgICAgICAgbW9kZWwucHJvZ3JhbS5pZCA9IHRoaXMucHJvcHMuaWQgKyAnLXByb2dyYW0nO1xuICAgICAgICBtb2RlbC5nZW9tZXRyeS5pZCA9IHRoaXMucHJvcHMuaWQgKyAnLWdlb21ldHJ5JztcbiAgICAgICAgbW9kZWwuc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVNYW5hZ2VyLmdldEF0dHJpYnV0ZXMoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIGJ5IGxheWVyIG1hbmFnZXIgd2hlbiBleGlzdGluZyBsYXllciBpcyBnZXR0aW5nIG5ldyBwcm9wc1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVMYXllcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgICAgLy8gQ2hlY2sgZm9yIGRlcHJlY2F0ZWQgbWV0aG9kXG4gICAgICBpZiAodGhpcy5zaG91bGRVcGRhdGUpIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgJ2RlY2suZ2wgdjMgJyArIHRoaXMgKyAnOiBcInNob3VsZFVwZGF0ZVwiIGRlcHJlY2F0ZWQsIHJlbmFtZWQgdG8gXCJzaG91bGRVcGRhdGVTdGF0ZVwiJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgICAgdmFyIHN0YXRlTmVlZHNVcGRhdGUgPSB0aGlzLnNob3VsZFVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuXG4gICAgICBpZiAoc3RhdGVOZWVkc1VwZGF0ZSkge1xuXG4gICAgICAgIC8vIENhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGUgbWV0aG9kIGlmIGRlZmluZWRcbiAgICAgICAgdmFyIGhhc1JlZGVmaW5lZE1ldGhvZCA9IHRoaXMud2lsbFJlY2VpdmVQcm9wcyAmJiB0aGlzLndpbGxSZWNlaXZlUHJvcHMgIT09IExheWVyLnByb3RvdHlwZS53aWxsUmVjZWl2ZVByb3BzO1xuICAgICAgICBpZiAoaGFzUmVkZWZpbmVkTWV0aG9kKSB7XG4gICAgICAgICAgbG9nLm9uY2UoMCwgJ2RlY2suZ2wgdjMgd2lsbFJlY2VpdmVQcm9wcyBkZXByZWNhdGVkLiBVc2UgdXBkYXRlU3RhdGUgaW4gJyArIHRoaXMpO1xuICAgICAgICAgIHZhciBvbGRQcm9wcyA9IHVwZGF0ZVBhcmFtcy5vbGRQcm9wcyxcbiAgICAgICAgICAgICAgcHJvcHMgPSB1cGRhdGVQYXJhbXMucHJvcHMsXG4gICAgICAgICAgICAgIGNoYW5nZUZsYWdzID0gdXBkYXRlUGFyYW1zLmNoYW5nZUZsYWdzO1xuXG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZShjaGFuZ2VGbGFncyk7XG4gICAgICAgICAgdGhpcy53aWxsUmVjZWl2ZVByb3BzKG9sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3MpO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZGF0YUNoYW5nZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdmlld3BvcnRDaGFuZ2VkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG5cbiAgICAgICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAgICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcblxuICAgICAgICAvLyBSdW4gdGhlIGF0dHJpYnV0ZSB1cGRhdGVyc1xuICAgICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXModXBkYXRlUGFyYW1zLnByb3BzKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmFzZVVuaWZvcm1zKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5nZXROdW1JbnN0YW5jZXMoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gICAgLy8gQ2FsbGVkIGJ5IG1hbmFnZXIgd2hlbiBsYXllciBpcyBhYm91dCB0byBiZSBkaXNwb3NlZFxuICAgIC8vIE5vdGU6IG5vdCBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBvbiBhcHBsaWNhdGlvbiBzaHV0ZG93blxuXG4gIH0sIHtcbiAgICBrZXk6ICdmaW5hbGl6ZUxheWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluYWxpemVMYXllcigpIHtcbiAgICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgICAgdGhpcy5maW5hbGl6ZVN0YXRlKCk7XG4gICAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZXMgdW5pZm9ybXNcblxuICB9LCB7XG4gICAga2V5OiAnZHJhd0xheWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xheWVyKF9yZWY2KSB7XG4gICAgICB2YXIgX3JlZjYkdW5pZm9ybXMgPSBfcmVmNi51bmlmb3JtcyxcbiAgICAgICAgICB1bmlmb3JtcyA9IF9yZWY2JHVuaWZvcm1zID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWY2JHVuaWZvcm1zO1xuXG4gICAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICAgIHRoaXMuZHJhdyh7IHVuaWZvcm1zOiB1bmlmb3JtcyB9KTtcbiAgICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gICAgfVxuXG4gICAgLy8ge3VuaWZvcm1zID0ge30sIC4uLm9wdHN9XG5cbiAgfSwge1xuICAgIGtleTogJ3BpY2tMYXllcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBpY2tMYXllcihvcHRzKSB7XG4gICAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RcbiAgICAgIHJldHVybiB0aGlzLmdldFBpY2tpbmdJbmZvKG9wdHMpO1xuICAgICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaWZmUHJvcHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaWZmUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzLCBjb250ZXh0KSB7XG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiBhbnkgcHJvcHMgaGF2ZSBjaGFuZ2VkIChpZ25vcmUgcHJvcHMgdGhhdCB3aWxsIGJlIGV4YW1pbmVkIHNlcGFyYXRlbHkpXG4gICAgICB2YXIgcHJvcHNDaGFuZ2VkUmVhc29uID0gY29tcGFyZVByb3BzKHtcbiAgICAgICAgbmV3UHJvcHM6IG5ld1Byb3BzLFxuICAgICAgICBvbGRQcm9wczogb2xkUHJvcHMsXG4gICAgICAgIGlnbm9yZVByb3BzOiB7IGRhdGE6IG51bGwsIHVwZGF0ZVRyaWdnZXJzOiBudWxsIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBOb3cgY2hlY2sgaWYgYW55IGRhdGEgcmVsYXRlZCBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgICAgIHZhciBkYXRhQ2hhbmdlZFJlYXNvbiA9IHRoaXMuX2RpZmZEYXRhUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzKTtcblxuICAgICAgdmFyIHByb3BzQ2hhbmdlZCA9IEJvb2xlYW4ocHJvcHNDaGFuZ2VkUmVhc29uKTtcbiAgICAgIHZhciBkYXRhQ2hhbmdlZCA9IEJvb2xlYW4oZGF0YUNoYW5nZWRSZWFzb24pO1xuICAgICAgdmFyIHZpZXdwb3J0Q2hhbmdlZCA9IGNvbnRleHQudmlld3BvcnRDaGFuZ2VkO1xuICAgICAgdmFyIHNvbWV0aGluZ0NoYW5nZWQgPSBwcm9wc0NoYW5nZWQgfHwgZGF0YUNoYW5nZWQgfHwgdmlld3BvcnRDaGFuZ2VkO1xuXG4gICAgICAvLyBDaGVjayB1cGRhdGUgdHJpZ2dlcnMgdG8gZGV0ZXJtaW5lIGlmIGFueSBhdHRyaWJ1dGVzIG5lZWQgcmVnZW5lcmF0aW9uXG4gICAgICAvLyBOb3RlIC0gaWYgZGF0YSBoYXMgY2hhbmdlZCwgYWxsIGF0dHJpYnV0ZXMgd2lsbCBuZWVkIHJlZ2VuZXJhdGlvbiwgc28gc2tpcCB0aGlzIHN0ZXBcbiAgICAgIGlmICghZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fZGlmZlVwZGF0ZVRyaWdnZXJzKG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cubG9nKDEsICdkYXRhQ2hhbmdlZDogJyArIGRhdGFDaGFuZ2VkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNDaGFuZ2VkOiBwcm9wc0NoYW5nZWQsXG4gICAgICAgIGRhdGFDaGFuZ2VkOiBkYXRhQ2hhbmdlZCxcbiAgICAgICAgdmlld3BvcnRDaGFuZ2VkOiB2aWV3cG9ydENoYW5nZWQsXG4gICAgICAgIHNvbWV0aGluZ0NoYW5nZWQ6IHNvbWV0aGluZ0NoYW5nZWQsXG4gICAgICAgIHJlYXNvbjogZGF0YUNoYW5nZWRSZWFzb24gfHwgcHJvcHNDaGFuZ2VkUmVhc29uXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrcyBzdGF0ZSBvZiBhdHRyaWJ1dGVzIGFuZCBtb2RlbFxuICAgIC8vIFRPRE8gLSBpcyBhdHRyaWJ1dGUgbWFuYWdlciBuZWVkZWQ/IC0gTW9kZWwgc2hvdWxkIGJlIGVub3VnaC5cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TmVlZHNSZWRyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROZWVkc1JlZHJhdygpIHtcbiAgICAgIHZhciBfcmVmNyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZjckY2xlYXJSZWRyYXdGbGFnID0gX3JlZjcuY2xlYXJSZWRyYXdGbGFncyxcbiAgICAgICAgICBjbGVhclJlZHJhd0ZsYWdzID0gX3JlZjckY2xlYXJSZWRyYXdGbGFnID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWY3JGNsZWFyUmVkcmF3RmxhZztcblxuICAgICAgLy8gdGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBieSB0aGUgcmVuZGVyIGxvb3AgYXMgc29vbiBhIHRoZSBsYXllclxuICAgICAgLy8gaGFzIGJlZW4gY3JlYXRlZCwgc28gZ3VhcmQgYWdhaW5zdCB1bmluaXRpYWxpemVkIHN0YXRlXG4gICAgICBpZiAoIXRoaXMuc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVkcmF3ID0gZmFsc2U7XG4gICAgICByZWRyYXcgPSByZWRyYXcgfHwgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdztcbiAgICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ICYmICFjbGVhclJlZHJhd0ZsYWdzO1xuXG4gICAgICB2YXIgX3N0YXRlMiA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgYXR0cmlidXRlTWFuYWdlciA9IF9zdGF0ZTIuYXR0cmlidXRlTWFuYWdlcixcbiAgICAgICAgICBtb2RlbCA9IF9zdGF0ZTIubW9kZWw7XG5cbiAgICAgIHJlZHJhdyA9IHJlZHJhdyB8fCBhdHRyaWJ1dGVNYW5hZ2VyICYmIGF0dHJpYnV0ZU1hbmFnZXIuZ2V0TmVlZHNSZWRyYXcoeyBjbGVhclJlZHJhd0ZsYWdzOiBjbGVhclJlZHJhd0ZsYWdzIH0pO1xuICAgICAgcmVkcmF3ID0gcmVkcmF3IHx8IG1vZGVsICYmIG1vZGVsLmdldE5lZWRzUmVkcmF3KHsgY2xlYXJSZWRyYXdGbGFnczogY2xlYXJSZWRyYXdGbGFncyB9KTtcblxuICAgICAgcmV0dXJuIHJlZHJhdztcbiAgICB9XG5cbiAgICAvLyBQUklWQVRFIE1FVEhPRFNcblxuICAgIC8vIFRoZSBjb21wYXJpc29uIG9mIHRoZSBkYXRhIHByb3AgcmVxdWlyZXMgc3BlY2lhbCBoYW5kbGluZ1xuICAgIC8vIHRoZSBkYXRhQ29tcGFyYXRvciBzaG91bGQgYmUgdXNlZCBpZiBzdXBwbGllZFxuXG4gIH0sIHtcbiAgICBrZXk6ICdfZGlmZkRhdGFQcm9wcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kaWZmRGF0YVByb3BzKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgLy8gU3VwcG9ydCBvcHRpb25hbCBhcHAgZGVmaW5lZCBjb21wYXJpc29uIG9mIGRhdGFcbiAgICAgIHZhciBkYXRhQ29tcGFyYXRvciA9IG5ld1Byb3BzLmRhdGFDb21wYXJhdG9yO1xuXG4gICAgICBpZiAoZGF0YUNvbXBhcmF0b3IpIHtcbiAgICAgICAgaWYgKCFkYXRhQ29tcGFyYXRvcihuZXdQcm9wcy5kYXRhLCBvbGRQcm9wcy5kYXRhKSkge1xuICAgICAgICAgIHJldHVybiAnRGF0YSBjb21wYXJhdG9yIGRldGVjdGVkIGEgY2hhbmdlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIGRvIGEgc2hhbGxvdyBlcXVhbCBvbiBwcm9wc1xuICAgICAgfSBlbHNlIGlmIChuZXdQcm9wcy5kYXRhICE9PSBvbGRQcm9wcy5kYXRhKSB7XG4gICAgICAgIHJldHVybiAnQSBuZXcgZGF0YSBjb250YWluZXIgd2FzIHN1cHBsaWVkJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2tzIGlmIGFueSB1cGRhdGUgdHJpZ2dlcnMgaGF2ZSBjaGFuZ2VkLCBhbmQgaW52YWxpZGF0ZVxuICAgIC8vIGF0dHJpYnV0ZXMgYWNjb3JkaW5nbHkuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2RpZmZVcGRhdGVUcmlnZ2VycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kaWZmVXBkYXRlVHJpZ2dlcnMob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICAvLyBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgICAgLy8gY29uc3QgdXBkYXRlVHJpZ2dlck1hcCA9IGF0dHJpYnV0ZU1hbmFnZXIuZ2V0VXBkYXRlVHJpZ2dlck1hcCgpO1xuXG4gICAgICB2YXIgY2hhbmdlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIG5ld1Byb3BzLnVwZGF0ZVRyaWdnZXJzKSB7XG4gICAgICAgIHZhciBvbGRUcmlnZ2VycyA9IG9sZFByb3BzLnVwZGF0ZVRyaWdnZXJzW3Byb3BOYW1lXSB8fCB7fTtcbiAgICAgICAgdmFyIG5ld1RyaWdnZXJzID0gbmV3UHJvcHMudXBkYXRlVHJpZ2dlcnNbcHJvcE5hbWVdIHx8IHt9O1xuICAgICAgICB2YXIgZGlmZlJlYXNvbiA9IGNvbXBhcmVQcm9wcyh7XG4gICAgICAgICAgb2xkUHJvcHM6IG9sZFRyaWdnZXJzLFxuICAgICAgICAgIG5ld1Byb3BzOiBuZXdUcmlnZ2Vyc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpZmZSZWFzb24pIHtcbiAgICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICBsb2cubG9nKDEsICd1cGRhdGVUcmlnZ2VycyBpbnZhbGlkYXRpbmcgYWxsIGF0dHJpYnV0ZXM6ICcgKyBkaWZmUmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZUF0dHJpYnV0ZSgnYWxsJyk7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2cubG9nKDEsICd1cGRhdGVUcmlnZ2VycyBpbnZhbGlkYXRpbmcgYXR0cmlidXRlICcgKyBwcm9wTmFtZSArICc6ICcgKyBkaWZmUmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZUF0dHJpYnV0ZShwcm9wTmFtZSk7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZhbGlkYXRlUmVxdWlyZWRQcm9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVSZXF1aXJlZFByb3AocHJvcGVydHlOYW1lLCBjb25kaXRpb24pIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMucHJvcHNbcHJvcGVydHlOYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgJyArIHByb3BlcnR5TmFtZSArICcgdW5kZWZpbmVkIGluIGxheWVyICcgKyB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25kaXRpb24gJiYgIWNvbmRpdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgcHJvcGVydHkgJyArIHByb3BlcnR5TmFtZSArICcgaW4gbGF5ZXIgJyArIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVCYXNlVW5pZm9ybXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQmFzZVVuaWZvcm1zKCkge1xuICAgICAgdGhpcy5zZXRVbmlmb3Jtcyh7XG4gICAgICAgIC8vIGFwcGx5IGdhbW1hIHRvIG9wYWNpdHkgdG8gbWFrZSBpdCB2aXN1YWxseSBcImxpbmVhclwiXG4gICAgICAgIG9wYWNpdHk6IE1hdGgucG93KHRoaXMucHJvcHMub3BhY2l0eSwgMSAvIDIuMiksXG4gICAgICAgIE9ORTogMS4wXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBERVBSRUNBVEVEIE1FVEhPRFNcbiAgICAvLyBzaG91bGRVcGRhdGUoKSB7fVxuXG4gIH0sIHtcbiAgICBrZXk6ICd3aWxsUmVjZWl2ZVByb3BzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lsbFJlY2VpdmVQcm9wcygpIHt9XG5cbiAgICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRVbmlmb3JtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVuaWZvcm1zKHVuaWZvcm1NYXApIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybU1hcCk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPIC0gc2V0IG5lZWRzUmVkcmF3IG9uIHRoZSBtb2RlbD9cbiAgICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgbG9nKDMsICdsYXllci5zZXRVbmlmb3JtcycsIHVuaWZvcm1NYXApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXllcjtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXI7XG5cblxuTGF5ZXIubGF5ZXJOYW1lID0gJ0xheWVyJztcbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuLy8gSEVMUEVSU1xuXG4vLyBDb25zdHJ1Y3RvcnMgaGF2ZSB0aGVpciBzdXBlciBjbGFzcyBjb25zdHJ1Y3RvcnMgYXMgcHJvdG90eXBlc1xuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHkob2JqZWN0LCBwcm9wKSB7XG4gIHJldHVybiBvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgb2JqZWN0W3Byb3BdO1xufVxuLypcbiAqIFJldHVybiBtZXJnZWQgZGVmYXVsdCBwcm9wcyBzdG9yZWQgb24gbGF5ZXJzIGNvbnN0cnVjdG9yLCBjcmVhdGUgdGhlbSBpZiBuZWVkZWRcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKGxheWVyKSB7XG4gIHZhciBtZXJnZWREZWZhdWx0UHJvcHMgPSBnZXRPd25Qcm9wZXJ0eShsYXllci5jb25zdHJ1Y3RvciwgJ21lcmdlZERlZmF1bHRQcm9wcycpO1xuICBpZiAobWVyZ2VkRGVmYXVsdFByb3BzKSB7XG4gICAgcmV0dXJuIG1lcmdlZERlZmF1bHRQcm9wcztcbiAgfVxuICByZXR1cm4gbWVyZ2VEZWZhdWx0UHJvcHMobGF5ZXIpO1xufVxuXG4vKlxuICogV2FsayB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBtZXJnZSBhbGwgZGVmYXVsdCBwcm9wc1xuICovXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRQcm9wcyhsYXllcikge1xuICB2YXIgc3ViQ2xhc3NDb25zdHJ1Y3RvciA9IGxheWVyLmNvbnN0cnVjdG9yO1xuICB2YXIgbGF5ZXJOYW1lID0gZ2V0T3duUHJvcGVydHkoc3ViQ2xhc3NDb25zdHJ1Y3RvciwgJ2xheWVyTmFtZScpO1xuICBpZiAoIWxheWVyTmFtZSkge1xuICAgIGxvZy5vbmNlKDAsICdsYXllciAnICsgbGF5ZXIuY29uc3RydWN0b3IubmFtZSArICcgZG9lcyBub3Qgc3BlY2lmeSBhIFwibGF5ZXJOYW1lXCInKTtcbiAgfVxuICB2YXIgbWVyZ2VkRGVmYXVsdFByb3BzID0ge1xuICAgIGlkOiBsYXllck5hbWUgfHwgbGF5ZXIuY29uc3RydWN0b3IubmFtZVxuICB9O1xuXG4gIHdoaWxlIChsYXllcikge1xuICAgIHZhciBsYXllckRlZmF1bHRQcm9wcyA9IGdldE93blByb3BlcnR5KGxheWVyLmNvbnN0cnVjdG9yLCAnZGVmYXVsdFByb3BzJyk7XG4gICAgT2JqZWN0LmZyZWV6ZShsYXllckRlZmF1bHRQcm9wcyk7XG4gICAgaWYgKGxheWVyRGVmYXVsdFByb3BzKSB7XG4gICAgICBtZXJnZWREZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBsYXllckRlZmF1bHRQcm9wcywgbWVyZ2VkRGVmYXVsdFByb3BzKTtcbiAgICB9XG4gICAgbGF5ZXIgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobGF5ZXIpO1xuICB9XG4gIC8vIFN0b3JlIGZvciBxdWljayBsb29rdXBcbiAgc3ViQ2xhc3NDb25zdHJ1Y3Rvci5tZXJnZWREZWZhdWx0UHJvcHMgPSBtZXJnZWREZWZhdWx0UHJvcHM7XG4gIHJldHVybiBtZXJnZWREZWZhdWx0UHJvcHM7XG59XG5cbmV4cG9ydCB2YXIgVEVTVF9FWFBPUlRTID0ge1xuICBtZXJnZURlZmF1bHRQcm9wczogbWVyZ2VEZWZhdWx0UHJvcHNcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL2xheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 15 */
/* unknown exports provided */
/*!********************************************!*\
  !*** ./src/lib/viewports/flat-viewport.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright (c) 2015 Uber Technologies, Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable */\n\n\nvar PI = Math.PI;\nvar pow = Math.pow;\nvar tan = Math.tan;\nvar log = Math.log;\nvar atan = Math.atan;\nvar exp = Math.exp;\nvar DEGREES_TO_RADIANS = PI / 180;\nvar RADIANS_TO_DEGREES = 180 / PI;\nfunction radians(value) {\n  return value * DEGREES_TO_RADIANS;\n}\nfunction degrees(value) {\n  return value * RADIANS_TO_DEGREES;\n}\n// see: https://en.wikipedia.org/wiki/Web_Mercator\nfunction ViewportMercator() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var scale = (opts.tileSize || 512) * 0.5 / PI * pow(2, opts.zoom);\n  var lamda = radians(opts.longitude);\n  var phi = radians(opts.latitude);\n  var x = scale * (lamda + PI);\n  var y = scale * (PI - log(tan(PI * 0.25 + phi * 0.5)));\n  var offsetX = opts.width * 0.5 - x;\n  var offsetY = opts.height * 0.5 - y;\n\n  function project(lnglat2) {\n    var lamda2 = lnglat2[0] * DEGREES_TO_RADIANS;\n    var phi2 = lnglat2[1] * DEGREES_TO_RADIANS;\n    var x2 = scale * (lamda2 + PI);\n    var y2 = scale * (PI - log(tan(PI * 0.25 + phi2 * 0.5)));\n    return [x2 + offsetX, y2 + offsetY];\n  }\n\n  function unproject(xy) {\n    var x2 = xy[0] - offsetX;\n    var y2 = xy[1] - offsetY;\n    var lamda2 = x2 / scale - PI;\n    var phi2 = 2 * (atan(exp(PI - y2 / scale)) - PI * 0.25);\n    return [degrees(lamda2), degrees(phi2)];\n  }\n\n  function contains(lnglat2) {\n    var xy = project(lnglat2);\n    var x = xy[0];\n    var y = xy[1];\n    return x >= 0 && x <= opts.width && y >= 0 && y <= opts.height;\n  }\n\n  return { project: project, unproject: unproject, contains: contains };\n}\n\nmodule.exports = ViewportMercator;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZpZXdwb3J0cy9mbGF0LXZpZXdwb3J0LmpzP2U4NGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbi8qIGVzbGludC1kaXNhYmxlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQSSA9IE1hdGguUEk7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgdGFuID0gTWF0aC50YW47XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgYXRhbiA9IE1hdGguYXRhbjtcbnZhciBleHAgPSBNYXRoLmV4cDtcbnZhciBERUdSRUVTX1RPX1JBRElBTlMgPSBQSSAvIDE4MDtcbnZhciBSQURJQU5TX1RPX0RFR1JFRVMgPSAxODAgLyBQSTtcbmZ1bmN0aW9uIHJhZGlhbnModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICogREVHUkVFU19UT19SQURJQU5TO1xufVxuZnVuY3Rpb24gZGVncmVlcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgKiBSQURJQU5TX1RPX0RFR1JFRVM7XG59XG4vLyBzZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NZXJjYXRvclxuZnVuY3Rpb24gVmlld3BvcnRNZXJjYXRvcigpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBzY2FsZSA9IChvcHRzLnRpbGVTaXplIHx8IDUxMikgKiAwLjUgLyBQSSAqIHBvdygyLCBvcHRzLnpvb20pO1xuICB2YXIgbGFtZGEgPSByYWRpYW5zKG9wdHMubG9uZ2l0dWRlKTtcbiAgdmFyIHBoaSA9IHJhZGlhbnMob3B0cy5sYXRpdHVkZSk7XG4gIHZhciB4ID0gc2NhbGUgKiAobGFtZGEgKyBQSSk7XG4gIHZhciB5ID0gc2NhbGUgKiAoUEkgLSBsb2codGFuKFBJICogMC4yNSArIHBoaSAqIDAuNSkpKTtcbiAgdmFyIG9mZnNldFggPSBvcHRzLndpZHRoICogMC41IC0geDtcbiAgdmFyIG9mZnNldFkgPSBvcHRzLmhlaWdodCAqIDAuNSAtIHk7XG5cbiAgZnVuY3Rpb24gcHJvamVjdChsbmdsYXQyKSB7XG4gICAgdmFyIGxhbWRhMiA9IGxuZ2xhdDJbMF0gKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gICAgdmFyIHBoaTIgPSBsbmdsYXQyWzFdICogREVHUkVFU19UT19SQURJQU5TO1xuICAgIHZhciB4MiA9IHNjYWxlICogKGxhbWRhMiArIFBJKTtcbiAgICB2YXIgeTIgPSBzY2FsZSAqIChQSSAtIGxvZyh0YW4oUEkgKiAwLjI1ICsgcGhpMiAqIDAuNSkpKTtcbiAgICByZXR1cm4gW3gyICsgb2Zmc2V0WCwgeTIgKyBvZmZzZXRZXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucHJvamVjdCh4eSkge1xuICAgIHZhciB4MiA9IHh5WzBdIC0gb2Zmc2V0WDtcbiAgICB2YXIgeTIgPSB4eVsxXSAtIG9mZnNldFk7XG4gICAgdmFyIGxhbWRhMiA9IHgyIC8gc2NhbGUgLSBQSTtcbiAgICB2YXIgcGhpMiA9IDIgKiAoYXRhbihleHAoUEkgLSB5MiAvIHNjYWxlKSkgLSBQSSAqIDAuMjUpO1xuICAgIHJldHVybiBbZGVncmVlcyhsYW1kYTIpLCBkZWdyZWVzKHBoaTIpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKGxuZ2xhdDIpIHtcbiAgICB2YXIgeHkgPSBwcm9qZWN0KGxuZ2xhdDIpO1xuICAgIHZhciB4ID0geHlbMF07XG4gICAgdmFyIHkgPSB4eVsxXTtcbiAgICByZXR1cm4geCA+PSAwICYmIHggPD0gb3B0cy53aWR0aCAmJiB5ID49IDAgJiYgeSA8PSBvcHRzLmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7IHByb2plY3Q6IHByb2plY3QsIHVucHJvamVjdDogdW5wcm9qZWN0LCBjb250YWluczogY29udGFpbnMgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1lcmNhdG9yO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi92aWV3cG9ydHMvZmxhdC12aWV3cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 16 */
/* exports provided: default, ViewportMercatorProject, FlatViewport, Viewport, PerspectiveViewport, OrthographicViewport, WebMercatorViewport */
/* exports used: WebMercatorViewport, Viewport */
/*!************************************!*\
  !*** ./src/lib/viewports/index.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flat_viewport__ = __webpack_require__(/*! ./flat-viewport */ 15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flat_viewport___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__flat_viewport__);\n/* unused harmony reexport default */\n/* unused harmony reexport ViewportMercatorProject */\n/* unused harmony reexport FlatViewport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__viewport__ = __webpack_require__(/*! ./viewport */ 9);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_1__viewport__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__perspective_viewport__ = __webpack_require__(/*! ./perspective-viewport */ 25);\n/* unused harmony reexport PerspectiveViewport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__orthographic_viewport__ = __webpack_require__(/*! ./orthographic-viewport */ 68);\n/* unused harmony reexport OrthographicViewport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__web_mercator_viewport__ = __webpack_require__(/*! ./web-mercator-viewport */ 69);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_4__web_mercator_viewport__[\"a\"]; });\n// Classic web-mercator-project\n\n\n\n\n// 3D viewports\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZpZXdwb3J0cy9pbmRleC5qcz84OTkyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENsYXNzaWMgd2ViLW1lcmNhdG9yLXByb2plY3RcbmV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL2ZsYXQtdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBWaWV3cG9ydE1lcmNhdG9yUHJvamVjdCB9IGZyb20gJy4vZmxhdC12aWV3cG9ydCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZsYXRWaWV3cG9ydCB9IGZyb20gJy4vZmxhdC12aWV3cG9ydCc7XG5cbi8vIDNEIHZpZXdwb3J0c1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBWaWV3cG9ydCB9IGZyb20gJy4vdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQZXJzcGVjdGl2ZVZpZXdwb3J0IH0gZnJvbSAnLi9wZXJzcGVjdGl2ZS12aWV3cG9ydCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE9ydGhvZ3JhcGhpY1ZpZXdwb3J0IH0gZnJvbSAnLi9vcnRob2dyYXBoaWMtdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBXZWJNZXJjYXRvclZpZXdwb3J0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi92aWV3cG9ydHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 17 */
/* exports provided: default */
/* exports used: default */
/*!*************************************************************!*\
  !*** ./src/experimental/effects/reflection-effect/index.js ***!
  \*************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__reflection_effect__ = __webpack_require__(/*! ./reflection-effect */ 47);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__reflection_effect__[\"a\"]; });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvaW5kZXguanM/ZDg0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9yZWZsZWN0aW9uLWVmZmVjdCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 18 */
/* exports provided: default */
/* exports used: default */
/*!************************************************!*\
  !*** ./src/layers/core/arc-layer/arc-layer.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\n\nvar defaultProps = {\n  getSourcePosition: function getSourcePosition(x) {\n    return x.sourcePosition;\n  },\n  getTargetPosition: function getTargetPosition(x) {\n    return x.targetPosition;\n  },\n  getSourceColor: function getSourceColor(x) {\n    return x.color || DEFAULT_COLOR;\n  },\n  getTargetColor: function getTargetColor(x) {\n    return x.color || DEFAULT_COLOR;\n  },\n  strokeWidth: 1\n};\n\nvar ArcLayer = function (_Layer) {\n  _inherits(ArcLayer, _Layer);\n\n  function ArcLayer() {\n    _classCallCheck(this, ArcLayer);\n\n    return _possibleConstructorReturn(this, (ArcLayer.__proto__ || Object.getPrototypeOf(ArcLayer)).apply(this, arguments));\n  }\n\n  _createClass(ArcLayer, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      var gl = this.context.gl;\n\n      this.setState({ model: this._createModel(gl) });\n\n      var attributeManager = this.state.attributeManager;\n      /* eslint-disable max-len */\n\n      attributeManager.addInstanced({\n        instancePositions: { size: 4, accessor: ['getSourcePosition', 'getTargetPosition'], update: this.calculateInstancePositions },\n        instanceSourceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getSourceColor', update: this.calculateInstanceSourceColors },\n        instanceTargetColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getTargetColor', update: this.calculateInstanceTargetColors }\n      });\n\n      /* eslint-enable max-len */\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref) {\n      var uniforms = _ref.uniforms;\n      var strokeWidth = this.props.strokeWidth;\n      var _context$viewport = this.context.viewport,\n          width = _context$viewport.width,\n          height = _context$viewport.height;\n\n\n      this.state.model.render(Object.assign({}, uniforms, {\n        screenSize: [width, height],\n        strokeWidth: strokeWidth\n      }));\n    }\n  }, {\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME arc-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec4 instanceSourceColors;\\nattribute vec4 instanceTargetColors;\\nattribute vec4 instancePositions;\\nattribute vec3 instancePickingColors;\\n\\nuniform float numSegments;\\nuniform vec2 screenSize;\\nuniform float strokeWidth;\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\n\\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\\n\\n  vec2 x = mix(source, target, ratio);\\n  vec2 center = mix(source, target, 0.5);\\n\\n  float dSourceCenter = distance(source, center);\\n  float dXCenter = distance(x, center);\\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\\n}\\n\\n// offset vector by strokeWidth pixels\\n// offset_direction is -1 (left) or 1 (right)\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace * screenSize);\\n  // rotate by 90 degrees\\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n\\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\\n  vec2 offset_clipspace = offset_screenspace / screenSize * 2.0;\\n\\n  return offset_clipspace;\\n}\\n\\nfloat getSegmentRatio(float index) {\\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\\n}\\n\\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\\n  float vertex_height = paraboloid(source, target, segmentRatio);\\n\\n  return vec3(\\n    mix(source, target, segmentRatio),\\n    sqrt(max(0.0, vertex_height))\\n  );\\n}\\n\\nvoid main(void) {\\n  vec2 source = project_position(instancePositions.xy);\\n  vec2 target = project_position(instancePositions.zw);\\n\\n  float segmentIndex = positions.x;\\n  float segmentRatio = getSegmentRatio(segmentIndex);\\n  // if it\\'s the first point, use next - current as direction\\n  // otherwise use current - prev\\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\\n\\n  vec3 currPos = getPos(source, target, segmentRatio);\\n  vec3 nextPos = getPos(source, target, nextSegmentRatio);\\n  vec4 curr = project_to_clipspace(vec4(currPos, 1.0));\\n  vec4 next = project_to_clipspace(vec4(nextPos, 1.0));\\n\\n  // extrude\\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y);\\n  gl_Position = curr + vec4(offset, 0.0, 0.0);\\n\\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\\n\\n  vColor = mix(\\n    vec4(color.rgb, color.a * opacity),\\n    vec4(instancePickingColors / 255., 1.),\\n    renderPickingBuffer\\n  );\\n}\\n',\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME arc-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n'\n      };\n    }\n  }, {\n    key: '_createModel',\n    value: function _createModel(gl) {\n      var positions = [];\n      var NUM_SEGMENTS = 50;\n      /*\n       *  (0, -1)-------------_(1, -1)\n       *       |          _,-\"  |\n       *       o      _,-\"      o\n       *       |  _,-\"          |\n       *   (0, 1)\"-------------(1, 1)\n       */\n      for (var i = 0; i < NUM_SEGMENTS; i++) {\n        positions = positions.concat([i, -1, 0, i, 1, 0]);\n      }\n\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      var model = new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n        gl: gl,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_STRIP,\n          positions: new Float32Array(positions)\n        }),\n        isInstanced: true\n      });\n\n      model.setUniforms({ numSegments: NUM_SEGMENTS });\n\n      return model;\n    }\n  }, {\n    key: 'calculateInstancePositions',\n    value: function calculateInstancePositions(attribute) {\n      var _props = this.props,\n          data = _props.data,\n          getSourcePosition = _props.getSourcePosition,\n          getTargetPosition = _props.getTargetPosition;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n\n          var sourcePosition = getSourcePosition(object);\n          var targetPosition = getTargetPosition(object);\n          value[i + 0] = sourcePosition[0];\n          value[i + 1] = sourcePosition[1];\n          value[i + 2] = targetPosition[0];\n          value[i + 3] = targetPosition[1];\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceSourceColors',\n    value: function calculateInstanceSourceColors(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getSourceColor = _props2.getSourceColor;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n\n          var color = getSourceColor(object);\n          value[i + 0] = color[0];\n          value[i + 1] = color[1];\n          value[i + 2] = color[2];\n          value[i + 3] = isNaN(color[3]) ? 255 : color[3];\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceTargetColors',\n    value: function calculateInstanceTargetColors(attribute) {\n      var _props3 = this.props,\n          data = _props3.data,\n          getTargetColor = _props3.getTargetColor;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var object = _step3.value;\n\n          var color = getTargetColor(object);\n          value[i + 0] = color[0];\n          value[i + 1] = color[1];\n          value[i + 2] = color[2];\n          value[i + 3] = isNaN(color[3]) ? 255 : color[3];\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }]);\n\n  return ArcLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ArcLayer;\n\n\nArcLayer.layerName = 'ArcLayer';\nArcLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvYXJjLWxheWVyL2FyYy1sYXllci5qcz8wZjEzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHsgYXNzZW1ibGVTaGFkZXJzIH0gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7IEdMLCBNb2RlbCwgR2VvbWV0cnkgfSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG52YXIgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBnZXRTb3VyY2VQb3NpdGlvbjogZnVuY3Rpb24gZ2V0U291cmNlUG9zaXRpb24oeCkge1xuICAgIHJldHVybiB4LnNvdXJjZVBvc2l0aW9uO1xuICB9LFxuICBnZXRUYXJnZXRQb3NpdGlvbjogZnVuY3Rpb24gZ2V0VGFyZ2V0UG9zaXRpb24oeCkge1xuICAgIHJldHVybiB4LnRhcmdldFBvc2l0aW9uO1xuICB9LFxuICBnZXRTb3VyY2VDb2xvcjogZnVuY3Rpb24gZ2V0U291cmNlQ29sb3IoeCkge1xuICAgIHJldHVybiB4LmNvbG9yIHx8IERFRkFVTFRfQ09MT1I7XG4gIH0sXG4gIGdldFRhcmdldENvbG9yOiBmdW5jdGlvbiBnZXRUYXJnZXRDb2xvcih4KSB7XG4gICAgcmV0dXJuIHguY29sb3IgfHwgREVGQVVMVF9DT0xPUjtcbiAgfSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbnZhciBBcmNMYXllciA9IGZ1bmN0aW9uIChfTGF5ZXIpIHtcbiAgX2luaGVyaXRzKEFyY0xheWVyLCBfTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIEFyY0xheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcmNMYXllcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEFyY0xheWVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXJjTGF5ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBcmNMYXllciwgW3tcbiAgICBrZXk6ICdpbml0aWFsaXplU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBtb2RlbDogdGhpcy5fY3JlYXRlTW9kZWwoZ2wpIH0pO1xuXG4gICAgICB2YXIgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlcjtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICBpbnN0YW5jZVBvc2l0aW9uczogeyBzaXplOiA0LCBhY2Nlc3NvcjogWydnZXRTb3VyY2VQb3NpdGlvbicsICdnZXRUYXJnZXRQb3NpdGlvbiddLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMgfSxcbiAgICAgICAgaW5zdGFuY2VTb3VyY2VDb2xvcnM6IHsgc2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgYWNjZXNzb3I6ICdnZXRTb3VyY2VDb2xvcicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVNvdXJjZUNvbG9ycyB9LFxuICAgICAgICBpbnN0YW5jZVRhcmdldENvbG9yczogeyBzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldFRhcmdldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0Q29sb3JzIH1cbiAgICAgIH0pO1xuXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmKSB7XG4gICAgICB2YXIgdW5pZm9ybXMgPSBfcmVmLnVuaWZvcm1zO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gdGhpcy5wcm9wcy5zdHJva2VXaWR0aDtcbiAgICAgIHZhciBfY29udGV4dCR2aWV3cG9ydCA9IHRoaXMuY29udGV4dC52aWV3cG9ydCxcbiAgICAgICAgICB3aWR0aCA9IF9jb250ZXh0JHZpZXdwb3J0LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9jb250ZXh0JHZpZXdwb3J0LmhlaWdodDtcblxuXG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgICBzY3JlZW5TaXplOiBbd2lkdGgsIGhlaWdodF0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aFxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFNoYWRlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFkZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgYXJjLWxheWVyLXZlcnRleC1zaGFkZXJcXG5cXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VTb3VyY2VDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VUYXJnZXRDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VQb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcblxcbnVuaWZvcm0gZmxvYXQgbnVtU2VnbWVudHM7XFxudW5pZm9ybSB2ZWMyIHNjcmVlblNpemU7XFxudW5pZm9ybSBmbG9hdCBzdHJva2VXaWR0aDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxuZmxvYXQgcGFyYWJvbG9pZCh2ZWMyIHNvdXJjZSwgdmVjMiB0YXJnZXQsIGZsb2F0IHJhdGlvKSB7XFxuXFxuICB2ZWMyIHggPSBtaXgoc291cmNlLCB0YXJnZXQsIHJhdGlvKTtcXG4gIHZlYzIgY2VudGVyID0gbWl4KHNvdXJjZSwgdGFyZ2V0LCAwLjUpO1xcblxcbiAgZmxvYXQgZFNvdXJjZUNlbnRlciA9IGRpc3RhbmNlKHNvdXJjZSwgY2VudGVyKTtcXG4gIGZsb2F0IGRYQ2VudGVyID0gZGlzdGFuY2UoeCwgY2VudGVyKTtcXG4gIHJldHVybiAoZFNvdXJjZUNlbnRlciArIGRYQ2VudGVyKSAqIChkU291cmNlQ2VudGVyIC0gZFhDZW50ZXIpO1xcbn1cXG5cXG4vLyBvZmZzZXQgdmVjdG9yIGJ5IHN0cm9rZVdpZHRoIHBpeGVsc1xcbi8vIG9mZnNldF9kaXJlY3Rpb24gaXMgLTEgKGxlZnQpIG9yIDEgKHJpZ2h0KVxcbnZlYzIgZ2V0RXh0cnVzaW9uT2Zmc2V0KHZlYzIgbGluZV9jbGlwc3BhY2UsIGZsb2F0IG9mZnNldF9kaXJlY3Rpb24pIHtcXG4gIC8vIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIG9mIHRoZSBsaW5lXFxuICB2ZWMyIGRpcl9zY3JlZW5zcGFjZSA9IG5vcm1hbGl6ZShsaW5lX2NsaXBzcGFjZSAqIHNjcmVlblNpemUpO1xcbiAgLy8gcm90YXRlIGJ5IDkwIGRlZ3JlZXNcXG4gIGRpcl9zY3JlZW5zcGFjZSA9IHZlYzIoLWRpcl9zY3JlZW5zcGFjZS55LCBkaXJfc2NyZWVuc3BhY2UueCk7XFxuXFxuICB2ZWMyIG9mZnNldF9zY3JlZW5zcGFjZSA9IGRpcl9zY3JlZW5zcGFjZSAqIG9mZnNldF9kaXJlY3Rpb24gKiBzdHJva2VXaWR0aCAvIDIuMDtcXG4gIHZlYzIgb2Zmc2V0X2NsaXBzcGFjZSA9IG9mZnNldF9zY3JlZW5zcGFjZSAvIHNjcmVlblNpemUgKiAyLjA7XFxuXFxuICByZXR1cm4gb2Zmc2V0X2NsaXBzcGFjZTtcXG59XFxuXFxuZmxvYXQgZ2V0U2VnbWVudFJhdGlvKGZsb2F0IGluZGV4KSB7XFxuICByZXR1cm4gc21vb3Roc3RlcCgwLjAsIDEuMCwgaW5kZXggLyAobnVtU2VnbWVudHMgLSAxLjApKTtcXG59XFxuXFxudmVjMyBnZXRQb3ModmVjMiBzb3VyY2UsIHZlYzIgdGFyZ2V0LCBmbG9hdCBzZWdtZW50UmF0aW8pIHtcXG4gIGZsb2F0IHZlcnRleF9oZWlnaHQgPSBwYXJhYm9sb2lkKHNvdXJjZSwgdGFyZ2V0LCBzZWdtZW50UmF0aW8pO1xcblxcbiAgcmV0dXJuIHZlYzMoXFxuICAgIG1peChzb3VyY2UsIHRhcmdldCwgc2VnbWVudFJhdGlvKSxcXG4gICAgc3FydChtYXgoMC4wLCB2ZXJ0ZXhfaGVpZ2h0KSlcXG4gICk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICB2ZWMyIHNvdXJjZSA9IHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMueHkpO1xcbiAgdmVjMiB0YXJnZXQgPSBwcm9qZWN0X3Bvc2l0aW9uKGluc3RhbmNlUG9zaXRpb25zLnp3KTtcXG5cXG4gIGZsb2F0IHNlZ21lbnRJbmRleCA9IHBvc2l0aW9ucy54O1xcbiAgZmxvYXQgc2VnbWVudFJhdGlvID0gZ2V0U2VnbWVudFJhdGlvKHNlZ21lbnRJbmRleCk7XFxuICAvLyBpZiBpdFxcJ3MgdGhlIGZpcnN0IHBvaW50LCB1c2UgbmV4dCAtIGN1cnJlbnQgYXMgZGlyZWN0aW9uXFxuICAvLyBvdGhlcndpc2UgdXNlIGN1cnJlbnQgLSBwcmV2XFxuICBmbG9hdCBpbmRleERpciA9IG1peCgtMS4wLCAxLjAsIHN0ZXAoc2VnbWVudEluZGV4LCAwLjApKTtcXG4gIGZsb2F0IG5leHRTZWdtZW50UmF0aW8gPSBnZXRTZWdtZW50UmF0aW8oc2VnbWVudEluZGV4ICsgaW5kZXhEaXIpO1xcblxcbiAgdmVjMyBjdXJyUG9zID0gZ2V0UG9zKHNvdXJjZSwgdGFyZ2V0LCBzZWdtZW50UmF0aW8pO1xcbiAgdmVjMyBuZXh0UG9zID0gZ2V0UG9zKHNvdXJjZSwgdGFyZ2V0LCBuZXh0U2VnbWVudFJhdGlvKTtcXG4gIHZlYzQgY3VyciA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQoY3VyclBvcywgMS4wKSk7XFxuICB2ZWM0IG5leHQgPSBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0KG5leHRQb3MsIDEuMCkpO1xcblxcbiAgLy8gZXh0cnVkZVxcbiAgdmVjMiBvZmZzZXQgPSBnZXRFeHRydXNpb25PZmZzZXQoKG5leHQueHkgLSBjdXJyLnh5KSAqIGluZGV4RGlyLCBwb3NpdGlvbnMueSk7XFxuICBnbF9Qb3NpdGlvbiA9IGN1cnIgKyB2ZWM0KG9mZnNldCwgMC4wLCAwLjApO1xcblxcbiAgdmVjNCBjb2xvciA9IG1peChpbnN0YW5jZVNvdXJjZUNvbG9ycywgaW5zdGFuY2VUYXJnZXRDb2xvcnMsIHNlZ21lbnRSYXRpbykgLyAyNTUuO1xcblxcbiAgdkNvbG9yID0gbWl4KFxcbiAgICB2ZWM0KGNvbG9yLnJnYiwgY29sb3IuYSAqIG9wYWNpdHkpLFxcbiAgICB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKSxcXG4gICAgcmVuZGVyUGlja2luZ0J1ZmZlclxcbiAgKTtcXG59XFxuJyxcbiAgICAgICAgZnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgYXJjLWxheWVyLWZyYWdtZW50LXNoYWRlclxcblxcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XFxufVxcbidcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZU1vZGVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZU1vZGVsKGdsKSB7XG4gICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICB2YXIgTlVNX1NFR01FTlRTID0gNTA7XG4gICAgICAvKlxuICAgICAgICogICgwLCAtMSktLS0tLS0tLS0tLS0tXygxLCAtMSlcbiAgICAgICAqICAgICAgIHwgICAgICAgICAgXywtXCIgIHxcbiAgICAgICAqICAgICAgIG8gICAgICBfLC1cIiAgICAgIG9cbiAgICAgICAqICAgICAgIHwgIF8sLVwiICAgICAgICAgIHxcbiAgICAgICAqICAgKDAsIDEpXCItLS0tLS0tLS0tLS0tKDEsIDEpXG4gICAgICAgKi9cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlVNX1NFR01FTlRTOyBpKyspIHtcbiAgICAgICAgcG9zaXRpb25zID0gcG9zaXRpb25zLmNvbmNhdChbaSwgLTEsIDAsIGksIDEsIDBdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKHtcbiAgICAgICAgZ2w6IGdsLFxuICAgICAgICB2czogc2hhZGVycy52cyxcbiAgICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRV9TVFJJUCxcbiAgICAgICAgICBwb3NpdGlvbnM6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zKVxuICAgICAgICB9KSxcbiAgICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBtb2RlbC5zZXRVbmlmb3Jtcyh7IG51bVNlZ21lbnRzOiBOVU1fU0VHTUVOVFMgfSk7XG5cbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wcy5kYXRhLFxuICAgICAgICAgIGdldFNvdXJjZVBvc2l0aW9uID0gX3Byb3BzLmdldFNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgIGdldFRhcmdldFBvc2l0aW9uID0gX3Byb3BzLmdldFRhcmdldFBvc2l0aW9uO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG9iamVjdCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIHNvdXJjZVBvc2l0aW9uID0gZ2V0U291cmNlUG9zaXRpb24ob2JqZWN0KTtcbiAgICAgICAgICB2YXIgdGFyZ2V0UG9zaXRpb24gPSBnZXRUYXJnZXRQb3NpdGlvbihvYmplY3QpO1xuICAgICAgICAgIHZhbHVlW2kgKyAwXSA9IHNvdXJjZVBvc2l0aW9uWzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAxXSA9IHNvdXJjZVBvc2l0aW9uWzFdO1xuICAgICAgICAgIHZhbHVlW2kgKyAyXSA9IHRhcmdldFBvc2l0aW9uWzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAzXSA9IHRhcmdldFBvc2l0aW9uWzFdO1xuICAgICAgICAgIGkgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VDb2xvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3Byb3BzMi5kYXRhLFxuICAgICAgICAgIGdldFNvdXJjZUNvbG9yID0gX3Byb3BzMi5nZXRTb3VyY2VDb2xvcjtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZSxcbiAgICAgICAgICBzaXplID0gYXR0cmlidXRlLnNpemU7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgY29sb3IgPSBnZXRTb3VyY2VDb2xvcihvYmplY3QpO1xuICAgICAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAxXSA9IGNvbG9yWzFdO1xuICAgICAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgICAgIHZhbHVlW2kgKyAzXSA9IGlzTmFOKGNvbG9yWzNdKSA/IDI1NSA6IGNvbG9yWzNdO1xuICAgICAgICAgIGkgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0Q29sb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wczMuZGF0YSxcbiAgICAgICAgICBnZXRUYXJnZXRDb2xvciA9IF9wcm9wczMuZ2V0VGFyZ2V0Q29sb3I7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUsXG4gICAgICAgICAgc2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIGNvbG9yID0gZ2V0VGFyZ2V0Q29sb3Iob2JqZWN0KTtcbiAgICAgICAgICB2YWx1ZVtpICsgMF0gPSBjb2xvclswXTtcbiAgICAgICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgICAgICB2YWx1ZVtpICsgM10gPSBpc05hTihjb2xvclszXSkgPyAyNTUgOiBjb2xvclszXTtcbiAgICAgICAgICBpICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXJjTGF5ZXI7XG59KExheWVyKTtcblxuZXhwb3J0IGRlZmF1bHQgQXJjTGF5ZXI7XG5cblxuQXJjTGF5ZXIubGF5ZXJOYW1lID0gJ0FyY0xheWVyJztcbkFyY0xheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9hcmMtbGF5ZXIvYXJjLWxheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 19 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************!*\
  !*** ./src/layers/core/grid-layer/grid-layer.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [255, 0, 255, 255];\n\nvar defaultProps = {\n  extruded: true,\n  latOffset: 0.0089,\n  lonOffset: 0.0113,\n  elevationScale: 1,\n  getPosition: function getPosition(x) {\n    return x.position;\n  },\n  getElevation: function getElevation(x) {\n    return x.elevation;\n  },\n  getColor: function getColor(x) {\n    return x.color;\n  },\n  lightSettings: {\n    lightsPosition: [-122.45, 37.65, 8000, -122.45, 37.20, 1000],\n    ambientRatio: 0.4,\n    diffuseRatio: 0.6,\n    specularRatio: 0.8,\n    lightsStrength: [1.0, 0.0, 0.8, 0.0],\n    numberOfLights: 2\n  }\n};\n\nvar GridLayer = function (_Layer) {\n  _inherits(GridLayer, _Layer);\n\n  function GridLayer() {\n    _classCallCheck(this, GridLayer);\n\n    return _possibleConstructorReturn(this, (GridLayer.__proto__ || Object.getPrototypeOf(GridLayer)).apply(this, arguments));\n  }\n\n  _createClass(GridLayer, [{\n    key: 'getShaders',\n\n    /**\n     * A generic GridLayer that takes latitude longitude delta of cells as a uniform\n     * and the min lat lng of cells. grid can be 3d when pass in a height\n     * and set enable3d to true\n     *\n     * @param {array} props.data -\n     * @param {boolean} props.extruded - enable grid elevation\n     * @param {number} props.latOffset - grid cell size in lat delta\n     * @param {number} props.lonOffset - grid cell size in lng delta\n     * @param {function} props.getPosition - position accessor, returned as [minLng, minLat]\n     * @param {function} props.getElevation - elevation accessor\n     * @param {function} props.getColor - color accessor, returned as [r, g, b, a]\n     */\n\n    value: function getShaders() {\n      var vertex = '// Inspired by screen-grid-layer vertex shader in deck.gl\\n\\n/* vertex shader for the grid-layer */\\n#define SHADER_NAME grid-layer-vs\\n\\nattribute vec3 positions;\\nattribute vec3 normals;\\n\\nattribute vec4 instancePositions;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\n// Picking uniforms\\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\\nuniform float renderPickingBuffer;\\nuniform vec3 selectedPickingColor;\\n\\n// Custom uniforms\\nuniform float extruded;\\nuniform float lonOffset;\\nuniform float latOffset;\\nuniform float opacity;\\nuniform float elevationScale;\\n\\n// A magic number to scale elevation so that 1 unit approximate to 1 meter\\n#define ELEVATION_SCALE 0.8\\n\\n// Result\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n\\n  // cube gemoetry vertics are between -1 to 1, scale and transform it to between 0, 1\\n  vec2 ptPosition = instancePositions.xy + vec2((positions.x + 1.0 ) * lonOffset / 2.0, (positions.y + 1.0) * latOffset / 2.0);\\n\\n  vec2 pos = project_position(ptPosition);\\n\\n  float elevation = 0.0;\\n\\n  if (extruded > 0.5) {\\n    elevation = project_scale(instancePositions.w  * (positions.z + 1.0) * ELEVATION_SCALE * elevationScale);\\n  }\\n\\n  // extrude positions\\n  vec3 extrudedPosition = vec3(pos.xy, elevation + 1.0);\\n  vec4 position_worldspace = vec4(extrudedPosition, 1.0);\\n  gl_Position = project_to_clipspace(position_worldspace);\\n\\n  if (renderPickingBuffer < 0.5) {\\n\\n    // TODO: we should allow the user to specify the color for \"selected element\"\\n    // check whether a bar is currently picked.\\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\\n\\n    float lightWeight = 1.0;\\n\\n    if (extruded > 0.5) {\\n      lightWeight = getLightWeight(\\n        position_worldspace,\\n        normals\\n      );\\n    }\\n\\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\\n    vec4 color = vec4(lightWeightedColor, instanceColors.a * opacity) / 255.0;\\n    vColor = color;\\n\\n  } else {\\n\\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\\n     vColor = pickingColor;\\n\\n  }\\n}\\n';\n      var picking = '// whether is point picked\\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\\n return float(pickingColors.x == selectedColor.x\\n && pickingColors.y == selectedColor.y\\n && pickingColors.z == selectedColor.z);\\n}\\n';\n      var vs = picking.concat(vertex);\n\n      return {\n        vs: vs,\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n/* fragment shader for the grid-layer */\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n',\n        modules: ['lighting']\n      };\n    }\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      var gl = this.context.gl;\n\n      this.setState({ model: this._createModel(gl) });\n\n      var attributeManager = this.state.attributeManager;\n      /* eslint-disable max-len */\n\n      attributeManager.addInstanced({\n        instancePositions: { size: 4, accessor: ['getPosition', 'getElevation'], update: this.calculateInstancePositions },\n        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }\n      });\n      /* eslint-enable max-len */\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(opt) {\n      _get(GridLayer.prototype.__proto__ || Object.getPrototypeOf(GridLayer.prototype), 'updateState', this).call(this, opt);\n      this.updateUniforms();\n    }\n  }, {\n    key: '_createModel',\n    value: function _createModel(gl) {\n      var geometry = new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"CubeGeometry\"]({});\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: geometry,\n        isInstanced: true\n      });\n    }\n  }, {\n    key: 'updateUniforms',\n    value: function updateUniforms() {\n      var _props = this.props,\n          opacity = _props.opacity,\n          extruded = _props.extruded,\n          elevationScale = _props.elevationScale,\n          latOffset = _props.latOffset,\n          lonOffset = _props.lonOffset,\n          lightSettings = _props.lightSettings;\n\n\n      this.setUniforms(Object.assign({}, {\n        extruded: extruded,\n        elevationScale: elevationScale,\n        opacity: opacity,\n        latOffset: latOffset,\n        lonOffset: lonOffset\n      }, lightSettings));\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref) {\n      var uniforms = _ref.uniforms;\n\n      _get(GridLayer.prototype.__proto__ || Object.getPrototypeOf(GridLayer.prototype), 'draw', this).call(this, { uniforms: Object.assign({}, uniforms) });\n    }\n  }, {\n    key: 'calculateInstancePositions',\n    value: function calculateInstancePositions(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getPosition = _props2.getPosition,\n          getElevation = _props2.getElevation;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n\n          var position = getPosition(object);\n          var elevation = getElevation(object) || 0;\n          value[i + 0] = position[0];\n          value[i + 1] = position[1];\n          value[i + 2] = 0;\n          value[i + 3] = elevation;\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceColors',\n    value: function calculateInstanceColors(attribute) {\n      var _props3 = this.props,\n          data = _props3.data,\n          getColor = _props3.getColor;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n\n          var color = getColor(object) || DEFAULT_COLOR;\n          value[i + 0] = color[0];\n          value[i + 1] = color[1];\n          value[i + 2] = color[2];\n          value[i + 3] = Number.isFinite(color[3]) ? color[3] : DEFAULT_COLOR[3];\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }]);\n\n  return GridLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = GridLayer;\n\n\nGridLayer.layerName = 'GridLayer';\nGridLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ3JpZC1sYXllci9ncmlkLWxheWVyLmpzPzZkNTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIENvcHlyaWdodCAoYykgMjAxNiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBHTCwgTW9kZWwsIEN1YmVHZW9tZXRyeSB9IGZyb20gJ2x1bWEuZ2wnO1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbnZhciBERUZBVUxUX0NPTE9SID0gWzI1NSwgMCwgMjU1LCAyNTVdO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBleHRydWRlZDogdHJ1ZSxcbiAgbGF0T2Zmc2V0OiAwLjAwODksXG4gIGxvbk9mZnNldDogMC4wMTEzLFxuICBlbGV2YXRpb25TY2FsZTogMSxcbiAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uIGdldFBvc2l0aW9uKHgpIHtcbiAgICByZXR1cm4geC5wb3NpdGlvbjtcbiAgfSxcbiAgZ2V0RWxldmF0aW9uOiBmdW5jdGlvbiBnZXRFbGV2YXRpb24oeCkge1xuICAgIHJldHVybiB4LmVsZXZhdGlvbjtcbiAgfSxcbiAgZ2V0Q29sb3I6IGZ1bmN0aW9uIGdldENvbG9yKHgpIHtcbiAgICByZXR1cm4geC5jb2xvcjtcbiAgfSxcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNjUsIDgwMDAsIC0xMjIuNDUsIDM3LjIwLCAxMDAwXSxcbiAgICBhbWJpZW50UmF0aW86IDAuNCxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsxLjAsIDAuMCwgMC44LCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH1cbn07XG5cbnZhciBHcmlkTGF5ZXIgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhHcmlkTGF5ZXIsIF9MYXllcik7XG5cbiAgZnVuY3Rpb24gR3JpZExheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmlkTGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChHcmlkTGF5ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcmlkTGF5ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHcmlkTGF5ZXIsIFt7XG4gICAga2V5OiAnZ2V0U2hhZGVycycsXG5cbiAgICAvKipcbiAgICAgKiBBIGdlbmVyaWMgR3JpZExheWVyIHRoYXQgdGFrZXMgbGF0aXR1ZGUgbG9uZ2l0dWRlIGRlbHRhIG9mIGNlbGxzIGFzIGEgdW5pZm9ybVxuICAgICAqIGFuZCB0aGUgbWluIGxhdCBsbmcgb2YgY2VsbHMuIGdyaWQgY2FuIGJlIDNkIHdoZW4gcGFzcyBpbiBhIGhlaWdodFxuICAgICAqIGFuZCBzZXQgZW5hYmxlM2QgdG8gdHJ1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gcHJvcHMuZGF0YSAtXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwcm9wcy5leHRydWRlZCAtIGVuYWJsZSBncmlkIGVsZXZhdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy5sYXRPZmZzZXQgLSBncmlkIGNlbGwgc2l6ZSBpbiBsYXQgZGVsdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJvcHMubG9uT2Zmc2V0IC0gZ3JpZCBjZWxsIHNpemUgaW4gbG5nIGRlbHRhXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvcHMuZ2V0UG9zaXRpb24gLSBwb3NpdGlvbiBhY2Nlc3NvciwgcmV0dXJuZWQgYXMgW21pbkxuZywgbWluTGF0XVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb3BzLmdldEVsZXZhdGlvbiAtIGVsZXZhdGlvbiBhY2Nlc3NvclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb3BzLmdldENvbG9yIC0gY29sb3IgYWNjZXNzb3IsIHJldHVybmVkIGFzIFtyLCBnLCBiLCBhXVxuICAgICAqL1xuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoYWRlcnMoKSB7XG4gICAgICB2YXIgdmVydGV4ID0gJy8vIEluc3BpcmVkIGJ5IHNjcmVlbi1ncmlkLWxheWVyIHZlcnRleCBzaGFkZXIgaW4gZGVjay5nbFxcblxcbi8qIHZlcnRleCBzaGFkZXIgZm9yIHRoZSBncmlkLWxheWVyICovXFxuI2RlZmluZSBTSEFERVJfTkFNRSBncmlkLWxheWVyLXZzXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbHM7XFxuXFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VQb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcblxcbi8vIFBpY2tpbmcgdW5pZm9ybXNcXG4vLyBTZXQgdG8gMS4wIGlmIHJlbmRlcmluZyBwaWNraW5nIGJ1ZmZlciwgMC4wIGlmIHJlbmRlcmluZyBmb3IgZGlzcGxheVxcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcXG51bmlmb3JtIHZlYzMgc2VsZWN0ZWRQaWNraW5nQ29sb3I7XFxuXFxuLy8gQ3VzdG9tIHVuaWZvcm1zXFxudW5pZm9ybSBmbG9hdCBleHRydWRlZDtcXG51bmlmb3JtIGZsb2F0IGxvbk9mZnNldDtcXG51bmlmb3JtIGZsb2F0IGxhdE9mZnNldDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCBlbGV2YXRpb25TY2FsZTtcXG5cXG4vLyBBIG1hZ2ljIG51bWJlciB0byBzY2FsZSBlbGV2YXRpb24gc28gdGhhdCAxIHVuaXQgYXBwcm94aW1hdGUgdG8gMSBtZXRlclxcbiNkZWZpbmUgRUxFVkFUSU9OX1NDQUxFIDAuOFxcblxcbi8vIFJlc3VsdFxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXG4gIC8vIGN1YmUgZ2Vtb2V0cnkgdmVydGljcyBhcmUgYmV0d2VlbiAtMSB0byAxLCBzY2FsZSBhbmQgdHJhbnNmb3JtIGl0IHRvIGJldHdlZW4gMCwgMVxcbiAgdmVjMiBwdFBvc2l0aW9uID0gaW5zdGFuY2VQb3NpdGlvbnMueHkgKyB2ZWMyKChwb3NpdGlvbnMueCArIDEuMCApICogbG9uT2Zmc2V0IC8gMi4wLCAocG9zaXRpb25zLnkgKyAxLjApICogbGF0T2Zmc2V0IC8gMi4wKTtcXG5cXG4gIHZlYzIgcG9zID0gcHJvamVjdF9wb3NpdGlvbihwdFBvc2l0aW9uKTtcXG5cXG4gIGZsb2F0IGVsZXZhdGlvbiA9IDAuMDtcXG5cXG4gIGlmIChleHRydWRlZCA+IDAuNSkge1xcbiAgICBlbGV2YXRpb24gPSBwcm9qZWN0X3NjYWxlKGluc3RhbmNlUG9zaXRpb25zLncgICogKHBvc2l0aW9ucy56ICsgMS4wKSAqIEVMRVZBVElPTl9TQ0FMRSAqIGVsZXZhdGlvblNjYWxlKTtcXG4gIH1cXG5cXG4gIC8vIGV4dHJ1ZGUgcG9zaXRpb25zXFxuICB2ZWMzIGV4dHJ1ZGVkUG9zaXRpb24gPSB2ZWMzKHBvcy54eSwgZWxldmF0aW9uICsgMS4wKTtcXG4gIHZlYzQgcG9zaXRpb25fd29ybGRzcGFjZSA9IHZlYzQoZXh0cnVkZWRQb3NpdGlvbiwgMS4wKTtcXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2UocG9zaXRpb25fd29ybGRzcGFjZSk7XFxuXFxuICBpZiAocmVuZGVyUGlja2luZ0J1ZmZlciA8IDAuNSkge1xcblxcbiAgICAvLyBUT0RPOiB3ZSBzaG91bGQgYWxsb3cgdGhlIHVzZXIgdG8gc3BlY2lmeSB0aGUgY29sb3IgZm9yIFwic2VsZWN0ZWQgZWxlbWVudFwiXFxuICAgIC8vIGNoZWNrIHdoZXRoZXIgYSBiYXIgaXMgY3VycmVudGx5IHBpY2tlZC5cXG4gICAgZmxvYXQgc2VsZWN0ZWQgPSBpc1BpY2tlZChpbnN0YW5jZVBpY2tpbmdDb2xvcnMsIHNlbGVjdGVkUGlja2luZ0NvbG9yKTtcXG5cXG4gICAgZmxvYXQgbGlnaHRXZWlnaHQgPSAxLjA7XFxuXFxuICAgIGlmIChleHRydWRlZCA+IDAuNSkge1xcbiAgICAgIGxpZ2h0V2VpZ2h0ID0gZ2V0TGlnaHRXZWlnaHQoXFxuICAgICAgICBwb3NpdGlvbl93b3JsZHNwYWNlLFxcbiAgICAgICAgbm9ybWFsc1xcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgdmVjMyBsaWdodFdlaWdodGVkQ29sb3IgPSBsaWdodFdlaWdodCAqIGluc3RhbmNlQ29sb3JzLnJnYjtcXG4gICAgdmVjNCBjb2xvciA9IHZlYzQobGlnaHRXZWlnaHRlZENvbG9yLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuMDtcXG4gICAgdkNvbG9yID0gY29sb3I7XFxuXFxuICB9IGVsc2Uge1xcblxcbiAgICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LjAsIDEuMCk7XFxuICAgICB2Q29sb3IgPSBwaWNraW5nQ29sb3I7XFxuXFxuICB9XFxufVxcbic7XG4gICAgICB2YXIgcGlja2luZyA9ICcvLyB3aGV0aGVyIGlzIHBvaW50IHBpY2tlZFxcbmZsb2F0IGlzUGlja2VkKHZlYzMgcGlja2luZ0NvbG9ycywgdmVjMyBzZWxlY3RlZENvbG9yKSB7XFxuIHJldHVybiBmbG9hdChwaWNraW5nQ29sb3JzLnggPT0gc2VsZWN0ZWRDb2xvci54XFxuICYmIHBpY2tpbmdDb2xvcnMueSA9PSBzZWxlY3RlZENvbG9yLnlcXG4gJiYgcGlja2luZ0NvbG9ycy56ID09IHNlbGVjdGVkQ29sb3Iueik7XFxufVxcbic7XG4gICAgICB2YXIgdnMgPSBwaWNraW5nLmNvbmNhdCh2ZXJ0ZXgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2czogdnMsXG4gICAgICAgIGZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4vKiBmcmFnbWVudCBzaGFkZXIgZm9yIHRoZSBncmlkLWxheWVyICovXFxuXFxuI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcXG59XFxuJyxcbiAgICAgICAgbW9kdWxlczogWydsaWdodGluZyddXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luaXRpYWxpemVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1vZGVsOiB0aGlzLl9jcmVhdGVNb2RlbChnbCkgfSk7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7IHNpemU6IDQsIGFjY2Vzc29yOiBbJ2dldFBvc2l0aW9uJywgJ2dldEVsZXZhdGlvbiddLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMgfSxcbiAgICAgICAgaW5zdGFuY2VDb2xvcnM6IHsgc2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgYWNjZXNzb3I6ICdnZXRDb2xvcicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyB9XG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGUob3B0KSB7XG4gICAgICBfZ2V0KEdyaWRMYXllci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcmlkTGF5ZXIucHJvdG90eXBlKSwgJ3VwZGF0ZVN0YXRlJywgdGhpcykuY2FsbCh0aGlzLCBvcHQpO1xuICAgICAgdGhpcy51cGRhdGVVbmlmb3JtcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVNb2RlbChnbCkge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IEN1YmVHZW9tZXRyeSh7fSk7XG4gICAgICB2YXIgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgICAgZ2w6IGdsLFxuICAgICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgICAgdnM6IHNoYWRlcnMudnMsXG4gICAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVVbmlmb3JtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVVuaWZvcm1zKCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgb3BhY2l0eSA9IF9wcm9wcy5vcGFjaXR5LFxuICAgICAgICAgIGV4dHJ1ZGVkID0gX3Byb3BzLmV4dHJ1ZGVkLFxuICAgICAgICAgIGVsZXZhdGlvblNjYWxlID0gX3Byb3BzLmVsZXZhdGlvblNjYWxlLFxuICAgICAgICAgIGxhdE9mZnNldCA9IF9wcm9wcy5sYXRPZmZzZXQsXG4gICAgICAgICAgbG9uT2Zmc2V0ID0gX3Byb3BzLmxvbk9mZnNldCxcbiAgICAgICAgICBsaWdodFNldHRpbmdzID0gX3Byb3BzLmxpZ2h0U2V0dGluZ3M7XG5cblxuICAgICAgdGhpcy5zZXRVbmlmb3JtcyhPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgIGV4dHJ1ZGVkOiBleHRydWRlZCxcbiAgICAgICAgZWxldmF0aW9uU2NhbGU6IGVsZXZhdGlvblNjYWxlLFxuICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxuICAgICAgICBsYXRPZmZzZXQ6IGxhdE9mZnNldCxcbiAgICAgICAgbG9uT2Zmc2V0OiBsb25PZmZzZXRcbiAgICAgIH0sIGxpZ2h0U2V0dGluZ3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmKSB7XG4gICAgICB2YXIgdW5pZm9ybXMgPSBfcmVmLnVuaWZvcm1zO1xuXG4gICAgICBfZ2V0KEdyaWRMYXllci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcmlkTGF5ZXIucHJvdG90eXBlKSwgJ2RyYXcnLCB0aGlzKS5jYWxsKHRoaXMsIHsgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zKSB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHMyLmRhdGEsXG4gICAgICAgICAgZ2V0UG9zaXRpb24gPSBfcHJvcHMyLmdldFBvc2l0aW9uLFxuICAgICAgICAgIGdldEVsZXZhdGlvbiA9IF9wcm9wczIuZ2V0RWxldmF0aW9uO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG9iamVjdCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24ob2JqZWN0KTtcbiAgICAgICAgICB2YXIgZWxldmF0aW9uID0gZ2V0RWxldmF0aW9uKG9iamVjdCkgfHwgMDtcbiAgICAgICAgICB2YWx1ZVtpICsgMF0gPSBwb3NpdGlvblswXTtcbiAgICAgICAgICB2YWx1ZVtpICsgMV0gPSBwb3NpdGlvblsxXTtcbiAgICAgICAgICB2YWx1ZVtpICsgMl0gPSAwO1xuICAgICAgICAgIHZhbHVlW2kgKyAzXSA9IGVsZXZhdGlvbjtcbiAgICAgICAgICBpICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZUluc3RhbmNlQ29sb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wczMuZGF0YSxcbiAgICAgICAgICBnZXRDb2xvciA9IF9wcm9wczMuZ2V0Q29sb3I7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUsXG4gICAgICAgICAgc2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3Iob2JqZWN0KSB8fCBERUZBVUxUX0NPTE9SO1xuICAgICAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAxXSA9IGNvbG9yWzFdO1xuICAgICAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgICAgIHZhbHVlW2kgKyAzXSA9IE51bWJlci5pc0Zpbml0ZShjb2xvclszXSkgPyBjb2xvclszXSA6IERFRkFVTFRfQ09MT1JbM107XG4gICAgICAgICAgaSArPSBzaXplO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdyaWRMYXllcjtcbn0oTGF5ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBHcmlkTGF5ZXI7XG5cblxuR3JpZExheWVyLmxheWVyTmFtZSA9ICdHcmlkTGF5ZXInO1xuR3JpZExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9ncmlkLWxheWVyL2dyaWQtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 20 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************!*\
  !*** ./src/layers/core/hexagon-layer/hexagon-layer.js ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\nfunction positionsAreEqual(v1, v2) {\n  // Hex positions are expected to change entirely, not to maintain some\n  // positions and change others. Right now we only check a single vertex,\n  // because H3 guarantees order, but even if that wasn't true, this would only\n  // return a false positive for adjacent hexagons, which is close enough for\n  // our purposes.\n  return v1 === v2 || v1 && v2 && v1[0][0] === v2[0][0] && v1[0][1] === v2[0][1];\n}\n\nvar DEFAULT_COLOR = [255, 0, 255, 255];\n\nvar defaultProps = {\n  extruded: true,\n  hexagonVertices: null,\n  opacity: 0.8,\n  coverage: 1,\n  elevationScale: 1,\n  getCentroid: function getCentroid(x) {\n    return x.centroid;\n  },\n  getColor: function getColor(x) {\n    return x.color;\n  },\n  getElevation: function getElevation(x) {\n    return x.elevation;\n  },\n  lightSettings: {\n    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],\n    ambientRatio: 0.4,\n    diffuseRatio: 0.6,\n    specularRatio: 0.8,\n    lightsStrength: [1.2, 0.0, 0.8, 0.0],\n    numberOfLights: 2\n  }\n};\n\nvar HexagonLayer = function (_Layer) {\n  _inherits(HexagonLayer, _Layer);\n\n  function HexagonLayer(props) {\n    _classCallCheck(this, HexagonLayer);\n\n    var missingProps = false;\n    if (!props.hexagonVertices && (!props.radius || !Number.isFinite(props.angle))) {\n      __WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"a\" /* log */].once(0, 'HexagonLayer: Either hexagonVertices or radius and angel are ' + 'needed to calculate primitive hexagon.');\n      missingProps = true;\n    } else if (props.hexagonVertices && (!Array.isArray(props.hexagonVertices) || props.hexagonVertices.length < 6)) {\n      __WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"a\" /* log */].once(0, 'HexagonLayer: HexagonVertices needs to be an array of 6 points');\n\n      missingProps = true;\n    }\n\n    if (missingProps) {\n      __WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"a\" /* log */].once(0, 'Now using 1000 meter as default radius, 0 as default angel');\n      props.radius = 1000;\n      props.angle = 0;\n    }\n\n    return _possibleConstructorReturn(this, (HexagonLayer.__proto__ || Object.getPrototypeOf(HexagonLayer)).call(this, props));\n  }\n\n  /**\n   * DeckGL calls initializeState when GL context is available\n   * Essentially a deferred constructor\n   */\n\n\n  _createClass(HexagonLayer, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      var gl = this.context.gl;\n\n      this.setState({ model: this.getModel(gl) });\n\n      var attributeManager = this.state.attributeManager;\n      /* eslint-disable max-len */\n\n      attributeManager.addInstanced({\n        instancePositions: { size: 3, accessor: ['getCentroid', 'getElevation'], update: this.calculateInstancePositions },\n        instanceColors: { size: 4, type: gl.UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }\n      });\n      /* eslint-enable max-len */\n\n      this.updateRadiusAngle();\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(opt) {\n      _get(HexagonLayer.prototype.__proto__ || Object.getPrototypeOf(HexagonLayer.prototype), 'updateState', this).call(this, opt);\n\n      var viewportChanged = opt.changeFlags.viewportChanged;\n      var model = this.state.model;\n\n      // Update the positions in the model if they've changes\n\n      var verticesChanged = !positionsAreEqual(opt.oldProps.hexagonVertices, opt.props.hexagonVertices);\n\n      if (model && (verticesChanged || viewportChanged)) {\n        this.updateRadiusAngle();\n      }\n\n      this.updateUniforms();\n    }\n  }, {\n    key: 'updateRadiusAngle',\n    value: function updateRadiusAngle() {\n      var angle = void 0;\n      var radius = void 0;\n      var hexagonVertices = this.props.hexagonVertices;\n\n\n      if (Array.isArray(hexagonVertices) && hexagonVertices.length >= 6) {\n\n        // calculate angle and vertices from hexagonVertices if provided\n        var vertices = this.props.hexagonVertices;\n\n        var vertex0 = vertices[0];\n        var vertex3 = vertices[3];\n\n        // transform to space coordinates\n        var spaceCoord0 = this.projectFlat(vertex0);\n        var spaceCoord3 = this.projectFlat(vertex3);\n\n        // distance between two close centroids\n        var dx = spaceCoord0[0] - spaceCoord3[0];\n        var dy = spaceCoord0[1] - spaceCoord3[1];\n        var dxy = Math.sqrt(dx * dx + dy * dy);\n\n        // Calculate angle that the perpendicular hexagon vertex axis is tilted\n        angle = Math.acos(dx / dxy) * -Math.sign(dy) + Math.PI / 2;\n        radius = dxy / 2;\n      } else if (this.props.radius && Number.isFinite(this.props.angle)) {\n\n        // if no hexagonVertices provided, try use radius & angle\n        var viewport = this.context.viewport;\n\n        var _viewport$getDistance = viewport.getDistanceScales(),\n            pixelsPerMeter = _viewport$getDistance.pixelsPerMeter;\n\n        angle = this.props.angle;\n        radius = this.props.radius * pixelsPerMeter[0];\n      }\n\n      this.setUniforms({\n        angle: angle,\n        radius: radius\n      });\n    }\n  }, {\n    key: 'getCylinderGeometry',\n    value: function getCylinderGeometry(radius) {\n      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"CylinderGeometry\"]({\n        radius: radius,\n        topRadius: radius,\n        bottomRadius: radius,\n        topCap: true,\n        bottomCap: true,\n        height: 1,\n        nradial: 6,\n        nvertical: 1\n      });\n    }\n  }, {\n    key: 'updateUniforms',\n    value: function updateUniforms() {\n      var _props = this.props,\n          opacity = _props.opacity,\n          elevationScale = _props.elevationScale,\n          extruded = _props.extruded,\n          coverage = _props.coverage,\n          lightSettings = _props.lightSettings;\n\n\n      this.setUniforms(Object.assign({}, {\n        extruded: extruded,\n        opacity: opacity,\n        coverage: coverage,\n        elevationScale: elevationScale\n      }, lightSettings));\n    }\n  }, {\n    key: 'getShaders',\n    value: function getShaders() {\n      var vertex = '#define SHADER_NAME extruded-hexagon-layer-vs\\n\\nattribute vec3 positions;\\nattribute vec3 normals;\\n\\nattribute vec3 instancePositions;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\n// Picking uniforms\\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\\nuniform float renderPickingBuffer;\\nuniform vec3 selectedPickingColor;\\n\\n// Custom uniforms\\nuniform float opacity;\\nuniform float radius;\\nuniform float angle;\\nuniform float extruded;\\nuniform float coverage;\\nuniform float elevationScale;\\n\\n// Result\\nvarying vec4 vColor;\\n\\n// A magic number to scale elevation so that 1 unit approximate to 1 meter.\\n#define ELEVATION_SCALE 0.8\\n\\n\\nvoid main(void) {\\n\\n  // rotate primitive position and normal\\n  mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\\n\\n  vec2 rPos = rotationMatrix * positions.xz;\\n  vec2 rNorm = rotationMatrix * normals.xz;\\n\\n  vec3 rotatedPositions = vec3(rPos.x, positions.y, rPos.y);\\n  vec3 rotatedNormals = vec3(rNorm.x, normals.y, rNorm.y);\\n\\n  // calculate elevation, if 3d not enabled set to 0\\n  // cylindar gemoetry height are between -0.5 to 0.5, transform it to between 0, 1\\n  float elevation = 0.0;\\n\\n  if (extruded > 0.5) {\\n    elevation = project_scale(instancePositions.z * (positions.y + 0.5) * ELEVATION_SCALE * elevationScale);\\n}\\n\\n  float dotRadius = radius * clamp(coverage, 0.0, 1.0);\\n  // // project center of hexagon\\n\\n  vec4 centroidPosition = vec4(project_position(instancePositions.xy), elevation, 0.0);\\n\\n  vec4 position_worldspace = centroidPosition + vec4(vec2(rotatedPositions.xz * dotRadius), 0., 1.);\\n\\n  gl_Position = project_to_clipspace(position_worldspace);\\n\\n  // render display\\n  if (renderPickingBuffer < 0.5) {\\n\\n    // TODO: we should allow the user to specify the color for \"selected element\"\\n    // check whether hexagon is currently picked.\\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\\n\\n    // Light calculations\\n    // Worldspace is the linear space after Mercator projection\\n\\n    vec3 normals_worldspace = rotatedNormals;\\n\\n    float lightWeight = 1.0;\\n\\n    if (extruded > 0.5) {\\n      lightWeight = getLightWeight(\\n        position_worldspace,\\n        normals_worldspace\\n      );\\n    }\\n\\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\\n\\n    // Color: Either opacity-multiplied instance color, or picking color\\n    vec4 color = vec4(lightWeightedColor, opacity * instanceColors.a) / 255.0;\\n\\n    vColor = color;\\n\\n  } else {\\n\\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\\n    vColor = pickingColor;\\n\\n  }\\n}\\n';\n      var picking = '// whether is point picked\\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\\n return float(pickingColors.x == selectedColor.x\\n && pickingColors.y == selectedColor.y\\n && pickingColors.z == selectedColor.z);\\n}\\n';\n      var vs = picking.concat(vertex);\n      return {\n        vs: vs,\n        fs: '// See: npm glsl-shader-name\\n#define SHADER_NAME extruded-hexagon-layer-fs\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n',\n        modules: ['lighting']\n      };\n    }\n  }, {\n    key: 'getModel',\n    value: function getModel(gl) {\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: this.getCylinderGeometry(1),\n        isInstanced: true\n      });\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref) {\n      var uniforms = _ref.uniforms;\n\n      _get(HexagonLayer.prototype.__proto__ || Object.getPrototypeOf(HexagonLayer.prototype), 'draw', this).call(this, { uniforms: Object.assign({}, uniforms) });\n    }\n  }, {\n    key: 'calculateInstancePositions',\n    value: function calculateInstancePositions(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getCentroid = _props2.getCentroid,\n          getElevation = _props2.getElevation;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n\n          var _getCentroid = getCentroid(object),\n              _getCentroid2 = _slicedToArray(_getCentroid, 2),\n              lon = _getCentroid2[0],\n              lat = _getCentroid2[1];\n\n          var elevation = getElevation(object);\n          value[i + 0] = lon;\n          value[i + 1] = lat;\n          value[i + 2] = elevation || this.props.elevation;\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceColors',\n    value: function calculateInstanceColors(attribute) {\n      var _props3 = this.props,\n          data = _props3.data,\n          getColor = _props3.getColor;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n\n          var color = getColor(object) || DEFAULT_COLOR;\n\n          value[i + 0] = color[0];\n          value[i + 1] = color[1];\n          value[i + 2] = color[2];\n          value[i + 3] = Number.isFinite(color[3]) ? color[3] : DEFAULT_COLOR[3];\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }]);\n\n  return HexagonLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = HexagonLayer;\n\n\nHexagonLayer.layerName = 'HexagonLayer';\nHexagonLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1sYXllci9oZXhhZ29uLWxheWVyLmpzPzBmYjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHsgYXNzZW1ibGVTaGFkZXJzIH0gZnJvbSAnLi4vLi4vLi4vc2hhZGVyLXV0aWxzJztcbmltcG9ydCB7IE1vZGVsLCBDeWxpbmRlckdlb21ldHJ5IH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5cbmZ1bmN0aW9uIHBvc2l0aW9uc0FyZUVxdWFsKHYxLCB2Mikge1xuICAvLyBIZXggcG9zaXRpb25zIGFyZSBleHBlY3RlZCB0byBjaGFuZ2UgZW50aXJlbHksIG5vdCB0byBtYWludGFpbiBzb21lXG4gIC8vIHBvc2l0aW9ucyBhbmQgY2hhbmdlIG90aGVycy4gUmlnaHQgbm93IHdlIG9ubHkgY2hlY2sgYSBzaW5nbGUgdmVydGV4LFxuICAvLyBiZWNhdXNlIEgzIGd1YXJhbnRlZXMgb3JkZXIsIGJ1dCBldmVuIGlmIHRoYXQgd2Fzbid0IHRydWUsIHRoaXMgd291bGQgb25seVxuICAvLyByZXR1cm4gYSBmYWxzZSBwb3NpdGl2ZSBmb3IgYWRqYWNlbnQgaGV4YWdvbnMsIHdoaWNoIGlzIGNsb3NlIGVub3VnaCBmb3JcbiAgLy8gb3VyIHB1cnBvc2VzLlxuICByZXR1cm4gdjEgPT09IHYyIHx8IHYxICYmIHYyICYmIHYxWzBdWzBdID09PSB2MlswXVswXSAmJiB2MVswXVsxXSA9PT0gdjJbMF1bMV07XG59XG5cbnZhciBERUZBVUxUX0NPTE9SID0gWzI1NSwgMCwgMjU1LCAyNTVdO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBleHRydWRlZDogdHJ1ZSxcbiAgaGV4YWdvblZlcnRpY2VzOiBudWxsLFxuICBvcGFjaXR5OiAwLjgsXG4gIGNvdmVyYWdlOiAxLFxuICBlbGV2YXRpb25TY2FsZTogMSxcbiAgZ2V0Q2VudHJvaWQ6IGZ1bmN0aW9uIGdldENlbnRyb2lkKHgpIHtcbiAgICByZXR1cm4geC5jZW50cm9pZDtcbiAgfSxcbiAgZ2V0Q29sb3I6IGZ1bmN0aW9uIGdldENvbG9yKHgpIHtcbiAgICByZXR1cm4geC5jb2xvcjtcbiAgfSxcbiAgZ2V0RWxldmF0aW9uOiBmdW5jdGlvbiBnZXRFbGV2YXRpb24oeCkge1xuICAgIHJldHVybiB4LmVsZXZhdGlvbjtcbiAgfSxcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMDAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC40LFxuICAgIGRpZmZ1c2VSYXRpbzogMC42LFxuICAgIHNwZWN1bGFyUmF0aW86IDAuOCxcbiAgICBsaWdodHNTdHJlbmd0aDogWzEuMiwgMC4wLCAwLjgsIDAuMF0sXG4gICAgbnVtYmVyT2ZMaWdodHM6IDJcbiAgfVxufTtcblxudmFyIEhleGFnb25MYXllciA9IGZ1bmN0aW9uIChfTGF5ZXIpIHtcbiAgX2luaGVyaXRzKEhleGFnb25MYXllciwgX0xheWVyKTtcblxuICBmdW5jdGlvbiBIZXhhZ29uTGF5ZXIocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGV4YWdvbkxheWVyKTtcblxuICAgIHZhciBtaXNzaW5nUHJvcHMgPSBmYWxzZTtcbiAgICBpZiAoIXByb3BzLmhleGFnb25WZXJ0aWNlcyAmJiAoIXByb3BzLnJhZGl1cyB8fCAhTnVtYmVyLmlzRmluaXRlKHByb3BzLmFuZ2xlKSkpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdIZXhhZ29uTGF5ZXI6IEVpdGhlciBoZXhhZ29uVmVydGljZXMgb3IgcmFkaXVzIGFuZCBhbmdlbCBhcmUgJyArICduZWVkZWQgdG8gY2FsY3VsYXRlIHByaW1pdGl2ZSBoZXhhZ29uLicpO1xuICAgICAgbWlzc2luZ1Byb3BzID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHByb3BzLmhleGFnb25WZXJ0aWNlcyAmJiAoIUFycmF5LmlzQXJyYXkocHJvcHMuaGV4YWdvblZlcnRpY2VzKSB8fCBwcm9wcy5oZXhhZ29uVmVydGljZXMubGVuZ3RoIDwgNikpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdIZXhhZ29uTGF5ZXI6IEhleGFnb25WZXJ0aWNlcyBuZWVkcyB0byBiZSBhbiBhcnJheSBvZiA2IHBvaW50cycpO1xuXG4gICAgICBtaXNzaW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtaXNzaW5nUHJvcHMpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdOb3cgdXNpbmcgMTAwMCBtZXRlciBhcyBkZWZhdWx0IHJhZGl1cywgMCBhcyBkZWZhdWx0IGFuZ2VsJyk7XG4gICAgICBwcm9wcy5yYWRpdXMgPSAxMDAwO1xuICAgICAgcHJvcHMuYW5nbGUgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSGV4YWdvbkxheWVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSGV4YWdvbkxheWVyKSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY2tHTCBjYWxscyBpbml0aWFsaXplU3RhdGUgd2hlbiBHTCBjb250ZXh0IGlzIGF2YWlsYWJsZVxuICAgKiBFc3NlbnRpYWxseSBhIGRlZmVycmVkIGNvbnN0cnVjdG9yXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhleGFnb25MYXllciwgW3tcbiAgICBrZXk6ICdpbml0aWFsaXplU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBtb2RlbDogdGhpcy5nZXRNb2RlbChnbCkgfSk7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7IHNpemU6IDMsIGFjY2Vzc29yOiBbJ2dldENlbnRyb2lkJywgJ2dldEVsZXZhdGlvbiddLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMgfSxcbiAgICAgICAgaW5zdGFuY2VDb2xvcnM6IHsgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgYWNjZXNzb3I6ICdnZXRDb2xvcicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyB9XG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgICB0aGlzLnVwZGF0ZVJhZGl1c0FuZ2xlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTdGF0ZShvcHQpIHtcbiAgICAgIF9nZXQoSGV4YWdvbkxheWVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEhleGFnb25MYXllci5wcm90b3R5cGUpLCAndXBkYXRlU3RhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIG9wdCk7XG5cbiAgICAgIHZhciB2aWV3cG9ydENoYW5nZWQgPSBvcHQuY2hhbmdlRmxhZ3Mudmlld3BvcnRDaGFuZ2VkO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5zdGF0ZS5tb2RlbDtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBwb3NpdGlvbnMgaW4gdGhlIG1vZGVsIGlmIHRoZXkndmUgY2hhbmdlc1xuXG4gICAgICB2YXIgdmVydGljZXNDaGFuZ2VkID0gIXBvc2l0aW9uc0FyZUVxdWFsKG9wdC5vbGRQcm9wcy5oZXhhZ29uVmVydGljZXMsIG9wdC5wcm9wcy5oZXhhZ29uVmVydGljZXMpO1xuXG4gICAgICBpZiAobW9kZWwgJiYgKHZlcnRpY2VzQ2hhbmdlZCB8fCB2aWV3cG9ydENoYW5nZWQpKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUmFkaXVzQW5nbGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVVbmlmb3JtcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVJhZGl1c0FuZ2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUmFkaXVzQW5nbGUoKSB7XG4gICAgICB2YXIgYW5nbGUgPSB2b2lkIDA7XG4gICAgICB2YXIgcmFkaXVzID0gdm9pZCAwO1xuICAgICAgdmFyIGhleGFnb25WZXJ0aWNlcyA9IHRoaXMucHJvcHMuaGV4YWdvblZlcnRpY2VzO1xuXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhleGFnb25WZXJ0aWNlcykgJiYgaGV4YWdvblZlcnRpY2VzLmxlbmd0aCA+PSA2KSB7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGFuZ2xlIGFuZCB2ZXJ0aWNlcyBmcm9tIGhleGFnb25WZXJ0aWNlcyBpZiBwcm92aWRlZFxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnByb3BzLmhleGFnb25WZXJ0aWNlcztcblxuICAgICAgICB2YXIgdmVydGV4MCA9IHZlcnRpY2VzWzBdO1xuICAgICAgICB2YXIgdmVydGV4MyA9IHZlcnRpY2VzWzNdO1xuXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBzcGFjZSBjb29yZGluYXRlc1xuICAgICAgICB2YXIgc3BhY2VDb29yZDAgPSB0aGlzLnByb2plY3RGbGF0KHZlcnRleDApO1xuICAgICAgICB2YXIgc3BhY2VDb29yZDMgPSB0aGlzLnByb2plY3RGbGF0KHZlcnRleDMpO1xuXG4gICAgICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGNsb3NlIGNlbnRyb2lkc1xuICAgICAgICB2YXIgZHggPSBzcGFjZUNvb3JkMFswXSAtIHNwYWNlQ29vcmQzWzBdO1xuICAgICAgICB2YXIgZHkgPSBzcGFjZUNvb3JkMFsxXSAtIHNwYWNlQ29vcmQzWzFdO1xuICAgICAgICB2YXIgZHh5ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgYW5nbGUgdGhhdCB0aGUgcGVycGVuZGljdWxhciBoZXhhZ29uIHZlcnRleCBheGlzIGlzIHRpbHRlZFxuICAgICAgICBhbmdsZSA9IE1hdGguYWNvcyhkeCAvIGR4eSkgKiAtTWF0aC5zaWduKGR5KSArIE1hdGguUEkgLyAyO1xuICAgICAgICByYWRpdXMgPSBkeHkgLyAyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnJhZGl1cyAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy5wcm9wcy5hbmdsZSkpIHtcblxuICAgICAgICAvLyBpZiBubyBoZXhhZ29uVmVydGljZXMgcHJvdmlkZWQsIHRyeSB1c2UgcmFkaXVzICYgYW5nbGVcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuXG4gICAgICAgIHZhciBfdmlld3BvcnQkZ2V0RGlzdGFuY2UgPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpLFxuICAgICAgICAgICAgcGl4ZWxzUGVyTWV0ZXIgPSBfdmlld3BvcnQkZ2V0RGlzdGFuY2UucGl4ZWxzUGVyTWV0ZXI7XG5cbiAgICAgICAgYW5nbGUgPSB0aGlzLnByb3BzLmFuZ2xlO1xuICAgICAgICByYWRpdXMgPSB0aGlzLnByb3BzLnJhZGl1cyAqIHBpeGVsc1Blck1ldGVyWzBdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFVuaWZvcm1zKHtcbiAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICByYWRpdXM6IHJhZGl1c1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q3lsaW5kZXJHZW9tZXRyeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN5bGluZGVyR2VvbWV0cnkocmFkaXVzKSB7XG4gICAgICByZXR1cm4gbmV3IEN5bGluZGVyR2VvbWV0cnkoe1xuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgdG9wUmFkaXVzOiByYWRpdXMsXG4gICAgICAgIGJvdHRvbVJhZGl1czogcmFkaXVzLFxuICAgICAgICB0b3BDYXA6IHRydWUsXG4gICAgICAgIGJvdHRvbUNhcDogdHJ1ZSxcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBucmFkaWFsOiA2LFxuICAgICAgICBudmVydGljYWw6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVVuaWZvcm1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVW5pZm9ybXMoKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBvcGFjaXR5ID0gX3Byb3BzLm9wYWNpdHksXG4gICAgICAgICAgZWxldmF0aW9uU2NhbGUgPSBfcHJvcHMuZWxldmF0aW9uU2NhbGUsXG4gICAgICAgICAgZXh0cnVkZWQgPSBfcHJvcHMuZXh0cnVkZWQsXG4gICAgICAgICAgY292ZXJhZ2UgPSBfcHJvcHMuY292ZXJhZ2UsXG4gICAgICAgICAgbGlnaHRTZXR0aW5ncyA9IF9wcm9wcy5saWdodFNldHRpbmdzO1xuXG5cbiAgICAgIHRoaXMuc2V0VW5pZm9ybXMoT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICBleHRydWRlZDogZXh0cnVkZWQsXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgIGNvdmVyYWdlOiBjb3ZlcmFnZSxcbiAgICAgICAgZWxldmF0aW9uU2NhbGU6IGVsZXZhdGlvblNjYWxlXG4gICAgICB9LCBsaWdodFNldHRpbmdzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2hhZGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoYWRlcnMoKSB7XG4gICAgICB2YXIgdmVydGV4ID0gJyNkZWZpbmUgU0hBREVSX05BTUUgZXh0cnVkZWQtaGV4YWdvbi1sYXllci12c1xcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBub3JtYWxzO1xcblxcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG4vLyBQaWNraW5nIHVuaWZvcm1zXFxuLy8gU2V0IHRvIDEuMCBpZiByZW5kZXJpbmcgcGlja2luZyBidWZmZXIsIDAuMCBpZiByZW5kZXJpbmcgZm9yIGRpc3BsYXlcXG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XFxudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xcblxcbi8vIEN1c3RvbSB1bmlmb3Jtc1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXG51bmlmb3JtIGZsb2F0IGFuZ2xlO1xcbnVuaWZvcm0gZmxvYXQgZXh0cnVkZWQ7XFxudW5pZm9ybSBmbG9hdCBjb3ZlcmFnZTtcXG51bmlmb3JtIGZsb2F0IGVsZXZhdGlvblNjYWxlO1xcblxcbi8vIFJlc3VsdFxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxuLy8gQSBtYWdpYyBudW1iZXIgdG8gc2NhbGUgZWxldmF0aW9uIHNvIHRoYXQgMSB1bml0IGFwcHJveGltYXRlIHRvIDEgbWV0ZXIuXFxuI2RlZmluZSBFTEVWQVRJT05fU0NBTEUgMC44XFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXG4gIC8vIHJvdGF0ZSBwcmltaXRpdmUgcG9zaXRpb24gYW5kIG5vcm1hbFxcbiAgbWF0MiByb3RhdGlvbk1hdHJpeCA9IG1hdDIoY29zKGFuZ2xlKSwgLXNpbihhbmdsZSksIHNpbihhbmdsZSksIGNvcyhhbmdsZSkpO1xcblxcbiAgdmVjMiByUG9zID0gcm90YXRpb25NYXRyaXggKiBwb3NpdGlvbnMueHo7XFxuICB2ZWMyIHJOb3JtID0gcm90YXRpb25NYXRyaXggKiBub3JtYWxzLnh6O1xcblxcbiAgdmVjMyByb3RhdGVkUG9zaXRpb25zID0gdmVjMyhyUG9zLngsIHBvc2l0aW9ucy55LCByUG9zLnkpO1xcbiAgdmVjMyByb3RhdGVkTm9ybWFscyA9IHZlYzMock5vcm0ueCwgbm9ybWFscy55LCByTm9ybS55KTtcXG5cXG4gIC8vIGNhbGN1bGF0ZSBlbGV2YXRpb24sIGlmIDNkIG5vdCBlbmFibGVkIHNldCB0byAwXFxuICAvLyBjeWxpbmRhciBnZW1vZXRyeSBoZWlnaHQgYXJlIGJldHdlZW4gLTAuNSB0byAwLjUsIHRyYW5zZm9ybSBpdCB0byBiZXR3ZWVuIDAsIDFcXG4gIGZsb2F0IGVsZXZhdGlvbiA9IDAuMDtcXG5cXG4gIGlmIChleHRydWRlZCA+IDAuNSkge1xcbiAgICBlbGV2YXRpb24gPSBwcm9qZWN0X3NjYWxlKGluc3RhbmNlUG9zaXRpb25zLnogKiAocG9zaXRpb25zLnkgKyAwLjUpICogRUxFVkFUSU9OX1NDQUxFICogZWxldmF0aW9uU2NhbGUpO1xcbn1cXG5cXG4gIGZsb2F0IGRvdFJhZGl1cyA9IHJhZGl1cyAqIGNsYW1wKGNvdmVyYWdlLCAwLjAsIDEuMCk7XFxuICAvLyAvLyBwcm9qZWN0IGNlbnRlciBvZiBoZXhhZ29uXFxuXFxuICB2ZWM0IGNlbnRyb2lkUG9zaXRpb24gPSB2ZWM0KHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMueHkpLCBlbGV2YXRpb24sIDAuMCk7XFxuXFxuICB2ZWM0IHBvc2l0aW9uX3dvcmxkc3BhY2UgPSBjZW50cm9pZFBvc2l0aW9uICsgdmVjNCh2ZWMyKHJvdGF0ZWRQb3NpdGlvbnMueHogKiBkb3RSYWRpdXMpLCAwLiwgMS4pO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZShwb3NpdGlvbl93b3JsZHNwYWNlKTtcXG5cXG4gIC8vIHJlbmRlciBkaXNwbGF5XFxuICBpZiAocmVuZGVyUGlja2luZ0J1ZmZlciA8IDAuNSkge1xcblxcbiAgICAvLyBUT0RPOiB3ZSBzaG91bGQgYWxsb3cgdGhlIHVzZXIgdG8gc3BlY2lmeSB0aGUgY29sb3IgZm9yIFwic2VsZWN0ZWQgZWxlbWVudFwiXFxuICAgIC8vIGNoZWNrIHdoZXRoZXIgaGV4YWdvbiBpcyBjdXJyZW50bHkgcGlja2VkLlxcbiAgICBmbG9hdCBzZWxlY3RlZCA9IGlzUGlja2VkKGluc3RhbmNlUGlja2luZ0NvbG9ycywgc2VsZWN0ZWRQaWNraW5nQ29sb3IpO1xcblxcbiAgICAvLyBMaWdodCBjYWxjdWxhdGlvbnNcXG4gICAgLy8gV29ybGRzcGFjZSBpcyB0aGUgbGluZWFyIHNwYWNlIGFmdGVyIE1lcmNhdG9yIHByb2plY3Rpb25cXG5cXG4gICAgdmVjMyBub3JtYWxzX3dvcmxkc3BhY2UgPSByb3RhdGVkTm9ybWFscztcXG5cXG4gICAgZmxvYXQgbGlnaHRXZWlnaHQgPSAxLjA7XFxuXFxuICAgIGlmIChleHRydWRlZCA+IDAuNSkge1xcbiAgICAgIGxpZ2h0V2VpZ2h0ID0gZ2V0TGlnaHRXZWlnaHQoXFxuICAgICAgICBwb3NpdGlvbl93b3JsZHNwYWNlLFxcbiAgICAgICAgbm9ybWFsc193b3JsZHNwYWNlXFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICB2ZWMzIGxpZ2h0V2VpZ2h0ZWRDb2xvciA9IGxpZ2h0V2VpZ2h0ICogaW5zdGFuY2VDb2xvcnMucmdiO1xcblxcbiAgICAvLyBDb2xvcjogRWl0aGVyIG9wYWNpdHktbXVsdGlwbGllZCBpbnN0YW5jZSBjb2xvciwgb3IgcGlja2luZyBjb2xvclxcbiAgICB2ZWM0IGNvbG9yID0gdmVjNChsaWdodFdlaWdodGVkQ29sb3IsIG9wYWNpdHkgKiBpbnN0YW5jZUNvbG9ycy5hKSAvIDI1NS4wO1xcblxcbiAgICB2Q29sb3IgPSBjb2xvcjtcXG5cXG4gIH0gZWxzZSB7XFxuXFxuICAgIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuMCwgMS4wKTtcXG4gICAgdkNvbG9yID0gcGlja2luZ0NvbG9yO1xcblxcbiAgfVxcbn1cXG4nO1xuICAgICAgdmFyIHBpY2tpbmcgPSAnLy8gd2hldGhlciBpcyBwb2ludCBwaWNrZWRcXG5mbG9hdCBpc1BpY2tlZCh2ZWMzIHBpY2tpbmdDb2xvcnMsIHZlYzMgc2VsZWN0ZWRDb2xvcikge1xcbiByZXR1cm4gZmxvYXQocGlja2luZ0NvbG9ycy54ID09IHNlbGVjdGVkQ29sb3IueFxcbiAmJiBwaWNraW5nQ29sb3JzLnkgPT0gc2VsZWN0ZWRDb2xvci55XFxuICYmIHBpY2tpbmdDb2xvcnMueiA9PSBzZWxlY3RlZENvbG9yLnopO1xcbn1cXG4nO1xuICAgICAgdmFyIHZzID0gcGlja2luZy5jb25jYXQodmVydGV4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZzOiB2cyxcbiAgICAgICAgZnM6ICcvLyBTZWU6IG5wbSBnbHNsLXNoYWRlci1uYW1lXFxuI2RlZmluZSBTSEFERVJfTkFNRSBleHRydWRlZC1oZXhhZ29uLWxheWVyLWZzXFxuXFxuI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcXG59XFxuJyxcbiAgICAgICAgbW9kdWxlczogWydsaWdodGluZyddXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldE1vZGVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kZWwoZ2wpIHtcbiAgICAgIHZhciBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgICBnbDogZ2wsXG4gICAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgICB2czogc2hhZGVycy52cyxcbiAgICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICAgIGdlb21ldHJ5OiB0aGlzLmdldEN5bGluZGVyR2VvbWV0cnkoMSksXG4gICAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmKSB7XG4gICAgICB2YXIgdW5pZm9ybXMgPSBfcmVmLnVuaWZvcm1zO1xuXG4gICAgICBfZ2V0KEhleGFnb25MYXllci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihIZXhhZ29uTGF5ZXIucHJvdG90eXBlKSwgJ2RyYXcnLCB0aGlzKS5jYWxsKHRoaXMsIHsgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zKSB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHMyLmRhdGEsXG4gICAgICAgICAgZ2V0Q2VudHJvaWQgPSBfcHJvcHMyLmdldENlbnRyb2lkLFxuICAgICAgICAgIGdldEVsZXZhdGlvbiA9IF9wcm9wczIuZ2V0RWxldmF0aW9uO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG9iamVjdCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF9nZXRDZW50cm9pZCA9IGdldENlbnRyb2lkKG9iamVjdCksXG4gICAgICAgICAgICAgIF9nZXRDZW50cm9pZDIgPSBfc2xpY2VkVG9BcnJheShfZ2V0Q2VudHJvaWQsIDIpLFxuICAgICAgICAgICAgICBsb24gPSBfZ2V0Q2VudHJvaWQyWzBdLFxuICAgICAgICAgICAgICBsYXQgPSBfZ2V0Q2VudHJvaWQyWzFdO1xuXG4gICAgICAgICAgdmFyIGVsZXZhdGlvbiA9IGdldEVsZXZhdGlvbihvYmplY3QpO1xuICAgICAgICAgIHZhbHVlW2kgKyAwXSA9IGxvbjtcbiAgICAgICAgICB2YWx1ZVtpICsgMV0gPSBsYXQ7XG4gICAgICAgICAgdmFsdWVbaSArIDJdID0gZWxldmF0aW9uIHx8IHRoaXMucHJvcHMuZWxldmF0aW9uO1xuICAgICAgICAgIGkgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3Byb3BzMy5kYXRhLFxuICAgICAgICAgIGdldENvbG9yID0gX3Byb3BzMy5nZXRDb2xvcjtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZSxcbiAgICAgICAgICBzaXplID0gYXR0cmlidXRlLnNpemU7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgY29sb3IgPSBnZXRDb2xvcihvYmplY3QpIHx8IERFRkFVTFRfQ09MT1I7XG5cbiAgICAgICAgICB2YWx1ZVtpICsgMF0gPSBjb2xvclswXTtcbiAgICAgICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgICAgICB2YWx1ZVtpICsgM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiBERUZBVUxUX0NPTE9SWzNdO1xuICAgICAgICAgIGkgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIZXhhZ29uTGF5ZXI7XG59KExheWVyKTtcblxuZXhwb3J0IGRlZmF1bHQgSGV4YWdvbkxheWVyO1xuXG5cbkhleGFnb25MYXllci5sYXllck5hbWUgPSAnSGV4YWdvbkxheWVyJztcbkhleGFnb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvaGV4YWdvbi1sYXllci9oZXhhZ29uLWxheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 21 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************!*\
  !*** ./src/layers/core/line-layer/line-layer.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\n\nvar defaultProps = {\n  getSourcePosition: function getSourcePosition(x) {\n    return x.sourcePosition;\n  },\n  getTargetPosition: function getTargetPosition(x) {\n    return x.targetPosition;\n  },\n  getColor: function getColor(x) {\n    return x.color || DEFAULT_COLOR;\n  },\n  strokeWidth: 1\n};\n\nvar LineLayer = function (_Layer) {\n  _inherits(LineLayer, _Layer);\n\n  function LineLayer() {\n    _classCallCheck(this, LineLayer);\n\n    return _possibleConstructorReturn(this, (LineLayer.__proto__ || Object.getPrototypeOf(LineLayer)).apply(this, arguments));\n  }\n\n  _createClass(LineLayer, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      var gl = this.context.gl;\n\n      this.setState({ model: this.createModel(gl) });\n\n      var attributeManager = this.state.attributeManager;\n\n      /* eslint-disable max-len */\n\n      attributeManager.addInstanced({\n        instanceSourcePositions: { size: 3, accessor: 'getSourcePosition', update: this.calculateInstanceSourcePositions },\n        instanceTargetPositions: { size: 3, accessor: 'getTargetPosition', update: this.calculateInstanceTargetPositions },\n        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }\n      });\n      /* eslint-enable max-len */\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref) {\n      var uniforms = _ref.uniforms;\n      var strokeWidth = this.props.strokeWidth;\n      var _context$viewport = this.context.viewport,\n          width = _context$viewport.width,\n          height = _context$viewport.height;\n\n\n      this.state.model.render(Object.assign({}, uniforms, {\n        screenSize: [width, height],\n        strokeWidth: strokeWidth\n      }));\n    }\n  }, {\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME line-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec3 instanceSourcePositions;\\nattribute vec3 instanceTargetPositions;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform vec2 screenSize;\\nuniform float strokeWidth;\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\n\\n// offset vector by strokeWidth pixels\\n// offset_direction is -1 (left) or 1 (right)\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace * screenSize);\\n  // rotate by 90 degrees\\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n\\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\\n  vec2 offset_clipspace = offset_screenspace / screenSize * 2.0;\\n\\n  return offset_clipspace;\\n}\\n\\nvoid main(void) {\\n  // Position\\n  vec3 sourcePos = project_position(instanceSourcePositions);\\n  vec3 targetPos = project_position(instanceTargetPositions);\\n  vec4 source = project_to_clipspace(vec4(sourcePos, 1.0));\\n  vec4 target = project_to_clipspace(vec4(targetPos, 1.0));\\n\\n  // linear interpolation of source & target to pick right coord\\n  float segmentIndex = positions.x;\\n  vec4 p = mix(source, target, segmentIndex);\\n\\n  // extrude\\n  vec2 offset = getExtrusionOffset(target.xy - source.xy, positions.y);\\n  gl_Position = p + vec4(offset, 0.0, 0.0);\\n\\n  // Color\\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n  vColor = mix(\\n    color,\\n    pickingColor,\\n    renderPickingBuffer\\n  );\\n}\\n',\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n#define SHADER_NAME line-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n'\n      };\n    }\n  }, {\n    key: 'createModel',\n    value: function createModel(gl) {\n      /*\n       *  (0, -1)-------------_(1, -1)\n       *       |          _,-\"  |\n       *       o      _,-\"      o\n       *       |  _,-\"          |\n       *   (0, 1)\"-------------(1, 1)\n       */\n      var positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];\n\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_STRIP,\n          positions: new Float32Array(positions)\n        }),\n        isInstanced: true\n      });\n    }\n  }, {\n    key: 'calculateInstanceSourcePositions',\n    value: function calculateInstanceSourcePositions(attribute) {\n      var _props = this.props,\n          data = _props.data,\n          getSourcePosition = _props.getSourcePosition;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n\n          var sourcePosition = getSourcePosition(object);\n          value[i + 0] = sourcePosition[0];\n          value[i + 1] = sourcePosition[1];\n          value[i + 2] = isNaN(sourcePosition[2]) ? 0 : sourcePosition[2];\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceTargetPositions',\n    value: function calculateInstanceTargetPositions(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getTargetPosition = _props2.getTargetPosition;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n\n          var targetPosition = getTargetPosition(object);\n          value[i + 0] = targetPosition[0];\n          value[i + 1] = targetPosition[1];\n          value[i + 2] = isNaN(targetPosition[2]) ? 0 : targetPosition[2];\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceColors',\n    value: function calculateInstanceColors(attribute) {\n      var _props3 = this.props,\n          data = _props3.data,\n          getColor = _props3.getColor;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var object = _step3.value;\n\n          var color = getColor(object);\n          value[i + 0] = color[0];\n          value[i + 1] = color[1];\n          value[i + 2] = color[2];\n          value[i + 3] = isNaN(color[3]) ? 255 : color[3];\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }]);\n\n  return LineLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = LineLayer;\n\n\nLineLayer.layerName = 'LineLayer';\nLineLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvbGluZS1sYXllci9saW5lLWxheWVyLmpzPzgyODkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgeyBhc3NlbWJsZVNoYWRlcnMgfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHsgR0wsIE1vZGVsLCBHZW9tZXRyeSB9IGZyb20gJ2x1bWEuZ2wnO1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbnZhciBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGdldFNvdXJjZVBvc2l0aW9uOiBmdW5jdGlvbiBnZXRTb3VyY2VQb3NpdGlvbih4KSB7XG4gICAgcmV0dXJuIHguc291cmNlUG9zaXRpb247XG4gIH0sXG4gIGdldFRhcmdldFBvc2l0aW9uOiBmdW5jdGlvbiBnZXRUYXJnZXRQb3NpdGlvbih4KSB7XG4gICAgcmV0dXJuIHgudGFyZ2V0UG9zaXRpb247XG4gIH0sXG4gIGdldENvbG9yOiBmdW5jdGlvbiBnZXRDb2xvcih4KSB7XG4gICAgcmV0dXJuIHguY29sb3IgfHwgREVGQVVMVF9DT0xPUjtcbiAgfSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbnZhciBMaW5lTGF5ZXIgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhMaW5lTGF5ZXIsIF9MYXllcik7XG5cbiAgZnVuY3Rpb24gTGluZUxheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lTGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMaW5lTGF5ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaW5lTGF5ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5lTGF5ZXIsIFt7XG4gICAga2V5OiAnaW5pdGlhbGl6ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgbW9kZWw6IHRoaXMuY3JlYXRlTW9kZWwoZ2wpIH0pO1xuXG4gICAgICB2YXIgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlcjtcblxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgIGluc3RhbmNlU291cmNlUG9zaXRpb25zOiB7IHNpemU6IDMsIGFjY2Vzc29yOiAnZ2V0U291cmNlUG9zaXRpb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VQb3NpdGlvbnMgfSxcbiAgICAgICAgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM6IHsgc2l6ZTogMywgYWNjZXNzb3I6ICdnZXRUYXJnZXRQb3NpdGlvbicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVRhcmdldFBvc2l0aW9ucyB9LFxuICAgICAgICBpbnN0YW5jZUNvbG9yczogeyBzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzIH1cbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoX3JlZikge1xuICAgICAgdmFyIHVuaWZvcm1zID0gX3JlZi51bmlmb3JtcztcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMucHJvcHMuc3Ryb2tlV2lkdGg7XG4gICAgICB2YXIgX2NvbnRleHQkdmlld3BvcnQgPSB0aGlzLmNvbnRleHQudmlld3BvcnQsXG4gICAgICAgICAgd2lkdGggPSBfY29udGV4dCR2aWV3cG9ydC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfY29udGV4dCR2aWV3cG9ydC5oZWlnaHQ7XG5cblxuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIoT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgICAgc2NyZWVuU2l6ZTogW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGhcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTaGFkZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2hhZGVycygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIGxpbmUtbGF5ZXItdmVydGV4LXNoYWRlclxcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVRhcmdldFBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XFxuXFxudW5pZm9ybSB2ZWMyIHNjcmVlblNpemU7XFxudW5pZm9ybSBmbG9hdCBzdHJva2VXaWR0aDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxuLy8gb2Zmc2V0IHZlY3RvciBieSBzdHJva2VXaWR0aCBwaXhlbHNcXG4vLyBvZmZzZXRfZGlyZWN0aW9uIGlzIC0xIChsZWZ0KSBvciAxIChyaWdodClcXG52ZWMyIGdldEV4dHJ1c2lvbk9mZnNldCh2ZWMyIGxpbmVfY2xpcHNwYWNlLCBmbG9hdCBvZmZzZXRfZGlyZWN0aW9uKSB7XFxuICAvLyBub3JtYWxpemVkIGRpcmVjdGlvbiBvZiB0aGUgbGluZVxcbiAgdmVjMiBkaXJfc2NyZWVuc3BhY2UgPSBub3JtYWxpemUobGluZV9jbGlwc3BhY2UgKiBzY3JlZW5TaXplKTtcXG4gIC8vIHJvdGF0ZSBieSA5MCBkZWdyZWVzXFxuICBkaXJfc2NyZWVuc3BhY2UgPSB2ZWMyKC1kaXJfc2NyZWVuc3BhY2UueSwgZGlyX3NjcmVlbnNwYWNlLngpO1xcblxcbiAgdmVjMiBvZmZzZXRfc2NyZWVuc3BhY2UgPSBkaXJfc2NyZWVuc3BhY2UgKiBvZmZzZXRfZGlyZWN0aW9uICogc3Ryb2tlV2lkdGggLyAyLjA7XFxuICB2ZWMyIG9mZnNldF9jbGlwc3BhY2UgPSBvZmZzZXRfc2NyZWVuc3BhY2UgLyBzY3JlZW5TaXplICogMi4wO1xcblxcbiAgcmV0dXJuIG9mZnNldF9jbGlwc3BhY2U7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBQb3NpdGlvblxcbiAgdmVjMyBzb3VyY2VQb3MgPSBwcm9qZWN0X3Bvc2l0aW9uKGluc3RhbmNlU291cmNlUG9zaXRpb25zKTtcXG4gIHZlYzMgdGFyZ2V0UG9zID0gcHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVRhcmdldFBvc2l0aW9ucyk7XFxuICB2ZWM0IHNvdXJjZSA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQoc291cmNlUG9zLCAxLjApKTtcXG4gIHZlYzQgdGFyZ2V0ID0gcHJvamVjdF90b19jbGlwc3BhY2UodmVjNCh0YXJnZXRQb3MsIDEuMCkpO1xcblxcbiAgLy8gbGluZWFyIGludGVycG9sYXRpb24gb2Ygc291cmNlICYgdGFyZ2V0IHRvIHBpY2sgcmlnaHQgY29vcmRcXG4gIGZsb2F0IHNlZ21lbnRJbmRleCA9IHBvc2l0aW9ucy54O1xcbiAgdmVjNCBwID0gbWl4KHNvdXJjZSwgdGFyZ2V0LCBzZWdtZW50SW5kZXgpO1xcblxcbiAgLy8gZXh0cnVkZVxcbiAgdmVjMiBvZmZzZXQgPSBnZXRFeHRydXNpb25PZmZzZXQodGFyZ2V0Lnh5IC0gc291cmNlLnh5LCBwb3NpdGlvbnMueSk7XFxuICBnbF9Qb3NpdGlvbiA9IHAgKyB2ZWM0KG9mZnNldCwgMC4wLCAwLjApO1xcblxcbiAgLy8gQ29sb3JcXG4gIHZlYzQgY29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcXG4gIHZlYzQgcGlja2luZ0NvbG9yID0gdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLik7XFxuICB2Q29sb3IgPSBtaXgoXFxuICAgIGNvbG9yLFxcbiAgICBwaWNraW5nQ29sb3IsXFxuICAgIHJlbmRlclBpY2tpbmdCdWZmZXJcXG4gICk7XFxufVxcbicsXG4gICAgICAgIGZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIGxpbmUtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxuI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcXG59XFxuJ1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU1vZGVsKGdsKSB7XG4gICAgICAvKlxuICAgICAgICogICgwLCAtMSktLS0tLS0tLS0tLS0tXygxLCAtMSlcbiAgICAgICAqICAgICAgIHwgICAgICAgICAgXywtXCIgIHxcbiAgICAgICAqICAgICAgIG8gICAgICBfLC1cIiAgICAgIG9cbiAgICAgICAqICAgICAgIHwgIF8sLVwiICAgICAgICAgIHxcbiAgICAgICAqICAgKDAsIDEpXCItLS0tLS0tLS0tLS0tKDEsIDEpXG4gICAgICAgKi9cbiAgICAgIHZhciBwb3NpdGlvbnMgPSBbMCwgLTEsIDAsIDAsIDEsIDAsIDEsIC0xLCAwLCAxLCAxLCAwXTtcblxuICAgICAgdmFyIHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICAgIGdsOiBnbCxcbiAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFX1NUUklQLFxuICAgICAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpXG4gICAgICAgIH0pLFxuICAgICAgICBpc0luc3RhbmNlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VQb3NpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHMuZGF0YSxcbiAgICAgICAgICBnZXRTb3VyY2VQb3NpdGlvbiA9IF9wcm9wcy5nZXRTb3VyY2VQb3NpdGlvbjtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZSxcbiAgICAgICAgICBzaXplID0gYXR0cmlidXRlLnNpemU7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBzb3VyY2VQb3NpdGlvbiA9IGdldFNvdXJjZVBvc2l0aW9uKG9iamVjdCk7XG4gICAgICAgICAgdmFsdWVbaSArIDBdID0gc291cmNlUG9zaXRpb25bMF07XG4gICAgICAgICAgdmFsdWVbaSArIDFdID0gc291cmNlUG9zaXRpb25bMV07XG4gICAgICAgICAgdmFsdWVbaSArIDJdID0gaXNOYU4oc291cmNlUG9zaXRpb25bMl0pID8gMCA6IHNvdXJjZVBvc2l0aW9uWzJdO1xuICAgICAgICAgIGkgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnN0YW5jZVRhcmdldFBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3Byb3BzMi5kYXRhLFxuICAgICAgICAgIGdldFRhcmdldFBvc2l0aW9uID0gX3Byb3BzMi5nZXRUYXJnZXRQb3NpdGlvbjtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZSxcbiAgICAgICAgICBzaXplID0gYXR0cmlidXRlLnNpemU7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgdGFyZ2V0UG9zaXRpb24gPSBnZXRUYXJnZXRQb3NpdGlvbihvYmplY3QpO1xuICAgICAgICAgIHZhbHVlW2kgKyAwXSA9IHRhcmdldFBvc2l0aW9uWzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAxXSA9IHRhcmdldFBvc2l0aW9uWzFdO1xuICAgICAgICAgIHZhbHVlW2kgKyAyXSA9IGlzTmFOKHRhcmdldFBvc2l0aW9uWzJdKSA/IDAgOiB0YXJnZXRQb3NpdGlvblsyXTtcbiAgICAgICAgICBpICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHMzLmRhdGEsXG4gICAgICAgICAgZ2V0Q29sb3IgPSBfcHJvcHMzLmdldENvbG9yO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG9iamVjdCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgIHZhciBjb2xvciA9IGdldENvbG9yKG9iamVjdCk7XG4gICAgICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF07XG4gICAgICAgICAgdmFsdWVbaSArIDFdID0gY29sb3JbMV07XG4gICAgICAgICAgdmFsdWVbaSArIDJdID0gY29sb3JbMl07XG4gICAgICAgICAgdmFsdWVbaSArIDNdID0gaXNOYU4oY29sb3JbM10pID8gMjU1IDogY29sb3JbM107XG4gICAgICAgICAgaSArPSBzaXplO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbmVMYXllcjtcbn0oTGF5ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBMaW5lTGF5ZXI7XG5cblxuTGluZUxheWVyLmxheWVyTmFtZSA9ICdMaW5lTGF5ZXInO1xuTGluZUxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9saW5lLWxheWVyL2xpbmUtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 22 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************!*\
  !*** ./src/layers/core/path-layer/path-layer.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\n\nvar defaultProps = {\n  opacity: 1,\n  strokeWidthScale: 1, // stroke width in meters\n  rounded: false,\n  miterLimit: 4,\n  strokeWidthMinPixels: 0, //  min stroke width in pixels\n  strokeWidthMaxPixels: Number.MAX_SAFE_INTEGER, // max stroke width in pixels\n  getPath: function getPath(object) {\n    return object.path;\n  },\n  getColor: function getColor(object) {\n    return object.color || DEFAULT_COLOR;\n  },\n  getStrokeWidth: function getStrokeWidth(object) {\n    return object.width || 1;\n  }\n};\n\nvar isClosed = function isClosed(path) {\n  var firstPoint = path[0];\n  var lastPoint = path[path.length - 1];\n  return firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1] && firstPoint[2] === lastPoint[2];\n};\n\nvar PathLayer = function (_Layer) {\n  _inherits(PathLayer, _Layer);\n\n  function PathLayer() {\n    _classCallCheck(this, PathLayer);\n\n    return _possibleConstructorReturn(this, (PathLayer.__proto__ || Object.getPrototypeOf(PathLayer)).apply(this, arguments));\n  }\n\n  _createClass(PathLayer, [{\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '#define SHADER_NAME path-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec3 instanceLeftDeltas;\\nattribute vec3 instanceRightDeltas;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float strokeWidthScale;\\nuniform float strokeWidthMinPixels;\\nuniform float strokeWidthMaxPixels;\\nuniform float jointType;\\nuniform float miterLimit;\\n\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\n\\nconst float EPSILON = 0.001;\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\n\\n// calculate line join positions\\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\\n\\n  float width = clamp(project_scale(instanceStrokeWidths * strokeWidthScale),\\n    strokeWidthMinPixels, strokeWidthMaxPixels) / 2.0;\\n\\n  vec2 deltaA = currPoint.xy - prevPoint.xy;\\n  vec2 deltaB = nextPoint.xy - currPoint.xy;\\n\\n  vec2 offsetVec;\\n  float offsetScale;\\n  float offsetDirection;\\n\\n  float lenA = length(deltaA);\\n  float lenB = length(deltaB);\\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(1.0, 0.0);\\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(1.0, 0.0);\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n\\n  // tangent of the corner\\n  vec2 tangent = vec2(dirA + dirB);\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  // direction of the corner\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  // width offset from current position\\n  vec2 perp = mix(perpB, perpA, positions.x);\\n  float L = mix(lenB, lenA, positions.x);\\n\\n  // cap super sharp angles\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\\n\\n  // relative position to the corner:\\n  // -1: inside (smaller side of the angle)\\n  // 0: center\\n  // 1: outside (bigger side of the angle)\\n  float cornerPosition = mix(\\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\\n    0.0,\\n    positions.z\\n  );\\n\\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\\n\\n  // do not bevel if line segment is too short\\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\\n  // trim if inside corner extends further than the line segment\\n  offsetScale = mix(\\n    offsetScale,\\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\\n    float(cornerPosition < 0.0)\\n  );\\n\\n  vMiterLength = mix(\\n    offsetScale * cornerPosition,\\n    mix(offsetScale, 0.0, cornerPosition),\\n    step(0.0, cornerPosition)\\n  ) - sinHalfA * jointType;\\n  offsetDirection = mix(\\n    positions.y,\\n    mix(\\n      flipIfTrue(turnsRight), \\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)), \\n      cornerPosition\\n    ),\\n    step(0.0, cornerPosition)\\n  );\\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\\n\\n  // special treatment for start cap and end cap\\n  float isStartCap = step(0.0, -lenA);\\n  float isEndCap = step(0.0, -lenB);\\n  float isCap = max(isStartCap, isEndCap);\\n\\n  // 0: center, 1: side\\n  cornerPosition = isCap * (1.0 - positions.z);\\n\\n  // start of path: use next - curr\\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\\n  // end of path: use curr - prev\\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\\n\\n  // extend out a triangle to envelope the round cap\\n  offsetScale = mix(\\n    offsetScale,\\n    mix(4.0 * jointType, 1.0, cornerPosition),\\n    isCap\\n  );\\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\\n\\n  offsetDirection = mix(\\n    offsetDirection,\\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\\n    isCap\\n  );\\n\\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\\n\\n  return currPoint + vec3(vCornerOffset * width, 0.0);\\n}\\n\\nvoid main() {\\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors, 255.) / 255.;\\n  vColor = mix(color, pickingColor, renderPickingBuffer);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 prevPosition = mix(-instanceLeftDeltas, vec3(0.0), isEnd) + instanceStartPositions;\\n  prevPosition = project_position(prevPosition);\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  currPosition = project_position(currPosition);\\n\\n  vec3 nextPosition = mix(vec3(0.0), instanceRightDeltas, isEnd) + instanceEndPositions;\\n  nextPosition = project_position(nextPosition);\\n\\n  vec3 pos;\\n\\n  pos = lineJoin(prevPosition, currPosition, nextPosition);\\n\\n  gl_Position = project_to_clipspace(vec4(pos, 1.0));\\n}\\n',\n        fs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME path-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nuniform float jointType;\\nuniform float miterLimit;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\n\\nvoid main(void) {\\n  // if joint is rounded, test distance from the corner\\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\\n    discard;\\n  }\\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\\n    discard;\\n  }\\n  gl_FragColor = vColor;\\n}\\n'\n      };\n    }\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      var gl = this.context.gl;\n\n      this.setState({ model: this.getModel(gl) });\n\n      var attributeManager = this.state.attributeManager;\n      /* eslint-disable max-len */\n\n      attributeManager.addInstanced({\n        instanceStartPositions: { size: 3, update: this.calculateStartPositions },\n        instanceEndPositions: { size: 3, update: this.calculateEndPositions },\n        instanceLeftDeltas: { size: 3, update: this.calculateLeftDeltas },\n        instanceRightDeltas: { size: 3, update: this.calculateRightDeltas },\n        instanceStrokeWidths: { size: 1, accessor: 'getStrokeWidth', update: this.calculateStrokeWidths },\n        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateColors },\n        instancePickingColors: { size: 3, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, update: this.calculatePickingColors }\n      });\n      /* eslint-enable max-len */\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n      var getPath = this.props.getPath;\n      var attributeManager = this.state.attributeManager;\n\n\n      if (changeFlags.dataChanged) {\n        // this.state.paths only stores point positions in each path\n        var paths = props.data.map(getPath);\n        var numInstances = paths.reduce(function (count, path) {\n          return count + path.length - 1;\n        }, 0);\n\n        this.setState({ paths: paths, numInstances: numInstances });\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var _props = this.props,\n          rounded = _props.rounded,\n          miterLimit = _props.miterLimit,\n          strokeWidthScale = _props.strokeWidthScale,\n          strokeWidthMinPixels = _props.strokeWidthMinPixels,\n          strokeWidthMaxPixels = _props.strokeWidthMaxPixels;\n\n\n      this.state.model.render(Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        strokeWidthScale: strokeWidthScale,\n        miterLimit: miterLimit,\n        strokeWidthMinPixels: strokeWidthMinPixels,\n        strokeWidthMaxPixels: strokeWidthMaxPixels\n      }));\n    }\n  }, {\n    key: 'getModel',\n    value: function getModel(gl) {\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      /*\n       *       _\n       *        \"-_ 1                   3                       5\n       *     _     \"o---------------------o-------------------_-o\n       *       -   / \"\"--..__              '.             _.-' /\n       *   _     \"@- - - - - \"\"--..__- - - - x - - - -_.@'    /\n       *    \"-_  /                   \"\"--..__ '.  _,-` :     /\n       *       \"o----------------------------\"\"-o'    :     /\n       *      0,2                            4 / '.  :     /\n       *                                      /   '.:     /\n       *                                     /     :'.   /\n       *                                    /     :  ', /\n       *                                   /     :     o\n       */\n\n      var SEGMENT_INDICES = [\n      // start corner\n      0, 2, 1,\n      // body\n      1, 2, 4, 1, 4, 3,\n      // end corner\n      3, 4, 5];\n\n      // [0] position on segment - 0: start, 1: end\n      // [1] side of path - -1: left, 0: center, 1: right\n      // [2] role - 0: offset point 1: joint point\n      var SEGMENT_POSITIONS = [\n      // bevel start corner\n      0, 0, 1,\n      // start inner corner\n      0, -1, 0,\n      // start outer corner\n      0, 1, 0,\n      // end inner corner\n      1, -1, 0,\n      // end outer corner\n      1, 1, 0,\n      // bevel end corner\n      1, 0, 1];\n\n      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        fs: shaders.fs,\n        vs: shaders.vs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLES,\n          attributes: {\n            indices: new Uint16Array(SEGMENT_INDICES),\n            positions: new Float32Array(SEGMENT_POSITIONS)\n          }\n        }),\n        isInstanced: true\n      });\n    }\n  }, {\n    key: 'calculateStartPositions',\n    value: function calculateStartPositions(attribute) {\n      var paths = this.state.paths;\n      var value = attribute.value;\n\n\n      var i = 0;\n      paths.forEach(function (path) {\n        var numSegments = path.length - 1;\n        for (var ptIndex = 0; ptIndex < numSegments; ptIndex++) {\n          var point = path[ptIndex];\n          value[i++] = point[0];\n          value[i++] = point[1];\n          value[i++] = point[2] || 0;\n        }\n      });\n    }\n  }, {\n    key: 'calculateEndPositions',\n    value: function calculateEndPositions(attribute) {\n      var paths = this.state.paths;\n      var value = attribute.value;\n\n\n      var i = 0;\n      paths.forEach(function (path) {\n        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {\n          var point = path[ptIndex];\n          value[i++] = point[0];\n          value[i++] = point[1];\n          value[i++] = point[2] || 0;\n        }\n      });\n    }\n  }, {\n    key: 'calculateLeftDeltas',\n    value: function calculateLeftDeltas(attribute) {\n      var paths = this.state.paths;\n      var value = attribute.value;\n\n\n      var i = 0;\n      paths.forEach(function (path) {\n        var numSegments = path.length - 1;\n        var prevPoint = isClosed(path) ? path[path.length - 2] : path[0];\n\n        for (var ptIndex = 0; ptIndex < numSegments; ptIndex++) {\n          var point = path[ptIndex];\n          value[i++] = point[0] - prevPoint[0];\n          value[i++] = point[1] - prevPoint[1];\n          value[i++] = point[2] - prevPoint[2] || 0;\n          prevPoint = point;\n        }\n      });\n    }\n  }, {\n    key: 'calculateRightDeltas',\n    value: function calculateRightDeltas(attribute) {\n      var paths = this.state.paths;\n      var value = attribute.value;\n\n\n      var i = 0;\n      paths.forEach(function (path) {\n        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {\n          var point = path[ptIndex];\n          var nextPoint = path[ptIndex + 1];\n          if (!nextPoint) {\n            nextPoint = isClosed(path) ? path[1] : point;\n          }\n\n          value[i++] = nextPoint[0] - point[0];\n          value[i++] = nextPoint[1] - point[1];\n          value[i++] = nextPoint[2] - point[2] || 0;\n        }\n      });\n    }\n  }, {\n    key: 'calculateStrokeWidths',\n    value: function calculateStrokeWidths(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getStrokeWidth = _props2.getStrokeWidth;\n      var paths = this.state.paths;\n      var value = attribute.value;\n\n\n      var i = 0;\n      paths.forEach(function (path, index) {\n        var width = getStrokeWidth(data[index], index);\n        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {\n          value[i++] = width;\n        }\n      });\n    }\n  }, {\n    key: 'calculateColors',\n    value: function calculateColors(attribute) {\n      var _props3 = this.props,\n          data = _props3.data,\n          getColor = _props3.getColor;\n      var paths = this.state.paths;\n      var value = attribute.value;\n\n\n      var i = 0;\n      paths.forEach(function (path, index) {\n        var pointColor = getColor(data[index], index);\n        if (isNaN(pointColor[3])) {\n          pointColor[3] = 255;\n        }\n        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {\n          value[i++] = pointColor[0];\n          value[i++] = pointColor[1];\n          value[i++] = pointColor[2];\n          value[i++] = pointColor[3];\n        }\n      });\n    }\n\n    // Override the default picking colors calculation\n\n  }, {\n    key: 'calculatePickingColors',\n    value: function calculatePickingColors(attribute) {\n      var _this2 = this;\n\n      var paths = this.state.paths;\n      var value = attribute.value;\n\n\n      var i = 0;\n      paths.forEach(function (path, index) {\n        var pickingColor = _this2.encodePickingColor(index);\n        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {\n          value[i++] = pickingColor[0];\n          value[i++] = pickingColor[1];\n          value[i++] = pickingColor[2];\n        }\n      });\n    }\n  }]);\n\n  return PathLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = PathLayer;\n\n\nPathLayer.layerName = 'PathLayer';\nPathLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcGF0aC1sYXllci9wYXRoLWxheWVyLmpzP2U0NzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgeyBhc3NlbWJsZVNoYWRlcnMgfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHsgR0wsIE1vZGVsLCBHZW9tZXRyeSB9IGZyb20gJ2x1bWEuZ2wnO1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbnZhciBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIG9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoU2NhbGU6IDEsIC8vIHN0cm9rZSB3aWR0aCBpbiBtZXRlcnNcbiAgcm91bmRlZDogZmFsc2UsXG4gIG1pdGVyTGltaXQ6IDQsXG4gIHN0cm9rZVdpZHRoTWluUGl4ZWxzOiAwLCAvLyAgbWluIHN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcbiAgc3Ryb2tlV2lkdGhNYXhQaXhlbHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCAvLyBtYXggc3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuICBnZXRQYXRoOiBmdW5jdGlvbiBnZXRQYXRoKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QucGF0aDtcbiAgfSxcbiAgZ2V0Q29sb3I6IGZ1bmN0aW9uIGdldENvbG9yKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QuY29sb3IgfHwgREVGQVVMVF9DT0xPUjtcbiAgfSxcbiAgZ2V0U3Ryb2tlV2lkdGg6IGZ1bmN0aW9uIGdldFN0cm9rZVdpZHRoKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3Qud2lkdGggfHwgMTtcbiAgfVxufTtcblxudmFyIGlzQ2xvc2VkID0gZnVuY3Rpb24gaXNDbG9zZWQocGF0aCkge1xuICB2YXIgZmlyc3RQb2ludCA9IHBhdGhbMF07XG4gIHZhciBsYXN0UG9pbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIHJldHVybiBmaXJzdFBvaW50WzBdID09PSBsYXN0UG9pbnRbMF0gJiYgZmlyc3RQb2ludFsxXSA9PT0gbGFzdFBvaW50WzFdICYmIGZpcnN0UG9pbnRbMl0gPT09IGxhc3RQb2ludFsyXTtcbn07XG5cbnZhciBQYXRoTGF5ZXIgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhQYXRoTGF5ZXIsIF9MYXllcik7XG5cbiAgZnVuY3Rpb24gUGF0aExheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXRoTGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQYXRoTGF5ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQYXRoTGF5ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYXRoTGF5ZXIsIFt7XG4gICAga2V5OiAnZ2V0U2hhZGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoYWRlcnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2czogJyNkZWZpbmUgU0hBREVSX05BTUUgcGF0aC1sYXllci12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcblxcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlU3RhcnRQb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VFbmRQb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VMZWZ0RGVsdGFzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUmlnaHREZWx0YXM7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlU3Ryb2tlV2lkdGhzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG51bmlmb3JtIGZsb2F0IHN0cm9rZVdpZHRoU2NhbGU7XFxudW5pZm9ybSBmbG9hdCBzdHJva2VXaWR0aE1pblBpeGVscztcXG51bmlmb3JtIGZsb2F0IHN0cm9rZVdpZHRoTWF4UGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgam9pbnRUeXBlO1xcbnVuaWZvcm0gZmxvYXQgbWl0ZXJMaW1pdDtcXG5cXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyB2ZWMyIHZDb3JuZXJPZmZzZXQ7XFxudmFyeWluZyBmbG9hdCB2TWl0ZXJMZW5ndGg7XFxuXFxuY29uc3QgZmxvYXQgRVBTSUxPTiA9IDAuMDAxO1xcblxcbmZsb2F0IGZsaXBJZlRydWUoYm9vbCBmbGFnKSB7XFxuICByZXR1cm4gLShmbG9hdChmbGFnKSAqIDIuIC0gMS4pO1xcbn1cXG5cXG4vLyBjYWxjdWxhdGUgbGluZSBqb2luIHBvc2l0aW9uc1xcbnZlYzMgbGluZUpvaW4odmVjMyBwcmV2UG9pbnQsIHZlYzMgY3VyclBvaW50LCB2ZWMzIG5leHRQb2ludCkge1xcblxcbiAgZmxvYXQgd2lkdGggPSBjbGFtcChwcm9qZWN0X3NjYWxlKGluc3RhbmNlU3Ryb2tlV2lkdGhzICogc3Ryb2tlV2lkdGhTY2FsZSksXFxuICAgIHN0cm9rZVdpZHRoTWluUGl4ZWxzLCBzdHJva2VXaWR0aE1heFBpeGVscykgLyAyLjA7XFxuXFxuICB2ZWMyIGRlbHRhQSA9IGN1cnJQb2ludC54eSAtIHByZXZQb2ludC54eTtcXG4gIHZlYzIgZGVsdGFCID0gbmV4dFBvaW50Lnh5IC0gY3VyclBvaW50Lnh5O1xcblxcbiAgdmVjMiBvZmZzZXRWZWM7XFxuICBmbG9hdCBvZmZzZXRTY2FsZTtcXG4gIGZsb2F0IG9mZnNldERpcmVjdGlvbjtcXG5cXG4gIGZsb2F0IGxlbkEgPSBsZW5ndGgoZGVsdGFBKTtcXG4gIGZsb2F0IGxlbkIgPSBsZW5ndGgoZGVsdGFCKTtcXG4gIHZlYzIgZGlyQSA9IGxlbkEgPiAwLiA/IG5vcm1hbGl6ZShkZWx0YUEpIDogdmVjMigxLjAsIDAuMCk7XFxuICB2ZWMyIGRpckIgPSBsZW5CID4gMC4gPyBub3JtYWxpemUoZGVsdGFCKSA6IHZlYzIoMS4wLCAwLjApO1xcbiAgdmVjMiBwZXJwQSA9IHZlYzIoLWRpckEueSwgZGlyQS54KTtcXG4gIHZlYzIgcGVycEIgPSB2ZWMyKC1kaXJCLnksIGRpckIueCk7XFxuXFxuICAvLyB0YW5nZW50IG9mIHRoZSBjb3JuZXJcXG4gIHZlYzIgdGFuZ2VudCA9IHZlYzIoZGlyQSArIGRpckIpO1xcbiAgdGFuZ2VudCA9IGxlbmd0aCh0YW5nZW50KSA+IDAuID8gbm9ybWFsaXplKHRhbmdlbnQpIDogcGVycEE7XFxuICAvLyBkaXJlY3Rpb24gb2YgdGhlIGNvcm5lclxcbiAgdmVjMiBtaXRlclZlYyA9IHZlYzIoLXRhbmdlbnQueSwgdGFuZ2VudC54KTtcXG4gIC8vIHdpZHRoIG9mZnNldCBmcm9tIGN1cnJlbnQgcG9zaXRpb25cXG4gIHZlYzIgcGVycCA9IG1peChwZXJwQiwgcGVycEEsIHBvc2l0aW9ucy54KTtcXG4gIGZsb2F0IEwgPSBtaXgobGVuQiwgbGVuQSwgcG9zaXRpb25zLngpO1xcblxcbiAgLy8gY2FwIHN1cGVyIHNoYXJwIGFuZ2xlc1xcbiAgZmxvYXQgc2luSGFsZkEgPSBhYnMoZG90KG1pdGVyVmVjLCBwZXJwKSk7XFxuICBmbG9hdCBjb3NIYWxmQSA9IGFicyhkb3QoZGlyQSwgbWl0ZXJWZWMpKTtcXG4gIGJvb2wgdHVybnNSaWdodCA9IGRpckEueCAqIGRpckIueSA+IGRpckEueSAqIGRpckIueDtcXG5cXG4gIC8vIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBjb3JuZXI6XFxuICAvLyAtMTogaW5zaWRlIChzbWFsbGVyIHNpZGUgb2YgdGhlIGFuZ2xlKVxcbiAgLy8gMDogY2VudGVyXFxuICAvLyAxOiBvdXRzaWRlIChiaWdnZXIgc2lkZSBvZiB0aGUgYW5nbGUpXFxuICBmbG9hdCBjb3JuZXJQb3NpdGlvbiA9IG1peChcXG4gICAgZmxpcElmVHJ1ZSh0dXJuc1JpZ2h0ID09IChwb3NpdGlvbnMueSA+IDAuMCkpLFxcbiAgICAwLjAsXFxuICAgIHBvc2l0aW9ucy56XFxuICApO1xcblxcbiAgb2Zmc2V0U2NhbGUgPSAxLjAgLyBtYXgoc2luSGFsZkEsIEVQU0lMT04pO1xcblxcbiAgLy8gZG8gbm90IGJldmVsIGlmIGxpbmUgc2VnbWVudCBpcyB0b28gc2hvcnRcXG4gIGNvcm5lclBvc2l0aW9uICo9IGZsb2F0KGNvcm5lclBvc2l0aW9uIDw9IDAuMCB8fCBzaW5IYWxmQSA8IG1pbihsZW5BLCBsZW5CKSAvIHdpZHRoICogY29zSGFsZkEpO1xcbiAgLy8gdHJpbSBpZiBpbnNpZGUgY29ybmVyIGV4dGVuZHMgZnVydGhlciB0aGFuIHRoZSBsaW5lIHNlZ21lbnRcXG4gIG9mZnNldFNjYWxlID0gbWl4KFxcbiAgICBvZmZzZXRTY2FsZSxcXG4gICAgbWluKG9mZnNldFNjYWxlLCBMIC8gd2lkdGggLyBtYXgoY29zSGFsZkEsIEVQU0lMT04pKSxcXG4gICAgZmxvYXQoY29ybmVyUG9zaXRpb24gPCAwLjApXFxuICApO1xcblxcbiAgdk1pdGVyTGVuZ3RoID0gbWl4KFxcbiAgICBvZmZzZXRTY2FsZSAqIGNvcm5lclBvc2l0aW9uLFxcbiAgICBtaXgob2Zmc2V0U2NhbGUsIDAuMCwgY29ybmVyUG9zaXRpb24pLFxcbiAgICBzdGVwKDAuMCwgY29ybmVyUG9zaXRpb24pXFxuICApIC0gc2luSGFsZkEgKiBqb2ludFR5cGU7XFxuICBvZmZzZXREaXJlY3Rpb24gPSBtaXgoXFxuICAgIHBvc2l0aW9ucy55LFxcbiAgICBtaXgoXFxuICAgICAgZmxpcElmVHJ1ZSh0dXJuc1JpZ2h0KSwgXFxuICAgICAgcG9zaXRpb25zLnkgKiBmbGlwSWZUcnVlKHR1cm5zUmlnaHQgPT0gKHBvc2l0aW9ucy54ID09IDEuKSksIFxcbiAgICAgIGNvcm5lclBvc2l0aW9uXFxuICAgICksXFxuICAgIHN0ZXAoMC4wLCBjb3JuZXJQb3NpdGlvbilcXG4gICk7XFxuICBvZmZzZXRWZWMgPSBtaXgobWl0ZXJWZWMsIC10YW5nZW50LCBzdGVwKDAuNSwgY29ybmVyUG9zaXRpb24pKTtcXG4gIG9mZnNldFNjYWxlID0gbWl4KG9mZnNldFNjYWxlLCAxLjAgLyBtYXgoY29zSGFsZkEsIDAuMDAxKSwgc3RlcCgwLjUsIGNvcm5lclBvc2l0aW9uKSk7XFxuXFxuICAvLyBzcGVjaWFsIHRyZWF0bWVudCBmb3Igc3RhcnQgY2FwIGFuZCBlbmQgY2FwXFxuICBmbG9hdCBpc1N0YXJ0Q2FwID0gc3RlcCgwLjAsIC1sZW5BKTtcXG4gIGZsb2F0IGlzRW5kQ2FwID0gc3RlcCgwLjAsIC1sZW5CKTtcXG4gIGZsb2F0IGlzQ2FwID0gbWF4KGlzU3RhcnRDYXAsIGlzRW5kQ2FwKTtcXG5cXG4gIC8vIDA6IGNlbnRlciwgMTogc2lkZVxcbiAgY29ybmVyUG9zaXRpb24gPSBpc0NhcCAqICgxLjAgLSBwb3NpdGlvbnMueik7XFxuXFxuICAvLyBzdGFydCBvZiBwYXRoOiB1c2UgbmV4dCAtIGN1cnJcXG4gIG9mZnNldFZlYyA9IG1peChvZmZzZXRWZWMsIG1peChkaXJCLCBwZXJwQiwgY29ybmVyUG9zaXRpb24pLCBpc1N0YXJ0Q2FwKTtcXG4gIC8vIGVuZCBvZiBwYXRoOiB1c2UgY3VyciAtIHByZXZcXG4gIG9mZnNldFZlYyA9IG1peChvZmZzZXRWZWMsIG1peChkaXJBLCBwZXJwQSwgY29ybmVyUG9zaXRpb24pLCBpc0VuZENhcCk7XFxuXFxuICAvLyBleHRlbmQgb3V0IGEgdHJpYW5nbGUgdG8gZW52ZWxvcGUgdGhlIHJvdW5kIGNhcFxcbiAgb2Zmc2V0U2NhbGUgPSBtaXgoXFxuICAgIG9mZnNldFNjYWxlLFxcbiAgICBtaXgoNC4wICogam9pbnRUeXBlLCAxLjAsIGNvcm5lclBvc2l0aW9uKSxcXG4gICAgaXNDYXBcXG4gICk7XFxuICB2TWl0ZXJMZW5ndGggPSBtaXgodk1pdGVyTGVuZ3RoLCAxLjAgLSBjb3JuZXJQb3NpdGlvbiwgaXNDYXApO1xcblxcbiAgb2Zmc2V0RGlyZWN0aW9uID0gbWl4KFxcbiAgICBvZmZzZXREaXJlY3Rpb24sXFxuICAgIG1peChmbGlwSWZUcnVlKGlzU3RhcnRDYXAgPiAwLiksIHBvc2l0aW9ucy55LCBjb3JuZXJQb3NpdGlvbiksXFxuICAgIGlzQ2FwXFxuICApO1xcblxcbiAgdkNvcm5lck9mZnNldCA9IG9mZnNldFZlYyAqIG9mZnNldERpcmVjdGlvbiAqIG9mZnNldFNjYWxlO1xcblxcbiAgcmV0dXJuIGN1cnJQb2ludCArIHZlYzModkNvcm5lck9mZnNldCAqIHdpZHRoLCAwLjApO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IGNvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XFxuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzLCAyNTUuKSAvIDI1NS47XFxuICB2Q29sb3IgPSBtaXgoY29sb3IsIHBpY2tpbmdDb2xvciwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XFxuXFxuICBmbG9hdCBpc0VuZCA9IHBvc2l0aW9ucy54O1xcblxcbiAgdmVjMyBwcmV2UG9zaXRpb24gPSBtaXgoLWluc3RhbmNlTGVmdERlbHRhcywgdmVjMygwLjApLCBpc0VuZCkgKyBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zO1xcbiAgcHJldlBvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbihwcmV2UG9zaXRpb24pO1xcblxcbiAgdmVjMyBjdXJyUG9zaXRpb24gPSBtaXgoaW5zdGFuY2VTdGFydFBvc2l0aW9ucywgaW5zdGFuY2VFbmRQb3NpdGlvbnMsIGlzRW5kKTtcXG4gIGN1cnJQb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb24oY3VyclBvc2l0aW9uKTtcXG5cXG4gIHZlYzMgbmV4dFBvc2l0aW9uID0gbWl4KHZlYzMoMC4wKSwgaW5zdGFuY2VSaWdodERlbHRhcywgaXNFbmQpICsgaW5zdGFuY2VFbmRQb3NpdGlvbnM7XFxuICBuZXh0UG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uKG5leHRQb3NpdGlvbik7XFxuXFxuICB2ZWMzIHBvcztcXG5cXG4gIHBvcyA9IGxpbmVKb2luKHByZXZQb3NpdGlvbiwgY3VyclBvc2l0aW9uLCBuZXh0UG9zaXRpb24pO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0KHBvcywgMS4wKSk7XFxufVxcbicsXG4gICAgICAgIGZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIHBhdGgtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxuI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gZmxvYXQgam9pbnRUeXBlO1xcbnVuaWZvcm0gZmxvYXQgbWl0ZXJMaW1pdDtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2Q29ybmVyT2Zmc2V0O1xcbnZhcnlpbmcgZmxvYXQgdk1pdGVyTGVuZ3RoO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBpZiBqb2ludCBpcyByb3VuZGVkLCB0ZXN0IGRpc3RhbmNlIGZyb20gdGhlIGNvcm5lclxcbiAgaWYgKGpvaW50VHlwZSA+IDAuMCAmJiB2TWl0ZXJMZW5ndGggPiAwLjAgJiYgbGVuZ3RoKHZDb3JuZXJPZmZzZXQpID4gMS4wKSB7XFxuICAgIGRpc2NhcmQ7XFxuICB9XFxuICBpZiAoam9pbnRUeXBlID09IDAuMCAmJiB2TWl0ZXJMZW5ndGggPiBtaXRlckxpbWl0KSB7XFxuICAgIGRpc2NhcmQ7XFxuICB9XFxuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XFxufVxcbidcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5pdGlhbGl6ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgbW9kZWw6IHRoaXMuZ2V0TW9kZWwoZ2wpIH0pO1xuXG4gICAgICB2YXIgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlcjtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zOiB7IHNpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVTdGFydFBvc2l0aW9ucyB9LFxuICAgICAgICBpbnN0YW5jZUVuZFBvc2l0aW9uczogeyBzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlRW5kUG9zaXRpb25zIH0sXG4gICAgICAgIGluc3RhbmNlTGVmdERlbHRhczogeyBzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlTGVmdERlbHRhcyB9LFxuICAgICAgICBpbnN0YW5jZVJpZ2h0RGVsdGFzOiB7IHNpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVSaWdodERlbHRhcyB9LFxuICAgICAgICBpbnN0YW5jZVN0cm9rZVdpZHRoczogeyBzaXplOiAxLCBhY2Nlc3NvcjogJ2dldFN0cm9rZVdpZHRoJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVN0cm9rZVdpZHRocyB9LFxuICAgICAgICBpbnN0YW5jZUNvbG9yczogeyBzaXplOiA0LCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldENvbG9yJywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9ycyB9LFxuICAgICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHsgc2l6ZTogMywgdHlwZTogR0wuVU5TSUdORURfQllURSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMgfVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKF9yZWYpIHtcbiAgICAgIHZhciBvbGRQcm9wcyA9IF9yZWYub2xkUHJvcHMsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICAgIGNoYW5nZUZsYWdzID0gX3JlZi5jaGFuZ2VGbGFncztcbiAgICAgIHZhciBnZXRQYXRoID0gdGhpcy5wcm9wcy5nZXRQYXRoO1xuICAgICAgdmFyIGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXI7XG5cblxuICAgICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIC8vIHRoaXMuc3RhdGUucGF0aHMgb25seSBzdG9yZXMgcG9pbnQgcG9zaXRpb25zIGluIGVhY2ggcGF0aFxuICAgICAgICB2YXIgcGF0aHMgPSBwcm9wcy5kYXRhLm1hcChnZXRQYXRoKTtcbiAgICAgICAgdmFyIG51bUluc3RhbmNlcyA9IHBhdGhzLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gY291bnQgKyBwYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBwYXRoczogcGF0aHMsIG51bUluc3RhbmNlczogbnVtSW5zdGFuY2VzIH0pO1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmMikge1xuICAgICAgdmFyIHVuaWZvcm1zID0gX3JlZjIudW5pZm9ybXM7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICByb3VuZGVkID0gX3Byb3BzLnJvdW5kZWQsXG4gICAgICAgICAgbWl0ZXJMaW1pdCA9IF9wcm9wcy5taXRlckxpbWl0LFxuICAgICAgICAgIHN0cm9rZVdpZHRoU2NhbGUgPSBfcHJvcHMuc3Ryb2tlV2lkdGhTY2FsZSxcbiAgICAgICAgICBzdHJva2VXaWR0aE1pblBpeGVscyA9IF9wcm9wcy5zdHJva2VXaWR0aE1pblBpeGVscyxcbiAgICAgICAgICBzdHJva2VXaWR0aE1heFBpeGVscyA9IF9wcm9wcy5zdHJva2VXaWR0aE1heFBpeGVscztcblxuXG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgICBqb2ludFR5cGU6IE51bWJlcihyb3VuZGVkKSxcbiAgICAgICAgc3Ryb2tlV2lkdGhTY2FsZTogc3Ryb2tlV2lkdGhTY2FsZSxcbiAgICAgICAgbWl0ZXJMaW1pdDogbWl0ZXJMaW1pdCxcbiAgICAgICAgc3Ryb2tlV2lkdGhNaW5QaXhlbHM6IHN0cm9rZVdpZHRoTWluUGl4ZWxzLFxuICAgICAgICBzdHJva2VXaWR0aE1heFBpeGVsczogc3Ryb2tlV2lkdGhNYXhQaXhlbHNcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vZGVsKGdsKSB7XG4gICAgICB2YXIgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuXG4gICAgICAvKlxuICAgICAgICogICAgICAgX1xuICAgICAgICogICAgICAgIFwiLV8gMSAgICAgICAgICAgICAgICAgICAzICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgKiAgICAgXyAgICAgXCJvLS0tLS0tLS0tLS0tLS0tLS0tLS0tby0tLS0tLS0tLS0tLS0tLS0tLS1fLW9cbiAgICAgICAqICAgICAgIC0gICAvIFwiXCItLS4uX18gICAgICAgICAgICAgICcuICAgICAgICAgICAgIF8uLScgL1xuICAgICAgICogICBfICAgICBcIkAtIC0gLSAtIC0gXCJcIi0tLi5fXy0gLSAtIC0geCAtIC0gLSAtXy5AJyAgICAvXG4gICAgICAgKiAgICBcIi1fICAvICAgICAgICAgICAgICAgICAgIFwiXCItLS4uX18gJy4gIF8sLWAgOiAgICAgL1xuICAgICAgICogICAgICAgXCJvLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiXCItbycgICAgOiAgICAgL1xuICAgICAgICogICAgICAwLDIgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCAvICcuICA6ICAgICAvXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICcuOiAgICAgL1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgOicuICAgL1xuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgICA6ICAnLCAvXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgOiAgICAgb1xuICAgICAgICovXG5cbiAgICAgIHZhciBTRUdNRU5UX0lORElDRVMgPSBbXG4gICAgICAvLyBzdGFydCBjb3JuZXJcbiAgICAgIDAsIDIsIDEsXG4gICAgICAvLyBib2R5XG4gICAgICAxLCAyLCA0LCAxLCA0LCAzLFxuICAgICAgLy8gZW5kIGNvcm5lclxuICAgICAgMywgNCwgNV07XG5cbiAgICAgIC8vIFswXSBwb3NpdGlvbiBvbiBzZWdtZW50IC0gMDogc3RhcnQsIDE6IGVuZFxuICAgICAgLy8gWzFdIHNpZGUgb2YgcGF0aCAtIC0xOiBsZWZ0LCAwOiBjZW50ZXIsIDE6IHJpZ2h0XG4gICAgICAvLyBbMl0gcm9sZSAtIDA6IG9mZnNldCBwb2ludCAxOiBqb2ludCBwb2ludFxuICAgICAgdmFyIFNFR01FTlRfUE9TSVRJT05TID0gW1xuICAgICAgLy8gYmV2ZWwgc3RhcnQgY29ybmVyXG4gICAgICAwLCAwLCAxLFxuICAgICAgLy8gc3RhcnQgaW5uZXIgY29ybmVyXG4gICAgICAwLCAtMSwgMCxcbiAgICAgIC8vIHN0YXJ0IG91dGVyIGNvcm5lclxuICAgICAgMCwgMSwgMCxcbiAgICAgIC8vIGVuZCBpbm5lciBjb3JuZXJcbiAgICAgIDEsIC0xLCAwLFxuICAgICAgLy8gZW5kIG91dGVyIGNvcm5lclxuICAgICAgMSwgMSwgMCxcbiAgICAgIC8vIGJldmVsIGVuZCBjb3JuZXJcbiAgICAgIDEsIDAsIDFdO1xuXG4gICAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgICAgZ2w6IGdsLFxuICAgICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVTLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGluZGljZXM6IG5ldyBVaW50MTZBcnJheShTRUdNRU5UX0lORElDRVMpLFxuICAgICAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KFNFR01FTlRfUE9TSVRJT05TKVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVTdGFydFBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVN0YXJ0UG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHBhdGhzID0gdGhpcy5zdGF0ZS5wYXRocztcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblxuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgcHRJbmRleCA9IDA7IHB0SW5kZXggPCBudW1TZWdtZW50czsgcHRJbmRleCsrKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gcGF0aFtwdEluZGV4XTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRbMF07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50WzFdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBwb2ludFsyXSB8fCAwO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVFbmRQb3NpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVFbmRQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgcGF0aHMgPSB0aGlzLnN0YXRlLnBhdGhzO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgZm9yICh2YXIgcHRJbmRleCA9IDE7IHB0SW5kZXggPCBwYXRoLmxlbmd0aDsgcHRJbmRleCsrKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gcGF0aFtwdEluZGV4XTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRbMF07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50WzFdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBwb2ludFsyXSB8fCAwO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVMZWZ0RGVsdGFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlTGVmdERlbHRhcyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBwYXRocyA9IHRoaXMuc3RhdGUucGF0aHM7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBwcmV2UG9pbnQgPSBpc0Nsb3NlZChwYXRoKSA/IHBhdGhbcGF0aC5sZW5ndGggLSAyXSA6IHBhdGhbMF07XG5cbiAgICAgICAgZm9yICh2YXIgcHRJbmRleCA9IDA7IHB0SW5kZXggPCBudW1TZWdtZW50czsgcHRJbmRleCsrKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gcGF0aFtwdEluZGV4XTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcG9pbnRbMF0gLSBwcmV2UG9pbnRbMF07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50WzFdIC0gcHJldlBvaW50WzFdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBwb2ludFsyXSAtIHByZXZQb2ludFsyXSB8fCAwO1xuICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVSaWdodERlbHRhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVJpZ2h0RGVsdGFzKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHBhdGhzID0gdGhpcy5zdGF0ZS5wYXRocztcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblxuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGZvciAodmFyIHB0SW5kZXggPSAxOyBwdEluZGV4IDwgcGF0aC5sZW5ndGg7IHB0SW5kZXgrKykge1xuICAgICAgICAgIHZhciBwb2ludCA9IHBhdGhbcHRJbmRleF07XG4gICAgICAgICAgdmFyIG5leHRQb2ludCA9IHBhdGhbcHRJbmRleCArIDFdO1xuICAgICAgICAgIGlmICghbmV4dFBvaW50KSB7XG4gICAgICAgICAgICBuZXh0UG9pbnQgPSBpc0Nsb3NlZChwYXRoKSA/IHBhdGhbMV0gOiBwb2ludDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZVtpKytdID0gbmV4dFBvaW50WzBdIC0gcG9pbnRbMF07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IG5leHRQb2ludFsxXSAtIHBvaW50WzFdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBuZXh0UG9pbnRbMl0gLSBwb2ludFsyXSB8fCAwO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVTdHJva2VXaWR0aHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVTdHJva2VXaWR0aHMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wczIuZGF0YSxcbiAgICAgICAgICBnZXRTdHJva2VXaWR0aCA9IF9wcm9wczIuZ2V0U3Ryb2tlV2lkdGg7XG4gICAgICB2YXIgcGF0aHMgPSB0aGlzLnN0YXRlLnBhdGhzO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgsIGluZGV4KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGdldFN0cm9rZVdpZHRoKGRhdGFbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgIGZvciAodmFyIHB0SW5kZXggPSAxOyBwdEluZGV4IDwgcGF0aC5sZW5ndGg7IHB0SW5kZXgrKykge1xuICAgICAgICAgIHZhbHVlW2krK10gPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlQ29sb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHMzLmRhdGEsXG4gICAgICAgICAgZ2V0Q29sb3IgPSBfcHJvcHMzLmdldENvbG9yO1xuICAgICAgdmFyIHBhdGhzID0gdGhpcy5zdGF0ZS5wYXRocztcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblxuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoLCBpbmRleCkge1xuICAgICAgICB2YXIgcG9pbnRDb2xvciA9IGdldENvbG9yKGRhdGFbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgIGlmIChpc05hTihwb2ludENvbG9yWzNdKSkge1xuICAgICAgICAgIHBvaW50Q29sb3JbM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgcHRJbmRleCA9IDE7IHB0SW5kZXggPCBwYXRoLmxlbmd0aDsgcHRJbmRleCsrKSB7XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50Q29sb3JbMF07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50Q29sb3JbMV07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50Q29sb3JbMl07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBvaW50Q29sb3JbM107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHBpY2tpbmcgY29sb3JzIGNhbGN1bGF0aW9uXG5cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZVBpY2tpbmdDb2xvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBwYXRocyA9IHRoaXMuc3RhdGUucGF0aHM7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHBpY2tpbmdDb2xvciA9IF90aGlzMi5lbmNvZGVQaWNraW5nQ29sb3IoaW5kZXgpO1xuICAgICAgICBmb3IgKHZhciBwdEluZGV4ID0gMTsgcHRJbmRleCA8IHBhdGgubGVuZ3RoOyBwdEluZGV4KyspIHtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcGlja2luZ0NvbG9yWzBdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBwaWNraW5nQ29sb3JbMV07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBpY2tpbmdDb2xvclsyXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhdGhMYXllcjtcbn0oTGF5ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBQYXRoTGF5ZXI7XG5cblxuUGF0aExheWVyLmxheWVyTmFtZSA9ICdQYXRoTGF5ZXInO1xuUGF0aExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9wYXRoLWxheWVyL3BhdGgtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 23 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************!*\
  !*** ./src/layers/core/polygon-layer/polygon-layer.js ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_path__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polygon_tesselator__ = __webpack_require__(/*! ./polygon-tesselator */ 55);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polygon_tesselator_extruded__ = __webpack_require__(/*! ./polygon-tesselator-extruded */ 54);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n// Polygon geometry generation is managed by the polygon tesselator\n\n\n\n// const defaultColor = [0, 0, 0, 255];\n\nvar defaultProps = {\n  // Whether to extrude in 2.5D\n  extruded: false,\n  // Whether to draw a GL.LINES wireframe of the polygon\n  // TODO - not clear that this should be part of the main layer\n  wireframe: false,\n  // Accessor for polygon geometry\n  getPolygon: function getPolygon(f) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"h\" /* get */])(f, 'polygon') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"h\" /* get */])(f, 'geometry.coordinates');\n  },\n  // Accessor for extrusion height\n  getElevation: function getElevation(f) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"h\" /* get */])(f, 'elevation') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"h\" /* get */])(f, 'properties.height') || 0;\n  },\n  // Accessor for color\n  getColor: function getColor(f) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"h\" /* get */])(f, 'color') || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"h\" /* get */])(f, 'properties.color');\n  },\n  // Optional settings for 'lighting' shader module\n  lightSettings: {\n    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],\n    ambientRatio: 0.05,\n    diffuseRatio: 0.6,\n    specularRatio: 0.8,\n    lightsStrength: [2.0, 0.0, 0.0, 0.0],\n    numberOfLights: 2\n  },\n  fp64: false\n};\n\nvar PolygonLayer = function (_Layer) {\n  _inherits(PolygonLayer, _Layer);\n\n  function PolygonLayer() {\n    _classCallCheck(this, PolygonLayer);\n\n    return _possibleConstructorReturn(this, (PolygonLayer.__proto__ || Object.getPrototypeOf(PolygonLayer)).apply(this, arguments));\n  }\n\n  _createClass(PolygonLayer, [{\n    key: 'getShaders',\n    value: function getShaders() {\n\n      var shaders = this.props.fp64 ? {\n        vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n#define SHADER_NAME polygon-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec2 positions64xyLow;\\nattribute vec3 normals;\\nattribute vec4 colors;\\nattribute vec3 pickingColors;\\n\\nuniform float extruded;\\nuniform float opacity;\\n\\nuniform float renderPickingBuffer;\\nuniform vec3 selectedPickingColor;\\n\\n// PICKING\\nuniform float pickingEnabled;\\nvarying vec4 vPickingColor;\\n\\nvoid main(void) {\\n  vec4 positions64xy = vec4(positions.x, positions64xyLow.x, positions.y, positions64xyLow.y);\\n\\n  vec2 projected_coord_xy[2];\\n  project_position_fp64(positions64xy, projected_coord_xy);\\n\\n  vec2 vertex_pos_modelspace[4];\\n  vertex_pos_modelspace[0] = projected_coord_xy[0];\\n  vertex_pos_modelspace[1] = projected_coord_xy[1];\\n  vertex_pos_modelspace[2] = vec2(project_scale(positions.z), 0.0);\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\\n\\n  vec4 position_worldspace = vec4(vertex_pos_modelspace[0].x, vertex_pos_modelspace[1].x, vertex_pos_modelspace[2].x, vertex_pos_modelspace[3].x);\\n\\n  if (pickingEnabled < 0.5) {\\n    float lightWeight = 1.0;\\n\\n    if (extruded > 0.5) {\\n      lightWeight = getLightWeight(\\n        position_worldspace,\\n        normals\\n      );\\n    }\\n\\n    vec3 lightWeightedColor = lightWeight * colors.rgb;\\n    vec4 color = vec4(lightWeightedColor, colors.a * opacity) / 255.0;\\n\\n    vPickingColor = color;\\n\\n  } else {\\n    vPickingColor = vec4(pickingColors.rgb / 255.0, 1.0);\\n  }\\n}\\n',\n        fs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n#define SHADER_NAME polygon-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\n// PICKING\\n// uniform bool pickingEnabled;\\nvarying vec4 vPickingColor;\\nvec4 picking_getColor() {\\n  return vPickingColor;\\n}\\n// PICKING\\n\\nvoid main(void) {\\n  gl_FragColor = picking_getColor();\\n}\\n',\n        modules: ['lighting', 'fp64', 'project64'] } : {\n        vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n#define SHADER_NAME polygon-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec3 normals;\\nattribute vec4 colors;\\nattribute vec3 pickingColors;\\n\\nuniform float extruded;\\nuniform float opacity;\\n\\nuniform float renderPickingBuffer;\\nuniform vec3 selectedPickingColor;\\n\\n// PICKING\\nuniform float pickingEnabled;\\nvarying vec4 vPickingColor;\\n\\nvoid main(void) {\\n  vec4 position_worldspace = vec4(project_position(positions), 1.0);\\n  gl_Position = project_to_clipspace(position_worldspace);\\n\\n  if (pickingEnabled < 0.5) {\\n    float lightWeight = 1.0;\\n\\n    if (extruded > 0.5) {\\n      lightWeight = getLightWeight(\\n        position_worldspace,\\n        normals\\n      );\\n    }\\n\\n    vec3 lightWeightedColor = lightWeight * colors.rgb;\\n    vec4 color = vec4(lightWeightedColor, colors.a * opacity) / 255.0;\\n\\n    vPickingColor = color;\\n\\n  } else {\\n    vPickingColor = vec4(pickingColors.rgb / 255.0, 1.0);\\n  }\\n}\\n',\n        fs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n#define SHADER_NAME polygon-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\n// PICKING\\n// uniform bool pickingEnabled;\\nvarying vec4 vPickingColor;\\nvec4 picking_getColor() {\\n  return vPickingColor;\\n}\\n// PICKING\\n\\nvoid main(void) {\\n  gl_FragColor = picking_getColor();\\n}\\n',\n        modules: ['lighting'] };\n      return shaders;\n    }\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      var gl = this.context.gl;\n\n      this.setState({\n        model: this.getModel(gl),\n        numInstances: 0,\n        IndexType: gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array\n      });\n\n      var attributeManager = this.state.attributeManager;\n\n      var noAlloc = true;\n      /* eslint-disable max-len */\n      attributeManager.add({\n        indices: { size: 1, isIndexed: true, update: this.calculateIndices, noAlloc: noAlloc },\n        positions: { size: 3, accessor: 'getHeight', update: this.calculatePositions, noAlloc: noAlloc },\n        normals: { size: 3, update: this.calculateNormals, noAlloc: noAlloc },\n        colors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateColors, noAlloc: noAlloc },\n        pickingColors: { size: 3, type: __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].UNSIGNED_BYTE, update: this.calculatePickingColors, noAlloc: noAlloc }\n      });\n      /* eslint-enable max-len */\n\n      if (this.props.fp64) {\n        attributeManager.add({\n          positions64xyLow: { size: 2, update: this.calculatePositionsLow }\n        });\n      }\n    }\n  }, {\n    key: 'updateModel',\n    value: function updateModel(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      if (props.fp64 !== oldProps.fp64) {\n        var gl = this.context.gl;\n\n        this.setState({ model: this.getModel(gl) });\n      }\n    }\n  }, {\n    key: 'updateAttribute',\n    value: function updateAttribute(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (props.fp64 !== oldProps.fp64) {\n        var attributeManager = this.state.attributeManager;\n\n        attributeManager.invalidateAll();\n\n        if (props.fp64 === true) {\n          attributeManager.add({\n            positions64xyLow: { size: 2, update: this.calculatePositionsLow }\n          });\n        } else {\n          attributeManager.remove(['positions64xyLow']);\n        }\n      }\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref3) {\n      var props = _ref3.props,\n          oldProps = _ref3.oldProps,\n          changeFlags = _ref3.changeFlags;\n\n      this.updateGeometry({ props: props, oldProps: oldProps, changeFlags: changeFlags });\n      this.updateModel({ props: props, oldProps: oldProps, changeFlags: changeFlags });\n      this.updateAttribute({ props: props, oldProps: oldProps, changeFlags: changeFlags });\n\n      var opacity = props.opacity,\n          extruded = props.extruded,\n          lightSettings = props.lightSettings;\n\n\n      this.setUniforms(Object.assign({}, {\n        extruded: extruded ? 1.0 : 0.0,\n        opacity: opacity\n      }, lightSettings));\n    }\n  }, {\n    key: 'updateGeometry',\n    value: function updateGeometry(_ref4) {\n      var _this2 = this;\n\n      var props = _ref4.props,\n          oldProps = _ref4.oldProps,\n          changeFlags = _ref4.changeFlags;\n\n      var geometryChanged = props.extruded !== oldProps.extruded || props.wireframe !== oldProps.wireframe || props.fp64 !== oldProps.fp64;\n\n      if (changeFlags.dataChanged || geometryChanged) {\n        (function () {\n          var getPolygon = props.getPolygon,\n              extruded = props.extruded,\n              wireframe = props.wireframe,\n              _getHeight = props.getHeight;\n\n          // TODO - avoid creating a temporary array here: let the tesselator iterate\n\n          var polygons = props.data.map(getPolygon);\n\n          _this2.setState({\n            polygonTesselator: !extruded ? new __WEBPACK_IMPORTED_MODULE_5__polygon_tesselator__[\"a\" /* PolygonTesselator */]({ polygons: polygons, fp64: _this2.props.fp64 }) : new __WEBPACK_IMPORTED_MODULE_6__polygon_tesselator_extruded__[\"a\" /* PolygonTesselatorExtruded */]({ polygons: polygons, wireframe: wireframe,\n              getHeight: function getHeight(polygonIndex) {\n                return _getHeight(_this2.props.data[polygonIndex]);\n              },\n              fp64: _this2.props.fp64\n            })\n          });\n\n          _this2.state.attributeManager.invalidateAll();\n        })();\n      }\n    }\n  }, {\n    key: 'getModel',\n    value: function getModel(gl) {\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n      return new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Geometry\"]({\n          drawMode: this.props.wireframe ? __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LINES : __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].TRIANGLES\n        }),\n        vertexCount: 0,\n        isIndexed: true\n      });\n    }\n  }, {\n    key: 'calculateIndices',\n    value: function calculateIndices(attribute) {\n      attribute.value = this.state.polygonTesselator.indices();\n      attribute.target = __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].ELEMENT_ARRAY_BUFFER;\n      this.state.model.setVertexCount(attribute.value.length / attribute.size);\n    }\n  }, {\n    key: 'calculatePositions',\n    value: function calculatePositions(attribute) {\n      attribute.value = this.state.polygonTesselator.positions().positions;\n    }\n  }, {\n    key: 'calculatePositionsLow',\n    value: function calculatePositionsLow(attribute) {\n      attribute.value = this.state.polygonTesselator.positions().positions64xyLow;\n    }\n  }, {\n    key: 'calculateNormals',\n    value: function calculateNormals(attribute) {\n      attribute.value = this.state.polygonTesselator.normals();\n    }\n  }, {\n    key: 'calculateColors',\n    value: function calculateColors(attribute) {\n      var _this3 = this;\n\n      attribute.value = this.state.polygonTesselator.colors({\n        getColor: function getColor(polygonIndex) {\n          return _this3.props.getColor(_this3.props.data[polygonIndex]);\n        }\n      });\n    }\n\n    // Override the default picking colors calculation\n\n  }, {\n    key: 'calculatePickingColors',\n    value: function calculatePickingColors(attribute) {\n      attribute.value = this.state.polygonTesselator.pickingColors();\n    }\n  }]);\n\n  return PolygonLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = PolygonLayer;\n\n\nPolygonLayer.layerName = 'PolygonLayer';\nPolygonLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9seWdvbi1sYXllci9wb2x5Z29uLWxheWVyLmpzPzRkYzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgeyBhc3NlbWJsZVNoYWRlcnMgfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCB7IEdMLCBNb2RlbCwgR2VvbWV0cnkgfSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG4vLyBQb2x5Z29uIGdlb21ldHJ5IGdlbmVyYXRpb24gaXMgbWFuYWdlZCBieSB0aGUgcG9seWdvbiB0ZXNzZWxhdG9yXG5pbXBvcnQgeyBQb2x5Z29uVGVzc2VsYXRvciB9IGZyb20gJy4vcG9seWdvbi10ZXNzZWxhdG9yJztcbmltcG9ydCB7IFBvbHlnb25UZXNzZWxhdG9yRXh0cnVkZWQgfSBmcm9tICcuL3BvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZCc7XG5cbi8vIGNvbnN0IGRlZmF1bHRDb2xvciA9IFswLCAwLCAwLCAyNTVdO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICAvLyBXaGV0aGVyIHRvIGV4dHJ1ZGUgaW4gMi41RFxuICBleHRydWRlZDogZmFsc2UsXG4gIC8vIFdoZXRoZXIgdG8gZHJhdyBhIEdMLkxJTkVTIHdpcmVmcmFtZSBvZiB0aGUgcG9seWdvblxuICAvLyBUT0RPIC0gbm90IGNsZWFyIHRoYXQgdGhpcyBzaG91bGQgYmUgcGFydCBvZiB0aGUgbWFpbiBsYXllclxuICB3aXJlZnJhbWU6IGZhbHNlLFxuICAvLyBBY2Nlc3NvciBmb3IgcG9seWdvbiBnZW9tZXRyeVxuICBnZXRQb2x5Z29uOiBmdW5jdGlvbiBnZXRQb2x5Z29uKGYpIHtcbiAgICByZXR1cm4gZ2V0KGYsICdwb2x5Z29uJykgfHwgZ2V0KGYsICdnZW9tZXRyeS5jb29yZGluYXRlcycpO1xuICB9LFxuICAvLyBBY2Nlc3NvciBmb3IgZXh0cnVzaW9uIGhlaWdodFxuICBnZXRFbGV2YXRpb246IGZ1bmN0aW9uIGdldEVsZXZhdGlvbihmKSB7XG4gICAgcmV0dXJuIGdldChmLCAnZWxldmF0aW9uJykgfHwgZ2V0KGYsICdwcm9wZXJ0aWVzLmhlaWdodCcpIHx8IDA7XG4gIH0sXG4gIC8vIEFjY2Vzc29yIGZvciBjb2xvclxuICBnZXRDb2xvcjogZnVuY3Rpb24gZ2V0Q29sb3IoZikge1xuICAgIHJldHVybiBnZXQoZiwgJ2NvbG9yJykgfHwgZ2V0KGYsICdwcm9wZXJ0aWVzLmNvbG9yJyk7XG4gIH0sXG4gIC8vIE9wdGlvbmFsIHNldHRpbmdzIGZvciAnbGlnaHRpbmcnIHNoYWRlciBtb2R1bGVcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMDAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4wNSxcbiAgICBkaWZmdXNlUmF0aW86IDAuNixcbiAgICBzcGVjdWxhclJhdGlvOiAwLjgsXG4gICAgbGlnaHRzU3RyZW5ndGg6IFsyLjAsIDAuMCwgMC4wLCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAyXG4gIH0sXG4gIGZwNjQ6IGZhbHNlXG59O1xuXG52YXIgUG9seWdvbkxheWVyID0gZnVuY3Rpb24gKF9MYXllcikge1xuICBfaW5oZXJpdHMoUG9seWdvbkxheWVyLCBfTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIFBvbHlnb25MYXllcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9seWdvbkxheWVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUG9seWdvbkxheWVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUG9seWdvbkxheWVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9seWdvbkxheWVyLCBbe1xuICAgIGtleTogJ2dldFNoYWRlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFkZXJzKCkge1xuXG4gICAgICB2YXIgc2hhZGVycyA9IHRoaXMucHJvcHMuZnA2NCA/IHtcbiAgICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcbiNkZWZpbmUgU0hBREVSX05BTUUgcG9seWdvbi1sYXllci12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uczY0eHlMb3c7XFxuYXR0cmlidXRlIHZlYzMgbm9ybWFscztcXG5hdHRyaWJ1dGUgdmVjNCBjb2xvcnM7XFxuYXR0cmlidXRlIHZlYzMgcGlja2luZ0NvbG9ycztcXG5cXG51bmlmb3JtIGZsb2F0IGV4dHJ1ZGVkO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG5cXG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XFxudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xcblxcbi8vIFBJQ0tJTkdcXG51bmlmb3JtIGZsb2F0IHBpY2tpbmdFbmFibGVkO1xcbnZhcnlpbmcgdmVjNCB2UGlja2luZ0NvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICB2ZWM0IHBvc2l0aW9uczY0eHkgPSB2ZWM0KHBvc2l0aW9ucy54LCBwb3NpdGlvbnM2NHh5TG93LngsIHBvc2l0aW9ucy55LCBwb3NpdGlvbnM2NHh5TG93LnkpO1xcblxcbiAgdmVjMiBwcm9qZWN0ZWRfY29vcmRfeHlbMl07XFxuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQocG9zaXRpb25zNjR4eSwgcHJvamVjdGVkX2Nvb3JkX3h5KTtcXG5cXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdID0gcHJvamVjdGVkX2Nvb3JkX3h5WzBdO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzFdID0gcHJvamVjdGVkX2Nvb3JkX3h5WzFdO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdID0gdmVjMihwcm9qZWN0X3NjYWxlKHBvc2l0aW9ucy56KSwgMC4wKTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSk7XFxuXFxuICB2ZWM0IHBvc2l0aW9uX3dvcmxkc3BhY2UgPSB2ZWM0KHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXS54LCB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0ueCwgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdLngsIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXS54KTtcXG5cXG4gIGlmIChwaWNraW5nRW5hYmxlZCA8IDAuNSkge1xcbiAgICBmbG9hdCBsaWdodFdlaWdodCA9IDEuMDtcXG5cXG4gICAgaWYgKGV4dHJ1ZGVkID4gMC41KSB7XFxuICAgICAgbGlnaHRXZWlnaHQgPSBnZXRMaWdodFdlaWdodChcXG4gICAgICAgIHBvc2l0aW9uX3dvcmxkc3BhY2UsXFxuICAgICAgICBub3JtYWxzXFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICB2ZWMzIGxpZ2h0V2VpZ2h0ZWRDb2xvciA9IGxpZ2h0V2VpZ2h0ICogY29sb3JzLnJnYjtcXG4gICAgdmVjNCBjb2xvciA9IHZlYzQobGlnaHRXZWlnaHRlZENvbG9yLCBjb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjA7XFxuXFxuICAgIHZQaWNraW5nQ29sb3IgPSBjb2xvcjtcXG5cXG4gIH0gZWxzZSB7XFxuICAgIHZQaWNraW5nQ29sb3IgPSB2ZWM0KHBpY2tpbmdDb2xvcnMucmdiIC8gMjU1LjAsIDEuMCk7XFxuICB9XFxufVxcbicsXG4gICAgICAgIGZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIHBvbHlnb24tbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxuI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIFBJQ0tJTkdcXG4vLyB1bmlmb3JtIGJvb2wgcGlja2luZ0VuYWJsZWQ7XFxudmFyeWluZyB2ZWM0IHZQaWNraW5nQ29sb3I7XFxudmVjNCBwaWNraW5nX2dldENvbG9yKCkge1xcbiAgcmV0dXJuIHZQaWNraW5nQ29sb3I7XFxufVxcbi8vIFBJQ0tJTkdcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gcGlja2luZ19nZXRDb2xvcigpO1xcbn1cXG4nLFxuICAgICAgICBtb2R1bGVzOiBbJ2xpZ2h0aW5nJywgJ2ZwNjQnLCAncHJvamVjdDY0J10gfSA6IHtcbiAgICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcbiNkZWZpbmUgU0hBREVSX05BTUUgcG9seWdvbi1sYXllci12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbHM7XFxuYXR0cmlidXRlIHZlYzQgY29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIHBpY2tpbmdDb2xvcnM7XFxuXFxudW5pZm9ybSBmbG9hdCBleHRydWRlZDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuXFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcbnVuaWZvcm0gdmVjMyBzZWxlY3RlZFBpY2tpbmdDb2xvcjtcXG5cXG4vLyBQSUNLSU5HXFxudW5pZm9ybSBmbG9hdCBwaWNraW5nRW5hYmxlZDtcXG52YXJ5aW5nIHZlYzQgdlBpY2tpbmdDb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgdmVjNCBwb3NpdGlvbl93b3JsZHNwYWNlID0gdmVjNChwcm9qZWN0X3Bvc2l0aW9uKHBvc2l0aW9ucyksIDEuMCk7XFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uX3dvcmxkc3BhY2UpO1xcblxcbiAgaWYgKHBpY2tpbmdFbmFibGVkIDwgMC41KSB7XFxuICAgIGZsb2F0IGxpZ2h0V2VpZ2h0ID0gMS4wO1xcblxcbiAgICBpZiAoZXh0cnVkZWQgPiAwLjUpIHtcXG4gICAgICBsaWdodFdlaWdodCA9IGdldExpZ2h0V2VpZ2h0KFxcbiAgICAgICAgcG9zaXRpb25fd29ybGRzcGFjZSxcXG4gICAgICAgIG5vcm1hbHNcXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgIHZlYzMgbGlnaHRXZWlnaHRlZENvbG9yID0gbGlnaHRXZWlnaHQgKiBjb2xvcnMucmdiO1xcbiAgICB2ZWM0IGNvbG9yID0gdmVjNChsaWdodFdlaWdodGVkQ29sb3IsIGNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuMDtcXG5cXG4gICAgdlBpY2tpbmdDb2xvciA9IGNvbG9yO1xcblxcbiAgfSBlbHNlIHtcXG4gICAgdlBpY2tpbmdDb2xvciA9IHZlYzQocGlja2luZ0NvbG9ycy5yZ2IgLyAyNTUuMCwgMS4wKTtcXG4gIH1cXG59XFxuJyxcbiAgICAgICAgZnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcbiNkZWZpbmUgU0hBREVSX05BTUUgcG9seWdvbi1sYXllci1mcmFnbWVudC1zaGFkZXJcXG5cXG4jaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gUElDS0lOR1xcbi8vIHVuaWZvcm0gYm9vbCBwaWNraW5nRW5hYmxlZDtcXG52YXJ5aW5nIHZlYzQgdlBpY2tpbmdDb2xvcjtcXG52ZWM0IHBpY2tpbmdfZ2V0Q29sb3IoKSB7XFxuICByZXR1cm4gdlBpY2tpbmdDb2xvcjtcXG59XFxuLy8gUElDS0lOR1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSBwaWNraW5nX2dldENvbG9yKCk7XFxufVxcbicsXG4gICAgICAgIG1vZHVsZXM6IFsnbGlnaHRpbmcnXSB9O1xuICAgICAgcmV0dXJuIHNoYWRlcnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5pdGlhbGl6ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWwoZ2wpLFxuICAgICAgICBudW1JbnN0YW5jZXM6IDAsXG4gICAgICAgIEluZGV4VHlwZTogZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JykgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5XG4gICAgICB9KTtcblxuICAgICAgdmFyIGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXI7XG5cbiAgICAgIHZhciBub0FsbG9jID0gdHJ1ZTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICAgICAgaW5kaWNlczogeyBzaXplOiAxLCBpc0luZGV4ZWQ6IHRydWUsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbmRpY2VzLCBub0FsbG9jOiBub0FsbG9jIH0sXG4gICAgICAgIHBvc2l0aW9uczogeyBzaXplOiAzLCBhY2Nlc3NvcjogJ2dldEhlaWdodCcsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnMsIG5vQWxsb2M6IG5vQWxsb2MgfSxcbiAgICAgICAgbm9ybWFsczogeyBzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlTm9ybWFscywgbm9BbGxvYzogbm9BbGxvYyB9LFxuICAgICAgICBjb2xvcnM6IHsgc2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgYWNjZXNzb3I6ICdnZXRDb2xvcicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVDb2xvcnMsIG5vQWxsb2M6IG5vQWxsb2MgfSxcbiAgICAgICAgcGlja2luZ0NvbG9yczogeyBzaXplOiAzLCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUGlja2luZ0NvbG9ycywgbm9BbGxvYzogbm9BbGxvYyB9XG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgICBpZiAodGhpcy5wcm9wcy5mcDY0KSB7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICAgICAgICBwb3NpdGlvbnM2NHh5TG93OiB7IHNpemU6IDIsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnNMb3cgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU1vZGVsKF9yZWYpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgb2xkUHJvcHMgPSBfcmVmLm9sZFByb3BzLFxuICAgICAgICAgIGNoYW5nZUZsYWdzID0gX3JlZi5jaGFuZ2VGbGFncztcblxuICAgICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBtb2RlbDogdGhpcy5nZXRNb2RlbChnbCkgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlQXR0cmlidXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQXR0cmlidXRlKF9yZWYyKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmMi5wcm9wcyxcbiAgICAgICAgICBvbGRQcm9wcyA9IF9yZWYyLm9sZFByb3BzLFxuICAgICAgICAgIGNoYW5nZUZsYWdzID0gX3JlZjIuY2hhbmdlRmxhZ3M7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyO1xuXG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuXG4gICAgICAgIGlmIChwcm9wcy5mcDY0ID09PSB0cnVlKSB7XG4gICAgICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgICAgICAgICAgcG9zaXRpb25zNjR4eUxvdzogeyBzaXplOiAyLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zTG93IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbJ3Bvc2l0aW9uczY0eHlMb3cnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKF9yZWYzKSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmMy5wcm9wcyxcbiAgICAgICAgICBvbGRQcm9wcyA9IF9yZWYzLm9sZFByb3BzLFxuICAgICAgICAgIGNoYW5nZUZsYWdzID0gX3JlZjMuY2hhbmdlRmxhZ3M7XG5cbiAgICAgIHRoaXMudXBkYXRlR2VvbWV0cnkoeyBwcm9wczogcHJvcHMsIG9sZFByb3BzOiBvbGRQcm9wcywgY2hhbmdlRmxhZ3M6IGNoYW5nZUZsYWdzIH0pO1xuICAgICAgdGhpcy51cGRhdGVNb2RlbCh7IHByb3BzOiBwcm9wcywgb2xkUHJvcHM6IG9sZFByb3BzLCBjaGFuZ2VGbGFnczogY2hhbmdlRmxhZ3MgfSk7XG4gICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZSh7IHByb3BzOiBwcm9wcywgb2xkUHJvcHM6IG9sZFByb3BzLCBjaGFuZ2VGbGFnczogY2hhbmdlRmxhZ3MgfSk7XG5cbiAgICAgIHZhciBvcGFjaXR5ID0gcHJvcHMub3BhY2l0eSxcbiAgICAgICAgICBleHRydWRlZCA9IHByb3BzLmV4dHJ1ZGVkLFxuICAgICAgICAgIGxpZ2h0U2V0dGluZ3MgPSBwcm9wcy5saWdodFNldHRpbmdzO1xuXG5cbiAgICAgIHRoaXMuc2V0VW5pZm9ybXMoT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICBleHRydWRlZDogZXh0cnVkZWQgPyAxLjAgOiAwLjAsXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgIH0sIGxpZ2h0U2V0dGluZ3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVHZW9tZXRyeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUdlb21ldHJ5KF9yZWY0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHByb3BzID0gX3JlZjQucHJvcHMsXG4gICAgICAgICAgb2xkUHJvcHMgPSBfcmVmNC5vbGRQcm9wcyxcbiAgICAgICAgICBjaGFuZ2VGbGFncyA9IF9yZWY0LmNoYW5nZUZsYWdzO1xuXG4gICAgICB2YXIgZ2VvbWV0cnlDaGFuZ2VkID0gcHJvcHMuZXh0cnVkZWQgIT09IG9sZFByb3BzLmV4dHJ1ZGVkIHx8IHByb3BzLndpcmVmcmFtZSAhPT0gb2xkUHJvcHMud2lyZWZyYW1lIHx8IHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQ7XG5cbiAgICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBnZW9tZXRyeUNoYW5nZWQpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZ2V0UG9seWdvbiA9IHByb3BzLmdldFBvbHlnb24sXG4gICAgICAgICAgICAgIGV4dHJ1ZGVkID0gcHJvcHMuZXh0cnVkZWQsXG4gICAgICAgICAgICAgIHdpcmVmcmFtZSA9IHByb3BzLndpcmVmcmFtZSxcbiAgICAgICAgICAgICAgX2dldEhlaWdodCA9IHByb3BzLmdldEhlaWdodDtcblxuICAgICAgICAgIC8vIFRPRE8gLSBhdm9pZCBjcmVhdGluZyBhIHRlbXBvcmFyeSBhcnJheSBoZXJlOiBsZXQgdGhlIHRlc3NlbGF0b3IgaXRlcmF0ZVxuXG4gICAgICAgICAgdmFyIHBvbHlnb25zID0gcHJvcHMuZGF0YS5tYXAoZ2V0UG9seWdvbik7XG5cbiAgICAgICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcG9seWdvblRlc3NlbGF0b3I6ICFleHRydWRlZCA/IG5ldyBQb2x5Z29uVGVzc2VsYXRvcih7IHBvbHlnb25zOiBwb2x5Z29ucywgZnA2NDogX3RoaXMyLnByb3BzLmZwNjQgfSkgOiBuZXcgUG9seWdvblRlc3NlbGF0b3JFeHRydWRlZCh7IHBvbHlnb25zOiBwb2x5Z29ucywgd2lyZWZyYW1lOiB3aXJlZnJhbWUsXG4gICAgICAgICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24gZ2V0SGVpZ2h0KHBvbHlnb25JbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0SGVpZ2h0KF90aGlzMi5wcm9wcy5kYXRhW3BvbHlnb25JbmRleF0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmcDY0OiBfdGhpczIucHJvcHMuZnA2NFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF90aGlzMi5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vZGVsKGdsKSB7XG4gICAgICB2YXIgc2hhZGVycyA9IGFzc2VtYmxlU2hhZGVycyhnbCwgdGhpcy5nZXRTaGFkZXJzKCkpO1xuICAgICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICAgIGdsOiBnbCxcbiAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgZHJhd01vZGU6IHRoaXMucHJvcHMud2lyZWZyYW1lID8gR0wuTElORVMgOiBHTC5UUklBTkdMRVNcbiAgICAgICAgfSksXG4gICAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgICBpc0luZGV4ZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZUluZGljZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbmRpY2VzKGF0dHJpYnV0ZSkge1xuICAgICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5pbmRpY2VzKCk7XG4gICAgICBhdHRyaWJ1dGUudGFyZ2V0ID0gR0wuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldFZlcnRleENvdW50KGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlUG9zaXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5wb3NpdGlvbnMoKS5wb3NpdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlUG9zaXRpb25zTG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zTG93KGF0dHJpYnV0ZSkge1xuICAgICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5wb3NpdGlvbnMoKS5wb3NpdGlvbnM2NHh5TG93O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZU5vcm1hbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVOb3JtYWxzKGF0dHJpYnV0ZSkge1xuICAgICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5ub3JtYWxzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlQ29sb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IuY29sb3JzKHtcbiAgICAgICAgZ2V0Q29sb3I6IGZ1bmN0aW9uIGdldENvbG9yKHBvbHlnb25JbmRleCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMucHJvcHMuZ2V0Q29sb3IoX3RoaXMzLnByb3BzLmRhdGFbcG9seWdvbkluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHBpY2tpbmcgY29sb3JzIGNhbGN1bGF0aW9uXG5cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZVBpY2tpbmdDb2xvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5waWNraW5nQ29sb3JzKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvbHlnb25MYXllcjtcbn0oTGF5ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBQb2x5Z29uTGF5ZXI7XG5cblxuUG9seWdvbkxheWVyLmxheWVyTmFtZSA9ICdQb2x5Z29uTGF5ZXInO1xuUG9seWdvbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9wb2x5Z29uLWxheWVyL3BvbHlnb24tbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 24 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************************!*\
  !*** ./src/layers/deprecated/choropleth-layer/choropleth-layer.js ***!
  \********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geojson__ = __webpack_require__(/*! ./geojson */ 56);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut__ = __webpack_require__(/*! earcut */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_path__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 255, 255];\n\nvar defaultProps = {\n  getColor: function getColor(feature) {\n    return __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"c\" /* Container */].get(feature, 'properties.color');\n  },\n  drawContour: false,\n  strokeWidth: 1\n};\n\nvar ChoroplethLayer = function (_Layer) {\n  _inherits(ChoroplethLayer, _Layer);\n\n  function ChoroplethLayer() {\n    _classCallCheck(this, ChoroplethLayer);\n\n    return _possibleConstructorReturn(this, (ChoroplethLayer.__proto__ || Object.getPrototypeOf(ChoroplethLayer)).apply(this, arguments));\n  }\n\n  _createClass(ChoroplethLayer, [{\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME choropleth-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec4 colors;\\nattribute vec3 pickingColors;\\n\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\nuniform vec3 selectedPickingColor;\\n\\n// PICKING\\nuniform float pickingEnabled;\\nvarying vec4 vPickingColor;\\nvoid picking_setPickColor(vec3 pickingColor) {\\n  vPickingColor = vec4(pickingColor,  1.);\\n}\\nvec4 picking_setNormalAndPickColors(vec4 color, vec3 pickingColor) {\\n  vec4 pickingColor4 = vec4(pickingColor.rgb, 1.);\\n  vPickingColor = mix(color, pickingColor4, pickingEnabled);\\n  return vPickingColor;\\n}\\n\\n// PICKING\\n// vec4 getColor(vec4 color, float opacity, vec3 pickingColor, float renderPickingBuffer) {\\n//   vec4 color4 = vec4(color.xyz / 255., color.w / 255. * opacity);\\n//   vec4 pickingColor4 = vec4(pickingColor / 255., 1.);\\n//   return mix(color4, pickingColor4, renderPickingBuffer);\\n// }\\n\\nvoid main(void) {\\n\\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\\n\\n  picking_setNormalAndPickColors(\\n    color,\\n    pickingColors / 255.\\n  );\\n\\n  vec3 p = project_position(positions);\\n  gl_Position = project_to_clipspace(vec4(p, 1.));\\n}\\n',\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME choropleth-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\n// PICKING\\n// uniform bool pickingEnabled;\\nvarying vec4 vPickingColor;\\nvec4 picking_getColor() {\\n  return vPickingColor;\\n}\\n// PICKING\\n\\nvoid main(void) {\\n  gl_FragColor = picking_getColor();\\n}\\n'\n      };\n    }\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      var gl = this.context.gl;\n      var attributeManager = this.state.attributeManager;\n\n      attributeManager.addDynamic({\n        // Primtive attributes\n        indices: { size: 1, update: this.calculateIndices, isIndexed: true },\n        positions: { size: 3, update: this.calculatePositions },\n        colors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].UNSIGNED_BYTE, update: this.calculateColors },\n        // Instanced attributes\n        pickingColors: {\n          size: 3,\n          type: __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].UNSIGNED_BYTE,\n          update: this.calculatePickingColors,\n          noAlloc: true\n        }\n      });\n\n      var IndexType = gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array;\n\n      this.setState({\n        model: this.getModel(gl),\n        numInstances: 0,\n        IndexType: IndexType\n      });\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n      var attributeManager = this.state.attributeManager;\n\n      if (changeFlags.dataChanged) {\n        this.state.choropleths = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__geojson__[\"a\" /* extractPolygons */])(props.data);\n        attributeManager.invalidateAll();\n      }\n\n      if (oldProps.opacity !== props.opacity) {\n        this.setUniforms({ opacity: props.opacity });\n      }\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var gl = this.context.gl;\n\n      var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);\n      gl.lineWidth(lineWidth);\n      this.state.model.render(uniforms);\n      // Setting line width back to 1 is here to workaround a Google Chrome bug\n      // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with\n      // correct parameter\n      // This is not happening on Safari and Firefox\n      gl.lineWidth(1.0);\n    }\n  }, {\n    key: 'getPickingInfo',\n    value: function getPickingInfo(opts) {\n      var info = _get(ChoroplethLayer.prototype.__proto__ || Object.getPrototypeOf(ChoroplethLayer.prototype), 'getPickingInfo', this).call(this, opts);\n      var index = this.decodePickingColor(info.color);\n      var feature = index >= 0 ? __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"c\" /* Container */].get(this.props.data, ['features', index]) : null;\n      info.feature = feature;\n      info.object = feature;\n      return info;\n    }\n  }, {\n    key: 'getModel',\n    value: function getModel(gl) {\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      return new __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"Geometry\"]({\n          drawMode: this.props.drawContour ? __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].LINES : __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].TRIANGLES\n        }),\n        vertexCount: 0,\n        isIndexed: true\n      });\n    }\n  }, {\n    key: 'calculateIndices',\n    value: function calculateIndices(attribute) {\n      var _this2 = this;\n\n      // adjust index offset for multiple choropleths\n      var offsets = this.state.choropleths.reduce(function (acc, choropleth) {\n        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + choropleth.reduce(function (count, polygon) {\n          return count + polygon.length;\n        }, 0)]);\n      }, [0]);\n      var IndexType = this.state.IndexType;\n\n      if (IndexType === Uint16Array && offsets[offsets.length - 1] > 65535) {\n        throw new Error('Vertex count exceeds browser\\'s limit');\n      }\n\n      var indices = this.state.choropleths.map(function (choropleth, choroplethIndex) {\n        return _this2.props.drawContour ?\n        // 1. get sequentially ordered indices of each choropleth contour\n        // 2. offset them by the number of indices in previous choropleths\n        calculateContourIndices(choropleth).map(function (index) {\n          return index + offsets[choroplethIndex];\n        }) :\n        // 1. get triangulated indices for the internal areas\n        // 2. offset them by the number of indices in previous choropleths\n        calculateSurfaceIndices(choropleth).map(function (index) {\n          return index + offsets[choroplethIndex];\n        });\n      });\n\n      attribute.value = new IndexType(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"b\" /* flatten */])(indices));\n      attribute.target = __WEBPACK_IMPORTED_MODULE_4_luma_gl__[\"GL\"].ELEMENT_ARRAY_BUFFER;\n      this.state.model.setVertexCount(attribute.value.length / attribute.size);\n    }\n  }, {\n    key: 'calculatePositions',\n    value: function calculatePositions(attribute) {\n      var vertices = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"b\" /* flatten */])(this.state.choropleths);\n      attribute.value = new Float32Array(vertices);\n    }\n  }, {\n    key: 'calculateColors',\n    value: function calculateColors(attribute) {\n      var _props = this.props,\n          data = _props.data,\n          getColor = _props.getColor;\n\n      var features = __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"c\" /* Container */].get(data, 'features');\n      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {\n        var feature = __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"c\" /* Container */].get(features, choropleth.featureIndex);\n        var color = getColor(feature) || DEFAULT_COLOR;\n        // Ensure alpha is set\n        if (isNaN(color[3])) {\n          color[3] = DEFAULT_COLOR[3];\n        }\n        return choropleth.map(function (polygon) {\n          return polygon.map(function (vertex) {\n            return color;\n          });\n        });\n      });\n\n      attribute.value = new Uint8Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"b\" /* flatten */])(colors));\n    }\n\n    // Override the default picking colors calculation\n\n  }, {\n    key: 'calculatePickingColors',\n    value: function calculatePickingColors(attribute) {\n      var _this3 = this;\n\n      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {\n        var featureIndex = choropleth.featureIndex;\n\n        var color = _this3.props.drawContour ? [0, 0, 0] : [(featureIndex + 1) % 256, Math.floor((featureIndex + 1) / 256) % 256, Math.floor((featureIndex + 1) / 256 / 256) % 256];\n        return choropleth.map(function (polygon) {\n          return polygon.map(function (vertex) {\n            return color;\n          });\n        });\n      });\n\n      attribute.value = new Uint8Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"b\" /* flatten */])(colors));\n    }\n  }]);\n\n  return ChoroplethLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ChoroplethLayer;\n\n\nChoroplethLayer.layerName = 'ChoroplethLayer';\nChoroplethLayer.defaultProps = defaultProps;\n\n/*\n * get vertex indices for drawing choropleth contour\n * @param {[Number,Number,Number][][]} choropleth\n * @returns {[Number]} indices\n */\nfunction calculateContourIndices(choropleth) {\n  var offset = 0;\n\n  return choropleth.reduce(function (acc, polygon) {\n    var numVertices = polygon.length;\n\n    // use vertex pairs for gl.LINES => [0, 1, 1, 2, 2, ..., n-2, n-2, n-1]\n    var indices = [].concat(_toConsumableArray(acc), [offset]);\n    for (var i = 1; i < numVertices - 1; i++) {\n      indices.push(i + offset, i + offset);\n    }\n    indices.push(offset + numVertices - 1);\n\n    offset += numVertices;\n    return indices;\n  }, []);\n}\n\n/*\n * get vertex indices for drawing choropleth mesh\n * @param {[Number,Number,Number][][]} choropleth\n * @returns {[Number]} indices\n */\nfunction calculateSurfaceIndices(choropleth) {\n  var holes = null;\n\n  if (choropleth.length > 1) {\n    holes = choropleth.reduce(function (acc, polygon) {\n      return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);\n    }, [0]).slice(1, choropleth.length);\n  }\n\n  return __WEBPACK_IMPORTED_MODULE_5_earcut___default()(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"b\" /* flatten */])(choropleth), holes, 3);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci9jaG9yb3BsZXRoLWxheWVyLmpzP2RmYzUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgeyBhc3NlbWJsZVNoYWRlcnMgfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHsgQ29udGFpbmVyLCBmbGF0dGVuIH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCB7IGV4dHJhY3RQb2x5Z29ucyB9IGZyb20gJy4vZ2VvanNvbic7XG5pbXBvcnQgeyBHTCwgTW9kZWwsIEdlb21ldHJ5IH0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5cbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcblxudmFyIERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMjU1LCAyNTVdO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBnZXRDb2xvcjogZnVuY3Rpb24gZ2V0Q29sb3IoZmVhdHVyZSkge1xuICAgIHJldHVybiBDb250YWluZXIuZ2V0KGZlYXR1cmUsICdwcm9wZXJ0aWVzLmNvbG9yJyk7XG4gIH0sXG4gIGRyYXdDb250b3VyOiBmYWxzZSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbnZhciBDaG9yb3BsZXRoTGF5ZXIgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhDaG9yb3BsZXRoTGF5ZXIsIF9MYXllcik7XG5cbiAgZnVuY3Rpb24gQ2hvcm9wbGV0aExheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaG9yb3BsZXRoTGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDaG9yb3BsZXRoTGF5ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDaG9yb3BsZXRoTGF5ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDaG9yb3BsZXRoTGF5ZXIsIFt7XG4gICAga2V5OiAnZ2V0U2hhZGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoYWRlcnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2czogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBjaG9yb3BsZXRoLWxheWVyLXZlcnRleC1zaGFkZXJcXG5cXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzQgY29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIHBpY2tpbmdDb2xvcnM7XFxuXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcXG51bmlmb3JtIHZlYzMgc2VsZWN0ZWRQaWNraW5nQ29sb3I7XFxuXFxuLy8gUElDS0lOR1xcbnVuaWZvcm0gZmxvYXQgcGlja2luZ0VuYWJsZWQ7XFxudmFyeWluZyB2ZWM0IHZQaWNraW5nQ29sb3I7XFxudm9pZCBwaWNraW5nX3NldFBpY2tDb2xvcih2ZWMzIHBpY2tpbmdDb2xvcikge1xcbiAgdlBpY2tpbmdDb2xvciA9IHZlYzQocGlja2luZ0NvbG9yLCAgMS4pO1xcbn1cXG52ZWM0IHBpY2tpbmdfc2V0Tm9ybWFsQW5kUGlja0NvbG9ycyh2ZWM0IGNvbG9yLCB2ZWMzIHBpY2tpbmdDb2xvcikge1xcbiAgdmVjNCBwaWNraW5nQ29sb3I0ID0gdmVjNChwaWNraW5nQ29sb3IucmdiLCAxLik7XFxuICB2UGlja2luZ0NvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3I0LCBwaWNraW5nRW5hYmxlZCk7XFxuICByZXR1cm4gdlBpY2tpbmdDb2xvcjtcXG59XFxuXFxuLy8gUElDS0lOR1xcbi8vIHZlYzQgZ2V0Q29sb3IodmVjNCBjb2xvciwgZmxvYXQgb3BhY2l0eSwgdmVjMyBwaWNraW5nQ29sb3IsIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXIpIHtcXG4vLyAgIHZlYzQgY29sb3I0ID0gdmVjNChjb2xvci54eXogLyAyNTUuLCBjb2xvci53IC8gMjU1LiAqIG9wYWNpdHkpO1xcbi8vICAgdmVjNCBwaWNraW5nQ29sb3I0ID0gdmVjNChwaWNraW5nQ29sb3IgLyAyNTUuLCAxLik7XFxuLy8gICByZXR1cm4gbWl4KGNvbG9yNCwgcGlja2luZ0NvbG9yNCwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XFxuLy8gfVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFxuICB2ZWM0IGNvbG9yID0gdmVjNChjb2xvcnMucmdiLCBjb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcXG5cXG4gIHBpY2tpbmdfc2V0Tm9ybWFsQW5kUGlja0NvbG9ycyhcXG4gICAgY29sb3IsXFxuICAgIHBpY2tpbmdDb2xvcnMgLyAyNTUuXFxuICApO1xcblxcbiAgdmVjMyBwID0gcHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbnMpO1xcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZSh2ZWM0KHAsIDEuKSk7XFxufVxcbicsXG4gICAgICAgIGZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIGNob3JvcGxldGgtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxuI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIFBJQ0tJTkdcXG4vLyB1bmlmb3JtIGJvb2wgcGlja2luZ0VuYWJsZWQ7XFxudmFyeWluZyB2ZWM0IHZQaWNraW5nQ29sb3I7XFxudmVjNCBwaWNraW5nX2dldENvbG9yKCkge1xcbiAgcmV0dXJuIHZQaWNraW5nQ29sb3I7XFxufVxcbi8vIFBJQ0tJTkdcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gcGlja2luZ19nZXRDb2xvcigpO1xcbn1cXG4nXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luaXRpYWxpemVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcbiAgICAgIHZhciBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyO1xuXG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZER5bmFtaWMoe1xuICAgICAgICAvLyBQcmltdGl2ZSBhdHRyaWJ1dGVzXG4gICAgICAgIGluZGljZXM6IHsgc2l6ZTogMSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluZGljZXMsIGlzSW5kZXhlZDogdHJ1ZSB9LFxuICAgICAgICBwb3NpdGlvbnM6IHsgc2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9ucyB9LFxuICAgICAgICBjb2xvcnM6IHsgc2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9ycyB9LFxuICAgICAgICAvLyBJbnN0YW5jZWQgYXR0cmlidXRlc1xuICAgICAgICBwaWNraW5nQ29sb3JzOiB7XG4gICAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQaWNraW5nQ29sb3JzLFxuICAgICAgICAgIG5vQWxsb2M6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBJbmRleFR5cGUgPSBnbC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbChnbCksXG4gICAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgICAgSW5kZXhUeXBlOiBJbmRleFR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGUoX3JlZikge1xuICAgICAgdmFyIG9sZFByb3BzID0gX3JlZi5vbGRQcm9wcyxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgY2hhbmdlRmxhZ3MgPSBfcmVmLmNoYW5nZUZsYWdzO1xuICAgICAgdmFyIGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXI7XG5cbiAgICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLnN0YXRlLmNob3JvcGxldGhzID0gZXh0cmFjdFBvbHlnb25zKHByb3BzLmRhdGEpO1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9sZFByb3BzLm9wYWNpdHkgIT09IHByb3BzLm9wYWNpdHkpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3Jtcyh7IG9wYWNpdHk6IHByb3BzLm9wYWNpdHkgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoX3JlZjIpIHtcbiAgICAgIHZhciB1bmlmb3JtcyA9IF9yZWYyLnVuaWZvcm1zO1xuICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXG4gICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5zY3JlZW5Ub0RldmljZVBpeGVscyh0aGlzLnByb3BzLnN0cm9rZVdpZHRoKTtcbiAgICAgIGdsLmxpbmVXaWR0aChsaW5lV2lkdGgpO1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgICAgLy8gU2V0dGluZyBsaW5lIHdpZHRoIGJhY2sgdG8gMSBpcyBoZXJlIHRvIHdvcmthcm91bmQgYSBHb29nbGUgQ2hyb21lIGJ1Z1xuICAgICAgLy8gZ2wuY2xlYXIoKSBhbmQgZ2wuaXNFbmFibGVkKCkgd2lsbCByZXR1cm4gR0xfSU5WQUxJRF9WQUxVRSBldmVuIHdpdGhcbiAgICAgIC8vIGNvcnJlY3QgcGFyYW1ldGVyXG4gICAgICAvLyBUaGlzIGlzIG5vdCBoYXBwZW5pbmcgb24gU2FmYXJpIGFuZCBGaXJlZm94XG4gICAgICBnbC5saW5lV2lkdGgoMS4wKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQaWNraW5nSW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpY2tpbmdJbmZvKG9wdHMpIHtcbiAgICAgIHZhciBpbmZvID0gX2dldChDaG9yb3BsZXRoTGF5ZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2hvcm9wbGV0aExheWVyLnByb3RvdHlwZSksICdnZXRQaWNraW5nSW5mbycsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmRlY29kZVBpY2tpbmdDb2xvcihpbmZvLmNvbG9yKTtcbiAgICAgIHZhciBmZWF0dXJlID0gaW5kZXggPj0gMCA/IENvbnRhaW5lci5nZXQodGhpcy5wcm9wcy5kYXRhLCBbJ2ZlYXR1cmVzJywgaW5kZXhdKSA6IG51bGw7XG4gICAgICBpbmZvLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgaW5mby5vYmplY3QgPSBmZWF0dXJlO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TW9kZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb2RlbChnbCkge1xuICAgICAgdmFyIHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICAgIGdsOiBnbCxcbiAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgZHJhd01vZGU6IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgPyBHTC5MSU5FUyA6IEdMLlRSSUFOR0xFU1xuICAgICAgICB9KSxcbiAgICAgICAgdmVydGV4Q291bnQ6IDAsXG4gICAgICAgIGlzSW5kZXhlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5kaWNlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgY2hvcm9wbGV0aHNcbiAgICAgIHZhciBvZmZzZXRzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY2hvcm9wbGV0aCkge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhY2MpLCBbYWNjW2FjYy5sZW5ndGggLSAxXSArIGNob3JvcGxldGgucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgcG9seWdvbikge1xuICAgICAgICAgIHJldHVybiBjb3VudCArIHBvbHlnb24ubGVuZ3RoO1xuICAgICAgICB9LCAwKV0pO1xuICAgICAgfSwgWzBdKTtcbiAgICAgIHZhciBJbmRleFR5cGUgPSB0aGlzLnN0YXRlLkluZGV4VHlwZTtcblxuICAgICAgaWYgKEluZGV4VHlwZSA9PT0gVWludDE2QXJyYXkgJiYgb2Zmc2V0c1tvZmZzZXRzLmxlbmd0aCAtIDFdID4gNjU1MzUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggY291bnQgZXhjZWVkcyBicm93c2VyXFwncyBsaW1pdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMubWFwKGZ1bmN0aW9uIChjaG9yb3BsZXRoLCBjaG9yb3BsZXRoSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9wcy5kcmF3Q29udG91ciA/XG4gICAgICAgIC8vIDEuIGdldCBzZXF1ZW50aWFsbHkgb3JkZXJlZCBpbmRpY2VzIG9mIGVhY2ggY2hvcm9wbGV0aCBjb250b3VyXG4gICAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBjaG9yb3BsZXRoc1xuICAgICAgICBjYWxjdWxhdGVDb250b3VySW5kaWNlcyhjaG9yb3BsZXRoKS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ICsgb2Zmc2V0c1tjaG9yb3BsZXRoSW5kZXhdO1xuICAgICAgICB9KSA6XG4gICAgICAgIC8vIDEuIGdldCB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBmb3IgdGhlIGludGVybmFsIGFyZWFzXG4gICAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBjaG9yb3BsZXRoc1xuICAgICAgICBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyhjaG9yb3BsZXRoKS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ICsgb2Zmc2V0c1tjaG9yb3BsZXRoSW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgSW5kZXhUeXBlKGZsYXR0ZW4oaW5kaWNlcykpO1xuICAgICAgYXR0cmlidXRlLnRhcmdldCA9IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRWZXJ0ZXhDb3VudChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZVBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IGZsYXR0ZW4odGhpcy5zdGF0ZS5jaG9yb3BsZXRocyk7XG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVDb2xvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3Byb3BzLmRhdGEsXG4gICAgICAgICAgZ2V0Q29sb3IgPSBfcHJvcHMuZ2V0Q29sb3I7XG5cbiAgICAgIHZhciBmZWF0dXJlcyA9IENvbnRhaW5lci5nZXQoZGF0YSwgJ2ZlYXR1cmVzJyk7XG4gICAgICB2YXIgY29sb3JzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5tYXAoZnVuY3Rpb24gKGNob3JvcGxldGgsIGNob3JvcGxldGhJbmRleCkge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IENvbnRhaW5lci5nZXQoZmVhdHVyZXMsIGNob3JvcGxldGguZmVhdHVyZUluZGV4KTtcbiAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IoZmVhdHVyZSkgfHwgREVGQVVMVF9DT0xPUjtcbiAgICAgICAgLy8gRW5zdXJlIGFscGhhIGlzIHNldFxuICAgICAgICBpZiAoaXNOYU4oY29sb3JbM10pKSB7XG4gICAgICAgICAgY29sb3JbM10gPSBERUZBVUxUX0NPTE9SWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaG9yb3BsZXRoLm1hcChmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICAgIHJldHVybiBwb2x5Z29uLm1hcChmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBVaW50OEFycmF5KGZsYXR0ZW4oY29sb3JzKSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgcGlja2luZyBjb2xvcnMgY2FsY3VsYXRpb25cblxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlUGlja2luZ0NvbG9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMubWFwKGZ1bmN0aW9uIChjaG9yb3BsZXRoLCBjaG9yb3BsZXRoSW5kZXgpIHtcbiAgICAgICAgdmFyIGZlYXR1cmVJbmRleCA9IGNob3JvcGxldGguZmVhdHVyZUluZGV4O1xuXG4gICAgICAgIHZhciBjb2xvciA9IF90aGlzMy5wcm9wcy5kcmF3Q29udG91ciA/IFswLCAwLCAwXSA6IFsoZmVhdHVyZUluZGV4ICsgMSkgJSAyNTYsIE1hdGguZmxvb3IoKGZlYXR1cmVJbmRleCArIDEpIC8gMjU2KSAlIDI1NiwgTWF0aC5mbG9vcigoZmVhdHVyZUluZGV4ICsgMSkgLyAyNTYgLyAyNTYpICUgMjU2XTtcbiAgICAgICAgcmV0dXJuIGNob3JvcGxldGgubWFwKGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgICAgICAgcmV0dXJuIHBvbHlnb24ubWFwKGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoZmxhdHRlbihjb2xvcnMpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2hvcm9wbGV0aExheWVyO1xufShMYXllcik7XG5cbmV4cG9ydCBkZWZhdWx0IENob3JvcGxldGhMYXllcjtcblxuXG5DaG9yb3BsZXRoTGF5ZXIubGF5ZXJOYW1lID0gJ0Nob3JvcGxldGhMYXllcic7XG5DaG9yb3BsZXRoTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG4vKlxuICogZ2V0IHZlcnRleCBpbmRpY2VzIGZvciBkcmF3aW5nIGNob3JvcGxldGggY29udG91clxuICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXX0gY2hvcm9wbGV0aFxuICogQHJldHVybnMge1tOdW1iZXJdfSBpbmRpY2VzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKGNob3JvcGxldGgpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgcmV0dXJuIGNob3JvcGxldGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBvbHlnb24pIHtcbiAgICB2YXIgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgIC8vIHVzZSB2ZXJ0ZXggcGFpcnMgZm9yIGdsLkxJTkVTID0+IFswLCAxLCAxLCAyLCAyLCAuLi4sIG4tMiwgbi0yLCBuLTFdXG4gICAgdmFyIGluZGljZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFjYyksIFtvZmZzZXRdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIG9mZnNldCk7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChvZmZzZXQgKyBudW1WZXJ0aWNlcyAtIDEpO1xuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9LCBbXSk7XG59XG5cbi8qXG4gKiBnZXQgdmVydGV4IGluZGljZXMgZm9yIGRyYXdpbmcgY2hvcm9wbGV0aCBtZXNoXG4gKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyLE51bWJlcl1bXVtdfSBjaG9yb3BsZXRoXG4gKiBAcmV0dXJucyB7W051bWJlcl19IGluZGljZXNcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3VyZmFjZUluZGljZXMoY2hvcm9wbGV0aCkge1xuICB2YXIgaG9sZXMgPSBudWxsO1xuXG4gIGlmIChjaG9yb3BsZXRoLmxlbmd0aCA+IDEpIHtcbiAgICBob2xlcyA9IGNob3JvcGxldGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBvbHlnb24pIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFjYyksIFthY2NbYWNjLmxlbmd0aCAtIDFdICsgcG9seWdvbi5sZW5ndGhdKTtcbiAgICB9LCBbMF0pLnNsaWNlKDEsIGNob3JvcGxldGgubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBlYXJjdXQoZmxhdHRlbihjaG9yb3BsZXRoKSwgaG9sZXMsIDMpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9kZXByZWNhdGVkL2Nob3JvcGxldGgtbGF5ZXIvY2hvcm9wbGV0aC1sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 25 */
/* exports provided: default */
/* exports used: default */
/*!***************************************************!*\
  !*** ./src/lib/viewports/perspective-viewport.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(/*! ./viewport */ 9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\nvar DEGREES_TO_RADIANS = Math.PI / 180;\n\nvar PerspectiveViewport = function (_Viewport) {\n  _inherits(PerspectiveViewport, _Viewport);\n\n  function PerspectiveViewport(_ref) {\n    var width = _ref.width,\n        height = _ref.height,\n        eye = _ref.eye,\n        _ref$lookAt = _ref.lookAt,\n        lookAt = _ref$lookAt === undefined ? [0, 0, 0] : _ref$lookAt,\n        _ref$up = _ref.up,\n        up = _ref$up === undefined ? [0, 1, 0] : _ref$up,\n        _ref$fovy = _ref.fovy,\n        fovy = _ref$fovy === undefined ? 75 : _ref$fovy,\n        _ref$near = _ref.near,\n        near = _ref$near === undefined ? 1 : _ref$near,\n        _ref$far = _ref.far,\n        far = _ref$far === undefined ? 100 : _ref$far,\n        _ref$aspect = _ref.aspect,\n        aspect = _ref$aspect === undefined ? null : _ref$aspect;\n\n    _classCallCheck(this, PerspectiveViewport);\n\n    var fovyRadians = fovy * DEGREES_TO_RADIANS;\n    aspect = Number.isFinite(aspect) ? aspect : width / height;\n    return _possibleConstructorReturn(this, (PerspectiveViewport.__proto__ || Object.getPrototypeOf(PerspectiveViewport)).call(this, {\n      viewMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].lookAt([], eye, lookAt, up),\n      projectionMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].perspective([], fovyRadians, aspect, near, far),\n      width: width,\n      height: height\n    }));\n  }\n\n  return PerspectiveViewport;\n}(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = PerspectiveViewport;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZpZXdwb3J0cy9wZXJzcGVjdGl2ZS12aWV3cG9ydC5qcz81MmIxIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vdmlld3BvcnQnO1xuaW1wb3J0IHsgbWF0NCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbnZhciBERUdSRUVTX1RPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuXG52YXIgUGVyc3BlY3RpdmVWaWV3cG9ydCA9IGZ1bmN0aW9uIChfVmlld3BvcnQpIHtcbiAgX2luaGVyaXRzKFBlcnNwZWN0aXZlVmlld3BvcnQsIF9WaWV3cG9ydCk7XG5cbiAgZnVuY3Rpb24gUGVyc3BlY3RpdmVWaWV3cG9ydChfcmVmKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICAgIGV5ZSA9IF9yZWYuZXllLFxuICAgICAgICBfcmVmJGxvb2tBdCA9IF9yZWYubG9va0F0LFxuICAgICAgICBsb29rQXQgPSBfcmVmJGxvb2tBdCA9PT0gdW5kZWZpbmVkID8gWzAsIDAsIDBdIDogX3JlZiRsb29rQXQsXG4gICAgICAgIF9yZWYkdXAgPSBfcmVmLnVwLFxuICAgICAgICB1cCA9IF9yZWYkdXAgPT09IHVuZGVmaW5lZCA/IFswLCAxLCAwXSA6IF9yZWYkdXAsXG4gICAgICAgIF9yZWYkZm92eSA9IF9yZWYuZm92eSxcbiAgICAgICAgZm92eSA9IF9yZWYkZm92eSA9PT0gdW5kZWZpbmVkID8gNzUgOiBfcmVmJGZvdnksXG4gICAgICAgIF9yZWYkbmVhciA9IF9yZWYubmVhcixcbiAgICAgICAgbmVhciA9IF9yZWYkbmVhciA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkbmVhcixcbiAgICAgICAgX3JlZiRmYXIgPSBfcmVmLmZhcixcbiAgICAgICAgZmFyID0gX3JlZiRmYXIgPT09IHVuZGVmaW5lZCA/IDEwMCA6IF9yZWYkZmFyLFxuICAgICAgICBfcmVmJGFzcGVjdCA9IF9yZWYuYXNwZWN0LFxuICAgICAgICBhc3BlY3QgPSBfcmVmJGFzcGVjdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IF9yZWYkYXNwZWN0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBlcnNwZWN0aXZlVmlld3BvcnQpO1xuXG4gICAgdmFyIGZvdnlSYWRpYW5zID0gZm92eSAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgICBhc3BlY3QgPSBOdW1iZXIuaXNGaW5pdGUoYXNwZWN0KSA/IGFzcGVjdCA6IHdpZHRoIC8gaGVpZ2h0O1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUGVyc3BlY3RpdmVWaWV3cG9ydC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBlcnNwZWN0aXZlVmlld3BvcnQpKS5jYWxsKHRoaXMsIHtcbiAgICAgIHZpZXdNYXRyaXg6IG1hdDQubG9va0F0KFtdLCBleWUsIGxvb2tBdCwgdXApLFxuICAgICAgcHJvamVjdGlvbk1hdHJpeDogbWF0NC5wZXJzcGVjdGl2ZShbXSwgZm92eVJhZGlhbnMsIGFzcGVjdCwgbmVhciwgZmFyKSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIFBlcnNwZWN0aXZlVmlld3BvcnQ7XG59KFZpZXdwb3J0KTtcblxuZXhwb3J0IGRlZmF1bHQgUGVyc3BlY3RpdmVWaWV3cG9ydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdmlld3BvcnRzL3BlcnNwZWN0aXZlLXZpZXdwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 26 */
/* exports provided: isSimple, normalize, getVertexCount, getTriangleCount, forEachVertex */
/* exports used: normalize, getVertexCount, getTriangleCount, forEachVertex */
/*!**************************************************!*\
  !*** ./src/layers/core/polygon-layer/polygon.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\n/* unused harmony export isSimple */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = normalize;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = getVertexCount;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = getTriangleCount;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = forEachVertex;\n\n\n// Basic polygon support\n//\n// Handles simple and complex polygons\n// Simple polygons are arrays of vertices, implicitly \"closed\"\n// Complex polygons are arrays of simple polygons, with the first polygon\n// representing the outer hull and other polygons representing holes\n\n/**\n * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Normalize to ensure that all polygons in a list are complex - simplifies processing\n * @param {Array} polygon - either a complex or a simple polygon\n * @param {Object} opts\n * @param {Object} opts.dimensions - if 3, the coords will be padded with 0's if needed\n * @return {Array} - returns a complex polygons\n */\nfunction normalize(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$dimensions = _ref.dimensions,\n      dimensions = _ref$dimensions === undefined ? 3 : _ref$dimensions;\n\n  return isSimple(polygon) ? [polygon] : polygon;\n}\n\n/**\n * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction getVertexCount(polygon) {\n  return isSimple(polygon) ? __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].count(polygon) : polygon.reduce(function (count, simplePolygon) {\n    return count + __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].count(simplePolygon);\n  }, 0);\n}\n\n// Return number of triangles needed to tesselate the polygon\nfunction getTriangleCount(polygon) {\n  var triangleCount = 0;\n  var first = true;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = normalize(polygon)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var simplePolygon = _step.value;\n\n      var size = __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].count(simplePolygon);\n      if (first) {\n        triangleCount += size > 3 ? size - 3 : 0;\n      } else {\n        triangleCount += size + 1;\n      }\n      first = false;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return triangleCount;\n}\n\nfunction forEachVertex(polygon, visitor) {\n  if (isSimple(polygon)) {\n    __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].forEach(polygon, visitor);\n    return;\n  }\n\n  var vertexIndex = 0;\n  __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].forEach(polygon, function (simplePolygon) {\n    __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].forEach(simplePolygon, function (v, i, p) {\n      return visitor(v, vertexIndex, polygon);\n    });\n    vertexIndex++;\n  });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9seWdvbi1sYXllci9wb2x5Z29uLmpzPzA0NWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcblxuLy8gQmFzaWMgcG9seWdvbiBzdXBwb3J0XG4vL1xuLy8gSGFuZGxlcyBzaW1wbGUgYW5kIGNvbXBsZXggcG9seWdvbnNcbi8vIFNpbXBsZSBwb2x5Z29ucyBhcmUgYXJyYXlzIG9mIHZlcnRpY2VzLCBpbXBsaWNpdGx5IFwiY2xvc2VkXCJcbi8vIENvbXBsZXggcG9seWdvbnMgYXJlIGFycmF5cyBvZiBzaW1wbGUgcG9seWdvbnMsIHdpdGggdGhlIGZpcnN0IHBvbHlnb25cbi8vIHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgaHVsbCBhbmQgb3RoZXIgcG9seWdvbnMgcmVwcmVzZW50aW5nIGhvbGVzXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBpcyBhIG5vbi1uZXN0ZWQgcG9seWdvbiAoaS5lLiB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpcyBhIG51bWJlcilcbiAqIEBwYXJhbSB7QXJyYXl9IHBvbHlnb24gLSBlaXRoZXIgYSBjb21wbGV4IG9yIHNpbXBsZSBwb2x5Z29uXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgdGhlIHBvbHlnb24gaXMgYSBzaW1wbGUgcG9seWdvbiAoaS5lLiBub3QgYW4gYXJyYXkgb2YgcG9seWdvbnMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NpbXBsZShwb2x5Z29uKSB7XG4gIHJldHVybiBwb2x5Z29uLmxlbmd0aCA+PSAxICYmIHBvbHlnb25bMF0ubGVuZ3RoID49IDIgJiYgTnVtYmVyLmlzRmluaXRlKHBvbHlnb25bMF1bMF0pO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0byBlbnN1cmUgdGhhdCBhbGwgcG9seWdvbnMgaW4gYSBsaXN0IGFyZSBjb21wbGV4IC0gc2ltcGxpZmllcyBwcm9jZXNzaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwb2x5Z29uIC0gZWl0aGVyIGEgY29tcGxleCBvciBhIHNpbXBsZSBwb2x5Z29uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGltZW5zaW9ucyAtIGlmIDMsIHRoZSBjb29yZHMgd2lsbCBiZSBwYWRkZWQgd2l0aCAwJ3MgaWYgbmVlZGVkXG4gKiBAcmV0dXJuIHtBcnJheX0gLSByZXR1cm5zIGEgY29tcGxleCBwb2x5Z29uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHBvbHlnb24pIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZiRkaW1lbnNpb25zID0gX3JlZi5kaW1lbnNpb25zLFxuICAgICAgZGltZW5zaW9ucyA9IF9yZWYkZGltZW5zaW9ucyA9PT0gdW5kZWZpbmVkID8gMyA6IF9yZWYkZGltZW5zaW9ucztcblxuICByZXR1cm4gaXNTaW1wbGUocG9seWdvbikgPyBbcG9seWdvbl0gOiBwb2x5Z29uO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgaXMgYSBub24tbmVzdGVkIHBvbHlnb24gKGkuZS4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaXMgYSBudW1iZXIpXG4gKiBAcGFyYW0ge0FycmF5fSBwb2x5Z29uIC0gZWl0aGVyIGEgY29tcGxleCBvciBzaW1wbGUgcG9seWdvblxuICogQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHRoZSBwb2x5Z29uIGlzIGEgc2ltcGxlIHBvbHlnb24gKGkuZS4gbm90IGFuIGFycmF5IG9mIHBvbHlnb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVydGV4Q291bnQocG9seWdvbikge1xuICByZXR1cm4gaXNTaW1wbGUocG9seWdvbikgPyBDb250YWluZXIuY291bnQocG9seWdvbikgOiBwb2x5Z29uLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIHNpbXBsZVBvbHlnb24pIHtcbiAgICByZXR1cm4gY291bnQgKyBDb250YWluZXIuY291bnQoc2ltcGxlUG9seWdvbik7XG4gIH0sIDApO1xufVxuXG4vLyBSZXR1cm4gbnVtYmVyIG9mIHRyaWFuZ2xlcyBuZWVkZWQgdG8gdGVzc2VsYXRlIHRoZSBwb2x5Z29uXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJpYW5nbGVDb3VudChwb2x5Z29uKSB7XG4gIHZhciB0cmlhbmdsZUNvdW50ID0gMDtcbiAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbm9ybWFsaXplKHBvbHlnb24pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIHNpbXBsZVBvbHlnb24gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgdmFyIHNpemUgPSBDb250YWluZXIuY291bnQoc2ltcGxlUG9seWdvbik7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgdHJpYW5nbGVDb3VudCArPSBzaXplID4gMyA/IHNpemUgLSAzIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyaWFuZ2xlQ291bnQgKz0gc2l6ZSArIDE7XG4gICAgICB9XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJpYW5nbGVDb3VudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hWZXJ0ZXgocG9seWdvbiwgdmlzaXRvcikge1xuICBpZiAoaXNTaW1wbGUocG9seWdvbikpIHtcbiAgICBDb250YWluZXIuZm9yRWFjaChwb2x5Z29uLCB2aXNpdG9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmVydGV4SW5kZXggPSAwO1xuICBDb250YWluZXIuZm9yRWFjaChwb2x5Z29uLCBmdW5jdGlvbiAoc2ltcGxlUG9seWdvbikge1xuICAgIENvbnRhaW5lci5mb3JFYWNoKHNpbXBsZVBvbHlnb24sIGZ1bmN0aW9uICh2LCBpLCBwKSB7XG4gICAgICByZXR1cm4gdmlzaXRvcih2LCB2ZXJ0ZXhJbmRleCwgcG9seWdvbik7XG4gICAgfSk7XG4gICAgdmVydGV4SW5kZXgrKztcbiAgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvcG9seWdvbi1sYXllci9wb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 27 */
/* exports provided: glArrayFromType, default */
/* exports used: default */
/*!**************************************!*\
  !*** ./src/lib/attribute-manager.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(/*! ./utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);\n/* unused harmony export glArrayFromType */\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable guard-for-in */\n\n\n\n\nfunction noop() {}\n\n/* eslint-disable complexity */\nfunction glArrayFromType(glType) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$clamped = _ref.clamped,\n      clamped = _ref$clamped === undefined ? true : _ref$clamped;\n\n  // Sorted in some order of likelihood to reduce amount of comparisons\n  switch (glType) {\n    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].FLOAT:\n      return Float32Array;\n    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_SHORT:\n    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_SHORT_5_6_5:\n    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_SHORT_4_4_4_4:\n    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_SHORT_5_5_5_1:\n      return Uint16Array;\n    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_INT:\n      return Uint32Array;\n    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_BYTE:\n      return clamped ? Uint8ClampedArray : Uint8Array;\n    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].BYTE:\n      return Int8Array;\n    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].SHORT:\n      return Int16Array;\n    case __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].INT:\n      return Int32Array;\n    default:\n      throw new Error('Failed to deduce type from array');\n  }\n}\n/* eslint-enable complexity */\n\nvar AttributeManager = function () {\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   *\n   * Summary:\n   * - keeps track of valid state for each attribute\n   * - auto reallocates attributes when needed\n   * - auto updates attributes with registered updater functions\n   * - allows overriding with application supplied buffers\n   *\n   * Limitations:\n   * - There are currently no provisions for only invalidating a range of\n   *   indices in an attribute.\n   *\n   * @class\n   * @param {Object} [props]\n   * @param {String} [props.id] - identifier (for debugging)\n   */\n  function AttributeManager() {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$id = _ref2.id,\n        id = _ref2$id === undefined ? 'attribute-manager' : _ref2$id;\n\n    _classCallCheck(this, AttributeManager);\n\n    this.id = id;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.allocedInstances = -1;\n    this.needsRedraw = true;\n    this.userData = {};\n\n    this.onUpdateStart = noop;\n    this.onUpdateEnd = noop;\n    this.onLog = this._defaultLog;\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  /**\n   * Adds attributes\n   * Takes a map of attribute descriptor objects\n   * - keys are attribute names\n   * - values are objects with attribute fields\n   *\n   * attribute.size - number of elements per object\n   * attribute.updater - number of elements\n   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)\n   * attribute.noAlloc=false - if this attribute should not be allocated\n   *\n   * @example\n   * attributeManager.add({\n   *   positions: {size: 2, update: calculatePositions}\n   *   colors: {size: 3, update: calculateColors}\n   * });\n   *\n   * @param {Object} attributes - attribute map (see above)\n   * @param {Object} updaters - separate map of update functions (deprecated)\n   */\n\n\n  _createClass(AttributeManager, [{\n    key: 'add',\n    value: function add(attributes) {\n      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._add(attributes, updaters);\n    }\n\n    /**\n      * Removes attributes\n      * Takes an array of attribute names and delete them from\n      * the attribute map if they exists\n      *\n      * @example\n      * attributeManager.remove(['position']);\n      *\n      * @param {Object} attributeNameArray - attribute name array (see above)\n      */\n\n  }, {\n    key: 'remove',\n    value: function remove(attributeNameArray) {\n      for (var i = 0; i < attributeNameArray.length; i++) {\n        var name = attributeNameArray[i];\n        if (this.attributes[name] !== undefined) {\n          delete this.attributes[name];\n        }\n      }\n    }\n\n    /* Marks an attribute for update\n     * @param {string} triggerName: attribute or accessor name\n     */\n\n  }, {\n    key: 'invalidate',\n    value: function invalidate(triggerName) {\n      var attributes = this.attributes,\n          updateTriggers = this.updateTriggers;\n\n      var attributesToUpdate = updateTriggers[triggerName];\n\n      if (!attributesToUpdate) {\n        var message = 'invalidating non-existent attribute ' + triggerName + ' for ' + this.id + '\\n';\n        message += 'Valid attributes: ' + Object.keys(attributes).join(', ');\n        __WEBPACK_IMPORTED_MODULE_2_assert___default()(attributesToUpdate, message);\n      }\n      attributesToUpdate.forEach(function (name) {\n        var attribute = attributes[name];\n        if (attribute) {\n          attribute.needsUpdate = true;\n        }\n      });\n      // For performance tuning\n      this.onLog(1, 'invalidated attribute ' + attributesToUpdate + ' for ' + this.id);\n    }\n  }, {\n    key: 'invalidateAll',\n    value: function invalidateAll() {\n      var attributes = this.attributes;\n\n      for (var attributeName in attributes) {\n        this.invalidate(attributeName);\n      }\n    }\n\n    /**\n     * Ensure all attribute buffers are updated from props or data.\n     *\n     * Note: Any preallocated buffers in \"buffers\" matching registered attribute\n     * names will be used. No update will happen in this case.\n     * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.\n     *\n     * @param {Object} opts - options\n     * @param {Object} opts.data - data (iterable object)\n     * @param {Object} opts.numInstances - count of data\n     * @param {Object} opts.buffers = {} - pre-allocated buffers\n     * @param {Object} opts.props - passed to updaters\n     * @param {Object} opts.context - Used as \"this\" context for updaters\n     */\n\n  }, {\n    key: 'update',\n    value: function update() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          data = _ref3.data,\n          numInstances = _ref3.numInstances,\n          _ref3$props = _ref3.props,\n          props = _ref3$props === undefined ? {} : _ref3$props,\n          _ref3$buffers = _ref3.buffers,\n          buffers = _ref3$buffers === undefined ? {} : _ref3$buffers,\n          _ref3$context = _ref3.context,\n          context = _ref3$context === undefined ? {} : _ref3$context,\n          _ref3$ignoreUnknownAt = _ref3.ignoreUnknownAttributes,\n          ignoreUnknownAttributes = _ref3$ignoreUnknownAt === undefined ? false : _ref3$ignoreUnknownAt;\n\n      // First apply any application provided buffers\n      this._checkExternalBuffers({ buffers: buffers, ignoreUnknownAttributes: ignoreUnknownAttributes });\n      this._setExternalBuffers(buffers);\n\n      // Only initiate alloc/update (and logging) if actually needed\n      if (this._analyzeBuffers({ numInstances: numInstances })) {\n        this.onUpdateStart(this.id);\n        this._updateBuffers({ numInstances: numInstances, data: data, props: props, context: context });\n        this.onUpdateEnd(this.id);\n      }\n    }\n\n    /**\n     * Sets log functions to help trace or time attribute updates.\n     * Default logging uses luma logger.\n     *\n     * Note that the app may not be in control of when update is called,\n     * so hooks are provided for update start and end.\n     *\n     * @param {Object} [opts]\n     * @param {String} [opts.onLog=] - called to print\n     * @param {String} [opts.onUpdateStart=] - called before update() starts\n     * @param {String} [opts.onUpdateEnd=] - called after update() ends\n     */\n\n  }, {\n    key: 'setLogFunctions',\n    value: function setLogFunctions() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          onLog = _ref4.onLog,\n          onUpdateStart = _ref4.onUpdateStart,\n          onUpdateEnd = _ref4.onUpdateEnd;\n\n      this.onLog = onLog !== undefined ? onLog : this.onLog;\n      this.onUpdateStart = onUpdateStart !== undefined ? onUpdateStart : this.onUpdateStart;\n      this.onUpdateEnd = onUpdateEnd !== undefined ? onUpdateEnd : this.onUpdateEnd;\n    }\n\n    /**\n     * Returns all attribute descriptors\n     * Note: Format matches luma.gl Model/Program.setAttributes()\n     * @return {Object} attributes - descriptors\n     */\n\n  }, {\n    key: 'getAttributes',\n    value: function getAttributes() {\n      return this.attributes;\n    }\n\n    /**\n     * Returns changed attribute descriptors\n     * This indicates which WebGLBuggers need to be updated\n     * @return {Object} attributes - descriptors\n     */\n\n  }, {\n    key: 'getChangedAttributes',\n    value: function getChangedAttributes(_ref5) {\n      var _ref5$clearChangedFla = _ref5.clearChangedFlags,\n          clearChangedFlags = _ref5$clearChangedFla === undefined ? false : _ref5$clearChangedFla;\n      var attributes = this.attributes;\n\n      var changedAttributes = {};\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        if (attribute.changed) {\n          attribute.changed = attribute.changed && !clearChangedFlags;\n          changedAttributes[attributeName] = attribute;\n        }\n      }\n      return changedAttributes;\n    }\n\n    /**\n     * Returns the redraw flag, optionally clearing it.\n     * Redraw flag will be set if any attributes attributes changed since\n     * flag was last cleared.\n     *\n     * @param {Object} [opts]\n     * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag\n     * @return {Boolean} - whether a redraw is needed.\n     */\n\n  }, {\n    key: 'getNeedsRedraw',\n    value: function getNeedsRedraw() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref6$clearRedrawFlag = _ref6.clearRedrawFlags,\n          clearRedrawFlags = _ref6$clearRedrawFlag === undefined ? false : _ref6$clearRedrawFlag;\n\n      var redraw = this.needsRedraw;\n      redraw = redraw || this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n      return redraw;\n    }\n\n    /**\n     * Sets the redraw flag.\n     * @param {Boolean} redraw=true\n     * @return {AttributeManager} - for chaining\n     */\n\n  }, {\n    key: 'setNeedsRedraw',\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      this.needsRedraw = true;\n      return this;\n    }\n\n    // DEPRECATED METHODS\n\n    /**\n     * @deprecated since version 2.5, use add() instead\n     * Adds attributes\n     * @param {Object} attributes - attribute map (see above)\n     * @param {Object} updaters - separate map of update functions (deprecated)\n     */\n\n  }, {\n    key: 'addDynamic',\n    value: function addDynamic(attributes) {\n      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._add(attributes, updaters);\n    }\n\n    /**\n     * @deprecated since version 2.5, use add() instead\n     * Adds attributes\n     * @param {Object} attributes - attribute map (see above)\n     * @param {Object} updaters - separate map of update functions (deprecated)\n     */\n\n  }, {\n    key: 'addInstanced',\n    value: function addInstanced(attributes) {\n      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._add(attributes, updaters, { instanced: 1 });\n    }\n\n    // PRIVATE METHODS\n\n    // Default logger\n\n  }, {\n    key: '_defaultLog',\n    value: function _defaultLog(level, message) {\n      __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].log(level, message);\n    }\n\n    // Used to register an attribute\n\n  }, {\n    key: '_add',\n    value: function _add(attributes) {\n      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var newAttributes = {};\n\n      for (var attributeName in attributes) {\n        // support for separate update function map\n        // For now, just copy any attributes from that map into the main map\n        // TODO - Attribute maps are a deprecated feature, remove\n        if (attributeName in updaters) {\n          attributes[attributeName] = Object.assign({}, attributes[attributeName], updaters[attributeName]);\n        }\n\n        var attribute = attributes[attributeName];\n\n        var isIndexed = attribute.isIndexed || attribute.elements;\n        var size = attribute.elements && 1 || attribute.size;\n        var value = attribute.value || null;\n\n        // Initialize the attribute descriptor, with WebGL and metadata fields\n        var attributeData = Object.assign({\n          // Ensure that fields are present before Object.seal()\n          target: undefined,\n          userData: {} // Reserved for application\n        },\n        // Metadata\n        attribute, {\n          // State\n          isExternalBuffer: false,\n          needsAlloc: false,\n          needsUpdate: false,\n          changed: false,\n\n          // Luma fields\n          isIndexed: isIndexed,\n          size: size,\n          value: value\n        }, _extraProps);\n        // Sanity - no app fields on our attributes. Use userData instead.\n        Object.seal(attributeData);\n\n        // Check all fields and generate helpful error messages\n        this._validateAttributeDefinition(attributeName, attributeData);\n\n        // Add to both attributes list (for registration with model)\n        newAttributes[attributeName] = attributeData;\n      }\n\n      Object.assign(this.attributes, newAttributes);\n\n      this._mapUpdateTriggersToAttributes();\n    }\n\n    // build updateTrigger name to attribute name mapping\n\n  }, {\n    key: '_mapUpdateTriggersToAttributes',\n    value: function _mapUpdateTriggersToAttributes() {\n      var _this = this;\n\n      var triggers = {};\n\n      var _loop = function _loop(attributeName) {\n        var attribute = _this.attributes[attributeName];\n        var accessor = attribute.accessor;\n\n        // use attribute name as update trigger key\n\n        triggers[attributeName] = [attributeName];\n\n        // use accessor name as update trigger key\n        if (typeof accessor === 'string') {\n          accessor = [accessor];\n        }\n        if (Array.isArray(accessor)) {\n          accessor.forEach(function (accessorName) {\n            if (!triggers[accessorName]) {\n              triggers[accessorName] = [];\n            }\n            triggers[accessorName].push(attributeName);\n          });\n        }\n      };\n\n      for (var attributeName in this.attributes) {\n        _loop(attributeName);\n      }\n\n      this.updateTriggers = triggers;\n    }\n  }, {\n    key: '_validateAttributeDefinition',\n    value: function _validateAttributeDefinition(attributeName, attribute) {\n      __WEBPACK_IMPORTED_MODULE_2_assert___default()(attribute.size >= 1 && attribute.size <= 4, 'Attribute definition for ' + attributeName + ' invalid size');\n\n      // Check that either 'accessor' or 'update' is a valid function\n      var hasUpdater = attribute.noAlloc || typeof attribute.update === 'function' || typeof attribute.accessor === 'string';\n      if (!hasUpdater) {\n        throw new Error('Attribute ' + attributeName + ' missing update or accessor');\n      }\n    }\n\n    // Checks that any attribute buffers in props are valid\n    // Note: This is just to help app catch mistakes\n\n  }, {\n    key: '_checkExternalBuffers',\n    value: function _checkExternalBuffers() {\n      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref7$buffers = _ref7.buffers,\n          buffers = _ref7$buffers === undefined ? {} : _ref7$buffers,\n          _ref7$ignoreUnknownAt = _ref7.ignoreUnknownAttributes,\n          ignoreUnknownAttributes = _ref7$ignoreUnknownAt === undefined ? false : _ref7$ignoreUnknownAt;\n\n      var attributes = this.attributes;\n\n      for (var attributeName in buffers) {\n        var attribute = attributes[attributeName];\n        if (!attribute && !ignoreUnknownAttributes) {\n          throw new Error('Unknown attribute prop ' + attributeName);\n        }\n        // const buffer = buffers[attributeName];\n        // TODO - check buffer type\n      }\n    }\n\n    // Set the buffers for the supplied attributes\n    // Update attribute buffers from any attributes in props\n    // Detach any previously set buffers, marking all\n    // Attributes for auto allocation\n    /* eslint-disable max-statements */\n\n  }, {\n    key: '_setExternalBuffers',\n    value: function _setExternalBuffers(bufferMap) {\n      var attributes = this.attributes,\n          numInstances = this.numInstances;\n\n      // Copy the refs of any supplied buffers in the props\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        var buffer = bufferMap[attributeName];\n        attribute.isExternalBuffer = false;\n        if (buffer) {\n          if (!(buffer instanceof Float32Array)) {\n            throw new Error('Attribute properties must be of type Float32Array');\n          }\n          if (attribute.auto && buffer.length <= numInstances * attribute.size) {\n            throw new Error('Attribute prop array must match length and size');\n          }\n\n          attribute.isExternalBuffer = true;\n          attribute.needsUpdate = false;\n          if (attribute.value !== buffer) {\n            attribute.value = buffer;\n            attribute.changed = true;\n            this.needsRedraw = true;\n          }\n        }\n      }\n    }\n    /* eslint-enable max-statements */\n\n    /* Checks that typed arrays for attributes are big enough\n     * sets alloc flag if not\n     * @return {Boolean} whether any updates are needed\n     */\n\n  }, {\n    key: '_analyzeBuffers',\n    value: function _analyzeBuffers(_ref8) {\n      var numInstances = _ref8.numInstances;\n      var attributes = this.attributes;\n\n      __WEBPACK_IMPORTED_MODULE_2_assert___default()(numInstances !== undefined, 'numInstances not defined');\n\n      // Track whether any allocations or updates are needed\n      var needsUpdate = false;\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        if (!attribute.isExternalBuffer) {\n          // Do we need to reallocate the attribute's typed array?\n          var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;\n          if (needsAlloc && (attribute.update || attribute.accessor)) {\n            attribute.needsAlloc = true;\n            needsUpdate = true;\n          }\n          if (attribute.needsUpdate) {\n            needsUpdate = true;\n          }\n        }\n      }\n\n      return needsUpdate;\n    }\n\n    /**\n     * @private\n     * Calls update on any buffers that need update\n     * TODO? - If app supplied all attributes, no need to iterate over data\n     *\n     * @param {Object} opts - options\n     * @param {Object} opts.data - data (iterable object)\n     * @param {Object} opts.numInstances - count of data\n     * @param {Object} opts.buffers = {} - pre-allocated buffers\n     * @param {Object} opts.props - passed to updaters\n     * @param {Object} opts.context - Used as \"this\" context for updaters\n     */\n    /* eslint-disable max-statements, complexity */\n\n  }, {\n    key: '_updateBuffers',\n    value: function _updateBuffers(_ref9) {\n      var numInstances = _ref9.numInstances,\n          data = _ref9.data,\n          props = _ref9.props,\n          context = _ref9.context;\n      var attributes = this.attributes;\n\n      // Allocate at least one element to ensure a valid buffer\n\n      var allocCount = Math.max(numInstances, 1);\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n\n        // Allocate a new typed array if needed\n        if (attribute.needsAlloc) {\n          var ArrayType = glArrayFromType(attribute.type || __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].FLOAT);\n          attribute.value = new ArrayType(attribute.size * allocCount);\n          this.onLog(2, this.id + ':' + attributeName + ' allocated ' + allocCount);\n          attribute.needsAlloc = false;\n          attribute.needsUpdate = true;\n        }\n\n        // Call updater function if needed\n        if (attribute.needsUpdate) {\n          this._updateBuffer({ attribute: attribute, attributeName: attributeName, numInstances: numInstances, data: data, props: props, context: context });\n        }\n      }\n\n      this.allocedInstances = allocCount;\n    }\n  }, {\n    key: '_updateBuffer',\n    value: function _updateBuffer(_ref10) {\n      var attribute = _ref10.attribute,\n          attributeName = _ref10.attributeName,\n          numInstances = _ref10.numInstances,\n          data = _ref10.data,\n          props = _ref10.props,\n          context = _ref10.context;\n      var update = attribute.update,\n          accessor = attribute.accessor;\n\n      if (update) {\n        // Custom updater - typically for non-instanced layers\n        this.onLog(2, this.id + ':' + attributeName + ' updating ' + numInstances);\n        update.call(context, attribute, { data: data, props: props, numInstances: numInstances });\n        this._checkAttributeArray(attribute, attributeName);\n      } else if (accessor) {\n        // Standard updater\n        this._updateBufferViaStandardAccessor({ attribute: attribute, data: data, props: props });\n        this._checkAttributeArray(attribute, attributeName);\n      } else {\n        this.onLog(2, this.id + ':' + attributeName + ' missing update function');\n      }\n\n      attribute.needsUpdate = false;\n      attribute.changed = true;\n      this.needsRedraw = true;\n    }\n    /* eslint-enable max-statements */\n\n  }, {\n    key: '_updateBufferViaStandardAccessor',\n    value: function _updateBufferViaStandardAccessor(_ref11) {\n      var attribute = _ref11.attribute,\n          data = _ref11.data,\n          props = _ref11.props;\n      var accessor = attribute.accessor,\n          value = attribute.value,\n          size = attribute.size;\n\n      var accessorFunc = props[accessor];\n\n      __WEBPACK_IMPORTED_MODULE_2_assert___default()(typeof accessorFunc === 'function', 'accessor \"' + accessor + '\" is not a function');\n\n      var _attribute$defaultVal = attribute.defaultValue,\n          defaultValue = _attribute$defaultVal === undefined ? [0, 0, 0, 0] : _attribute$defaultVal;\n\n      defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n\n          var objectValue = accessorFunc(object);\n          objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];\n          /* eslint-disable no-fallthrough, default-case */\n          switch (size) {\n            case 4:\n              value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];\n            case 3:\n              value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];\n            case 2:\n              value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];\n            case 1:\n              value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];\n          }\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: '_checkAttributeArray',\n    value: function _checkAttributeArray(attribute, attributeName) {\n      var value = attribute.value;\n\n      if (value && value.length >= 4) {\n        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);\n        if (!valid) {\n          throw new Error('Illegal attribute generated for ' + attributeName);\n        }\n      }\n    }\n  }]);\n\n  return AttributeManager;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = AttributeManager;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2F0dHJpYnV0ZS1tYW5hZ2VyLmpzPzM0ZWYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG5pbXBvcnQgeyBHTCB9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5leHBvcnQgZnVuY3Rpb24gZ2xBcnJheUZyb21UeXBlKGdsVHlwZSkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICBfcmVmJGNsYW1wZWQgPSBfcmVmLmNsYW1wZWQsXG4gICAgICBjbGFtcGVkID0gX3JlZiRjbGFtcGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRjbGFtcGVkO1xuXG4gIC8vIFNvcnRlZCBpbiBzb21lIG9yZGVyIG9mIGxpa2VsaWhvb2QgdG8gcmVkdWNlIGFtb3VudCBvZiBjb21wYXJpc29uc1xuICBzd2l0Y2ggKGdsVHlwZSkge1xuICAgIGNhc2UgR0wuRkxPQVQ6XG4gICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgIGNhc2UgR0wuVU5TSUdORURfU0hPUlQ6XG4gICAgY2FzZSBHTC5VTlNJR05FRF9TSE9SVF81XzZfNTpcbiAgICBjYXNlIEdMLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ6XG4gICAgY2FzZSBHTC5VTlNJR05FRF9TSE9SVF81XzVfNV8xOlxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgIGNhc2UgR0wuVU5TSUdORURfSU5UOlxuICAgICAgcmV0dXJuIFVpbnQzMkFycmF5O1xuICAgIGNhc2UgR0wuVU5TSUdORURfQllURTpcbiAgICAgIHJldHVybiBjbGFtcGVkID8gVWludDhDbGFtcGVkQXJyYXkgOiBVaW50OEFycmF5O1xuICAgIGNhc2UgR0wuQllURTpcbiAgICAgIHJldHVybiBJbnQ4QXJyYXk7XG4gICAgY2FzZSBHTC5TSE9SVDpcbiAgICAgIHJldHVybiBJbnQxNkFycmF5O1xuICAgIGNhc2UgR0wuSU5UOlxuICAgICAgcmV0dXJuIEludDMyQXJyYXk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlZHVjZSB0eXBlIGZyb20gYXJyYXknKTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbnZhciBBdHRyaWJ1dGVNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBBdXRvbWF0ZWQgYXR0cmlidXRlIGdlbmVyYXRpb24gYW5kIG1hbmFnZW1lbnQuIFN1aXRhYmxlIHdoZW4gYSBzZXQgb2ZcbiAgICogdmVydGV4IHNoYWRlciBhdHRyaWJ1dGVzIGFyZSBnZW5lcmF0ZWQgYnkgaXRlcmF0aW9uIG92ZXIgYSBkYXRhIGFycmF5LFxuICAgKiBhbmQgdXBkYXRlcyB0byB0aGVzZSBhdHRyaWJ1dGVzIGFyZSBuZWVkZWQgZWl0aGVyIHdoZW4gdGhlIGRhdGEgaXRzZWxmXG4gICAqIGNoYW5nZXMsIG9yIHdoZW4gb3RoZXIgZGF0YSByZWxldmFudCB0byB0aGUgY2FsY3VsYXRpb25zIGNoYW5nZS5cbiAgICpcbiAgICogLSBGaXJzdCB0aGUgYXBwbGljYXRpb24gcmVnaXN0ZXJzIGRlc2NyaXB0aW9ucyBvZiBpdHMgZHluYW1pYyB2ZXJ0ZXhcbiAgICogICBhdHRyaWJ1dGVzIHVzaW5nIEF0dHJpYnV0ZU1hbmFnZXIuYWRkKCkuXG4gICAqIC0gVGhlbiwgd2hlbiBhbnkgY2hhbmdlIHRoYXQgYWZmZWN0cyBhdHRyaWJ1dGVzIGlzIGRldGVjdGVkIGJ5IHRoZVxuICAgKiAgIGFwcGxpY2F0aW9uLCB0aGUgYXBwIHdpbGwgY2FsbCBBdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUoKS5cbiAgICogLSBGaW5hbGx5IGJlZm9yZSBpdCByZW5kZXJzLCBpdCBjYWxscyBBdHRyaWJ1dGVNYW5hZ2VyLnVwZGF0ZSgpIHRvXG4gICAqICAgZW5zdXJlIHRoYXQgYXR0cmlidXRlcyBhcmUgYXV0b21hdGljYWxseSByZWJ1aWx0IGlmIGFueXRoaW5nIGhhcyBiZWVuXG4gICAqICAgaW52YWxpZGF0ZWQuXG4gICAqXG4gICAqIFRoZSBhcHBsaWNhdGlvbiBwcm92aWRlZCB1cGRhdGUgZnVuY3Rpb25zIGRlc2NyaWJlIGhvdyBhdHRyaWJ1dGVzXG4gICAqIHNob3VsZCBiZSB1cGRhdGVkIGZyb20gYSBkYXRhIGFycmF5IGFuZCBhcmUgZXhwZWN0ZWQgdG8gdHJhdmVyc2VcbiAgICogdGhhdCBkYXRhIGFycmF5IChvciBpdGVyYWJsZSkgYW5kIGZpbGwgaW4gdGhlIGF0dHJpYnV0ZSdzIHR5cGVkIGFycmF5LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGF0dHJpYnV0ZSBtYW5hZ2VyIGludGVudGlvbmFsbHkgZG9lcyBub3QgZG8gYWR2YW5jZWRcbiAgICogY2hhbmdlIGRldGVjdGlvbiwgYnV0IGluc3RlYWQgbWFrZXMgaXQgZWFzeSB0byBidWlsZCBzdWNoIGRldGVjdGlvblxuICAgKiBieSBvZmZlcmluZyB0aGUgYWJpbGl0eSB0byBcImludmFsaWRhdGVcIiBlYWNoIGF0dHJpYnV0ZSBzZXBhcmF0ZWx5LlxuICAgKlxuICAgKiBTdW1tYXJ5OlxuICAgKiAtIGtlZXBzIHRyYWNrIG9mIHZhbGlkIHN0YXRlIGZvciBlYWNoIGF0dHJpYnV0ZVxuICAgKiAtIGF1dG8gcmVhbGxvY2F0ZXMgYXR0cmlidXRlcyB3aGVuIG5lZWRlZFxuICAgKiAtIGF1dG8gdXBkYXRlcyBhdHRyaWJ1dGVzIHdpdGggcmVnaXN0ZXJlZCB1cGRhdGVyIGZ1bmN0aW9uc1xuICAgKiAtIGFsbG93cyBvdmVycmlkaW5nIHdpdGggYXBwbGljYXRpb24gc3VwcGxpZWQgYnVmZmVyc1xuICAgKlxuICAgKiBMaW1pdGF0aW9uczpcbiAgICogLSBUaGVyZSBhcmUgY3VycmVudGx5IG5vIHByb3Zpc2lvbnMgZm9yIG9ubHkgaW52YWxpZGF0aW5nIGEgcmFuZ2Ugb2ZcbiAgICogICBpbmRpY2VzIGluIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcHMuaWRdIC0gaWRlbnRpZmllciAoZm9yIGRlYnVnZ2luZylcbiAgICovXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZU1hbmFnZXIoKSB7XG4gICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZjIkaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgaWQgPSBfcmVmMiRpZCA9PT0gdW5kZWZpbmVkID8gJ2F0dHJpYnV0ZS1tYW5hZ2VyJyA6IF9yZWYyJGlkO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0dHJpYnV0ZU1hbmFnZXIpO1xuXG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMudXBkYXRlVHJpZ2dlcnMgPSB7fTtcbiAgICB0aGlzLmFsbG9jZWRJbnN0YW5jZXMgPSAtMTtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLnVzZXJEYXRhID0ge307XG5cbiAgICB0aGlzLm9uVXBkYXRlU3RhcnQgPSBub29wO1xuICAgIHRoaXMub25VcGRhdGVFbmQgPSBub29wO1xuICAgIHRoaXMub25Mb2cgPSB0aGlzLl9kZWZhdWx0TG9nO1xuXG4gICAgLy8gRm9yIGRlYnVnZ2luZyBzYW5pdHksIHByZXZlbnQgdW5pbml0aWFsaXplZCBtZW1iZXJzXG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhdHRyaWJ1dGVzXG4gICAqIFRha2VzIGEgbWFwIG9mIGF0dHJpYnV0ZSBkZXNjcmlwdG9yIG9iamVjdHNcbiAgICogLSBrZXlzIGFyZSBhdHRyaWJ1dGUgbmFtZXNcbiAgICogLSB2YWx1ZXMgYXJlIG9iamVjdHMgd2l0aCBhdHRyaWJ1dGUgZmllbGRzXG4gICAqXG4gICAqIGF0dHJpYnV0ZS5zaXplIC0gbnVtYmVyIG9mIGVsZW1lbnRzIHBlciBvYmplY3RcbiAgICogYXR0cmlidXRlLnVwZGF0ZXIgLSBudW1iZXIgb2YgZWxlbWVudHNcbiAgICogYXR0cmlidXRlLmluc3RhbmNlZD0wIC0gaXMgdGhpcyBpcyBhbiBpbnN0YW5jZWQgYXR0cmlidXRlIChhLmsuYS4gZGl2aXNvcilcbiAgICogYXR0cmlidXRlLm5vQWxsb2M9ZmFsc2UgLSBpZiB0aGlzIGF0dHJpYnV0ZSBzaG91bGQgbm90IGJlIGFsbG9jYXRlZFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAqICAgcG9zaXRpb25zOiB7c2l6ZTogMiwgdXBkYXRlOiBjYWxjdWxhdGVQb3NpdGlvbnN9XG4gICAqICAgY29sb3JzOiB7c2l6ZTogMywgdXBkYXRlOiBjYWxjdWxhdGVDb2xvcnN9XG4gICAqIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIGF0dHJpYnV0ZSBtYXAgKHNlZSBhYm92ZSlcbiAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXJzIC0gc2VwYXJhdGUgbWFwIG9mIHVwZGF0ZSBmdW5jdGlvbnMgKGRlcHJlY2F0ZWQpXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEF0dHJpYnV0ZU1hbmFnZXIsIFt7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGF0dHJpYnV0ZXMpIHtcbiAgICAgIHZhciB1cGRhdGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHRoaXMuX2FkZChhdHRyaWJ1dGVzLCB1cGRhdGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFJlbW92ZXMgYXR0cmlidXRlc1xuICAgICAgKiBUYWtlcyBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgYW5kIGRlbGV0ZSB0aGVtIGZyb21cbiAgICAgICogdGhlIGF0dHJpYnV0ZSBtYXAgaWYgdGhleSBleGlzdHNcbiAgICAgICpcbiAgICAgICogQGV4YW1wbGVcbiAgICAgICogYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoWydwb3NpdGlvbiddKTtcbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZU5hbWVBcnJheSAtIGF0dHJpYnV0ZSBuYW1lIGFycmF5IChzZWUgYWJvdmUpXG4gICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoYXR0cmlidXRlTmFtZUFycmF5KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZU5hbWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWVBcnJheVtpXTtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE1hcmtzIGFuIGF0dHJpYnV0ZSBmb3IgdXBkYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyaWdnZXJOYW1lOiBhdHRyaWJ1dGUgb3IgYWNjZXNzb3IgbmFtZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnZhbGlkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZSh0cmlnZ2VyTmFtZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcnMgPSB0aGlzLnVwZGF0ZVRyaWdnZXJzO1xuXG4gICAgICB2YXIgYXR0cmlidXRlc1RvVXBkYXRlID0gdXBkYXRlVHJpZ2dlcnNbdHJpZ2dlck5hbWVdO1xuXG4gICAgICBpZiAoIWF0dHJpYnV0ZXNUb1VwZGF0ZSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdpbnZhbGlkYXRpbmcgbm9uLWV4aXN0ZW50IGF0dHJpYnV0ZSAnICsgdHJpZ2dlck5hbWUgKyAnIGZvciAnICsgdGhpcy5pZCArICdcXG4nO1xuICAgICAgICBtZXNzYWdlICs9ICdWYWxpZCBhdHRyaWJ1dGVzOiAnICsgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuam9pbignLCAnKTtcbiAgICAgICAgYXNzZXJ0KGF0dHJpYnV0ZXNUb1VwZGF0ZSwgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzVG9VcGRhdGUuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZSkge1xuICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gRm9yIHBlcmZvcm1hbmNlIHR1bmluZ1xuICAgICAgdGhpcy5vbkxvZygxLCAnaW52YWxpZGF0ZWQgYXR0cmlidXRlICcgKyBhdHRyaWJ1dGVzVG9VcGRhdGUgKyAnIGZvciAnICsgdGhpcy5pZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW52YWxpZGF0ZUFsbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGVBbGwoKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgICAgZm9yICh2YXIgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgYWxsIGF0dHJpYnV0ZSBidWZmZXJzIGFyZSB1cGRhdGVkIGZyb20gcHJvcHMgb3IgZGF0YS5cbiAgICAgKlxuICAgICAqIE5vdGU6IEFueSBwcmVhbGxvY2F0ZWQgYnVmZmVycyBpbiBcImJ1ZmZlcnNcIiBtYXRjaGluZyByZWdpc3RlcmVkIGF0dHJpYnV0ZVxuICAgICAqIG5hbWVzIHdpbGwgYmUgdXNlZC4gTm8gdXBkYXRlIHdpbGwgaGFwcGVuIGluIHRoaXMgY2FzZS5cbiAgICAgKiBOb3RlOiBDYWxscyBvblVwZGF0ZVN0YXJ0IGFuZCBvblVwZGF0ZUVuZCBsb2cgY2FsbGJhY2tzIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIC0gZGF0YSAoaXRlcmFibGUgb2JqZWN0KVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLm51bUluc3RhbmNlcyAtIGNvdW50IG9mIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5idWZmZXJzID0ge30gLSBwcmUtYWxsb2NhdGVkIGJ1ZmZlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wcm9wcyAtIHBhc3NlZCB0byB1cGRhdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmNvbnRleHQgLSBVc2VkIGFzIFwidGhpc1wiIGNvbnRleHQgZm9yIHVwZGF0ZXJzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgZGF0YSA9IF9yZWYzLmRhdGEsXG4gICAgICAgICAgbnVtSW5zdGFuY2VzID0gX3JlZjMubnVtSW5zdGFuY2VzLFxuICAgICAgICAgIF9yZWYzJHByb3BzID0gX3JlZjMucHJvcHMsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmMyRwcm9wcyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmMyRwcm9wcyxcbiAgICAgICAgICBfcmVmMyRidWZmZXJzID0gX3JlZjMuYnVmZmVycyxcbiAgICAgICAgICBidWZmZXJzID0gX3JlZjMkYnVmZmVycyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmMyRidWZmZXJzLFxuICAgICAgICAgIF9yZWYzJGNvbnRleHQgPSBfcmVmMy5jb250ZXh0LFxuICAgICAgICAgIGNvbnRleHQgPSBfcmVmMyRjb250ZXh0ID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYzJGNvbnRleHQsXG4gICAgICAgICAgX3JlZjMkaWdub3JlVW5rbm93bkF0ID0gX3JlZjMuaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMsXG4gICAgICAgICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMgPSBfcmVmMyRpZ25vcmVVbmtub3duQXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjMkaWdub3JlVW5rbm93bkF0O1xuXG4gICAgICAvLyBGaXJzdCBhcHBseSBhbnkgYXBwbGljYXRpb24gcHJvdmlkZWQgYnVmZmVyc1xuICAgICAgdGhpcy5fY2hlY2tFeHRlcm5hbEJ1ZmZlcnMoeyBidWZmZXJzOiBidWZmZXJzLCBpZ25vcmVVbmtub3duQXR0cmlidXRlczogaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMgfSk7XG4gICAgICB0aGlzLl9zZXRFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVycyk7XG5cbiAgICAgIC8vIE9ubHkgaW5pdGlhdGUgYWxsb2MvdXBkYXRlIChhbmQgbG9nZ2luZykgaWYgYWN0dWFsbHkgbmVlZGVkXG4gICAgICBpZiAodGhpcy5fYW5hbHl6ZUJ1ZmZlcnMoeyBudW1JbnN0YW5jZXM6IG51bUluc3RhbmNlcyB9KSkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlU3RhcnQodGhpcy5pZCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlcnMoeyBudW1JbnN0YW5jZXM6IG51bUluc3RhbmNlcywgZGF0YTogZGF0YSwgcHJvcHM6IHByb3BzLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuICAgICAgICB0aGlzLm9uVXBkYXRlRW5kKHRoaXMuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbG9nIGZ1bmN0aW9ucyB0byBoZWxwIHRyYWNlIG9yIHRpbWUgYXR0cmlidXRlIHVwZGF0ZXMuXG4gICAgICogRGVmYXVsdCBsb2dnaW5nIHVzZXMgbHVtYSBsb2dnZXIuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIGFwcCBtYXkgbm90IGJlIGluIGNvbnRyb2wgb2Ygd2hlbiB1cGRhdGUgaXMgY2FsbGVkLFxuICAgICAqIHNvIGhvb2tzIGFyZSBwcm92aWRlZCBmb3IgdXBkYXRlIHN0YXJ0IGFuZCBlbmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLm9uTG9nPV0gLSBjYWxsZWQgdG8gcHJpbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25VcGRhdGVTdGFydD1dIC0gY2FsbGVkIGJlZm9yZSB1cGRhdGUoKSBzdGFydHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25VcGRhdGVFbmQ9XSAtIGNhbGxlZCBhZnRlciB1cGRhdGUoKSBlbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldExvZ0Z1bmN0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvZ0Z1bmN0aW9ucygpIHtcbiAgICAgIHZhciBfcmVmNCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgb25Mb2cgPSBfcmVmNC5vbkxvZyxcbiAgICAgICAgICBvblVwZGF0ZVN0YXJ0ID0gX3JlZjQub25VcGRhdGVTdGFydCxcbiAgICAgICAgICBvblVwZGF0ZUVuZCA9IF9yZWY0Lm9uVXBkYXRlRW5kO1xuXG4gICAgICB0aGlzLm9uTG9nID0gb25Mb2cgIT09IHVuZGVmaW5lZCA/IG9uTG9nIDogdGhpcy5vbkxvZztcbiAgICAgIHRoaXMub25VcGRhdGVTdGFydCA9IG9uVXBkYXRlU3RhcnQgIT09IHVuZGVmaW5lZCA/IG9uVXBkYXRlU3RhcnQgOiB0aGlzLm9uVXBkYXRlU3RhcnQ7XG4gICAgICB0aGlzLm9uVXBkYXRlRW5kID0gb25VcGRhdGVFbmQgIT09IHVuZGVmaW5lZCA/IG9uVXBkYXRlRW5kIDogdGhpcy5vblVwZGF0ZUVuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBhdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbiAgICAgKiBOb3RlOiBGb3JtYXQgbWF0Y2hlcyBsdW1hLmdsIE1vZGVsL1Byb2dyYW0uc2V0QXR0cmlidXRlcygpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gZGVzY3JpcHRvcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0QXR0cmlidXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2hhbmdlZCBhdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbiAgICAgKiBUaGlzIGluZGljYXRlcyB3aGljaCBXZWJHTEJ1Z2dlcnMgbmVlZCB0byBiZSB1cGRhdGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gZGVzY3JpcHRvcnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGFuZ2VkQXR0cmlidXRlcyhfcmVmNSkge1xuICAgICAgdmFyIF9yZWY1JGNsZWFyQ2hhbmdlZEZsYSA9IF9yZWY1LmNsZWFyQ2hhbmdlZEZsYWdzLFxuICAgICAgICAgIGNsZWFyQ2hhbmdlZEZsYWdzID0gX3JlZjUkY2xlYXJDaGFuZ2VkRmxhID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWY1JGNsZWFyQ2hhbmdlZEZsYTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICB2YXIgY2hhbmdlZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5jaGFuZ2VkKSB7XG4gICAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSBhdHRyaWJ1dGUuY2hhbmdlZCAmJiAhY2xlYXJDaGFuZ2VkRmxhZ3M7XG4gICAgICAgICAgY2hhbmdlZEF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2VkQXR0cmlidXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWRyYXcgZmxhZywgb3B0aW9uYWxseSBjbGVhcmluZyBpdC5cbiAgICAgKiBSZWRyYXcgZmxhZyB3aWxsIGJlIHNldCBpZiBhbnkgYXR0cmlidXRlcyBhdHRyaWJ1dGVzIGNoYW5nZWQgc2luY2VcbiAgICAgKiBmbGFnIHdhcyBsYXN0IGNsZWFyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmNsZWFyUmVkcmF3RmxhZ3M9ZmFsc2VdIC0gd2hldGhlciB0byBjbGVhciB0aGUgZmxhZ1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gd2hldGhlciBhIHJlZHJhdyBpcyBuZWVkZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldE5lZWRzUmVkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmVlZHNSZWRyYXcoKSB7XG4gICAgICB2YXIgX3JlZjYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIF9yZWY2JGNsZWFyUmVkcmF3RmxhZyA9IF9yZWY2LmNsZWFyUmVkcmF3RmxhZ3MsXG4gICAgICAgICAgY2xlYXJSZWRyYXdGbGFncyA9IF9yZWY2JGNsZWFyUmVkcmF3RmxhZyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmNiRjbGVhclJlZHJhd0ZsYWc7XG5cbiAgICAgIHZhciByZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3O1xuICAgICAgcmVkcmF3ID0gcmVkcmF3IHx8IHRoaXMubmVlZHNSZWRyYXc7XG4gICAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdGhpcy5uZWVkc1JlZHJhdyAmJiAhY2xlYXJSZWRyYXdGbGFncztcbiAgICAgIHJldHVybiByZWRyYXc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVkcmF3IGZsYWcuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZWRyYXc9dHJ1ZVxuICAgICAqIEByZXR1cm4ge0F0dHJpYnV0ZU1hbmFnZXJ9IC0gZm9yIGNoYWluaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NldE5lZWRzUmVkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TmVlZHNSZWRyYXcoKSB7XG4gICAgICB2YXIgcmVkcmF3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIERFUFJFQ0FURUQgTUVUSE9EU1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUsIHVzZSBhZGQoKSBpbnN0ZWFkXG4gICAgICogQWRkcyBhdHRyaWJ1dGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXJzIC0gc2VwYXJhdGUgbWFwIG9mIHVwZGF0ZSBmdW5jdGlvbnMgKGRlcHJlY2F0ZWQpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZER5bmFtaWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGREeW5hbWljKGF0dHJpYnV0ZXMpIHtcbiAgICAgIHZhciB1cGRhdGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHRoaXMuX2FkZChhdHRyaWJ1dGVzLCB1cGRhdGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUsIHVzZSBhZGQoKSBpbnN0ZWFkXG4gICAgICogQWRkcyBhdHRyaWJ1dGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgbWFwIChzZWUgYWJvdmUpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXJzIC0gc2VwYXJhdGUgbWFwIG9mIHVwZGF0ZSBmdW5jdGlvbnMgKGRlcHJlY2F0ZWQpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZEluc3RhbmNlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluc3RhbmNlZChhdHRyaWJ1dGVzKSB7XG4gICAgICB2YXIgdXBkYXRlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICB0aGlzLl9hZGQoYXR0cmlidXRlcywgdXBkYXRlcnMsIHsgaW5zdGFuY2VkOiAxIH0pO1xuICAgIH1cblxuICAgIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gICAgLy8gRGVmYXVsdCBsb2dnZXJcblxuICB9LCB7XG4gICAga2V5OiAnX2RlZmF1bHRMb2cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVmYXVsdExvZyhsZXZlbCwgbWVzc2FnZSkge1xuICAgICAgbG9nLmxvZyhsZXZlbCwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLy8gVXNlZCB0byByZWdpc3RlciBhbiBhdHRyaWJ1dGVcblxuICB9LCB7XG4gICAga2V5OiAnX2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGQoYXR0cmlidXRlcykge1xuICAgICAgdmFyIHVwZGF0ZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgdmFyIF9leHRyYVByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgdmFyIG5ld0F0dHJpYnV0ZXMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgZm9yIHNlcGFyYXRlIHVwZGF0ZSBmdW5jdGlvbiBtYXBcbiAgICAgICAgLy8gRm9yIG5vdywganVzdCBjb3B5IGFueSBhdHRyaWJ1dGVzIGZyb20gdGhhdCBtYXAgaW50byB0aGUgbWFpbiBtYXBcbiAgICAgICAgLy8gVE9ETyAtIEF0dHJpYnV0ZSBtYXBzIGFyZSBhIGRlcHJlY2F0ZWQgZmVhdHVyZSwgcmVtb3ZlXG4gICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lIGluIHVwZGF0ZXJzKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0sIHVwZGF0ZXJzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAgIHZhciBpc0luZGV4ZWQgPSBhdHRyaWJ1dGUuaXNJbmRleGVkIHx8IGF0dHJpYnV0ZS5lbGVtZW50cztcbiAgICAgICAgdmFyIHNpemUgPSBhdHRyaWJ1dGUuZWxlbWVudHMgJiYgMSB8fCBhdHRyaWJ1dGUuc2l6ZTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlIHx8IG51bGw7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgYXR0cmlidXRlIGRlc2NyaXB0b3IsIHdpdGggV2ViR0wgYW5kIG1ldGFkYXRhIGZpZWxkc1xuICAgICAgICB2YXIgYXR0cmlidXRlRGF0YSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGZpZWxkcyBhcmUgcHJlc2VudCBiZWZvcmUgT2JqZWN0LnNlYWwoKVxuICAgICAgICAgIHRhcmdldDogdW5kZWZpbmVkLFxuICAgICAgICAgIHVzZXJEYXRhOiB7fSAvLyBSZXNlcnZlZCBmb3IgYXBwbGljYXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWV0YWRhdGFcbiAgICAgICAgYXR0cmlidXRlLCB7XG4gICAgICAgICAgLy8gU3RhdGVcbiAgICAgICAgICBpc0V4dGVybmFsQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICBuZWVkc0FsbG9jOiBmYWxzZSxcbiAgICAgICAgICBuZWVkc1VwZGF0ZTogZmFsc2UsXG4gICAgICAgICAgY2hhbmdlZDogZmFsc2UsXG5cbiAgICAgICAgICAvLyBMdW1hIGZpZWxkc1xuICAgICAgICAgIGlzSW5kZXhlZDogaXNJbmRleGVkLFxuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0sIF9leHRyYVByb3BzKTtcbiAgICAgICAgLy8gU2FuaXR5IC0gbm8gYXBwIGZpZWxkcyBvbiBvdXIgYXR0cmlidXRlcy4gVXNlIHVzZXJEYXRhIGluc3RlYWQuXG4gICAgICAgIE9iamVjdC5zZWFsKGF0dHJpYnV0ZURhdGEpO1xuXG4gICAgICAgIC8vIENoZWNrIGFsbCBmaWVsZHMgYW5kIGdlbmVyYXRlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVBdHRyaWJ1dGVEZWZpbml0aW9uKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZURhdGEpO1xuXG4gICAgICAgIC8vIEFkZCB0byBib3RoIGF0dHJpYnV0ZXMgbGlzdCAoZm9yIHJlZ2lzdHJhdGlvbiB3aXRoIG1vZGVsKVxuICAgICAgICBuZXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlRGF0YTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xuXG4gICAgICB0aGlzLl9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcygpO1xuICAgIH1cblxuICAgIC8vIGJ1aWxkIHVwZGF0ZVRyaWdnZXIgbmFtZSB0byBhdHRyaWJ1dGUgbmFtZSBtYXBwaW5nXG5cbiAgfSwge1xuICAgIGtleTogJ19tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB0cmlnZ2VycyA9IHt9O1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBfdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICB2YXIgYWNjZXNzb3IgPSBhdHRyaWJ1dGUuYWNjZXNzb3I7XG5cbiAgICAgICAgLy8gdXNlIGF0dHJpYnV0ZSBuYW1lIGFzIHVwZGF0ZSB0cmlnZ2VyIGtleVxuXG4gICAgICAgIHRyaWdnZXJzW2F0dHJpYnV0ZU5hbWVdID0gW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAgIC8vIHVzZSBhY2Nlc3NvciBuYW1lIGFzIHVwZGF0ZSB0cmlnZ2VyIGtleVxuICAgICAgICBpZiAodHlwZW9mIGFjY2Vzc29yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGFjY2Vzc29yID0gW2FjY2Vzc29yXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhY2Nlc3NvcikpIHtcbiAgICAgICAgICBhY2Nlc3Nvci5mb3JFYWNoKGZ1bmN0aW9uIChhY2Nlc3Nvck5hbWUpIHtcbiAgICAgICAgICAgIGlmICghdHJpZ2dlcnNbYWNjZXNzb3JOYW1lXSkge1xuICAgICAgICAgICAgICB0cmlnZ2Vyc1thY2Nlc3Nvck5hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2Vyc1thY2Nlc3Nvck5hbWVdLnB1c2goYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIF9sb29wKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVRyaWdnZXJzID0gdHJpZ2dlcnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZUF0dHJpYnV0ZURlZmluaXRpb24oYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlKSB7XG4gICAgICBhc3NlcnQoYXR0cmlidXRlLnNpemUgPj0gMSAmJiBhdHRyaWJ1dGUuc2l6ZSA8PSA0LCAnQXR0cmlidXRlIGRlZmluaXRpb24gZm9yICcgKyBhdHRyaWJ1dGVOYW1lICsgJyBpbnZhbGlkIHNpemUnKTtcblxuICAgICAgLy8gQ2hlY2sgdGhhdCBlaXRoZXIgJ2FjY2Vzc29yJyBvciAndXBkYXRlJyBpcyBhIHZhbGlkIGZ1bmN0aW9uXG4gICAgICB2YXIgaGFzVXBkYXRlciA9IGF0dHJpYnV0ZS5ub0FsbG9jIHx8IHR5cGVvZiBhdHRyaWJ1dGUudXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhdHRyaWJ1dGUuYWNjZXNzb3IgPT09ICdzdHJpbmcnO1xuICAgICAgaWYgKCFoYXNVcGRhdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlICcgKyBhdHRyaWJ1dGVOYW1lICsgJyBtaXNzaW5nIHVwZGF0ZSBvciBhY2Nlc3NvcicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrcyB0aGF0IGFueSBhdHRyaWJ1dGUgYnVmZmVycyBpbiBwcm9wcyBhcmUgdmFsaWRcbiAgICAvLyBOb3RlOiBUaGlzIGlzIGp1c3QgdG8gaGVscCBhcHAgY2F0Y2ggbWlzdGFrZXNcblxuICB9LCB7XG4gICAga2V5OiAnX2NoZWNrRXh0ZXJuYWxCdWZmZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrRXh0ZXJuYWxCdWZmZXJzKCkge1xuICAgICAgdmFyIF9yZWY3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmNyRidWZmZXJzID0gX3JlZjcuYnVmZmVycyxcbiAgICAgICAgICBidWZmZXJzID0gX3JlZjckYnVmZmVycyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmNyRidWZmZXJzLFxuICAgICAgICAgIF9yZWY3JGlnbm9yZVVua25vd25BdCA9IF9yZWY3Lmlnbm9yZVVua25vd25BdHRyaWJ1dGVzLFxuICAgICAgICAgIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzID0gX3JlZjckaWdub3JlVW5rbm93bkF0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWY3JGlnbm9yZVVua25vd25BdDtcblxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgIGZvciAodmFyIGF0dHJpYnV0ZU5hbWUgaW4gYnVmZmVycykge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGUgJiYgIWlnbm9yZVVua25vd25BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGF0dHJpYnV0ZSBwcm9wICcgKyBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zdCBidWZmZXIgPSBidWZmZXJzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAvLyBUT0RPIC0gY2hlY2sgYnVmZmVyIHR5cGVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGJ1ZmZlcnMgZm9yIHRoZSBzdXBwbGllZCBhdHRyaWJ1dGVzXG4gICAgLy8gVXBkYXRlIGF0dHJpYnV0ZSBidWZmZXJzIGZyb20gYW55IGF0dHJpYnV0ZXMgaW4gcHJvcHNcbiAgICAvLyBEZXRhY2ggYW55IHByZXZpb3VzbHkgc2V0IGJ1ZmZlcnMsIG1hcmtpbmcgYWxsXG4gICAgLy8gQXR0cmlidXRlcyBmb3IgYXV0byBhbGxvY2F0aW9uXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3NldEV4dGVybmFsQnVmZmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVyTWFwKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcyxcbiAgICAgICAgICBudW1JbnN0YW5jZXMgPSB0aGlzLm51bUluc3RhbmNlcztcblxuICAgICAgLy8gQ29weSB0aGUgcmVmcyBvZiBhbnkgc3VwcGxpZWQgYnVmZmVycyBpbiB0aGUgcHJvcHNcblxuICAgICAgZm9yICh2YXIgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBhdHRyaWJ1dGUuaXNFeHRlcm5hbEJ1ZmZlciA9IGZhbHNlO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgcHJvcGVydGllcyBtdXN0IGJlIG9mIHR5cGUgRmxvYXQzMkFycmF5Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGUuYXV0byAmJiBidWZmZXIubGVuZ3RoIDw9IG51bUluc3RhbmNlcyAqIGF0dHJpYnV0ZS5zaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSBwcm9wIGFycmF5IG11c3QgbWF0Y2ggbGVuZ3RoIGFuZCBzaXplJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIgPSB0cnVlO1xuICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgIT09IGJ1ZmZlcikge1xuICAgICAgICAgICAgYXR0cmlidXRlLnZhbHVlID0gYnVmZmVyO1xuICAgICAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAgIC8qIENoZWNrcyB0aGF0IHR5cGVkIGFycmF5cyBmb3IgYXR0cmlidXRlcyBhcmUgYmlnIGVub3VnaFxuICAgICAqIHNldHMgYWxsb2MgZmxhZyBpZiBub3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIGFueSB1cGRhdGVzIGFyZSBuZWVkZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2FuYWx5emVCdWZmZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FuYWx5emVCdWZmZXJzKF9yZWY4KSB7XG4gICAgICB2YXIgbnVtSW5zdGFuY2VzID0gX3JlZjgubnVtSW5zdGFuY2VzO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgIGFzc2VydChudW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCwgJ251bUluc3RhbmNlcyBub3QgZGVmaW5lZCcpO1xuXG4gICAgICAvLyBUcmFjayB3aGV0aGVyIGFueSBhbGxvY2F0aW9ucyBvciB1cGRhdGVzIGFyZSBuZWVkZWRcbiAgICAgIHZhciBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGlmICghYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIpIHtcbiAgICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIHJlYWxsb2NhdGUgdGhlIGF0dHJpYnV0ZSdzIHR5cGVkIGFycmF5P1xuICAgICAgICAgIHZhciBuZWVkc0FsbG9jID0gYXR0cmlidXRlLnZhbHVlID09PSBudWxsIHx8IGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZSA8IG51bUluc3RhbmNlcztcbiAgICAgICAgICBpZiAobmVlZHNBbGxvYyAmJiAoYXR0cmlidXRlLnVwZGF0ZSB8fCBhdHRyaWJ1dGUuYWNjZXNzb3IpKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUubmVlZHNBbGxvYyA9IHRydWU7XG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGUubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5lZWRzVXBkYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQ2FsbHMgdXBkYXRlIG9uIGFueSBidWZmZXJzIHRoYXQgbmVlZCB1cGRhdGVcbiAgICAgKiBUT0RPPyAtIElmIGFwcCBzdXBwbGllZCBhbGwgYXR0cmlidXRlcywgbm8gbmVlZCB0byBpdGVyYXRlIG92ZXIgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZGF0YSAtIGRhdGEgKGl0ZXJhYmxlIG9iamVjdClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5udW1JbnN0YW5jZXMgLSBjb3VudCBvZiBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYnVmZmVycyA9IHt9IC0gcHJlLWFsbG9jYXRlZCBidWZmZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvcHMgLSBwYXNzZWQgdG8gdXBkYXRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jb250ZXh0IC0gVXNlZCBhcyBcInRoaXNcIiBjb250ZXh0IGZvciB1cGRhdGVyc1xuICAgICAqL1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVCdWZmZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUJ1ZmZlcnMoX3JlZjkpIHtcbiAgICAgIHZhciBudW1JbnN0YW5jZXMgPSBfcmVmOS5udW1JbnN0YW5jZXMsXG4gICAgICAgICAgZGF0YSA9IF9yZWY5LmRhdGEsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmOS5wcm9wcyxcbiAgICAgICAgICBjb250ZXh0ID0gX3JlZjkuY29udGV4dDtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAvLyBBbGxvY2F0ZSBhdCBsZWFzdCBvbmUgZWxlbWVudCB0byBlbnN1cmUgYSB2YWxpZCBidWZmZXJcblxuICAgICAgdmFyIGFsbG9jQ291bnQgPSBNYXRoLm1heChudW1JbnN0YW5jZXMsIDEpO1xuXG4gICAgICBmb3IgKHZhciBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgICAgLy8gQWxsb2NhdGUgYSBuZXcgdHlwZWQgYXJyYXkgaWYgbmVlZGVkXG4gICAgICAgIGlmIChhdHRyaWJ1dGUubmVlZHNBbGxvYykge1xuICAgICAgICAgIHZhciBBcnJheVR5cGUgPSBnbEFycmF5RnJvbVR5cGUoYXR0cmlidXRlLnR5cGUgfHwgR0wuRkxPQVQpO1xuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBBcnJheVR5cGUoYXR0cmlidXRlLnNpemUgKiBhbGxvY0NvdW50KTtcbiAgICAgICAgICB0aGlzLm9uTG9nKDIsIHRoaXMuaWQgKyAnOicgKyBhdHRyaWJ1dGVOYW1lICsgJyBhbGxvY2F0ZWQgJyArIGFsbG9jQ291bnQpO1xuICAgICAgICAgIGF0dHJpYnV0ZS5uZWVkc0FsbG9jID0gZmFsc2U7XG4gICAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGwgdXBkYXRlciBmdW5jdGlvbiBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlcih7IGF0dHJpYnV0ZTogYXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lOiBhdHRyaWJ1dGVOYW1lLCBudW1JbnN0YW5jZXM6IG51bUluc3RhbmNlcywgZGF0YTogZGF0YSwgcHJvcHM6IHByb3BzLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWxsb2NlZEluc3RhbmNlcyA9IGFsbG9jQ291bnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3VwZGF0ZUJ1ZmZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCdWZmZXIoX3JlZjEwKSB7XG4gICAgICB2YXIgYXR0cmlidXRlID0gX3JlZjEwLmF0dHJpYnV0ZSxcbiAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZjEwLmF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgbnVtSW5zdGFuY2VzID0gX3JlZjEwLm51bUluc3RhbmNlcyxcbiAgICAgICAgICBkYXRhID0gX3JlZjEwLmRhdGEsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmMTAucHJvcHMsXG4gICAgICAgICAgY29udGV4dCA9IF9yZWYxMC5jb250ZXh0O1xuICAgICAgdmFyIHVwZGF0ZSA9IGF0dHJpYnV0ZS51cGRhdGUsXG4gICAgICAgICAgYWNjZXNzb3IgPSBhdHRyaWJ1dGUuYWNjZXNzb3I7XG5cbiAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgLy8gQ3VzdG9tIHVwZGF0ZXIgLSB0eXBpY2FsbHkgZm9yIG5vbi1pbnN0YW5jZWQgbGF5ZXJzXG4gICAgICAgIHRoaXMub25Mb2coMiwgdGhpcy5pZCArICc6JyArIGF0dHJpYnV0ZU5hbWUgKyAnIHVwZGF0aW5nICcgKyBudW1JbnN0YW5jZXMpO1xuICAgICAgICB1cGRhdGUuY2FsbChjb250ZXh0LCBhdHRyaWJ1dGUsIHsgZGF0YTogZGF0YSwgcHJvcHM6IHByb3BzLCBudW1JbnN0YW5jZXM6IG51bUluc3RhbmNlcyB9KTtcbiAgICAgICAgdGhpcy5fY2hlY2tBdHRyaWJ1dGVBcnJheShhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChhY2Nlc3Nvcikge1xuICAgICAgICAvLyBTdGFuZGFyZCB1cGRhdGVyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlclZpYVN0YW5kYXJkQWNjZXNzb3IoeyBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSwgZGF0YTogZGF0YSwgcHJvcHM6IHByb3BzIH0pO1xuICAgICAgICB0aGlzLl9jaGVja0F0dHJpYnV0ZUFycmF5KGF0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uTG9nKDIsIHRoaXMuaWQgKyAnOicgKyBhdHRyaWJ1dGVOYW1lICsgJyBtaXNzaW5nIHVwZGF0ZSBmdW5jdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgIGF0dHJpYnV0ZS5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVCdWZmZXJWaWFTdGFuZGFyZEFjY2Vzc29yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUJ1ZmZlclZpYVN0YW5kYXJkQWNjZXNzb3IoX3JlZjExKSB7XG4gICAgICB2YXIgYXR0cmlidXRlID0gX3JlZjExLmF0dHJpYnV0ZSxcbiAgICAgICAgICBkYXRhID0gX3JlZjExLmRhdGEsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmMTEucHJvcHM7XG4gICAgICB2YXIgYWNjZXNzb3IgPSBhdHRyaWJ1dGUuYWNjZXNzb3IsXG4gICAgICAgICAgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUsXG4gICAgICAgICAgc2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuXG4gICAgICB2YXIgYWNjZXNzb3JGdW5jID0gcHJvcHNbYWNjZXNzb3JdO1xuXG4gICAgICBhc3NlcnQodHlwZW9mIGFjY2Vzc29yRnVuYyA9PT0gJ2Z1bmN0aW9uJywgJ2FjY2Vzc29yIFwiJyArIGFjY2Vzc29yICsgJ1wiIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIHZhciBfYXR0cmlidXRlJGRlZmF1bHRWYWwgPSBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IF9hdHRyaWJ1dGUkZGVmYXVsdFZhbCA9PT0gdW5kZWZpbmVkID8gWzAsIDAsIDAsIDBdIDogX2F0dHJpYnV0ZSRkZWZhdWx0VmFsO1xuXG4gICAgICBkZWZhdWx0VmFsdWUgPSBBcnJheS5pc0FycmF5KGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiBbZGVmYXVsdFZhbHVlXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBvYmplY3RWYWx1ZSA9IGFjY2Vzc29yRnVuYyhvYmplY3QpO1xuICAgICAgICAgIG9iamVjdFZhbHVlID0gQXJyYXkuaXNBcnJheShvYmplY3RWYWx1ZSkgPyBvYmplY3RWYWx1ZSA6IFtvYmplY3RWYWx1ZV07XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZmFsbHRocm91Z2gsIGRlZmF1bHQtY2FzZSAqL1xuICAgICAgICAgIHN3aXRjaCAoc2l6ZSkge1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB2YWx1ZVtpICsgM10gPSBOdW1iZXIuaXNGaW5pdGUob2JqZWN0VmFsdWVbM10pID8gb2JqZWN0VmFsdWVbM10gOiBkZWZhdWx0VmFsdWVbM107XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHZhbHVlW2kgKyAyXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVsyXSkgPyBvYmplY3RWYWx1ZVsyXSA6IGRlZmF1bHRWYWx1ZVsyXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdmFsdWVbaSArIDFdID0gTnVtYmVyLmlzRmluaXRlKG9iamVjdFZhbHVlWzFdKSA/IG9iamVjdFZhbHVlWzFdIDogZGVmYXVsdFZhbHVlWzFdO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB2YWx1ZVtpICsgMF0gPSBOdW1iZXIuaXNGaW5pdGUob2JqZWN0VmFsdWVbMF0pID8gb2JqZWN0VmFsdWVbMF0gOiBkZWZhdWx0VmFsdWVbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2NoZWNrQXR0cmlidXRlQXJyYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tBdHRyaWJ1dGVBcnJheShhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblxuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgIHZhciB2YWxpZCA9IE51bWJlci5pc0Zpbml0ZSh2YWx1ZVswXSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzFdKSAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWVbMl0pICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVszXSk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0cmlidXRlIGdlbmVyYXRlZCBmb3IgJyArIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF0dHJpYnV0ZU1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEF0dHJpYnV0ZU1hbmFnZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL2F0dHJpYnV0ZS1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 28 */
/* exports provided: COORDINATE_SYSTEM */
/* exports used: COORDINATE_SYSTEM */
/*!******************************!*\
  !*** ./src/lib/constants.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return COORDINATE_SYSTEM; });\n// Note: The numeric values here are matched by shader code in the\n// \"project\" and \"project64\" shader modules. Both places need to be\n// updated.\n\n// TODO: Maybe \"POSITIONS\" would be a better name?\nvar COORDINATE_SYSTEM = {\n  // Positions are interpreted as [lng, lat, elevation]\n  // lng lat are degrees, elevation is meters. distances as meters.\n  LNGLAT: 1.0,\n\n  // Positions are interpreted as lng lat offsets: [deltaLng, deltaLat, elevation]\n  // deltaLng, deltaLat are delta degrees, elevation is meters.\n  // distances as meters.\n  LNGLAT_OFFSETS: 3.0,\n\n  // Positions are interpreted as meter offsets, distances as meters\n  METER_OFFSETS: 2.0,\n  METERS: 2.0,\n\n  // Positions and distances are not transformed: [x, y, z] in unit coordinates\n  IDENTITY: 0.0\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2NvbnN0YW50cy5qcz82N2NmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5vdGU6IFRoZSBudW1lcmljIHZhbHVlcyBoZXJlIGFyZSBtYXRjaGVkIGJ5IHNoYWRlciBjb2RlIGluIHRoZVxuLy8gXCJwcm9qZWN0XCIgYW5kIFwicHJvamVjdDY0XCIgc2hhZGVyIG1vZHVsZXMuIEJvdGggcGxhY2VzIG5lZWQgdG8gYmVcbi8vIHVwZGF0ZWQuXG5cbi8vIFRPRE86IE1heWJlIFwiUE9TSVRJT05TXCIgd291bGQgYmUgYSBiZXR0ZXIgbmFtZT9cbmV4cG9ydCB2YXIgQ09PUkRJTkFURV9TWVNURU0gPSB7XG4gIC8vIFBvc2l0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgYXMgW2xuZywgbGF0LCBlbGV2YXRpb25dXG4gIC8vIGxuZyBsYXQgYXJlIGRlZ3JlZXMsIGVsZXZhdGlvbiBpcyBtZXRlcnMuIGRpc3RhbmNlcyBhcyBtZXRlcnMuXG4gIExOR0xBVDogMS4wLFxuXG4gIC8vIFBvc2l0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgYXMgbG5nIGxhdCBvZmZzZXRzOiBbZGVsdGFMbmcsIGRlbHRhTGF0LCBlbGV2YXRpb25dXG4gIC8vIGRlbHRhTG5nLCBkZWx0YUxhdCBhcmUgZGVsdGEgZGVncmVlcywgZWxldmF0aW9uIGlzIG1ldGVycy5cbiAgLy8gZGlzdGFuY2VzIGFzIG1ldGVycy5cbiAgTE5HTEFUX09GRlNFVFM6IDMuMCxcblxuICAvLyBQb3NpdGlvbnMgYXJlIGludGVycHJldGVkIGFzIG1ldGVyIG9mZnNldHMsIGRpc3RhbmNlcyBhcyBtZXRlcnNcbiAgTUVURVJfT0ZGU0VUUzogMi4wLFxuICBNRVRFUlM6IDIuMCxcblxuICAvLyBQb3NpdGlvbnMgYW5kIGRpc3RhbmNlcyBhcmUgbm90IHRyYW5zZm9ybWVkOiBbeCwgeSwgel0gaW4gdW5pdCBjb29yZGluYXRlc1xuICBJREVOVElUWTogMC4wXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 29 */
/* exports provided: default */
/* exports used: default */
/*!******************************!*\
  !*** ./src/lib/utils/log.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = log;\n/* eslint-disable no-console */\n/* global console */\n\n\nfunction log(priority) {\n  __WEBPACK_IMPORTED_MODULE_0_assert___default()(Number.isFinite(priority), 'log priority must be a number');\n  if (priority <= log.priority) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // Node doesn't have console.debug, but looks better in browser consoles\n    if (console.debug) {\n      var _console;\n\n      (_console = console).debug.apply(_console, args);\n    } else {\n      var _console2;\n\n      (_console2 = console).info.apply(_console2, args);\n    }\n  }\n}\n\nvar cache = {};\n\nfunction once(priority, arg) {\n  if (!cache[arg] && priority <= log.priority) {\n    var _console3;\n\n    for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    (_console3 = console).warn.apply(_console3, [arg].concat(args));\n    cache[arg] = true;\n  }\n}\n\nlog.priority = 0;\nlog.log = log;\nlog.once = once;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2xvZy5qcz9iNzFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbi8qIGdsb2JhbCBjb25zb2xlICovXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvZyhwcmlvcml0eSkge1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHByaW9yaXR5KSwgJ2xvZyBwcmlvcml0eSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIGlmIChwcmlvcml0eSA8PSBsb2cucHJpb3JpdHkpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIC8vIE5vZGUgZG9lc24ndCBoYXZlIGNvbnNvbGUuZGVidWcsIGJ1dCBsb29rcyBiZXR0ZXIgaW4gYnJvd3NlciBjb25zb2xlc1xuICAgIGlmIChjb25zb2xlLmRlYnVnKSB7XG4gICAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICAgIChfY29uc29sZSA9IGNvbnNvbGUpLmRlYnVnLmFwcGx5KF9jb25zb2xlLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jb25zb2xlMjtcblxuICAgICAgKF9jb25zb2xlMiA9IGNvbnNvbGUpLmluZm8uYXBwbHkoX2NvbnNvbGUyLCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGNhY2hlID0ge307XG5cbmZ1bmN0aW9uIG9uY2UocHJpb3JpdHksIGFyZykge1xuICBpZiAoIWNhY2hlW2FyZ10gJiYgcHJpb3JpdHkgPD0gbG9nLnByaW9yaXR5KSB7XG4gICAgdmFyIF9jb25zb2xlMztcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgKF9jb25zb2xlMyA9IGNvbnNvbGUpLndhcm4uYXBwbHkoX2NvbnNvbGUzLCBbYXJnXS5jb25jYXQoYXJncykpO1xuICAgIGNhY2hlW2FyZ10gPSB0cnVlO1xuICB9XG59XG5cbmxvZy5wcmlvcml0eSA9IDA7XG5sb2cubG9nID0gbG9nO1xubG9nLm9uY2UgPSBvbmNlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi91dGlscy9sb2cuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 30 */
/* exports provided: default */
/* exports used: default */
/*!*******************************!*\
  !*** ./src/react/autobind.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = autobind;\nvar PREDEFINED = ['constructor', 'render', 'componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount'];\n\n/**\n * Binds the \"this\" argument of all functions on a class instance to the instance\n * @param {Object} obj - class instance (typically a react component)\n */\nfunction autobind(obj) {\n  var proto = Object.getPrototypeOf(obj);\n  var propNames = Object.getOwnPropertyNames(proto);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var key = _step.value;\n\n      if (typeof obj[key] === 'function') {\n        if (!PREDEFINED.find(function (name) {\n          return key === name;\n        })) {\n          obj[key] = obj[key].bind(obj);\n        }\n      }\n    };\n\n    for (var _iterator = propNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      _loop();\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVhY3QvYXV0b2JpbmQuanM/ZWMyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUFJFREVGSU5FRCA9IFsnY29uc3RydWN0b3InLCAncmVuZGVyJywgJ2NvbXBvbmVudFdpbGxNb3VudCcsICdjb21wb25lbnREaWRNb3VudCcsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJywgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScsICdjb21wb25lbnRXaWxsVXBkYXRlJywgJ2NvbXBvbmVudERpZFVwZGF0ZScsICdjb21wb25lbnRXaWxsVW5tb3VudCddO1xuXG4vKipcbiAqIEJpbmRzIHRoZSBcInRoaXNcIiBhcmd1bWVudCBvZiBhbGwgZnVuY3Rpb25zIG9uIGEgY2xhc3MgaW5zdGFuY2UgdG8gdGhlIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gY2xhc3MgaW5zdGFuY2UgKHR5cGljYWxseSBhIHJlYWN0IGNvbXBvbmVudClcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b2JpbmQob2JqKSB7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIVBSRURFRklORUQuZmluZChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiBrZXkgPT09IG5hbWU7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBvYmpba2V5XS5iaW5kKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcHJvcE5hbWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgX2xvb3AoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcmVhY3QvYXV0b2JpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 31 */
/* exports provided: fp64, project, project64, lighting */
/* all exports used */
/*!*******************************************!*\
  !*** ./src/shader-utils/shader-chunks.js ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shaderlib_fp64__ = __webpack_require__(/*! ../shaderlib/fp64 */ 72);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"fp64\", function() { return __WEBPACK_IMPORTED_MODULE_0__shaderlib_fp64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaderlib_project__ = __webpack_require__(/*! ../shaderlib/project */ 74);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"project\", function() { return __WEBPACK_IMPORTED_MODULE_1__shaderlib_project__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaderlib_project64__ = __webpack_require__(/*! ../shaderlib/project64 */ 75);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"project64\", function() { return __WEBPACK_IMPORTED_MODULE_2__shaderlib_project64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaderlib_lighting__ = __webpack_require__(/*! ../shaderlib/lighting */ 73);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"lighting\", function() { return __WEBPACK_IMPORTED_MODULE_3__shaderlib_lighting__[\"a\"]; });\n// Load shader chunks\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVyLXV0aWxzL3NoYWRlci1jaHVua3MuanM/NWM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMb2FkIHNoYWRlciBjaHVua3NcbmV4cG9ydCAqIGZyb20gJy4uL3NoYWRlcmxpYi9mcDY0JztcbmV4cG9ydCAqIGZyb20gJy4uL3NoYWRlcmxpYi9wcm9qZWN0JztcbmV4cG9ydCAqIGZyb20gJy4uL3NoYWRlcmxpYi9wcm9qZWN0NjQnO1xuZXhwb3J0ICogZnJvbSAnLi4vc2hhZGVybGliL2xpZ2h0aW5nJztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXItdXRpbHMvc2hhZGVyLWNodW5rcy5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 32 */
/* exports provided: defaultColorRange */
/* exports used: defaultColorRange */
/*!**********************************!*\
  !*** ./src/utils/color-utils.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return defaultColorRange; });\nvar defaultColorRange = [[255, 255, 178], [254, 217, 118], [254, 178, 76], [253, 141, 60], [240, 59, 32], [189, 0, 38]];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvY29sb3ItdXRpbHMuanM/YmNmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGRlZmF1bHRDb2xvclJhbmdlID0gW1syNTUsIDI1NSwgMTc4XSwgWzI1NCwgMjE3LCAxMThdLCBbMjU0LCAxNzgsIDc2XSwgWzI1MywgMTQxLCA2MF0sIFsyNDAsIDU5LCAzMl0sIFsxODksIDAsIDM4XV07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdXRpbHMvY29sb3ItdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 33 */
/* exports provided: ordinalScale, linearScale */
/* exports used: ordinalScale, linearScale */
/*!**********************************!*\
  !*** ./src/utils/scale-utils.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ordinalScale;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = linearScale;\nfunction ordinalScale(domain, range, value) {\n  var step = (domain[1] - domain[0]) / range.length;\n  var idx = Math.floor((value - domain[0]) / step);\n  var clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n\n  return range[clampIdx];\n}\n\nfunction linearScale(domain, range, value) {\n\n  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvc2NhbGUtdXRpbHMuanM/ODI3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gb3JkaW5hbFNjYWxlKGRvbWFpbiwgcmFuZ2UsIHZhbHVlKSB7XG4gIHZhciBzdGVwID0gKGRvbWFpblsxXSAtIGRvbWFpblswXSkgLyByYW5nZS5sZW5ndGg7XG4gIHZhciBpZHggPSBNYXRoLmZsb29yKCh2YWx1ZSAtIGRvbWFpblswXSkgLyBzdGVwKTtcbiAgdmFyIGNsYW1wSWR4ID0gTWF0aC5tYXgoTWF0aC5taW4oaWR4LCByYW5nZS5sZW5ndGggLSAxKSwgMCk7XG5cbiAgcmV0dXJuIHJhbmdlW2NsYW1wSWR4XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclNjYWxlKGRvbWFpbiwgcmFuZ2UsIHZhbHVlKSB7XG5cbiAgcmV0dXJuICh2YWx1ZSAtIGRvbWFpblswXSkgLyAoZG9tYWluWzFdIC0gZG9tYWluWzBdKSAqIChyYW5nZVsxXSAtIHJhbmdlWzBdKSArIHJhbmdlWzBdO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3V0aWxzL3NjYWxlLXV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 34 */
/* unknown exports provided */
/* exports used: default */
/*!*************************************!*\
  !*** external "lodash.flattendeep" ***!
  \*************************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_34__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJsb2Rhc2guZmxhdHRlbmRlZXBcIj81M2RhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zNF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwibG9kYXNoLmZsYXR0ZW5kZWVwXCJcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 35 */
/* unknown exports provided */
/* exports used: PropTypes, createElement, default */
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_35__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdFwiPzNjNjIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzM1X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWFjdFwiXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 36 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************!*\
  !*** ./src/layers/core/geojson-layer/geojson-layer.js ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__scatterplot_layer_scatterplot_layer__ = __webpack_require__(/*! ../scatterplot-layer/scatterplot-layer */ 12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__ = __webpack_require__(/*! ../path-layer/path-layer */ 22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polygon_layer_polygon_layer__ = __webpack_require__(/*! ../polygon-layer/polygon-layer */ 23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geojson__ = __webpack_require__(/*! ./geojson */ 51);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\nvar defaultPointColor = [0xFF, 0x88, 0x00, 0xFF];\nvar defaultStrokeColor = [0x33, 0x33, 0x33, 0xFF];\nvar defaultFillColor = [0xBD, 0xE2, 0x7A, 0xFF];\n\nvar defaultProps = {\n  drawPoints: true,\n  drawLines: true,\n  drawPolygons: true,\n  fillPolygons: true,\n  // extrudePolygons: false,\n  // wireframe: false,\n\n  // Point accessors\n  getPointColor: function getPointColor(f) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'properties.color') || defaultPointColor;\n  },\n  getPointSize: function getPointSize(f) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'properties.size') || 5;\n  },\n\n  // Line and polygon outline accessors\n  getStrokeColor: function getStrokeColor(f) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'properties.strokeColor') || defaultStrokeColor;\n  },\n  getStrokeWidth: function getStrokeWidth(f) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'properties.strokeWidth') || 1;\n  },\n\n  // Polygon fill accessors\n  getFillColor: function getFillColor(f) {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'properties.fillColor') || defaultFillColor;\n  },\n\n  // Polygon extrusion accessor\n  getElevation: function getElevation(f) {\n    return 1000;\n  },\n  fp64: false\n};\n\nvar getCoordinates = function getCoordinates(f) {\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(f, 'geometry.coordinates');\n};\n\nvar GeoJsonLayer = function (_CompositeLayer) {\n  _inherits(GeoJsonLayer, _CompositeLayer);\n\n  function GeoJsonLayer() {\n    _classCallCheck(this, GeoJsonLayer);\n\n    return _possibleConstructorReturn(this, (GeoJsonLayer.__proto__ || Object.getPrototypeOf(GeoJsonLayer)).apply(this, arguments));\n  }\n\n  _createClass(GeoJsonLayer, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      this.state = {\n        subLayers: null\n      };\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n\n      if (changeFlags.dataChanged) {\n        var data = this.props.data;\n\n        var features = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__geojson__[\"a\" /* getGeojsonFeatures */])(data);\n        this.state.subLayers = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__geojson__[\"b\" /* separateGeojsonFeatures */])(features);\n      }\n    }\n  }, {\n    key: '_onHoverSubLayer',\n    value: function _onHoverSubLayer(info) {\n      info.object = info.object && info.object.feature || info.object;\n      this.props.onHover(info);\n    }\n  }, {\n    key: '_onClickSubLayer',\n    value: function _onClickSubLayer(info) {\n      info.object = info.object && info.object.feature || info.object;\n      this.props.onClick(info);\n    }\n  }, {\n    key: 'renderLayers',\n    value: function renderLayers() {\n      var _state$subLayers = this.state.subLayers,\n          pointFeatures = _state$subLayers.pointFeatures,\n          lineFeatures = _state$subLayers.lineFeatures,\n          polygonFeatures = _state$subLayers.polygonFeatures,\n          polygonOutlineFeatures = _state$subLayers.polygonOutlineFeatures;\n      var _props = this.props,\n          id = _props.id,\n          getPointColor = _props.getPointColor,\n          getPointSize = _props.getPointSize,\n          getStrokeColor = _props.getStrokeColor,\n          getStrokeWidth = _props.getStrokeWidth,\n          getFillColor = _props.getFillColor,\n          getElevation = _props.getElevation;\n      var _props2 = this.props,\n          extruded = _props2.extruded,\n          wireframe = _props2.wireframe;\n      var _props3 = this.props,\n          drawPoints = _props3.drawPoints,\n          drawLines = _props3.drawLines,\n          drawPolygons = _props3.drawPolygons,\n          fillPolygons = _props3.fillPolygons;\n\n      drawPoints = drawPoints && pointFeatures && pointFeatures.length > 0;\n      drawLines = drawLines && lineFeatures && lineFeatures.length > 0;\n      drawPolygons = drawPolygons && polygonOutlineFeatures && polygonOutlineFeatures.length > 0;\n      fillPolygons = fillPolygons && polygonFeatures && polygonFeatures.length > 0;\n\n      var onHover = this._onHoverSubLayer.bind(this);\n      var onClick = this._onClickSubLayer.bind(this);\n\n      // Filled Polygon Layer\n      var polygonFillLayer = fillPolygons && new __WEBPACK_IMPORTED_MODULE_3__polygon_layer_polygon_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n        id: id + '-polygon-fill',\n        data: polygonFeatures,\n        getPolygon: getCoordinates,\n        getElevation: getElevation,\n        getColor: getFillColor,\n        extruded: extruded,\n        wireframe: false,\n        onHover: onHover,\n        onClick: onClick,\n        updateTriggers: {\n          getElevation: this.props.updateTriggers.getElevation,\n          getColor: this.props.updateTriggers.getFillColor\n        }\n      }));\n\n      // Polygon outline or wireframe\n      var polygonOutlineLayer = null;\n      if (drawPolygons && extruded && wireframe) {\n        polygonOutlineLayer = new __WEBPACK_IMPORTED_MODULE_3__polygon_layer_polygon_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n          id: id + '-polygon-wireframe',\n          data: polygonFeatures,\n          getPolygon: getCoordinates,\n          getElevation: getElevation,\n          getColor: getStrokeColor,\n          extruded: true,\n          wireframe: true,\n          onHover: onHover,\n          onClick: onClick,\n          updateTriggers: {\n            getColor: this.props.updateTriggers.getStrokeColor\n          }\n        }));\n      } else if (drawPolygons) {\n        polygonOutlineLayer = new __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n          id: id + '-polygon-outline',\n          data: polygonOutlineFeatures,\n          getPath: getCoordinates,\n          getColor: getStrokeColor,\n          getStrokeWidth: getStrokeWidth,\n          onHover: onHover,\n          onClick: onClick,\n          updateTriggers: {\n            getColor: this.props.updateTriggers.getStrokeColor,\n            getStrokeWidth: this.props.updateTriggers.getStrokeWidth\n          }\n        }));\n      }\n\n      var lineLayer = drawLines && new __WEBPACK_IMPORTED_MODULE_2__path_layer_path_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n        id: id + '-line-paths',\n        data: lineFeatures,\n        getPath: getCoordinates,\n        getColor: getStrokeColor,\n        getStrokeWidth: getStrokeWidth,\n        onHover: onHover,\n        onClick: onClick,\n        updateTriggers: {\n          getColor: this.props.updateTriggers.getStrokeColor,\n          getStrokeWidth: this.props.updateTriggers.getStrokeWidth\n        }\n      }));\n\n      var pointLayer = drawPoints && new __WEBPACK_IMPORTED_MODULE_1__scatterplot_layer_scatterplot_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n        id: id + '-points',\n        data: pointFeatures,\n        getPosition: getCoordinates,\n        getColor: getPointColor,\n        getRadius: getPointSize,\n        onHover: onHover,\n        onClick: onClick,\n        updateTriggers: {\n          getColor: this.props.updateTriggers.getPointColor,\n          getRadius: this.props.updateTriggers.getPointSize\n        },\n        fp64: this.props.fp64\n      }));\n\n      return [polygonFillLayer, polygonOutlineLayer, lineLayer, pointLayer].filter(Boolean);\n    }\n  }]);\n\n  return GeoJsonLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"b\" /* CompositeLayer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = GeoJsonLayer;\n\n\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ2VvanNvbi1sYXllci9nZW9qc29uLWxheWVyLmpzP2I4MDYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBDb21wb3NpdGVMYXllciwgZ2V0IH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCBTY2F0dGVycGxvdExheWVyIGZyb20gJy4uL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyJztcbmltcG9ydCBQYXRoTGF5ZXIgZnJvbSAnLi4vcGF0aC1sYXllci9wYXRoLWxheWVyJztcbmltcG9ydCBQb2x5Z29uTGF5ZXIgZnJvbSAnLi4vcG9seWdvbi1sYXllci9wb2x5Z29uLWxheWVyJztcblxuaW1wb3J0IHsgZ2V0R2VvanNvbkZlYXR1cmVzLCBzZXBhcmF0ZUdlb2pzb25GZWF0dXJlcyB9IGZyb20gJy4vZ2VvanNvbic7XG5cbnZhciBkZWZhdWx0UG9pbnRDb2xvciA9IFsweEZGLCAweDg4LCAweDAwLCAweEZGXTtcbnZhciBkZWZhdWx0U3Ryb2tlQ29sb3IgPSBbMHgzMywgMHgzMywgMHgzMywgMHhGRl07XG52YXIgZGVmYXVsdEZpbGxDb2xvciA9IFsweEJELCAweEUyLCAweDdBLCAweEZGXTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgZHJhd1BvaW50czogdHJ1ZSxcbiAgZHJhd0xpbmVzOiB0cnVlLFxuICBkcmF3UG9seWdvbnM6IHRydWUsXG4gIGZpbGxQb2x5Z29uczogdHJ1ZSxcbiAgLy8gZXh0cnVkZVBvbHlnb25zOiBmYWxzZSxcbiAgLy8gd2lyZWZyYW1lOiBmYWxzZSxcblxuICAvLyBQb2ludCBhY2Nlc3NvcnNcbiAgZ2V0UG9pbnRDb2xvcjogZnVuY3Rpb24gZ2V0UG9pbnRDb2xvcihmKSB7XG4gICAgcmV0dXJuIGdldChmLCAncHJvcGVydGllcy5jb2xvcicpIHx8IGRlZmF1bHRQb2ludENvbG9yO1xuICB9LFxuICBnZXRQb2ludFNpemU6IGZ1bmN0aW9uIGdldFBvaW50U2l6ZShmKSB7XG4gICAgcmV0dXJuIGdldChmLCAncHJvcGVydGllcy5zaXplJykgfHwgNTtcbiAgfSxcblxuICAvLyBMaW5lIGFuZCBwb2x5Z29uIG91dGxpbmUgYWNjZXNzb3JzXG4gIGdldFN0cm9rZUNvbG9yOiBmdW5jdGlvbiBnZXRTdHJva2VDb2xvcihmKSB7XG4gICAgcmV0dXJuIGdldChmLCAncHJvcGVydGllcy5zdHJva2VDb2xvcicpIHx8IGRlZmF1bHRTdHJva2VDb2xvcjtcbiAgfSxcbiAgZ2V0U3Ryb2tlV2lkdGg6IGZ1bmN0aW9uIGdldFN0cm9rZVdpZHRoKGYpIHtcbiAgICByZXR1cm4gZ2V0KGYsICdwcm9wZXJ0aWVzLnN0cm9rZVdpZHRoJykgfHwgMTtcbiAgfSxcblxuICAvLyBQb2x5Z29uIGZpbGwgYWNjZXNzb3JzXG4gIGdldEZpbGxDb2xvcjogZnVuY3Rpb24gZ2V0RmlsbENvbG9yKGYpIHtcbiAgICByZXR1cm4gZ2V0KGYsICdwcm9wZXJ0aWVzLmZpbGxDb2xvcicpIHx8IGRlZmF1bHRGaWxsQ29sb3I7XG4gIH0sXG5cbiAgLy8gUG9seWdvbiBleHRydXNpb24gYWNjZXNzb3JcbiAgZ2V0RWxldmF0aW9uOiBmdW5jdGlvbiBnZXRFbGV2YXRpb24oZikge1xuICAgIHJldHVybiAxMDAwO1xuICB9LFxuICBmcDY0OiBmYWxzZVxufTtcblxudmFyIGdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMoZikge1xuICByZXR1cm4gZ2V0KGYsICdnZW9tZXRyeS5jb29yZGluYXRlcycpO1xufTtcblxudmFyIEdlb0pzb25MYXllciA9IGZ1bmN0aW9uIChfQ29tcG9zaXRlTGF5ZXIpIHtcbiAgX2luaGVyaXRzKEdlb0pzb25MYXllciwgX0NvbXBvc2l0ZUxheWVyKTtcblxuICBmdW5jdGlvbiBHZW9Kc29uTGF5ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdlb0pzb25MYXllcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEdlb0pzb25MYXllci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdlb0pzb25MYXllcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdlb0pzb25MYXllciwgW3tcbiAgICBrZXk6ICdpbml0aWFsaXplU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBzdWJMYXllcnM6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTdGF0ZShfcmVmKSB7XG4gICAgICB2YXIgb2xkUHJvcHMgPSBfcmVmLm9sZFByb3BzLFxuICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBjaGFuZ2VGbGFncyA9IF9yZWYuY2hhbmdlRmxhZ3M7XG5cbiAgICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcblxuICAgICAgICB2YXIgZmVhdHVyZXMgPSBnZXRHZW9qc29uRmVhdHVyZXMoZGF0YSk7XG4gICAgICAgIHRoaXMuc3RhdGUuc3ViTGF5ZXJzID0gc2VwYXJhdGVHZW9qc29uRmVhdHVyZXMoZmVhdHVyZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19vbkhvdmVyU3ViTGF5ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Ib3ZlclN1YkxheWVyKGluZm8pIHtcbiAgICAgIGluZm8ub2JqZWN0ID0gaW5mby5vYmplY3QgJiYgaW5mby5vYmplY3QuZmVhdHVyZSB8fCBpbmZvLm9iamVjdDtcbiAgICAgIHRoaXMucHJvcHMub25Ib3ZlcihpbmZvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfb25DbGlja1N1YkxheWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2xpY2tTdWJMYXllcihpbmZvKSB7XG4gICAgICBpbmZvLm9iamVjdCA9IGluZm8ub2JqZWN0ICYmIGluZm8ub2JqZWN0LmZlYXR1cmUgfHwgaW5mby5vYmplY3Q7XG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2soaW5mbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyTGF5ZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGF5ZXJzKCkge1xuICAgICAgdmFyIF9zdGF0ZSRzdWJMYXllcnMgPSB0aGlzLnN0YXRlLnN1YkxheWVycyxcbiAgICAgICAgICBwb2ludEZlYXR1cmVzID0gX3N0YXRlJHN1YkxheWVycy5wb2ludEZlYXR1cmVzLFxuICAgICAgICAgIGxpbmVGZWF0dXJlcyA9IF9zdGF0ZSRzdWJMYXllcnMubGluZUZlYXR1cmVzLFxuICAgICAgICAgIHBvbHlnb25GZWF0dXJlcyA9IF9zdGF0ZSRzdWJMYXllcnMucG9seWdvbkZlYXR1cmVzLFxuICAgICAgICAgIHBvbHlnb25PdXRsaW5lRmVhdHVyZXMgPSBfc3RhdGUkc3ViTGF5ZXJzLnBvbHlnb25PdXRsaW5lRmVhdHVyZXM7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBpZCA9IF9wcm9wcy5pZCxcbiAgICAgICAgICBnZXRQb2ludENvbG9yID0gX3Byb3BzLmdldFBvaW50Q29sb3IsXG4gICAgICAgICAgZ2V0UG9pbnRTaXplID0gX3Byb3BzLmdldFBvaW50U2l6ZSxcbiAgICAgICAgICBnZXRTdHJva2VDb2xvciA9IF9wcm9wcy5nZXRTdHJva2VDb2xvcixcbiAgICAgICAgICBnZXRTdHJva2VXaWR0aCA9IF9wcm9wcy5nZXRTdHJva2VXaWR0aCxcbiAgICAgICAgICBnZXRGaWxsQ29sb3IgPSBfcHJvcHMuZ2V0RmlsbENvbG9yLFxuICAgICAgICAgIGdldEVsZXZhdGlvbiA9IF9wcm9wcy5nZXRFbGV2YXRpb247XG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZXh0cnVkZWQgPSBfcHJvcHMyLmV4dHJ1ZGVkLFxuICAgICAgICAgIHdpcmVmcmFtZSA9IF9wcm9wczIud2lyZWZyYW1lO1xuICAgICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRyYXdQb2ludHMgPSBfcHJvcHMzLmRyYXdQb2ludHMsXG4gICAgICAgICAgZHJhd0xpbmVzID0gX3Byb3BzMy5kcmF3TGluZXMsXG4gICAgICAgICAgZHJhd1BvbHlnb25zID0gX3Byb3BzMy5kcmF3UG9seWdvbnMsXG4gICAgICAgICAgZmlsbFBvbHlnb25zID0gX3Byb3BzMy5maWxsUG9seWdvbnM7XG5cbiAgICAgIGRyYXdQb2ludHMgPSBkcmF3UG9pbnRzICYmIHBvaW50RmVhdHVyZXMgJiYgcG9pbnRGZWF0dXJlcy5sZW5ndGggPiAwO1xuICAgICAgZHJhd0xpbmVzID0gZHJhd0xpbmVzICYmIGxpbmVGZWF0dXJlcyAmJiBsaW5lRmVhdHVyZXMubGVuZ3RoID4gMDtcbiAgICAgIGRyYXdQb2x5Z29ucyA9IGRyYXdQb2x5Z29ucyAmJiBwb2x5Z29uT3V0bGluZUZlYXR1cmVzICYmIHBvbHlnb25PdXRsaW5lRmVhdHVyZXMubGVuZ3RoID4gMDtcbiAgICAgIGZpbGxQb2x5Z29ucyA9IGZpbGxQb2x5Z29ucyAmJiBwb2x5Z29uRmVhdHVyZXMgJiYgcG9seWdvbkZlYXR1cmVzLmxlbmd0aCA+IDA7XG5cbiAgICAgIHZhciBvbkhvdmVyID0gdGhpcy5fb25Ib3ZlclN1YkxheWVyLmJpbmQodGhpcyk7XG4gICAgICB2YXIgb25DbGljayA9IHRoaXMuX29uQ2xpY2tTdWJMYXllci5iaW5kKHRoaXMpO1xuXG4gICAgICAvLyBGaWxsZWQgUG9seWdvbiBMYXllclxuICAgICAgdmFyIHBvbHlnb25GaWxsTGF5ZXIgPSBmaWxsUG9seWdvbnMgJiYgbmV3IFBvbHlnb25MYXllcihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgIGlkOiBpZCArICctcG9seWdvbi1maWxsJyxcbiAgICAgICAgZGF0YTogcG9seWdvbkZlYXR1cmVzLFxuICAgICAgICBnZXRQb2x5Z29uOiBnZXRDb29yZGluYXRlcyxcbiAgICAgICAgZ2V0RWxldmF0aW9uOiBnZXRFbGV2YXRpb24sXG4gICAgICAgIGdldENvbG9yOiBnZXRGaWxsQ29sb3IsXG4gICAgICAgIGV4dHJ1ZGVkOiBleHRydWRlZCxcbiAgICAgICAgd2lyZWZyYW1lOiBmYWxzZSxcbiAgICAgICAgb25Ib3Zlcjogb25Ib3ZlcixcbiAgICAgICAgb25DbGljazogb25DbGljayxcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICBnZXRFbGV2YXRpb246IHRoaXMucHJvcHMudXBkYXRlVHJpZ2dlcnMuZ2V0RWxldmF0aW9uLFxuICAgICAgICAgIGdldENvbG9yOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzLmdldEZpbGxDb2xvclxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFBvbHlnb24gb3V0bGluZSBvciB3aXJlZnJhbWVcbiAgICAgIHZhciBwb2x5Z29uT3V0bGluZUxheWVyID0gbnVsbDtcbiAgICAgIGlmIChkcmF3UG9seWdvbnMgJiYgZXh0cnVkZWQgJiYgd2lyZWZyYW1lKSB7XG4gICAgICAgIHBvbHlnb25PdXRsaW5lTGF5ZXIgPSBuZXcgUG9seWdvbkxheWVyKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgICBpZDogaWQgKyAnLXBvbHlnb24td2lyZWZyYW1lJyxcbiAgICAgICAgICBkYXRhOiBwb2x5Z29uRmVhdHVyZXMsXG4gICAgICAgICAgZ2V0UG9seWdvbjogZ2V0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgZ2V0RWxldmF0aW9uOiBnZXRFbGV2YXRpb24sXG4gICAgICAgICAgZ2V0Q29sb3I6IGdldFN0cm9rZUNvbG9yLFxuICAgICAgICAgIGV4dHJ1ZGVkOiB0cnVlLFxuICAgICAgICAgIHdpcmVmcmFtZTogdHJ1ZSxcbiAgICAgICAgICBvbkhvdmVyOiBvbkhvdmVyLFxuICAgICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICAgIGdldENvbG9yOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzLmdldFN0cm9rZUNvbG9yXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2UgaWYgKGRyYXdQb2x5Z29ucykge1xuICAgICAgICBwb2x5Z29uT3V0bGluZUxheWVyID0gbmV3IFBhdGhMYXllcihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgICAgaWQ6IGlkICsgJy1wb2x5Z29uLW91dGxpbmUnLFxuICAgICAgICAgIGRhdGE6IHBvbHlnb25PdXRsaW5lRmVhdHVyZXMsXG4gICAgICAgICAgZ2V0UGF0aDogZ2V0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgZ2V0Q29sb3I6IGdldFN0cm9rZUNvbG9yLFxuICAgICAgICAgIGdldFN0cm9rZVdpZHRoOiBnZXRTdHJva2VXaWR0aCxcbiAgICAgICAgICBvbkhvdmVyOiBvbkhvdmVyLFxuICAgICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICAgIGdldENvbG9yOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzLmdldFN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgZ2V0U3Ryb2tlV2lkdGg6IHRoaXMucHJvcHMudXBkYXRlVHJpZ2dlcnMuZ2V0U3Ryb2tlV2lkdGhcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmVMYXllciA9IGRyYXdMaW5lcyAmJiBuZXcgUGF0aExheWVyKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgaWQ6IGlkICsgJy1saW5lLXBhdGhzJyxcbiAgICAgICAgZGF0YTogbGluZUZlYXR1cmVzLFxuICAgICAgICBnZXRQYXRoOiBnZXRDb29yZGluYXRlcyxcbiAgICAgICAgZ2V0Q29sb3I6IGdldFN0cm9rZUNvbG9yLFxuICAgICAgICBnZXRTdHJva2VXaWR0aDogZ2V0U3Ryb2tlV2lkdGgsXG4gICAgICAgIG9uSG92ZXI6IG9uSG92ZXIsXG4gICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0Q29sb3I6IHRoaXMucHJvcHMudXBkYXRlVHJpZ2dlcnMuZ2V0U3Ryb2tlQ29sb3IsXG4gICAgICAgICAgZ2V0U3Ryb2tlV2lkdGg6IHRoaXMucHJvcHMudXBkYXRlVHJpZ2dlcnMuZ2V0U3Ryb2tlV2lkdGhcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICB2YXIgcG9pbnRMYXllciA9IGRyYXdQb2ludHMgJiYgbmV3IFNjYXR0ZXJwbG90TGF5ZXIoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICBpZDogaWQgKyAnLXBvaW50cycsXG4gICAgICAgIGRhdGE6IHBvaW50RmVhdHVyZXMsXG4gICAgICAgIGdldFBvc2l0aW9uOiBnZXRDb29yZGluYXRlcyxcbiAgICAgICAgZ2V0Q29sb3I6IGdldFBvaW50Q29sb3IsXG4gICAgICAgIGdldFJhZGl1czogZ2V0UG9pbnRTaXplLFxuICAgICAgICBvbkhvdmVyOiBvbkhvdmVyLFxuICAgICAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldENvbG9yOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzLmdldFBvaW50Q29sb3IsXG4gICAgICAgICAgZ2V0UmFkaXVzOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzLmdldFBvaW50U2l6ZVxuICAgICAgICB9LFxuICAgICAgICBmcDY0OiB0aGlzLnByb3BzLmZwNjRcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIFtwb2x5Z29uRmlsbExheWVyLCBwb2x5Z29uT3V0bGluZUxheWVyLCBsaW5lTGF5ZXIsIHBvaW50TGF5ZXJdLmZpbHRlcihCb29sZWFuKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR2VvSnNvbkxheWVyO1xufShDb21wb3NpdGVMYXllcik7XG5cbmV4cG9ydCBkZWZhdWx0IEdlb0pzb25MYXllcjtcblxuXG5HZW9Kc29uTGF5ZXIubGF5ZXJOYW1lID0gJ0dlb0pzb25MYXllcic7XG5HZW9Kc29uTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2dlb2pzb24tbGF5ZXIvZ2VvanNvbi1sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 37 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************!*\
  !*** ./src/layers/core/icon-layer/icon-layer.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\n\n/*\n * @param {object} props\n * @param {Texture2D | string} props.iconAtlas - atlas image url or texture\n * @param {object} props.iconMapping - icon names mapped to icon definitions\n * @param {object} props.iconMapping[icon_name].x - x position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].y - y position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].width - width of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].height - height of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].anchorX - x anchor of icon on the atlas image,\n *   default to width / 2\n * @param {object} props.iconMapping[icon_name].anchorY - y anchor of icon on the atlas image,\n *   default to height / 2\n * @param {object} props.iconMapping[icon_name].mask - whether icon is treated as a transparency\n *   mask. If true, user defined color is applied. If false, original color from the image is\n *   applied. Default to false.\n * @param {number} props.size - icon size in pixels\n * @param {func} props.getPosition - returns anchor position of the icon, in [lng, lat, z]\n * @param {func} props.getIcon - returns icon name as a string\n * @param {func} props.getSize - returns icon size multiplier as a number\n * @param {func} props.getColor - returns color of the icon in [r, g, b, a]. Only works on icons\n *   with mask: true.\n */\nvar defaultProps = {\n  getPosition: function getPosition(x) {\n    return x.position;\n  },\n  getIcon: function getIcon(x) {\n    return x.icon;\n  },\n  getColor: function getColor(x) {\n    return x.color || DEFAULT_COLOR;\n  },\n  getSize: function getSize(x) {\n    return x.size || 1;\n  },\n  iconAtlas: null,\n  iconMapping: {},\n  sizeScale: 1\n};\n\nvar IconLayer = function (_Layer) {\n  _inherits(IconLayer, _Layer);\n\n  function IconLayer() {\n    _classCallCheck(this, IconLayer);\n\n    return _possibleConstructorReturn(this, (IconLayer.__proto__ || Object.getPrototypeOf(IconLayer)).apply(this, arguments));\n  }\n\n  _createClass(IconLayer, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      var attributeManager = this.state.attributeManager;\n      /* eslint-disable max-len */\n\n      attributeManager.addInstanced({\n        instancePositions: { size: 3, accessor: 'getPosition', update: this.calculateInstancePositions },\n        instanceSizes: { size: 1, accessor: 'getSize', update: this.calculateInstanceSizes },\n        instanceOffsets: { size: 2, accessor: 'getIcon', update: this.calculateInstanceOffsets },\n        instanceIconFrames: { size: 4, accessor: 'getIcon', update: this.calculateInstanceIconFrames },\n        instanceColorModes: { size: 1, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getIcon', update: this.calculateInstanceColorMode },\n        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }\n      });\n      /* eslint-enable max-len */\n\n      var gl = this.context.gl;\n\n      this.setState({ model: this.getModel(gl) });\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref) {\n      var _this2 = this;\n\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n      var iconAtlas = props.iconAtlas;\n\n\n      if (oldProps.iconAtlas !== iconAtlas) {\n        (function () {\n          var icons = {};\n          _this2.state.icons = icons;\n\n          if (iconAtlas instanceof __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Texture2D\"]) {\n            icons.texture = iconAtlas;\n          } else if (typeof iconAtlas === 'string') {\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"loadTextures\"])(_this2.context.gl, {\n              urls: [iconAtlas]\n            }).then(function (_ref2) {\n              var _ref3 = _slicedToArray(_ref2, 1),\n                  texture = _ref3[0];\n\n              icons.texture = texture;\n            });\n          }\n        })();\n      }\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref4) {\n      var uniforms = _ref4.uniforms;\n      var _context = this.context,\n          _context$viewport = _context.viewport,\n          width = _context$viewport.width,\n          height = _context$viewport.height,\n          gl = _context.gl;\n      var sizeScale = this.props.sizeScale;\n\n      var iconsTexture = this.state.icons && this.state.icons.texture;\n\n      if (iconsTexture) {\n        // transparency doesn't work with DEPTH_TEST on\n        // tradeoff being we cannot guarantee that foreground icons will be rendered on top\n        gl.disable(gl.DEPTH_TEST);\n\n        this.state.model.render(Object.assign({}, uniforms, {\n          iconsTexture: iconsTexture,\n          iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n          sizeScale: [sizeScale / width, -sizeScale / height]\n        }));\n\n        gl.enable(gl.DEPTH_TEST);\n      }\n    }\n  }, {\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n#define SHADER_NAME icon-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute vec3 instancePositions;\\nattribute float instanceSizes;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute vec4 instanceIconFrames;\\nattribute float instanceColorModes;\\nattribute vec2 instanceOffsets;\\n\\nuniform vec2 sizeScale;\\n\\nuniform float renderPickingBuffer;\\nuniform vec2 iconsTextureDim;\\n\\nvarying float vColorMode;\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\n\\nvoid main(void) {\\n  vec3 center = project_position(instancePositions);\\n  vec2 vertex = (positions + instanceOffsets * 2.0) * sizeScale * instanceSizes;\\n  gl_Position = project_to_clipspace(vec4(center, 1.0)) + vec4(vertex, 0.0, 0.0);\\n\\n  vTextureCoords = mix(\\n    instanceIconFrames.xy,\\n    instanceIconFrames.xy + instanceIconFrames.zw,\\n    (positions.xy + 1.0) / 2.0\\n  ) / iconsTextureDim;\\n\\n  vTextureCoords.y = 1.0 - vTextureCoords.y;\\n\\n  vec4 color = instanceColors / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n  vColor = mix(color, pickingColor, renderPickingBuffer);\\n\\n  vColorMode = instanceColorModes;\\n}\\n',\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n#define SHADER_NAME scatterplot-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\nuniform sampler2D iconsTexture;\\n\\nvarying float vColorMode;\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\n\\nvoid main(void) {\\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\\n\\n  // if colorMode == 0, use pixel color from the texture\\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\\n  vec3 color = mix(texColor.rgb, vColor.rgb,\\n    max(vColorMode, renderPickingBuffer)\\n  );\\n  float a = texColor.a * opacity * mix(1.0, vColor.a, vColorMode);\\n\\n  // if rendering to screen, use mixed alpha\\n  // if rendering picking buffer, use binary alpha\\n  a = mix(a, step(0.1, a), renderPickingBuffer);\\n\\n  gl_FragColor = vec4(color, a);\\n}\\n'\n      };\n    }\n  }, {\n    key: 'getModel',\n    value: function getModel(gl) {\n      var positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];\n\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_FAN,\n          positions: new Float32Array(positions)\n        }),\n        isInstanced: true\n      });\n    }\n  }, {\n    key: 'calculateInstancePositions',\n    value: function calculateInstancePositions(attribute) {\n      var _props = this.props,\n          data = _props.data,\n          getPosition = _props.getPosition;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n\n          var position = getPosition(object);\n          value[i++] = position[0];\n          value[i++] = position[1];\n          value[i++] = position[2] || 0;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceSizes',\n    value: function calculateInstanceSizes(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getSize = _props2.getSize;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n\n          value[i++] = getSize(object);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceColors',\n    value: function calculateInstanceColors(attribute) {\n      var _props3 = this.props,\n          data = _props3.data,\n          getColor = _props3.getColor;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var object = _step3.value;\n\n          var color = getColor(object);\n\n          value[i++] = color[0];\n          value[i++] = color[1];\n          value[i++] = color[2];\n          value[i++] = isNaN(color[3]) ? 255 : color[3];\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceOffsets',\n    value: function calculateInstanceOffsets(attribute) {\n      var _props4 = this.props,\n          data = _props4.data,\n          iconMapping = _props4.iconMapping,\n          getIcon = _props4.getIcon;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = data[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var object = _step4.value;\n\n          var icon = getIcon(object);\n          var rect = iconMapping[icon] || {};\n          value[i++] = 1 / 2 - rect.anchorX / rect.width || 0;\n          value[i++] = 1 / 2 - rect.anchorY / rect.height || 0;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceColorMode',\n    value: function calculateInstanceColorMode(attribute) {\n      var _props5 = this.props,\n          data = _props5.data,\n          iconMapping = _props5.iconMapping,\n          getIcon = _props5.getIcon;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = data[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var object = _step5.value;\n\n          var icon = getIcon(object);\n          var colorMode = iconMapping[icon] && iconMapping[icon].mask;\n          value[i++] = colorMode ? 1 : 0;\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceIconFrames',\n    value: function calculateInstanceIconFrames(attribute) {\n      var _props6 = this.props,\n          data = _props6.data,\n          iconMapping = _props6.iconMapping,\n          getIcon = _props6.getIcon;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = data[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var object = _step6.value;\n\n          var icon = getIcon(object);\n          var rect = iconMapping[icon] || {};\n          value[i++] = rect.x || 0;\n          value[i++] = rect.y || 0;\n          value[i++] = rect.width || 0;\n          value[i++] = rect.height || 0;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  }]);\n\n  return IconLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = IconLayer;\n\n\nIconLayer.layerName = 'IconLayer';\nIconLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvaWNvbi1sYXllci9pY29uLWxheWVyLmpzPzE1ZGEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgeyBhc3NlbWJsZVNoYWRlcnMgfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHsgR0wsIE1vZGVsLCBHZW9tZXRyeSwgVGV4dHVyZTJELCBsb2FkVGV4dHVyZXMgfSBmcm9tICdsdW1hLmdsJztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG52YXIgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xuXG4vKlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge1RleHR1cmUyRCB8IHN0cmluZ30gcHJvcHMuaWNvbkF0bGFzIC0gYXRsYXMgaW1hZ2UgdXJsIG9yIHRleHR1cmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcy5pY29uTWFwcGluZyAtIGljb24gbmFtZXMgbWFwcGVkIHRvIGljb24gZGVmaW5pdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcy5pY29uTWFwcGluZ1tpY29uX25hbWVdLnggLSB4IHBvc2l0aW9uIG9mIGljb24gb24gdGhlIGF0bGFzIGltYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMuaWNvbk1hcHBpbmdbaWNvbl9uYW1lXS55IC0geSBwb3NpdGlvbiBvZiBpY29uIG9uIHRoZSBhdGxhcyBpbWFnZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzLmljb25NYXBwaW5nW2ljb25fbmFtZV0ud2lkdGggLSB3aWR0aCBvZiBpY29uIG9uIHRoZSBhdGxhcyBpbWFnZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzLmljb25NYXBwaW5nW2ljb25fbmFtZV0uaGVpZ2h0IC0gaGVpZ2h0IG9mIGljb24gb24gdGhlIGF0bGFzIGltYWdlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMuaWNvbk1hcHBpbmdbaWNvbl9uYW1lXS5hbmNob3JYIC0geCBhbmNob3Igb2YgaWNvbiBvbiB0aGUgYXRsYXMgaW1hZ2UsXG4gKiAgIGRlZmF1bHQgdG8gd2lkdGggLyAyXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMuaWNvbk1hcHBpbmdbaWNvbl9uYW1lXS5hbmNob3JZIC0geSBhbmNob3Igb2YgaWNvbiBvbiB0aGUgYXRsYXMgaW1hZ2UsXG4gKiAgIGRlZmF1bHQgdG8gaGVpZ2h0IC8gMlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzLmljb25NYXBwaW5nW2ljb25fbmFtZV0ubWFzayAtIHdoZXRoZXIgaWNvbiBpcyB0cmVhdGVkIGFzIGEgdHJhbnNwYXJlbmN5XG4gKiAgIG1hc2suIElmIHRydWUsIHVzZXIgZGVmaW5lZCBjb2xvciBpcyBhcHBsaWVkLiBJZiBmYWxzZSwgb3JpZ2luYWwgY29sb3IgZnJvbSB0aGUgaW1hZ2UgaXNcbiAqICAgYXBwbGllZC4gRGVmYXVsdCB0byBmYWxzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy5zaXplIC0gaWNvbiBzaXplIGluIHBpeGVsc1xuICogQHBhcmFtIHtmdW5jfSBwcm9wcy5nZXRQb3NpdGlvbiAtIHJldHVybnMgYW5jaG9yIHBvc2l0aW9uIG9mIHRoZSBpY29uLCBpbiBbbG5nLCBsYXQsIHpdXG4gKiBAcGFyYW0ge2Z1bmN9IHByb3BzLmdldEljb24gLSByZXR1cm5zIGljb24gbmFtZSBhcyBhIHN0cmluZ1xuICogQHBhcmFtIHtmdW5jfSBwcm9wcy5nZXRTaXplIC0gcmV0dXJucyBpY29uIHNpemUgbXVsdGlwbGllciBhcyBhIG51bWJlclxuICogQHBhcmFtIHtmdW5jfSBwcm9wcy5nZXRDb2xvciAtIHJldHVybnMgY29sb3Igb2YgdGhlIGljb24gaW4gW3IsIGcsIGIsIGFdLiBPbmx5IHdvcmtzIG9uIGljb25zXG4gKiAgIHdpdGggbWFzazogdHJ1ZS5cbiAqL1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uIGdldFBvc2l0aW9uKHgpIHtcbiAgICByZXR1cm4geC5wb3NpdGlvbjtcbiAgfSxcbiAgZ2V0SWNvbjogZnVuY3Rpb24gZ2V0SWNvbih4KSB7XG4gICAgcmV0dXJuIHguaWNvbjtcbiAgfSxcbiAgZ2V0Q29sb3I6IGZ1bmN0aW9uIGdldENvbG9yKHgpIHtcbiAgICByZXR1cm4geC5jb2xvciB8fCBERUZBVUxUX0NPTE9SO1xuICB9LFxuICBnZXRTaXplOiBmdW5jdGlvbiBnZXRTaXplKHgpIHtcbiAgICByZXR1cm4geC5zaXplIHx8IDE7XG4gIH0sXG4gIGljb25BdGxhczogbnVsbCxcbiAgaWNvbk1hcHBpbmc6IHt9LFxuICBzaXplU2NhbGU6IDFcbn07XG5cbnZhciBJY29uTGF5ZXIgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhJY29uTGF5ZXIsIF9MYXllcik7XG5cbiAgZnVuY3Rpb24gSWNvbkxheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uTGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJY29uTGF5ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJY29uTGF5ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJY29uTGF5ZXIsIFt7XG4gICAga2V5OiAnaW5pdGlhbGl6ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgICAgdmFyIGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXI7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHsgc2l6ZTogMywgYWNjZXNzb3I6ICdnZXRQb3NpdGlvbicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyB9LFxuICAgICAgICBpbnN0YW5jZVNpemVzOiB7IHNpemU6IDEsIGFjY2Vzc29yOiAnZ2V0U2l6ZScsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVNpemVzIH0sXG4gICAgICAgIGluc3RhbmNlT2Zmc2V0czogeyBzaXplOiAyLCBhY2Nlc3NvcjogJ2dldEljb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VPZmZzZXRzIH0sXG4gICAgICAgIGluc3RhbmNlSWNvbkZyYW1lczogeyBzaXplOiA0LCBhY2Nlc3NvcjogJ2dldEljb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VJY29uRnJhbWVzIH0sXG4gICAgICAgIGluc3RhbmNlQ29sb3JNb2RlczogeyBzaXplOiAxLCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCBhY2Nlc3NvcjogJ2dldEljb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb2xvck1vZGUgfSxcbiAgICAgICAgaW5zdGFuY2VDb2xvcnM6IHsgc2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgYWNjZXNzb3I6ICdnZXRDb2xvcicsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyB9XG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBtb2RlbDogdGhpcy5nZXRNb2RlbChnbCkgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTdGF0ZShfcmVmKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9sZFByb3BzID0gX3JlZi5vbGRQcm9wcyxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgY2hhbmdlRmxhZ3MgPSBfcmVmLmNoYW5nZUZsYWdzO1xuICAgICAgdmFyIGljb25BdGxhcyA9IHByb3BzLmljb25BdGxhcztcblxuXG4gICAgICBpZiAob2xkUHJvcHMuaWNvbkF0bGFzICE9PSBpY29uQXRsYXMpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaWNvbnMgPSB7fTtcbiAgICAgICAgICBfdGhpczIuc3RhdGUuaWNvbnMgPSBpY29ucztcblxuICAgICAgICAgIGlmIChpY29uQXRsYXMgaW5zdGFuY2VvZiBUZXh0dXJlMkQpIHtcbiAgICAgICAgICAgIGljb25zLnRleHR1cmUgPSBpY29uQXRsYXM7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWNvbkF0bGFzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbG9hZFRleHR1cmVzKF90aGlzMi5jb250ZXh0LmdsLCB7XG4gICAgICAgICAgICAgIHVybHM6IFtpY29uQXRsYXNdXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMSksXG4gICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gX3JlZjNbMF07XG5cbiAgICAgICAgICAgICAgaWNvbnMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoX3JlZjQpIHtcbiAgICAgIHZhciB1bmlmb3JtcyA9IF9yZWY0LnVuaWZvcm1zO1xuICAgICAgdmFyIF9jb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgIF9jb250ZXh0JHZpZXdwb3J0ID0gX2NvbnRleHQudmlld3BvcnQsXG4gICAgICAgICAgd2lkdGggPSBfY29udGV4dCR2aWV3cG9ydC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfY29udGV4dCR2aWV3cG9ydC5oZWlnaHQsXG4gICAgICAgICAgZ2wgPSBfY29udGV4dC5nbDtcbiAgICAgIHZhciBzaXplU2NhbGUgPSB0aGlzLnByb3BzLnNpemVTY2FsZTtcblxuICAgICAgdmFyIGljb25zVGV4dHVyZSA9IHRoaXMuc3RhdGUuaWNvbnMgJiYgdGhpcy5zdGF0ZS5pY29ucy50ZXh0dXJlO1xuXG4gICAgICBpZiAoaWNvbnNUZXh0dXJlKSB7XG4gICAgICAgIC8vIHRyYW5zcGFyZW5jeSBkb2Vzbid0IHdvcmsgd2l0aCBERVBUSF9URVNUIG9uXG4gICAgICAgIC8vIHRyYWRlb2ZmIGJlaW5nIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCBmb3JlZ3JvdW5kIGljb25zIHdpbGwgYmUgcmVuZGVyZWQgb24gdG9wXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIoT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgICAgICBpY29uc1RleHR1cmU6IGljb25zVGV4dHVyZSxcbiAgICAgICAgICBpY29uc1RleHR1cmVEaW06IFtpY29uc1RleHR1cmUud2lkdGgsIGljb25zVGV4dHVyZS5oZWlnaHRdLFxuICAgICAgICAgIHNpemVTY2FsZTogW3NpemVTY2FsZSAvIHdpZHRoLCAtc2l6ZVNjYWxlIC8gaGVpZ2h0XVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFNoYWRlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFkZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcbiNkZWZpbmUgU0hBREVSX05BTUUgaWNvbi1sYXllci12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzIgcG9zaXRpb25zO1xcblxcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVNpemVzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUljb25GcmFtZXM7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlQ29sb3JNb2RlcztcXG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZU9mZnNldHM7XFxuXFxudW5pZm9ybSB2ZWMyIHNpemVTY2FsZTtcXG5cXG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XFxudW5pZm9ybSB2ZWMyIGljb25zVGV4dHVyZURpbTtcXG5cXG52YXJ5aW5nIGZsb2F0IHZDb2xvck1vZGU7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZHM7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIHZlYzMgY2VudGVyID0gcHJvamVjdF9wb3NpdGlvbihpbnN0YW5jZVBvc2l0aW9ucyk7XFxuICB2ZWMyIHZlcnRleCA9IChwb3NpdGlvbnMgKyBpbnN0YW5jZU9mZnNldHMgKiAyLjApICogc2l6ZVNjYWxlICogaW5zdGFuY2VTaXplcztcXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF90b19jbGlwc3BhY2UodmVjNChjZW50ZXIsIDEuMCkpICsgdmVjNCh2ZXJ0ZXgsIDAuMCwgMC4wKTtcXG5cXG4gIHZUZXh0dXJlQ29vcmRzID0gbWl4KFxcbiAgICBpbnN0YW5jZUljb25GcmFtZXMueHksXFxuICAgIGluc3RhbmNlSWNvbkZyYW1lcy54eSArIGluc3RhbmNlSWNvbkZyYW1lcy56dyxcXG4gICAgKHBvc2l0aW9ucy54eSArIDEuMCkgLyAyLjBcXG4gICkgLyBpY29uc1RleHR1cmVEaW07XFxuXFxuICB2VGV4dHVyZUNvb3Jkcy55ID0gMS4wIC0gdlRleHR1cmVDb29yZHMueTtcXG5cXG4gIHZlYzQgY29sb3IgPSBpbnN0YW5jZUNvbG9ycyAvIDI1NS47XFxuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pO1xcbiAgdkNvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3IsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xcblxcbiAgdkNvbG9yTW9kZSA9IGluc3RhbmNlQ29sb3JNb2RlcztcXG59XFxuJyxcbiAgICAgICAgZnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcbiNkZWZpbmUgU0hBREVSX05BTUUgc2NhdHRlcnBsb3QtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxuI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgaWNvbnNUZXh0dXJlO1xcblxcbnZhcnlpbmcgZmxvYXQgdkNvbG9yTW9kZTtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkcztcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRChpY29uc1RleHR1cmUsIHZUZXh0dXJlQ29vcmRzKTtcXG5cXG4gIC8vIGlmIGNvbG9yTW9kZSA9PSAwLCB1c2UgcGl4ZWwgY29sb3IgZnJvbSB0aGUgdGV4dHVyZVxcbiAgLy8gaWYgY29sb3JNb2RlID09IDEgb3IgcmVuZGVyaW5nIHBpY2tpbmcgYnVmZmVyLCB1c2UgdGV4dHVyZSBhcyB0cmFuc3BhcmVuY3kgbWFza1xcbiAgdmVjMyBjb2xvciA9IG1peCh0ZXhDb2xvci5yZ2IsIHZDb2xvci5yZ2IsXFxuICAgIG1heCh2Q29sb3JNb2RlLCByZW5kZXJQaWNraW5nQnVmZmVyKVxcbiAgKTtcXG4gIGZsb2F0IGEgPSB0ZXhDb2xvci5hICogb3BhY2l0eSAqIG1peCgxLjAsIHZDb2xvci5hLCB2Q29sb3JNb2RlKTtcXG5cXG4gIC8vIGlmIHJlbmRlcmluZyB0byBzY3JlZW4sIHVzZSBtaXhlZCBhbHBoYVxcbiAgLy8gaWYgcmVuZGVyaW5nIHBpY2tpbmcgYnVmZmVyLCB1c2UgYmluYXJ5IGFscGhhXFxuICBhID0gbWl4KGEsIHN0ZXAoMC4xLCBhKSwgcmVuZGVyUGlja2luZ0J1ZmZlcik7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBhKTtcXG59XFxuJ1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vZGVsKGdsKSB7XG4gICAgICB2YXIgcG9zaXRpb25zID0gWy0xLCAtMSwgMCwgLTEsIDEsIDAsIDEsIDEsIDAsIDEsIC0xLCAwXTtcblxuICAgICAgdmFyIHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICAgIGdsOiBnbCxcbiAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgZHJhd01vZGU6IEdMLlRSSUFOR0xFX0ZBTixcbiAgICAgICAgICBwb3NpdGlvbnM6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zKVxuICAgICAgICB9KSxcbiAgICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3Byb3BzLmRhdGEsXG4gICAgICAgICAgZ2V0UG9zaXRpb24gPSBfcHJvcHMuZ2V0UG9zaXRpb247XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKG9iamVjdCk7XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBvc2l0aW9uWzBdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBwb3NpdGlvblsxXTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcG9zaXRpb25bMl0gfHwgMDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VTaXplcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlU2l6ZXMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wczIuZGF0YSxcbiAgICAgICAgICBnZXRTaXplID0gX3Byb3BzMi5nZXRTaXplO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFsdWVbaSsrXSA9IGdldFNpemUob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZUluc3RhbmNlQ29sb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wczMuZGF0YSxcbiAgICAgICAgICBnZXRDb2xvciA9IF9wcm9wczMuZ2V0Q29sb3I7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICB2YXIgY29sb3IgPSBnZXRDb2xvcihvYmplY3QpO1xuXG4gICAgICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yWzBdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBjb2xvclsxXTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gY29sb3JbMl07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IGlzTmFOKGNvbG9yWzNdKSA/IDI1NSA6IGNvbG9yWzNdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VPZmZzZXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSW5zdGFuY2VPZmZzZXRzKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHM0LmRhdGEsXG4gICAgICAgICAgaWNvbk1hcHBpbmcgPSBfcHJvcHM0Lmljb25NYXBwaW5nLFxuICAgICAgICAgIGdldEljb24gPSBfcHJvcHM0LmdldEljb247XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICB2YXIgaWNvbiA9IGdldEljb24ob2JqZWN0KTtcbiAgICAgICAgICB2YXIgcmVjdCA9IGljb25NYXBwaW5nW2ljb25dIHx8IHt9O1xuICAgICAgICAgIHZhbHVlW2krK10gPSAxIC8gMiAtIHJlY3QuYW5jaG9yWCAvIHJlY3Qud2lkdGggfHwgMDtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gMSAvIDIgLSByZWN0LmFuY2hvclkgLyByZWN0LmhlaWdodCB8fCAwO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VDb2xvck1vZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnN0YW5jZUNvbG9yTW9kZShhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfcHJvcHM1ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3Byb3BzNS5kYXRhLFxuICAgICAgICAgIGljb25NYXBwaW5nID0gX3Byb3BzNS5pY29uTWFwcGluZyxcbiAgICAgICAgICBnZXRJY29uID0gX3Byb3BzNS5nZXRJY29uO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgdmFyIGljb24gPSBnZXRJY29uKG9iamVjdCk7XG4gICAgICAgICAgdmFyIGNvbG9yTW9kZSA9IGljb25NYXBwaW5nW2ljb25dICYmIGljb25NYXBwaW5nW2ljb25dLm1hc2s7XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yTW9kZSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I1LnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I1KSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VJY29uRnJhbWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSW5zdGFuY2VJY29uRnJhbWVzKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHM2LmRhdGEsXG4gICAgICAgICAgaWNvbk1hcHBpbmcgPSBfcHJvcHM2Lmljb25NYXBwaW5nLFxuICAgICAgICAgIGdldEljb24gPSBfcHJvcHM2LmdldEljb247XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I2ID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IChfc3RlcDYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICB2YXIgaWNvbiA9IGdldEljb24ob2JqZWN0KTtcbiAgICAgICAgICB2YXIgcmVjdCA9IGljb25NYXBwaW5nW2ljb25dIHx8IHt9O1xuICAgICAgICAgIHZhbHVlW2krK10gPSByZWN0LnggfHwgMDtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcmVjdC55IHx8IDA7XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHJlY3Qud2lkdGggfHwgMDtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcmVjdC5oZWlnaHQgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yNiA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiAmJiBfaXRlcmF0b3I2LnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJY29uTGF5ZXI7XG59KExheWVyKTtcblxuZXhwb3J0IGRlZmF1bHQgSWNvbkxheWVyO1xuXG5cbkljb25MYXllci5sYXllck5hbWUgPSAnSWNvbkxheWVyJztcbkljb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvaWNvbi1sYXllci9pY29uLWxheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 38 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/point-cloud-layer/point-cloud-layer.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\n\nvar defaultProps = {\n  getPosition: function getPosition(x) {\n    return x.position;\n  },\n  getNormal: function getNormal(x) {\n    return x.normal;\n  },\n  getColor: function getColor(x) {\n    return x.color || DEFAULT_COLOR;\n  },\n  radius: 10, //  point radius in pixels\n  lightSettings: {\n    lightsPosition: [0, 0, 5000, -1000, 1000, 8000, 5000, -5000, 1000],\n    ambientRatio: 0.2,\n    diffuseRatio: 0.6,\n    specularRatio: 0.8,\n    lightsStrength: [1.0, 0.0, 0.8, 0.0, 0.4, 0.0],\n    numberOfLights: 3\n  }\n};\n\nvar ScatterplotLayer = function (_Layer) {\n  _inherits(ScatterplotLayer, _Layer);\n\n  function ScatterplotLayer() {\n    _classCallCheck(this, ScatterplotLayer);\n\n    return _possibleConstructorReturn(this, (ScatterplotLayer.__proto__ || Object.getPrototypeOf(ScatterplotLayer)).apply(this, arguments));\n  }\n\n  _createClass(ScatterplotLayer, [{\n    key: 'getShaders',\n    value: function getShaders(id) {\n      return {\n        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME point-cloud-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec3 instanceNormals;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float renderPickingBuffer;\\nuniform float opacity;\\nuniform float radius;\\nuniform vec2 screenSize;\\n\\nvarying vec4 vColor;\\nvarying vec2 unitPosition;\\n\\nvoid main(void) {\\n  // position on the containing square in [-1, 1] space\\n  unitPosition = positions.xy;\\n\\n  // Find the center of the point and add the current vertex\\n  vec4 position_worldspace = vec4(project_position(instancePositions), 1.0);\\n  vec2 vertex = positions.xy * radius / screenSize * 2.0;\\n  gl_Position = project_to_clipspace(position_worldspace) + vec4(vertex, 0.0, 0.0);\\n\\n  // Apply lighting\\n  float lightWeight = getLightWeight(position_worldspace, instanceNormals);\\n\\n  // Apply opacity to instance color, or return instance picking color\\n  vec4 color = vec4(lightWeight * instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n  vColor = mix(color, pickingColor, renderPickingBuffer);\\n}\\n',\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME point-cloud-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\nvarying vec2 unitPosition;\\n\\nvoid main(void) {\\n\\n  float distToCenter = length(unitPosition);\\n\\n  if (distToCenter <= 1.0) {\\n    gl_FragColor = vColor;\\n  } else {\\n    discard;\\n  }\\n}\\n',\n        modules: ['lighting']\n      };\n    }\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      var gl = this.context.gl;\n\n      this.setState({ model: this._getModel(gl) });\n\n      /* eslint-disable max-len */\n      this.state.attributeManager.addInstanced({\n        instancePositions: { size: 3, accessor: 'getPosition', update: this.calculateInstancePositions },\n        instanceNormals: { size: 3, accessor: 'getNormal', defaultValue: 1, update: this.calculateInstanceNormals },\n        instanceColors: { size: 4, type: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }\n      });\n      /* eslint-enable max-len */\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref) {\n      var uniforms = _ref.uniforms;\n      var _props = this.props,\n          radius = _props.radius,\n          lightSettings = _props.lightSettings;\n      var _context$viewport = this.context.viewport,\n          width = _context$viewport.width,\n          height = _context$viewport.height;\n\n      this.state.model.render(Object.assign({}, uniforms, {\n        radius: radius,\n        screenSize: [width, height]\n      }, lightSettings));\n    }\n  }, {\n    key: '_getModel',\n    value: function _getModel(gl) {\n      // a triangle that minimally cover the unit circle\n      var positions = [];\n      for (var i = 0; i < 3; i++) {\n        var angle = i / 3 * Math.PI * 2;\n        positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);\n      }\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLES,\n          positions: new Float32Array(positions)\n        }),\n        isInstanced: true\n      });\n    }\n  }, {\n    key: 'calculateInstancePositions',\n    value: function calculateInstancePositions(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getPosition = _props2.getPosition;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var point = _step.value;\n\n          var position = getPosition(point);\n          value[i++] = position[0];\n          value[i++] = position[1];\n          value[i++] = position[2];\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceNormals',\n    value: function calculateInstanceNormals(attribute) {\n      var _props3 = this.props,\n          data = _props3.data,\n          getNormal = _props3.getNormal;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var point = _step2.value;\n\n          var normal = getNormal(point);\n          value[i++] = normal[0];\n          value[i++] = normal[1];\n          value[i++] = normal[2];\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceColors',\n    value: function calculateInstanceColors(attribute) {\n      var _props4 = this.props,\n          data = _props4.data,\n          getColor = _props4.getColor;\n      var value = attribute.value;\n\n      var i = 0;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var point = _step3.value;\n\n          var color = getColor(point);\n          value[i++] = color[0];\n          value[i++] = color[1];\n          value[i++] = color[2];\n          value[i++] = isNaN(color[3]) ? 255 : color[3];\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }]);\n\n  return ScatterplotLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ScatterplotLayer;\n\n\nScatterplotLayer.layerName = 'PointCloudLayer';\nScatterplotLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtY2xvdWQtbGF5ZXIvcG9pbnQtY2xvdWQtbGF5ZXIuanM/NWU1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBHTCwgTW9kZWwsIEdlb21ldHJ5IH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcblxudmFyIERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uIGdldFBvc2l0aW9uKHgpIHtcbiAgICByZXR1cm4geC5wb3NpdGlvbjtcbiAgfSxcbiAgZ2V0Tm9ybWFsOiBmdW5jdGlvbiBnZXROb3JtYWwoeCkge1xuICAgIHJldHVybiB4Lm5vcm1hbDtcbiAgfSxcbiAgZ2V0Q29sb3I6IGZ1bmN0aW9uIGdldENvbG9yKHgpIHtcbiAgICByZXR1cm4geC5jb2xvciB8fCBERUZBVUxUX0NPTE9SO1xuICB9LFxuICByYWRpdXM6IDEwLCAvLyAgcG9pbnQgcmFkaXVzIGluIHBpeGVsc1xuICBsaWdodFNldHRpbmdzOiB7XG4gICAgbGlnaHRzUG9zaXRpb246IFswLCAwLCA1MDAwLCAtMTAwMCwgMTAwMCwgODAwMCwgNTAwMCwgLTUwMDAsIDEwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC4yLFxuICAgIGRpZmZ1c2VSYXRpbzogMC42LFxuICAgIHNwZWN1bGFyUmF0aW86IDAuOCxcbiAgICBsaWdodHNTdHJlbmd0aDogWzEuMCwgMC4wLCAwLjgsIDAuMCwgMC40LCAwLjBdLFxuICAgIG51bWJlck9mTGlnaHRzOiAzXG4gIH1cbn07XG5cbnZhciBTY2F0dGVycGxvdExheWVyID0gZnVuY3Rpb24gKF9MYXllcikge1xuICBfaW5oZXJpdHMoU2NhdHRlcnBsb3RMYXllciwgX0xheWVyKTtcblxuICBmdW5jdGlvbiBTY2F0dGVycGxvdExheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2F0dGVycGxvdExheWVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2NhdHRlcnBsb3RMYXllci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjYXR0ZXJwbG90TGF5ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY2F0dGVycGxvdExheWVyLCBbe1xuICAgIGtleTogJ2dldFNoYWRlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFkZXJzKGlkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2czogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBwb2ludC1jbG91ZC1sYXllci12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcblxcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlTm9ybWFscztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XFxuXFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXG51bmlmb3JtIHZlYzIgc2NyZWVuU2l6ZTtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIC8vIHBvc2l0aW9uIG9uIHRoZSBjb250YWluaW5nIHNxdWFyZSBpbiBbLTEsIDFdIHNwYWNlXFxuICB1bml0UG9zaXRpb24gPSBwb3NpdGlvbnMueHk7XFxuXFxuICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHBvaW50IGFuZCBhZGQgdGhlIGN1cnJlbnQgdmVydGV4XFxuICB2ZWM0IHBvc2l0aW9uX3dvcmxkc3BhY2UgPSB2ZWM0KHByb2plY3RfcG9zaXRpb24oaW5zdGFuY2VQb3NpdGlvbnMpLCAxLjApO1xcbiAgdmVjMiB2ZXJ0ZXggPSBwb3NpdGlvbnMueHkgKiByYWRpdXMgLyBzY3JlZW5TaXplICogMi4wO1xcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZShwb3NpdGlvbl93b3JsZHNwYWNlKSArIHZlYzQodmVydGV4LCAwLjAsIDAuMCk7XFxuXFxuICAvLyBBcHBseSBsaWdodGluZ1xcbiAgZmxvYXQgbGlnaHRXZWlnaHQgPSBnZXRMaWdodFdlaWdodChwb3NpdGlvbl93b3JsZHNwYWNlLCBpbnN0YW5jZU5vcm1hbHMpO1xcblxcbiAgLy8gQXBwbHkgb3BhY2l0eSB0byBpbnN0YW5jZSBjb2xvciwgb3IgcmV0dXJuIGluc3RhbmNlIHBpY2tpbmcgY29sb3JcXG4gIHZlYzQgY29sb3IgPSB2ZWM0KGxpZ2h0V2VpZ2h0ICogaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xcbiAgdmVjNCBwaWNraW5nQ29sb3IgPSB2ZWM0KGluc3RhbmNlUGlja2luZ0NvbG9ycyAvIDI1NS4sIDEuKTtcXG4gIHZDb2xvciA9IG1peChjb2xvciwgcGlja2luZ0NvbG9yLCByZW5kZXJQaWNraW5nQnVmZmVyKTtcXG59XFxuJyxcbiAgICAgICAgZnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgcG9pbnQtY2xvdWQtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxuI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyB2ZWMyIHVuaXRQb3NpdGlvbjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcbiAgZmxvYXQgZGlzdFRvQ2VudGVyID0gbGVuZ3RoKHVuaXRQb3NpdGlvbik7XFxuXFxuICBpZiAoZGlzdFRvQ2VudGVyIDw9IDEuMCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XFxuICB9IGVsc2Uge1xcbiAgICBkaXNjYXJkO1xcbiAgfVxcbn1cXG4nLFxuICAgICAgICBtb2R1bGVzOiBbJ2xpZ2h0aW5nJ11cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5pdGlhbGl6ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgbW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKSB9KTtcblxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7IHNpemU6IDMsIGFjY2Vzc29yOiAnZ2V0UG9zaXRpb24nLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnMgfSxcbiAgICAgICAgaW5zdGFuY2VOb3JtYWxzOiB7IHNpemU6IDMsIGFjY2Vzc29yOiAnZ2V0Tm9ybWFsJywgZGVmYXVsdFZhbHVlOiAxLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VOb3JtYWxzIH0sXG4gICAgICAgIGluc3RhbmNlQ29sb3JzOiB7IHNpemU6IDQsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIGFjY2Vzc29yOiAnZ2V0Q29sb3InLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMgfVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmKSB7XG4gICAgICB2YXIgdW5pZm9ybXMgPSBfcmVmLnVuaWZvcm1zO1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgcmFkaXVzID0gX3Byb3BzLnJhZGl1cyxcbiAgICAgICAgICBsaWdodFNldHRpbmdzID0gX3Byb3BzLmxpZ2h0U2V0dGluZ3M7XG4gICAgICB2YXIgX2NvbnRleHQkdmlld3BvcnQgPSB0aGlzLmNvbnRleHQudmlld3BvcnQsXG4gICAgICAgICAgd2lkdGggPSBfY29udGV4dCR2aWV3cG9ydC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfY29udGV4dCR2aWV3cG9ydC5oZWlnaHQ7XG5cbiAgICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICBzY3JlZW5TaXplOiBbd2lkdGgsIGhlaWdodF1cbiAgICAgIH0sIGxpZ2h0U2V0dGluZ3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0TW9kZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TW9kZWwoZ2wpIHtcbiAgICAgIC8vIGEgdHJpYW5nbGUgdGhhdCBtaW5pbWFsbHkgY292ZXIgdGhlIHVuaXQgY2lyY2xlXG4gICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICB2YXIgYW5nbGUgPSBpIC8gMyAqIE1hdGguUEkgKiAyO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChNYXRoLmNvcyhhbmdsZSkgKiAyLCBNYXRoLnNpbihhbmdsZSkgKiAyLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgICBnbDogZ2wsXG4gICAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgICB2czogc2hhZGVycy52cyxcbiAgICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRVMsXG4gICAgICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucylcbiAgICAgICAgfSksXG4gICAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHMyLmRhdGEsXG4gICAgICAgICAgZ2V0UG9zaXRpb24gPSBfcHJvcHMyLmdldFBvc2l0aW9uO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKHBvaW50KTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gcG9zaXRpb25bMF07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IHBvc2l0aW9uWzFdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBwb3NpdGlvblsyXTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VOb3JtYWxzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSW5zdGFuY2VOb3JtYWxzKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHMzLmRhdGEsXG4gICAgICAgICAgZ2V0Tm9ybWFsID0gX3Byb3BzMy5nZXROb3JtYWw7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBwb2ludCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHZhciBub3JtYWwgPSBnZXROb3JtYWwocG9pbnQpO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBub3JtYWxbMF07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IG5vcm1hbFsxXTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gbm9ybWFsWzJdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3Byb3BzNC5kYXRhLFxuICAgICAgICAgIGdldENvbG9yID0gX3Byb3BzNC5nZXRDb2xvcjtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIGNvbG9yID0gZ2V0Q29sb3IocG9pbnQpO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBjb2xvclswXTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gY29sb3JbMV07XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IGNvbG9yWzJdO1xuICAgICAgICAgIHZhbHVlW2krK10gPSBpc05hTihjb2xvclszXSkgPyAyNTUgOiBjb2xvclszXTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY2F0dGVycGxvdExheWVyO1xufShMYXllcik7XG5cbmV4cG9ydCBkZWZhdWx0IFNjYXR0ZXJwbG90TGF5ZXI7XG5cblxuU2NhdHRlcnBsb3RMYXllci5sYXllck5hbWUgPSAnUG9pbnRDbG91ZExheWVyJztcblNjYXR0ZXJwbG90TGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL3BvaW50LWNsb3VkLWxheWVyL3BvaW50LWNsb3VkLWxheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 39 */
/* exports provided: default */
/* exports used: default */
/*!******************************************************************************!*\
  !*** ./src/layers/core/point-density-grid-layer/point-density-grid-layer.js ***!
  \******************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__grid_layer_grid_layer__ = __webpack_require__(/*! ../grid-layer/grid-layer */ 19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__grid_aggregator__ = __webpack_require__(/*! ./grid-aggregator */ 52);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__ = __webpack_require__(/*! ../../../utils/scale-utils */ 33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__ = __webpack_require__(/*! ../../../utils/color-utils */ 32);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\nvar defaultCellSize = 1000;\nvar defaultElevationRange = [0, 1000];\nvar defaultElevationScale = 1;\n\nvar defaultProps = {\n  cellSize: defaultCellSize,\n  colorRange: __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__[\"a\" /* defaultColorRange */],\n  elevationRange: defaultElevationRange,\n  elevationScale: defaultElevationScale,\n  getPosition: function getPosition(x) {\n    return x.position;\n  }\n};\n\nfunction noop() {}\n\nfunction _needsReProjectPoints(oldProps, props) {\n  return oldProps.cellSize !== props.cellSize;\n}\n\nvar PointDensityGridLayer = function (_Layer) {\n  _inherits(PointDensityGridLayer, _Layer);\n\n  function PointDensityGridLayer() {\n    _classCallCheck(this, PointDensityGridLayer);\n\n    return _possibleConstructorReturn(this, (PointDensityGridLayer.__proto__ || Object.getPrototypeOf(PointDensityGridLayer)).apply(this, arguments));\n  }\n\n  _createClass(PointDensityGridLayer, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      this.state = {\n        gridOffset: { yOffset: 0.0089, xOffset: 0.0113 },\n        layerData: [],\n        countRange: null,\n        pickedCell: null\n      };\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n\n      if (changeFlags.dataChanged || _needsReProjectPoints(oldProps, props)) {\n        var _props = this.props,\n            data = _props.data,\n            cellSize = _props.cellSize,\n            getPosition = _props.getPosition;\n\n        var _pointToDensityGridDa = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__grid_aggregator__[\"a\" /* pointToDensityGridData */])(data, cellSize, getPosition),\n            gridOffset = _pointToDensityGridDa.gridOffset,\n            layerData = _pointToDensityGridDa.layerData,\n            countRange = _pointToDensityGridDa.countRange;\n\n        Object.assign(this.state, { gridOffset: gridOffset, layerData: layerData, countRange: countRange });\n      }\n    }\n  }, {\n    key: 'getPickingInfo',\n    value: function getPickingInfo(opts) {\n      var info = _get(PointDensityGridLayer.prototype.__proto__ || Object.getPrototypeOf(PointDensityGridLayer.prototype), 'getPickingInfo', this).call(this, opts);\n      var pickedCell = this.state.pickedCell;\n\n      return Object.assign(info, {\n        layer: this,\n        // override index with cell index\n        index: pickedCell ? pickedCell.index : -1,\n        picked: Boolean(pickedCell),\n        // override object with picked cell\n        object: pickedCell\n      });\n    }\n  }, {\n    key: '_onHoverSublayer',\n    value: function _onHoverSublayer(info) {\n\n      this.state.pickedCell = info.picked && info.index > -1 ? this.state.layerData[info.index] : null;\n    }\n  }, {\n    key: '_onGetSublayerColor',\n    value: function _onGetSublayerColor(cell) {\n      var colorRange = this.props.colorRange;\n\n      var colorDomain = this.props.colorDomain || this.state.countRange;\n\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__[\"a\" /* ordinalScale */])(colorDomain, colorRange, cell.count);\n    }\n  }, {\n    key: '_onGetSublayerElevation',\n    value: function _onGetSublayerElevation(cell) {\n      var elevationRange = this.props.elevationRange;\n\n      var elevationDomain = this.props.elevationDomain || [0, this.state.countRange[1]];\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__[\"b\" /* linearScale */])(elevationDomain, elevationRange, cell.count);\n    }\n  }, {\n    key: 'renderLayers',\n    value: function renderLayers() {\n      var id = this.props.id;\n\n\n      return new __WEBPACK_IMPORTED_MODULE_1__grid_layer_grid_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n        id: id + '-density-grid',\n        data: this.state.layerData,\n        latOffset: this.state.gridOffset.yOffset,\n        lonOffset: this.state.gridOffset.xOffset,\n        getColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        getPosition: function getPosition(d) {\n          return d.position;\n        },\n        // Override user's onHover and onClick props\n        onHover: this._onHoverSublayer.bind(this),\n        onClick: noop,\n        updateTriggers: {\n          getColor: { colorRange: this.props.colorRange },\n          getElevation: { elevationRange: this.props.elevationRange }\n        }\n      }));\n    }\n  }]);\n\n  return PointDensityGridLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = PointDensityGridLayer;\n\n\nPointDensityGridLayer.layerName = 'PointDensityGridLayer';\nPointDensityGridLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtZGVuc2l0eS1ncmlkLWxheWVyL3BvaW50LWRlbnNpdHktZ3JpZC1sYXllci5qcz9iOTk0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgR3JpZExheWVyIGZyb20gJy4uL2dyaWQtbGF5ZXIvZ3JpZC1sYXllcic7XG5cbmltcG9ydCB7IHBvaW50VG9EZW5zaXR5R3JpZERhdGEgfSBmcm9tICcuL2dyaWQtYWdncmVnYXRvcic7XG5pbXBvcnQgeyBvcmRpbmFsU2NhbGUsIGxpbmVhclNjYWxlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvc2NhbGUtdXRpbHMnO1xuaW1wb3J0IHsgZGVmYXVsdENvbG9yUmFuZ2UgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb2xvci11dGlscyc7XG5cbnZhciBkZWZhdWx0Q2VsbFNpemUgPSAxMDAwO1xudmFyIGRlZmF1bHRFbGV2YXRpb25SYW5nZSA9IFswLCAxMDAwXTtcbnZhciBkZWZhdWx0RWxldmF0aW9uU2NhbGUgPSAxO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBjZWxsU2l6ZTogZGVmYXVsdENlbGxTaXplLFxuICBjb2xvclJhbmdlOiBkZWZhdWx0Q29sb3JSYW5nZSxcbiAgZWxldmF0aW9uUmFuZ2U6IGRlZmF1bHRFbGV2YXRpb25SYW5nZSxcbiAgZWxldmF0aW9uU2NhbGU6IGRlZmF1bHRFbGV2YXRpb25TY2FsZSxcbiAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uIGdldFBvc2l0aW9uKHgpIHtcbiAgICByZXR1cm4geC5wb3NpdGlvbjtcbiAgfVxufTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIF9uZWVkc1JlUHJvamVjdFBvaW50cyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIG9sZFByb3BzLmNlbGxTaXplICE9PSBwcm9wcy5jZWxsU2l6ZTtcbn1cblxudmFyIFBvaW50RGVuc2l0eUdyaWRMYXllciA9IGZ1bmN0aW9uIChfTGF5ZXIpIHtcbiAgX2luaGVyaXRzKFBvaW50RGVuc2l0eUdyaWRMYXllciwgX0xheWVyKTtcblxuICBmdW5jdGlvbiBQb2ludERlbnNpdHlHcmlkTGF5ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvaW50RGVuc2l0eUdyaWRMYXllcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBvaW50RGVuc2l0eUdyaWRMYXllci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvaW50RGVuc2l0eUdyaWRMYXllcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvaW50RGVuc2l0eUdyaWRMYXllciwgW3tcbiAgICBrZXk6ICdpbml0aWFsaXplU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBncmlkT2Zmc2V0OiB7IHlPZmZzZXQ6IDAuMDA4OSwgeE9mZnNldDogMC4wMTEzIH0sXG4gICAgICAgIGxheWVyRGF0YTogW10sXG4gICAgICAgIGNvdW50UmFuZ2U6IG51bGwsXG4gICAgICAgIHBpY2tlZENlbGw6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTdGF0ZShfcmVmKSB7XG4gICAgICB2YXIgb2xkUHJvcHMgPSBfcmVmLm9sZFByb3BzLFxuICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBjaGFuZ2VGbGFncyA9IF9yZWYuY2hhbmdlRmxhZ3M7XG5cbiAgICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBfbmVlZHNSZVByb2plY3RQb2ludHMob2xkUHJvcHMsIHByb3BzKSkge1xuICAgICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGRhdGEgPSBfcHJvcHMuZGF0YSxcbiAgICAgICAgICAgIGNlbGxTaXplID0gX3Byb3BzLmNlbGxTaXplLFxuICAgICAgICAgICAgZ2V0UG9zaXRpb24gPSBfcHJvcHMuZ2V0UG9zaXRpb247XG5cbiAgICAgICAgdmFyIF9wb2ludFRvRGVuc2l0eUdyaWREYSA9IHBvaW50VG9EZW5zaXR5R3JpZERhdGEoZGF0YSwgY2VsbFNpemUsIGdldFBvc2l0aW9uKSxcbiAgICAgICAgICAgIGdyaWRPZmZzZXQgPSBfcG9pbnRUb0RlbnNpdHlHcmlkRGEuZ3JpZE9mZnNldCxcbiAgICAgICAgICAgIGxheWVyRGF0YSA9IF9wb2ludFRvRGVuc2l0eUdyaWREYS5sYXllckRhdGEsXG4gICAgICAgICAgICBjb3VudFJhbmdlID0gX3BvaW50VG9EZW5zaXR5R3JpZERhLmNvdW50UmFuZ2U7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCB7IGdyaWRPZmZzZXQ6IGdyaWRPZmZzZXQsIGxheWVyRGF0YTogbGF5ZXJEYXRhLCBjb3VudFJhbmdlOiBjb3VudFJhbmdlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFBpY2tpbmdJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGlja2luZ0luZm8ob3B0cykge1xuICAgICAgdmFyIGluZm8gPSBfZ2V0KFBvaW50RGVuc2l0eUdyaWRMYXllci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQb2ludERlbnNpdHlHcmlkTGF5ZXIucHJvdG90eXBlKSwgJ2dldFBpY2tpbmdJbmZvJywgdGhpcykuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgIHZhciBwaWNrZWRDZWxsID0gdGhpcy5zdGF0ZS5waWNrZWRDZWxsO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihpbmZvLCB7XG4gICAgICAgIGxheWVyOiB0aGlzLFxuICAgICAgICAvLyBvdmVycmlkZSBpbmRleCB3aXRoIGNlbGwgaW5kZXhcbiAgICAgICAgaW5kZXg6IHBpY2tlZENlbGwgPyBwaWNrZWRDZWxsLmluZGV4IDogLTEsXG4gICAgICAgIHBpY2tlZDogQm9vbGVhbihwaWNrZWRDZWxsKSxcbiAgICAgICAgLy8gb3ZlcnJpZGUgb2JqZWN0IHdpdGggcGlja2VkIGNlbGxcbiAgICAgICAgb2JqZWN0OiBwaWNrZWRDZWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfb25Ib3ZlclN1YmxheWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uSG92ZXJTdWJsYXllcihpbmZvKSB7XG5cbiAgICAgIHRoaXMuc3RhdGUucGlja2VkQ2VsbCA9IGluZm8ucGlja2VkICYmIGluZm8uaW5kZXggPiAtMSA/IHRoaXMuc3RhdGUubGF5ZXJEYXRhW2luZm8uaW5kZXhdIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfb25HZXRTdWJsYXllckNvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uR2V0U3VibGF5ZXJDb2xvcihjZWxsKSB7XG4gICAgICB2YXIgY29sb3JSYW5nZSA9IHRoaXMucHJvcHMuY29sb3JSYW5nZTtcblxuICAgICAgdmFyIGNvbG9yRG9tYWluID0gdGhpcy5wcm9wcy5jb2xvckRvbWFpbiB8fCB0aGlzLnN0YXRlLmNvdW50UmFuZ2U7XG5cbiAgICAgIHJldHVybiBvcmRpbmFsU2NhbGUoY29sb3JEb21haW4sIGNvbG9yUmFuZ2UsIGNlbGwuY291bnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19vbkdldFN1YmxheWVyRWxldmF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uR2V0U3VibGF5ZXJFbGV2YXRpb24oY2VsbCkge1xuICAgICAgdmFyIGVsZXZhdGlvblJhbmdlID0gdGhpcy5wcm9wcy5lbGV2YXRpb25SYW5nZTtcblxuICAgICAgdmFyIGVsZXZhdGlvbkRvbWFpbiA9IHRoaXMucHJvcHMuZWxldmF0aW9uRG9tYWluIHx8IFswLCB0aGlzLnN0YXRlLmNvdW50UmFuZ2VbMV1dO1xuICAgICAgcmV0dXJuIGxpbmVhclNjYWxlKGVsZXZhdGlvbkRvbWFpbiwgZWxldmF0aW9uUmFuZ2UsIGNlbGwuY291bnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckxheWVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckxheWVycygpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMucHJvcHMuaWQ7XG5cblxuICAgICAgcmV0dXJuIG5ldyBHcmlkTGF5ZXIoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICBpZDogaWQgKyAnLWRlbnNpdHktZ3JpZCcsXG4gICAgICAgIGRhdGE6IHRoaXMuc3RhdGUubGF5ZXJEYXRhLFxuICAgICAgICBsYXRPZmZzZXQ6IHRoaXMuc3RhdGUuZ3JpZE9mZnNldC55T2Zmc2V0LFxuICAgICAgICBsb25PZmZzZXQ6IHRoaXMuc3RhdGUuZ3JpZE9mZnNldC54T2Zmc2V0LFxuICAgICAgICBnZXRDb2xvcjogdGhpcy5fb25HZXRTdWJsYXllckNvbG9yLmJpbmQodGhpcyksXG4gICAgICAgIGdldEVsZXZhdGlvbjogdGhpcy5fb25HZXRTdWJsYXllckVsZXZhdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gZ2V0UG9zaXRpb24oZCkge1xuICAgICAgICAgIHJldHVybiBkLnBvc2l0aW9uO1xuICAgICAgICB9LFxuICAgICAgICAvLyBPdmVycmlkZSB1c2VyJ3Mgb25Ib3ZlciBhbmQgb25DbGljayBwcm9wc1xuICAgICAgICBvbkhvdmVyOiB0aGlzLl9vbkhvdmVyU3VibGF5ZXIuYmluZCh0aGlzKSxcbiAgICAgICAgb25DbGljazogbm9vcCxcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICBnZXRDb2xvcjogeyBjb2xvclJhbmdlOiB0aGlzLnByb3BzLmNvbG9yUmFuZ2UgfSxcbiAgICAgICAgICBnZXRFbGV2YXRpb246IHsgZWxldmF0aW9uUmFuZ2U6IHRoaXMucHJvcHMuZWxldmF0aW9uUmFuZ2UgfVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvaW50RGVuc2l0eUdyaWRMYXllcjtcbn0oTGF5ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBQb2ludERlbnNpdHlHcmlkTGF5ZXI7XG5cblxuUG9pbnREZW5zaXR5R3JpZExheWVyLmxheWVyTmFtZSA9ICdQb2ludERlbnNpdHlHcmlkTGF5ZXInO1xuUG9pbnREZW5zaXR5R3JpZExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9wb2ludC1kZW5zaXR5LWdyaWQtbGF5ZXIvcG9pbnQtZGVuc2l0eS1ncmlkLWxheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 40 */
/* exports provided: default */
/* exports used: default */
/*!************************************************************************************!*\
  !*** ./src/layers/core/point-density-hexagon-layer/point-density-hexagon-layer.js ***!
  \************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hexagon_layer_hexagon_layer__ = __webpack_require__(/*! ../hexagon-layer/hexagon-layer */ 20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__ = __webpack_require__(/*! ../../../utils/scale-utils */ 33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__ = __webpack_require__(/*! ../../../utils/color-utils */ 32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__hexagon_aggregator__ = __webpack_require__(/*! ./hexagon-aggregator */ 53);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\nvar defaultRadius = 1000;\nvar defaultCoverage = 1;\nvar defaultElevationRange = [0, 1000];\nvar defaultElevationScale = 1;\nvar defaultAggregator = __WEBPACK_IMPORTED_MODULE_5__hexagon_aggregator__[\"a\" /* pointToHexbin */];\n\nvar defaultProps = {\n  colorRange: __WEBPACK_IMPORTED_MODULE_4__utils_color_utils__[\"a\" /* defaultColorRange */],\n  elevationRange: defaultElevationRange,\n  elevationScale: defaultElevationScale,\n  radius: defaultRadius,\n  coverage: defaultCoverage,\n  hexagonAggregator: defaultAggregator,\n  getPosition: function getPosition(x) {\n    return x.position;\n  }\n};\n\nfunction noop() {}\n\nfunction _needsReProjectPoints(oldProps, props) {\n  return oldProps.radius !== props.radius;\n}\n\nfunction _getCountRange(hexagons) {\n  return [Math.min.apply(null, hexagons.map(function (bin) {\n    return bin.points.length;\n  })), Math.max.apply(null, hexagons.map(function (bin) {\n    return bin.points.length;\n  }))];\n}\n\nvar PointDensityHexagonLayer = function (_Layer) {\n  _inherits(PointDensityHexagonLayer, _Layer);\n\n  function PointDensityHexagonLayer(props) {\n    _classCallCheck(this, PointDensityHexagonLayer);\n\n    if (!props.radius) {\n      __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"a\" /* log */].once(0, 'PointDensityHexagonLayer: radius in meter is needed to aggregate points into ' + 'hexagonal bins, Now using 1000 meter as default');\n\n      props.radius = defaultRadius;\n    }\n\n    return _possibleConstructorReturn(this, (PointDensityHexagonLayer.__proto__ || Object.getPrototypeOf(PointDensityHexagonLayer)).call(this, props));\n  }\n\n  _createClass(PointDensityHexagonLayer, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      this.state = {\n        hexagons: [],\n        countRange: null,\n        pickedCell: null\n      };\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n\n      if (changeFlags.dataChanged || _needsReProjectPoints(oldProps, props)) {\n        var hexagonAggregator = this.props.hexagonAggregator;\n        var viewport = this.context.viewport;\n\n\n        var hexagons = hexagonAggregator(this.props, viewport);\n        var countRange = _getCountRange(hexagons);\n\n        Object.assign(this.state, { hexagons: hexagons, countRange: countRange });\n      }\n    }\n  }, {\n    key: 'getPickingInfo',\n    value: function getPickingInfo(opts) {\n      var info = _get(PointDensityHexagonLayer.prototype.__proto__ || Object.getPrototypeOf(PointDensityHexagonLayer.prototype), 'getPickingInfo', this).call(this, opts);\n      var pickedCell = this.state.pickedCell;\n\n      return Object.assign(info, {\n        layer: this,\n        // override index with cell index\n        index: pickedCell ? pickedCell.index : -1,\n        picked: Boolean(pickedCell),\n        // override object with picked cell\n        object: pickedCell\n      });\n    }\n  }, {\n    key: '_onHoverSublayer',\n    value: function _onHoverSublayer(info) {\n\n      this.state.pickedCell = info.picked && info.index > -1 ? this.state.hexagons[info.index] : null;\n    }\n  }, {\n    key: '_onGetSublayerColor',\n    value: function _onGetSublayerColor(cell) {\n      var colorRange = this.props.colorRange;\n\n      var colorDomain = this.props.colorDomain || this.state.countRange;\n\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__[\"a\" /* ordinalScale */])(colorDomain, colorRange, cell.points.length);\n    }\n  }, {\n    key: '_onGetSublayerElevation',\n    value: function _onGetSublayerElevation(cell) {\n      var elevationRange = this.props.elevationRange;\n\n      var elevationDomain = this.props.elevationDomain || [0, this.state.countRange[1]];\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_scale_utils__[\"b\" /* linearScale */])(elevationDomain, elevationRange, cell.points.length);\n    }\n  }, {\n    key: 'renderLayers',\n    value: function renderLayers() {\n      var _props = this.props,\n          id = _props.id,\n          radius = _props.radius;\n\n\n      return new __WEBPACK_IMPORTED_MODULE_1__hexagon_layer_hexagon_layer__[\"a\" /* default */](Object.assign({}, this.props, {\n        id: id + '-density-hexagon',\n        data: this.state.hexagons,\n        radius: radius,\n        angle: Math.PI,\n        getColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        // Override user's onHover and onClick props\n        onHover: this._onHoverSublayer.bind(this),\n        onClick: noop,\n        updateTriggers: {\n          getColor: { colorRange: this.props.colorRange },\n          getElevation: { elevationRange: this.props.elevationRange }\n        }\n      }));\n    }\n  }]);\n\n  return PointDensityHexagonLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = PointDensityHexagonLayer;\n\n\nPointDensityHexagonLayer.layerName = 'PointDensityHexagonLayer';\nPointDensityHexagonLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtZGVuc2l0eS1oZXhhZ29uLWxheWVyL3BvaW50LWRlbnNpdHktaGV4YWdvbi1sYXllci5qcz85MTdlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgSGV4YWdvbkxheWVyIGZyb20gJy4uL2hleGFnb24tbGF5ZXIvaGV4YWdvbi1sYXllcic7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuXG5pbXBvcnQgeyBvcmRpbmFsU2NhbGUsIGxpbmVhclNjYWxlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvc2NhbGUtdXRpbHMnO1xuaW1wb3J0IHsgZGVmYXVsdENvbG9yUmFuZ2UgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb2xvci11dGlscyc7XG5pbXBvcnQgeyBwb2ludFRvSGV4YmluIH0gZnJvbSAnLi9oZXhhZ29uLWFnZ3JlZ2F0b3InO1xuXG52YXIgZGVmYXVsdFJhZGl1cyA9IDEwMDA7XG52YXIgZGVmYXVsdENvdmVyYWdlID0gMTtcbnZhciBkZWZhdWx0RWxldmF0aW9uUmFuZ2UgPSBbMCwgMTAwMF07XG52YXIgZGVmYXVsdEVsZXZhdGlvblNjYWxlID0gMTtcbnZhciBkZWZhdWx0QWdncmVnYXRvciA9IHBvaW50VG9IZXhiaW47XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNvbG9yUmFuZ2U6IGRlZmF1bHRDb2xvclJhbmdlLFxuICBlbGV2YXRpb25SYW5nZTogZGVmYXVsdEVsZXZhdGlvblJhbmdlLFxuICBlbGV2YXRpb25TY2FsZTogZGVmYXVsdEVsZXZhdGlvblNjYWxlLFxuICByYWRpdXM6IGRlZmF1bHRSYWRpdXMsXG4gIGNvdmVyYWdlOiBkZWZhdWx0Q292ZXJhZ2UsXG4gIGhleGFnb25BZ2dyZWdhdG9yOiBkZWZhdWx0QWdncmVnYXRvcixcbiAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uIGdldFBvc2l0aW9uKHgpIHtcbiAgICByZXR1cm4geC5wb3NpdGlvbjtcbiAgfVxufTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIF9uZWVkc1JlUHJvamVjdFBvaW50cyhvbGRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIG9sZFByb3BzLnJhZGl1cyAhPT0gcHJvcHMucmFkaXVzO1xufVxuXG5mdW5jdGlvbiBfZ2V0Q291bnRSYW5nZShoZXhhZ29ucykge1xuICByZXR1cm4gW01hdGgubWluLmFwcGx5KG51bGwsIGhleGFnb25zLm1hcChmdW5jdGlvbiAoYmluKSB7XG4gICAgcmV0dXJuIGJpbi5wb2ludHMubGVuZ3RoO1xuICB9KSksIE1hdGgubWF4LmFwcGx5KG51bGwsIGhleGFnb25zLm1hcChmdW5jdGlvbiAoYmluKSB7XG4gICAgcmV0dXJuIGJpbi5wb2ludHMubGVuZ3RoO1xuICB9KSldO1xufVxuXG52YXIgUG9pbnREZW5zaXR5SGV4YWdvbkxheWVyID0gZnVuY3Rpb24gKF9MYXllcikge1xuICBfaW5oZXJpdHMoUG9pbnREZW5zaXR5SGV4YWdvbkxheWVyLCBfTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIFBvaW50RGVuc2l0eUhleGFnb25MYXllcihwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2ludERlbnNpdHlIZXhhZ29uTGF5ZXIpO1xuXG4gICAgaWYgKCFwcm9wcy5yYWRpdXMpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdQb2ludERlbnNpdHlIZXhhZ29uTGF5ZXI6IHJhZGl1cyBpbiBtZXRlciBpcyBuZWVkZWQgdG8gYWdncmVnYXRlIHBvaW50cyBpbnRvICcgKyAnaGV4YWdvbmFsIGJpbnMsIE5vdyB1c2luZyAxMDAwIG1ldGVyIGFzIGRlZmF1bHQnKTtcblxuICAgICAgcHJvcHMucmFkaXVzID0gZGVmYXVsdFJhZGl1cztcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBvaW50RGVuc2l0eUhleGFnb25MYXllci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvaW50RGVuc2l0eUhleGFnb25MYXllcikpLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb2ludERlbnNpdHlIZXhhZ29uTGF5ZXIsIFt7XG4gICAga2V5OiAnaW5pdGlhbGl6ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgaGV4YWdvbnM6IFtdLFxuICAgICAgICBjb3VudFJhbmdlOiBudWxsLFxuICAgICAgICBwaWNrZWRDZWxsOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGUoX3JlZikge1xuICAgICAgdmFyIG9sZFByb3BzID0gX3JlZi5vbGRQcm9wcyxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgY2hhbmdlRmxhZ3MgPSBfcmVmLmNoYW5nZUZsYWdzO1xuXG4gICAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQgfHwgX25lZWRzUmVQcm9qZWN0UG9pbnRzKG9sZFByb3BzLCBwcm9wcykpIHtcbiAgICAgICAgdmFyIGhleGFnb25BZ2dyZWdhdG9yID0gdGhpcy5wcm9wcy5oZXhhZ29uQWdncmVnYXRvcjtcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuXG5cbiAgICAgICAgdmFyIGhleGFnb25zID0gaGV4YWdvbkFnZ3JlZ2F0b3IodGhpcy5wcm9wcywgdmlld3BvcnQpO1xuICAgICAgICB2YXIgY291bnRSYW5nZSA9IF9nZXRDb3VudFJhbmdlKGhleGFnb25zKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUsIHsgaGV4YWdvbnM6IGhleGFnb25zLCBjb3VudFJhbmdlOiBjb3VudFJhbmdlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFBpY2tpbmdJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGlja2luZ0luZm8ob3B0cykge1xuICAgICAgdmFyIGluZm8gPSBfZ2V0KFBvaW50RGVuc2l0eUhleGFnb25MYXllci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQb2ludERlbnNpdHlIZXhhZ29uTGF5ZXIucHJvdG90eXBlKSwgJ2dldFBpY2tpbmdJbmZvJywgdGhpcykuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgIHZhciBwaWNrZWRDZWxsID0gdGhpcy5zdGF0ZS5waWNrZWRDZWxsO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihpbmZvLCB7XG4gICAgICAgIGxheWVyOiB0aGlzLFxuICAgICAgICAvLyBvdmVycmlkZSBpbmRleCB3aXRoIGNlbGwgaW5kZXhcbiAgICAgICAgaW5kZXg6IHBpY2tlZENlbGwgPyBwaWNrZWRDZWxsLmluZGV4IDogLTEsXG4gICAgICAgIHBpY2tlZDogQm9vbGVhbihwaWNrZWRDZWxsKSxcbiAgICAgICAgLy8gb3ZlcnJpZGUgb2JqZWN0IHdpdGggcGlja2VkIGNlbGxcbiAgICAgICAgb2JqZWN0OiBwaWNrZWRDZWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfb25Ib3ZlclN1YmxheWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uSG92ZXJTdWJsYXllcihpbmZvKSB7XG5cbiAgICAgIHRoaXMuc3RhdGUucGlja2VkQ2VsbCA9IGluZm8ucGlja2VkICYmIGluZm8uaW5kZXggPiAtMSA/IHRoaXMuc3RhdGUuaGV4YWdvbnNbaW5mby5pbmRleF0gOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19vbkdldFN1YmxheWVyQ29sb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HZXRTdWJsYXllckNvbG9yKGNlbGwpIHtcbiAgICAgIHZhciBjb2xvclJhbmdlID0gdGhpcy5wcm9wcy5jb2xvclJhbmdlO1xuXG4gICAgICB2YXIgY29sb3JEb21haW4gPSB0aGlzLnByb3BzLmNvbG9yRG9tYWluIHx8IHRoaXMuc3RhdGUuY291bnRSYW5nZTtcblxuICAgICAgcmV0dXJuIG9yZGluYWxTY2FsZShjb2xvckRvbWFpbiwgY29sb3JSYW5nZSwgY2VsbC5wb2ludHMubGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfb25HZXRTdWJsYXllckVsZXZhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkdldFN1YmxheWVyRWxldmF0aW9uKGNlbGwpIHtcbiAgICAgIHZhciBlbGV2YXRpb25SYW5nZSA9IHRoaXMucHJvcHMuZWxldmF0aW9uUmFuZ2U7XG5cbiAgICAgIHZhciBlbGV2YXRpb25Eb21haW4gPSB0aGlzLnByb3BzLmVsZXZhdGlvbkRvbWFpbiB8fCBbMCwgdGhpcy5zdGF0ZS5jb3VudFJhbmdlWzFdXTtcbiAgICAgIHJldHVybiBsaW5lYXJTY2FsZShlbGV2YXRpb25Eb21haW4sIGVsZXZhdGlvblJhbmdlLCBjZWxsLnBvaW50cy5sZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckxheWVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckxheWVycygpIHtcbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGlkID0gX3Byb3BzLmlkLFxuICAgICAgICAgIHJhZGl1cyA9IF9wcm9wcy5yYWRpdXM7XG5cblxuICAgICAgcmV0dXJuIG5ldyBIZXhhZ29uTGF5ZXIoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICBpZDogaWQgKyAnLWRlbnNpdHktaGV4YWdvbicsXG4gICAgICAgIGRhdGE6IHRoaXMuc3RhdGUuaGV4YWdvbnMsXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICBhbmdsZTogTWF0aC5QSSxcbiAgICAgICAgZ2V0Q29sb3I6IHRoaXMuX29uR2V0U3VibGF5ZXJDb2xvci5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRFbGV2YXRpb246IHRoaXMuX29uR2V0U3VibGF5ZXJFbGV2YXRpb24uYmluZCh0aGlzKSxcbiAgICAgICAgLy8gT3ZlcnJpZGUgdXNlcidzIG9uSG92ZXIgYW5kIG9uQ2xpY2sgcHJvcHNcbiAgICAgICAgb25Ib3ZlcjogdGhpcy5fb25Ib3ZlclN1YmxheWVyLmJpbmQodGhpcyksXG4gICAgICAgIG9uQ2xpY2s6IG5vb3AsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0Q29sb3I6IHsgY29sb3JSYW5nZTogdGhpcy5wcm9wcy5jb2xvclJhbmdlIH0sXG4gICAgICAgICAgZ2V0RWxldmF0aW9uOiB7IGVsZXZhdGlvblJhbmdlOiB0aGlzLnByb3BzLmVsZXZhdGlvblJhbmdlIH1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb2ludERlbnNpdHlIZXhhZ29uTGF5ZXI7XG59KExheWVyKTtcblxuZXhwb3J0IGRlZmF1bHQgUG9pbnREZW5zaXR5SGV4YWdvbkxheWVyO1xuXG5cblBvaW50RGVuc2l0eUhleGFnb25MYXllci5sYXllck5hbWUgPSAnUG9pbnREZW5zaXR5SGV4YWdvbkxheWVyJztcblBvaW50RGVuc2l0eUhleGFnb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtZGVuc2l0eS1oZXhhZ29uLWxheWVyL3BvaW50LWRlbnNpdHktaGV4YWdvbi1sYXllci5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 41 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************************!*\
  !*** ./src/layers/core/screen-grid-layer/screen-grid-layer.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nvar defaultProps = {\n  // @type {number} opts.unitWidth - width of the unit rectangle\n  unitWidth: 100,\n  // @type {number} opts.unitHeight - height of the unit rectangle\n  unitHeight: 100,\n  minColor: [0, 0, 0, 255],\n  maxColor: [0, 255, 0, 255],\n  getPosition: function getPosition(d) {\n    return d.position;\n  },\n  getWeight: function getWeight(d) {\n    return 1;\n  }\n};\n\nvar ScreenGridLayer = function (_Layer) {\n  _inherits(ScreenGridLayer, _Layer);\n\n  function ScreenGridLayer() {\n    _classCallCheck(this, ScreenGridLayer);\n\n    return _possibleConstructorReturn(this, (ScreenGridLayer.__proto__ || Object.getPrototypeOf(ScreenGridLayer)).apply(this, arguments));\n  }\n\n  _createClass(ScreenGridLayer, [{\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME grid-layer-vs\\n\\nattribute vec3 vertices;\\nattribute vec3 instancePositions;\\nattribute float instanceCount;\\nattribute vec3 instancePickingColors;\\n\\nuniform float maxCount;\\nuniform float opacity;\\nuniform vec4 minColor;\\nuniform vec4 maxColor;\\nuniform float renderPickingBuffer;\\nuniform vec3 cellScale;\\nuniform vec3 selectedPickingColor;\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  vec4 color = mix(minColor, maxColor, instanceCount / maxCount) / 255.;\\n\\n  vColor = mix(\\n    vec4(color.rgb, color.a * opacity),\\n    vec4(instancePickingColors / 255., 1.),\\n    renderPickingBuffer\\n  );\\n\\n  gl_Position = vec4(instancePositions + vertices * cellScale, 1.);\\n}\\n',\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n/* fragment shader for the grid-layer */\\n#define SHADER_NAME grid-layer-fs\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n'\n      };\n    }\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      var attributeManager = this.state.attributeManager;\n      /* eslint-disable max-len */\n\n      attributeManager.addInstanced({\n        instancePositions: { size: 3, update: this.calculateInstancePositions },\n        instanceCount: { size: 1, accessor: ['getPosition', 'getWeight'], update: this.calculateInstanceCount }\n      });\n      /* eslint-disable max-len */\n\n      var gl = this.context.gl;\n\n      this.setState({ model: this.getModel(gl) });\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n\n      var cellSizeChanged = props.unitWidth !== oldProps.unitWidth || props.unitHeight !== oldProps.unitHeight;\n\n      if (cellSizeChanged || changeFlags.viewportChanged) {\n        this.updateCell();\n      }\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var _props = this.props,\n          minColor = _props.minColor,\n          maxColor = _props.maxColor;\n      var _state = this.state,\n          model = _state.model,\n          cellScale = _state.cellScale,\n          maxCount = _state.maxCount;\n      var gl = this.context.gl;\n\n      gl.depthMask(true);\n      uniforms = Object.assign({}, uniforms, { minColor: minColor, maxColor: maxColor, cellScale: cellScale, maxCount: maxCount });\n      model.render(uniforms);\n    }\n  }, {\n    key: 'getModel',\n    value: function getModel(gl) {\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      return new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"Geometry\"]({\n          drawMode: __WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"GL\"].TRIANGLE_FAN,\n          vertices: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        }),\n        isInstanced: true\n      });\n    }\n  }, {\n    key: 'updateCell',\n    value: function updateCell() {\n      var _context$viewport = this.context.viewport,\n          width = _context$viewport.width,\n          height = _context$viewport.height;\n      var _props2 = this.props,\n          unitWidth = _props2.unitWidth,\n          unitHeight = _props2.unitHeight;\n\n\n      var MARGIN = 2;\n      var cellScale = new Float32Array([(unitWidth - MARGIN) / width * 2, -(unitHeight - MARGIN) / height * 2, 1]);\n      var numCol = Math.ceil(width / unitWidth);\n      var numRow = Math.ceil(height / unitHeight);\n\n      this.setState({\n        cellScale: cellScale,\n        numCol: numCol,\n        numRow: numRow,\n        numInstances: numCol * numRow\n      });\n\n      var attributeManager = this.state.attributeManager;\n\n      attributeManager.invalidateAll();\n    }\n  }, {\n    key: 'calculateInstancePositions',\n    value: function calculateInstancePositions(attribute, _ref3) {\n      var numInstances = _ref3.numInstances;\n      var _context$viewport2 = this.context.viewport,\n          width = _context$viewport2.width,\n          height = _context$viewport2.height;\n      var _props3 = this.props,\n          unitWidth = _props3.unitWidth,\n          unitHeight = _props3.unitHeight;\n      var numCol = this.state.numCol;\n      var value = attribute.value,\n          size = attribute.size;\n\n\n      for (var i = 0; i < numInstances; i++) {\n        var x = i % numCol;\n        var y = Math.floor(i / numCol);\n        value[i * size + 0] = x * unitWidth / width * 2 - 1;\n        value[i * size + 1] = 1 - y * unitHeight / height * 2;\n        value[i * size + 2] = 0;\n      }\n    }\n  }, {\n    key: 'calculateInstanceCount',\n    value: function calculateInstanceCount(attribute) {\n      var _props4 = this.props,\n          data = _props4.data,\n          unitWidth = _props4.unitWidth,\n          unitHeight = _props4.unitHeight,\n          getPosition = _props4.getPosition,\n          getWeight = _props4.getWeight;\n      var _state2 = this.state,\n          numCol = _state2.numCol,\n          numRow = _state2.numRow;\n      var value = attribute.value;\n\n      var maxCount = 0;\n\n      value.fill(0.0);\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var point = _step.value;\n\n          var pixel = this.project(getPosition(point));\n          var colId = Math.floor(pixel[0] / unitWidth);\n          var rowId = Math.floor(pixel[1] / unitHeight);\n          if (colId >= 0 && colId < numCol && rowId >= 0 && rowId < numRow) {\n            var i = colId + rowId * numCol;\n            value[i] += getWeight(point);\n            if (value[i] > maxCount) {\n              maxCount = value[i];\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.setState({ maxCount: maxCount });\n    }\n  }]);\n\n  return ScreenGridLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ScreenGridLayer;\n\n\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvc2NyZWVuLWdyaWQtbGF5ZXIvc2NyZWVuLWdyaWQtbGF5ZXIuanM/NTBiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBHTCwgTW9kZWwsIEdlb21ldHJ5IH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgLy8gQHR5cGUge251bWJlcn0gb3B0cy51bml0V2lkdGggLSB3aWR0aCBvZiB0aGUgdW5pdCByZWN0YW5nbGVcbiAgdW5pdFdpZHRoOiAxMDAsXG4gIC8vIEB0eXBlIHtudW1iZXJ9IG9wdHMudW5pdEhlaWdodCAtIGhlaWdodCBvZiB0aGUgdW5pdCByZWN0YW5nbGVcbiAgdW5pdEhlaWdodDogMTAwLFxuICBtaW5Db2xvcjogWzAsIDAsIDAsIDI1NV0sXG4gIG1heENvbG9yOiBbMCwgMjU1LCAwLCAyNTVdLFxuICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gZ2V0UG9zaXRpb24oZCkge1xuICAgIHJldHVybiBkLnBvc2l0aW9uO1xuICB9LFxuICBnZXRXZWlnaHQ6IGZ1bmN0aW9uIGdldFdlaWdodChkKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5cbnZhciBTY3JlZW5HcmlkTGF5ZXIgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhTY3JlZW5HcmlkTGF5ZXIsIF9MYXllcik7XG5cbiAgZnVuY3Rpb24gU2NyZWVuR3JpZExheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JlZW5HcmlkTGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTY3JlZW5HcmlkTGF5ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JlZW5HcmlkTGF5ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY3JlZW5HcmlkTGF5ZXIsIFt7XG4gICAga2V5OiAnZ2V0U2hhZGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoYWRlcnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2czogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBncmlkLWxheWVyLXZzXFxuXFxuYXR0cmlidXRlIHZlYzMgdmVydGljZXM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlQ291bnQ7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcblxcbnVuaWZvcm0gZmxvYXQgbWF4Q291bnQ7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gdmVjNCBtaW5Db2xvcjtcXG51bmlmb3JtIHZlYzQgbWF4Q29sb3I7XFxudW5pZm9ybSBmbG9hdCByZW5kZXJQaWNraW5nQnVmZmVyO1xcbnVuaWZvcm0gdmVjMyBjZWxsU2NhbGU7XFxudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIHZlYzQgY29sb3IgPSBtaXgobWluQ29sb3IsIG1heENvbG9yLCBpbnN0YW5jZUNvdW50IC8gbWF4Q291bnQpIC8gMjU1LjtcXG5cXG4gIHZDb2xvciA9IG1peChcXG4gICAgdmVjNChjb2xvci5yZ2IsIGNvbG9yLmEgKiBvcGFjaXR5KSxcXG4gICAgdmVjNChpbnN0YW5jZVBpY2tpbmdDb2xvcnMgLyAyNTUuLCAxLiksXFxuICAgIHJlbmRlclBpY2tpbmdCdWZmZXJcXG4gICk7XFxuXFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoaW5zdGFuY2VQb3NpdGlvbnMgKyB2ZXJ0aWNlcyAqIGNlbGxTY2FsZSwgMS4pO1xcbn1cXG4nLFxuICAgICAgICBmczogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuLyogZnJhZ21lbnQgc2hhZGVyIGZvciB0aGUgZ3JpZC1sYXllciAqL1xcbiNkZWZpbmUgU0hBREVSX05BTUUgZ3JpZC1sYXllci1mc1xcblxcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XFxufVxcbidcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5pdGlhbGl6ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgICAgdmFyIGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXI7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHsgc2l6ZTogMywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zIH0sXG4gICAgICAgIGluc3RhbmNlQ291bnQ6IHsgc2l6ZTogMSwgYWNjZXNzb3I6IFsnZ2V0UG9zaXRpb24nLCAnZ2V0V2VpZ2h0J10sIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvdW50IH1cbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4gICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBtb2RlbDogdGhpcy5nZXRNb2RlbChnbCkgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTdGF0ZShfcmVmKSB7XG4gICAgICB2YXIgb2xkUHJvcHMgPSBfcmVmLm9sZFByb3BzLFxuICAgICAgICAgIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBjaGFuZ2VGbGFncyA9IF9yZWYuY2hhbmdlRmxhZ3M7XG5cbiAgICAgIHZhciBjZWxsU2l6ZUNoYW5nZWQgPSBwcm9wcy51bml0V2lkdGggIT09IG9sZFByb3BzLnVuaXRXaWR0aCB8fCBwcm9wcy51bml0SGVpZ2h0ICE9PSBvbGRQcm9wcy51bml0SGVpZ2h0O1xuXG4gICAgICBpZiAoY2VsbFNpemVDaGFuZ2VkIHx8IGNoYW5nZUZsYWdzLnZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNlbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmMikge1xuICAgICAgdmFyIHVuaWZvcm1zID0gX3JlZjIudW5pZm9ybXM7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBtaW5Db2xvciA9IF9wcm9wcy5taW5Db2xvcixcbiAgICAgICAgICBtYXhDb2xvciA9IF9wcm9wcy5tYXhDb2xvcjtcbiAgICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIG1vZGVsID0gX3N0YXRlLm1vZGVsLFxuICAgICAgICAgIGNlbGxTY2FsZSA9IF9zdGF0ZS5jZWxsU2NhbGUsXG4gICAgICAgICAgbWF4Q291bnQgPSBfc3RhdGUubWF4Q291bnQ7XG4gICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cbiAgICAgIGdsLmRlcHRoTWFzayh0cnVlKTtcbiAgICAgIHVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHsgbWluQ29sb3I6IG1pbkNvbG9yLCBtYXhDb2xvcjogbWF4Q29sb3IsIGNlbGxTY2FsZTogY2VsbFNjYWxlLCBtYXhDb3VudDogbWF4Q291bnQgfSk7XG4gICAgICBtb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldE1vZGVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kZWwoZ2wpIHtcbiAgICAgIHZhciBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgICBnbDogZ2wsXG4gICAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgICB2czogc2hhZGVycy52cyxcbiAgICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRV9GQU4sXG4gICAgICAgICAgdmVydGljZXM6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEsIDAsIDAsIDEsIDEsIDAsIDAsIDEsIDBdKVxuICAgICAgICB9KSxcbiAgICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUNlbGwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDZWxsKCkge1xuICAgICAgdmFyIF9jb250ZXh0JHZpZXdwb3J0ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0LFxuICAgICAgICAgIHdpZHRoID0gX2NvbnRleHQkdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX2NvbnRleHQkdmlld3BvcnQuaGVpZ2h0O1xuICAgICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIHVuaXRXaWR0aCA9IF9wcm9wczIudW5pdFdpZHRoLFxuICAgICAgICAgIHVuaXRIZWlnaHQgPSBfcHJvcHMyLnVuaXRIZWlnaHQ7XG5cblxuICAgICAgdmFyIE1BUkdJTiA9IDI7XG4gICAgICB2YXIgY2VsbFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbKHVuaXRXaWR0aCAtIE1BUkdJTikgLyB3aWR0aCAqIDIsIC0odW5pdEhlaWdodCAtIE1BUkdJTikgLyBoZWlnaHQgKiAyLCAxXSk7XG4gICAgICB2YXIgbnVtQ29sID0gTWF0aC5jZWlsKHdpZHRoIC8gdW5pdFdpZHRoKTtcbiAgICAgIHZhciBudW1Sb3cgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gdW5pdEhlaWdodCk7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBjZWxsU2NhbGU6IGNlbGxTY2FsZSxcbiAgICAgICAgbnVtQ29sOiBudW1Db2wsXG4gICAgICAgIG51bVJvdzogbnVtUm93LFxuICAgICAgICBudW1JbnN0YW5jZXM6IG51bUNvbCAqIG51bVJvd1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyO1xuXG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zKGF0dHJpYnV0ZSwgX3JlZjMpIHtcbiAgICAgIHZhciBudW1JbnN0YW5jZXMgPSBfcmVmMy5udW1JbnN0YW5jZXM7XG4gICAgICB2YXIgX2NvbnRleHQkdmlld3BvcnQyID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0LFxuICAgICAgICAgIHdpZHRoID0gX2NvbnRleHQkdmlld3BvcnQyLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9jb250ZXh0JHZpZXdwb3J0Mi5oZWlnaHQ7XG4gICAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgdW5pdFdpZHRoID0gX3Byb3BzMy51bml0V2lkdGgsXG4gICAgICAgICAgdW5pdEhlaWdodCA9IF9wcm9wczMudW5pdEhlaWdodDtcbiAgICAgIHZhciBudW1Db2wgPSB0aGlzLnN0YXRlLm51bUNvbDtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZSxcbiAgICAgICAgICBzaXplID0gYXR0cmlidXRlLnNpemU7XG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1JbnN0YW5jZXM7IGkrKykge1xuICAgICAgICB2YXIgeCA9IGkgJSBudW1Db2w7XG4gICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihpIC8gbnVtQ29sKTtcbiAgICAgICAgdmFsdWVbaSAqIHNpemUgKyAwXSA9IHggKiB1bml0V2lkdGggLyB3aWR0aCAqIDIgLSAxO1xuICAgICAgICB2YWx1ZVtpICogc2l6ZSArIDFdID0gMSAtIHkgKiB1bml0SGVpZ2h0IC8gaGVpZ2h0ICogMjtcbiAgICAgICAgdmFsdWVbaSAqIHNpemUgKyAyXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VDb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlQ291bnQoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wczQuZGF0YSxcbiAgICAgICAgICB1bml0V2lkdGggPSBfcHJvcHM0LnVuaXRXaWR0aCxcbiAgICAgICAgICB1bml0SGVpZ2h0ID0gX3Byb3BzNC51bml0SGVpZ2h0LFxuICAgICAgICAgIGdldFBvc2l0aW9uID0gX3Byb3BzNC5nZXRQb3NpdGlvbixcbiAgICAgICAgICBnZXRXZWlnaHQgPSBfcHJvcHM0LmdldFdlaWdodDtcbiAgICAgIHZhciBfc3RhdGUyID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBudW1Db2wgPSBfc3RhdGUyLm51bUNvbCxcbiAgICAgICAgICBudW1Sb3cgPSBfc3RhdGUyLm51bVJvdztcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblxuICAgICAgdmFyIG1heENvdW50ID0gMDtcblxuICAgICAgdmFsdWUuZmlsbCgwLjApO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBwaXhlbCA9IHRoaXMucHJvamVjdChnZXRQb3NpdGlvbihwb2ludCkpO1xuICAgICAgICAgIHZhciBjb2xJZCA9IE1hdGguZmxvb3IocGl4ZWxbMF0gLyB1bml0V2lkdGgpO1xuICAgICAgICAgIHZhciByb3dJZCA9IE1hdGguZmxvb3IocGl4ZWxbMV0gLyB1bml0SGVpZ2h0KTtcbiAgICAgICAgICBpZiAoY29sSWQgPj0gMCAmJiBjb2xJZCA8IG51bUNvbCAmJiByb3dJZCA+PSAwICYmIHJvd0lkIDwgbnVtUm93KSB7XG4gICAgICAgICAgICB2YXIgaSA9IGNvbElkICsgcm93SWQgKiBudW1Db2w7XG4gICAgICAgICAgICB2YWx1ZVtpXSArPSBnZXRXZWlnaHQocG9pbnQpO1xuICAgICAgICAgICAgaWYgKHZhbHVlW2ldID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgbWF4Q291bnQgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgbWF4Q291bnQ6IG1heENvdW50IH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY3JlZW5HcmlkTGF5ZXI7XG59KExheWVyKTtcblxuZXhwb3J0IGRlZmF1bHQgU2NyZWVuR3JpZExheWVyO1xuXG5cblNjcmVlbkdyaWRMYXllci5sYXllck5hbWUgPSAnU2NyZWVuR3JpZExheWVyJztcblNjcmVlbkdyaWRMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvc2NyZWVuLWdyaWQtbGF5ZXIvc2NyZWVuLWdyaWQtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 42 */
/* exports provided: default */
/* exports used: default */
/*!**************************************************************************!*\
  !*** ./src/layers/deprecated/choropleth-layer-64/choropleth-layer-64.js ***!
  \**************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__choropleth_layer_choropleth_layer__ = __webpack_require__(/*! ../choropleth-layer/choropleth-layer */ 24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep__ = __webpack_require__(/*! lodash.flattendeep */ 34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\nvar ChoroplethLayer64 = function (_ChoroplethLayer) {\n  _inherits(ChoroplethLayer64, _ChoroplethLayer);\n\n  function ChoroplethLayer64() {\n    _classCallCheck(this, ChoroplethLayer64);\n\n    return _possibleConstructorReturn(this, (ChoroplethLayer64.__proto__ || Object.getPrototypeOf(ChoroplethLayer64)).apply(this, arguments));\n  }\n\n  _createClass(ChoroplethLayer64, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      _get(ChoroplethLayer64.prototype.__proto__ || Object.getPrototypeOf(ChoroplethLayer64.prototype), 'initializeState', this).call(this);\n\n      this.state.attributeManager.addDynamic({\n        positions64: { size: 4, update: this.calculatePositions64 },\n        heights64: { size: 2, update: this.calculateHeights64 }\n      });\n    }\n  }, {\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME choropleth-layer-64-vertex-shader\\n\\nattribute vec4 positions64;\\nattribute vec2 heights64;\\nattribute vec4 colors;\\nattribute vec3 pickingColors;\\n\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\nuniform vec3 selectedPickingColor;\\n\\nuniform float pickingEnabled;\\nvarying vec4 vPickingColor;\\nvoid picking_setPickColor(vec3 pickingColor) {\\n  vPickingColor = vec4(pickingColor,  1.);\\n}\\nvec4 picking_setNormalAndPickColors(vec4 color, vec3 pickingColor) {\\n  vec4 pickingColor4 = vec4(pickingColor.rgb, 1.);\\n  vPickingColor = mix(color, pickingColor4, pickingEnabled);\\n  return vPickingColor;\\n}\\n\\nvoid main(void) {\\n  // For some reason, need to add one to elevation to show up in untilted mode\\n  vec2 projectedCoord[2];\\n  project_position_fp64(positions64, projectedCoord);\\n\\n  vec2 vertex_pos_modelspace[4];\\n\\n  vertex_pos_modelspace[0] = projectedCoord[0];\\n  vertex_pos_modelspace[1] = projectedCoord[1];\\n  vertex_pos_modelspace[2] = heights64;\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\\n\\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\\n\\n  picking_setNormalAndPickColors(\\n    color,\\n    pickingColors / 255.\\n  );\\n}\\n',\n        fs: _get(ChoroplethLayer64.prototype.__proto__ || Object.getPrototypeOf(ChoroplethLayer64.prototype), 'getShaders', this).call(this).fs,\n        fp64: true,\n        project64: true\n      };\n    }\n  }, {\n    key: 'calculatePositions64',\n    value: function calculatePositions64(attribute) {\n      var vertices = __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(this.state.choropleths);\n      attribute.value = new Float32Array(vertices.length / 3 * 4);\n      for (var index = 0; index < vertices.length / 3; index++) {\n        var _fp64ify = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(vertices[index * 3]);\n\n        var _fp64ify2 = _slicedToArray(_fp64ify, 2);\n\n        attribute.value[index * 4] = _fp64ify2[0];\n        attribute.value[index * 4 + 1] = _fp64ify2[1];\n\n        var _fp64ify3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(vertices[index * 3 + 1]);\n\n        var _fp64ify4 = _slicedToArray(_fp64ify3, 2);\n\n        attribute.value[index * 4 + 2] = _fp64ify4[0];\n        attribute.value[index * 4 + 3] = _fp64ify4[1];\n      }\n    }\n  }, {\n    key: 'calculateHeights64',\n    value: function calculateHeights64(attribute) {\n      var vertices = __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(this.state.choropleths);\n      attribute.value = new Float32Array(vertices.length / 3 * 2);\n      for (var index = 0; index < vertices.length / 3; index++) {\n        var _fp64ify5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(vertices[index * 3 + 2]);\n\n        var _fp64ify6 = _slicedToArray(_fp64ify5, 2);\n\n        attribute.value[index * 2] = _fp64ify6[0];\n        attribute.value[index * 2 + 1] = _fp64ify6[1];\n      }\n    }\n  }]);\n\n  return ChoroplethLayer64;\n}(__WEBPACK_IMPORTED_MODULE_0__choropleth_layer_choropleth_layer__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ChoroplethLayer64;\n\n\nChoroplethLayer64.layerName = 'ChoroplethLayer64';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci02NC9jaG9yb3BsZXRoLWxheWVyLTY0LmpzPzQyM2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IENob3JvcGxldGhMYXllciBmcm9tICcuLi9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXInO1xuaW1wb3J0IHsgZnA2NGlmeSB9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcbmltcG9ydCBmbGF0dGVuRGVlcCBmcm9tICdsb2Rhc2guZmxhdHRlbmRlZXAnO1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbnZhciBDaG9yb3BsZXRoTGF5ZXI2NCA9IGZ1bmN0aW9uIChfQ2hvcm9wbGV0aExheWVyKSB7XG4gIF9pbmhlcml0cyhDaG9yb3BsZXRoTGF5ZXI2NCwgX0Nob3JvcGxldGhMYXllcik7XG5cbiAgZnVuY3Rpb24gQ2hvcm9wbGV0aExheWVyNjQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENob3JvcGxldGhMYXllcjY0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ2hvcm9wbGV0aExheWVyNjQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDaG9yb3BsZXRoTGF5ZXI2NCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENob3JvcGxldGhMYXllcjY0LCBbe1xuICAgIGtleTogJ2luaXRpYWxpemVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICAgIF9nZXQoQ2hvcm9wbGV0aExheWVyNjQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2hvcm9wbGV0aExheWVyNjQucHJvdG90eXBlKSwgJ2luaXRpYWxpemVTdGF0ZScsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5hZGREeW5hbWljKHtcbiAgICAgICAgcG9zaXRpb25zNjQ6IHsgc2l6ZTogNCwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uczY0IH0sXG4gICAgICAgIGhlaWdodHM2NDogeyBzaXplOiAyLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSGVpZ2h0czY0IH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFNoYWRlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFkZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgY2hvcm9wbGV0aC1sYXllci02NC12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzQgcG9zaXRpb25zNjQ7XFxuYXR0cmlidXRlIHZlYzIgaGVpZ2h0czY0O1xcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9ycztcXG5hdHRyaWJ1dGUgdmVjMyBwaWNraW5nQ29sb3JzO1xcblxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IHJlbmRlclBpY2tpbmdCdWZmZXI7XFxudW5pZm9ybSB2ZWMzIHNlbGVjdGVkUGlja2luZ0NvbG9yO1xcblxcbnVuaWZvcm0gZmxvYXQgcGlja2luZ0VuYWJsZWQ7XFxudmFyeWluZyB2ZWM0IHZQaWNraW5nQ29sb3I7XFxudm9pZCBwaWNraW5nX3NldFBpY2tDb2xvcih2ZWMzIHBpY2tpbmdDb2xvcikge1xcbiAgdlBpY2tpbmdDb2xvciA9IHZlYzQocGlja2luZ0NvbG9yLCAgMS4pO1xcbn1cXG52ZWM0IHBpY2tpbmdfc2V0Tm9ybWFsQW5kUGlja0NvbG9ycyh2ZWM0IGNvbG9yLCB2ZWMzIHBpY2tpbmdDb2xvcikge1xcbiAgdmVjNCBwaWNraW5nQ29sb3I0ID0gdmVjNChwaWNraW5nQ29sb3IucmdiLCAxLik7XFxuICB2UGlja2luZ0NvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3I0LCBwaWNraW5nRW5hYmxlZCk7XFxuICByZXR1cm4gdlBpY2tpbmdDb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIC8vIEZvciBzb21lIHJlYXNvbiwgbmVlZCB0byBhZGQgb25lIHRvIGVsZXZhdGlvbiB0byBzaG93IHVwIGluIHVudGlsdGVkIG1vZGVcXG4gIHZlYzIgcHJvamVjdGVkQ29vcmRbMl07XFxuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQocG9zaXRpb25zNjQsIHByb2plY3RlZENvb3JkKTtcXG5cXG4gIHZlYzIgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzRdO1xcblxcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzBdID0gcHJvamVjdGVkQ29vcmRbMF07XFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBwcm9qZWN0ZWRDb29yZFsxXTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IGhlaWdodHM2NDtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSk7XFxuXFxuICB2ZWM0IGNvbG9yID0gdmVjNChjb2xvcnMucmdiLCBjb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcXG5cXG4gIHBpY2tpbmdfc2V0Tm9ybWFsQW5kUGlja0NvbG9ycyhcXG4gICAgY29sb3IsXFxuICAgIHBpY2tpbmdDb2xvcnMgLyAyNTUuXFxuICApO1xcbn1cXG4nLFxuICAgICAgICBmczogX2dldChDaG9yb3BsZXRoTGF5ZXI2NC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDaG9yb3BsZXRoTGF5ZXI2NC5wcm90b3R5cGUpLCAnZ2V0U2hhZGVycycsIHRoaXMpLmNhbGwodGhpcykuZnMsXG4gICAgICAgIGZwNjQ6IHRydWUsXG4gICAgICAgIHByb2plY3Q2NDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVQb3NpdGlvbnM2NCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uczY0KGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHZlcnRpY2VzID0gZmxhdHRlbkRlZXAodGhpcy5zdGF0ZS5jaG9yb3BsZXRocyk7XG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzLmxlbmd0aCAvIDMgKiA0KTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBfZnA2NGlmeSA9IGZwNjRpZnkodmVydGljZXNbaW5kZXggKiAzXSk7XG5cbiAgICAgICAgdmFyIF9mcDY0aWZ5MiA9IF9zbGljZWRUb0FycmF5KF9mcDY0aWZ5LCAyKTtcblxuICAgICAgICBhdHRyaWJ1dGUudmFsdWVbaW5kZXggKiA0XSA9IF9mcDY0aWZ5MlswXTtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlW2luZGV4ICogNCArIDFdID0gX2ZwNjRpZnkyWzFdO1xuXG4gICAgICAgIHZhciBfZnA2NGlmeTMgPSBmcDY0aWZ5KHZlcnRpY2VzW2luZGV4ICogMyArIDFdKTtcblxuICAgICAgICB2YXIgX2ZwNjRpZnk0ID0gX3NsaWNlZFRvQXJyYXkoX2ZwNjRpZnkzLCAyKTtcblxuICAgICAgICBhdHRyaWJ1dGUudmFsdWVbaW5kZXggKiA0ICsgMl0gPSBfZnA2NGlmeTRbMF07XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZVtpbmRleCAqIDQgKyAzXSA9IF9mcDY0aWZ5NFsxXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVIZWlnaHRzNjQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVIZWlnaHRzNjQoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgdmVydGljZXMgPSBmbGF0dGVuRGVlcCh0aGlzLnN0YXRlLmNob3JvcGxldGhzKTtcbiAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMubGVuZ3RoIC8gMyAqIDIpO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIF9mcDY0aWZ5NSA9IGZwNjRpZnkodmVydGljZXNbaW5kZXggKiAzICsgMl0pO1xuXG4gICAgICAgIHZhciBfZnA2NGlmeTYgPSBfc2xpY2VkVG9BcnJheShfZnA2NGlmeTUsIDIpO1xuXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZVtpbmRleCAqIDJdID0gX2ZwNjRpZnk2WzBdO1xuICAgICAgICBhdHRyaWJ1dGUudmFsdWVbaW5kZXggKiAyICsgMV0gPSBfZnA2NGlmeTZbMV07XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENob3JvcGxldGhMYXllcjY0O1xufShDaG9yb3BsZXRoTGF5ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBDaG9yb3BsZXRoTGF5ZXI2NDtcblxuXG5DaG9yb3BsZXRoTGF5ZXI2NC5sYXllck5hbWUgPSAnQ2hvcm9wbGV0aExheWVyNjQnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9kZXByZWNhdGVkL2Nob3JvcGxldGgtbGF5ZXItNjQvY2hvcm9wbGV0aC1sYXllci02NC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 43 */
/* exports provided: default */
/* exports used: default */
/*!********************************************************************************************!*\
  !*** ./src/layers/deprecated/extruded-choropleth-layer-64/extruded-choropleth-layer-64.js ***!
  \********************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut__ = __webpack_require__(/*! earcut */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_gl_matrix__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_path__);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [180, 180, 200];\nvar DEFAULT_AMBIENT_COLOR = [255, 255, 255];\nvar DEFAULT_POINTLIGHT_AMBIENT_COEFFICIENT = 0.1;\nvar DEFAULT_POINTLIGHT_LOCATION = [40.4406, -79.9959, 100];\nvar DEFAULT_POINTLIGHT_COLOR = [255, 255, 255];\nvar DEFAULT_POINTLIGHT_ATTENUATION = 1.0;\nvar DEFAULT_MATERIAL_SPECULAR_COLOR = [255, 255, 255];\nvar DEFAULT_MATERIAL_SHININESS = 1;\n\nvar defaultProps = {\n  opacity: 1,\n  elevation: 1\n};\n\nvar ExtrudedChoroplethLayer64 = function (_Layer) {\n  _inherits(ExtrudedChoroplethLayer64, _Layer);\n\n  function ExtrudedChoroplethLayer64() {\n    _classCallCheck(this, ExtrudedChoroplethLayer64);\n\n    return _possibleConstructorReturn(this, (ExtrudedChoroplethLayer64.__proto__ || Object.getPrototypeOf(ExtrudedChoroplethLayer64)).apply(this, arguments));\n  }\n\n  _createClass(ExtrudedChoroplethLayer64, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      var attributeManager = this.state.attributeManager;\n\n      attributeManager.add({\n        indices: { size: 1, isIndexed: true, update: this.calculateIndices },\n        positions: { size: 4, update: this.calculatePositions },\n        heights: { size: 2, update: this.calculateHeights },\n        normals: { size: 3, update: this.calculateNormals },\n        colors: { size: 4, update: this.calculateColors }\n      });\n\n      var gl = this.context.gl;\n\n      this.setState({\n        numInstances: 0,\n        model: this.getModel(gl)\n      });\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      var attributeManager = this.state.attributeManager;\n\n      if (changeFlags.dataChanged) {\n        this.extractExtrudedChoropleth();\n        attributeManager.invalidateAll();\n      }\n\n      var _props = this.props,\n          elevation = _props.elevation,\n          color = _props.color,\n          ambientColor = _props.ambientColor,\n          pointLightColor = _props.pointLightColor,\n          pointLightLocation = _props.pointLightLocation,\n          pointLightAmbientCoefficient = _props.pointLightAmbientCoefficient,\n          pointLightAttenuation = _props.pointLightAttenuation,\n          materialSpecularColor = _props.materialSpecularColor,\n          materialShininess = _props.materialShininess;\n\n\n      this.setUniforms({\n        elevation: Number.isFinite(elevation) ? elevation : 1,\n        colors: color || DEFAULT_COLOR,\n        uAmbientColor: ambientColor || DEFAULT_AMBIENT_COLOR,\n        uPointLightAmbientCoefficient: pointLightAmbientCoefficient || DEFAULT_POINTLIGHT_AMBIENT_COEFFICIENT,\n        uPointLightLocation: pointLightLocation || DEFAULT_POINTLIGHT_LOCATION,\n        uPointLightColor: pointLightColor || DEFAULT_POINTLIGHT_COLOR,\n        uPointLightAttenuation: pointLightAttenuation || DEFAULT_POINTLIGHT_ATTENUATION,\n        uMaterialSpecularColor: materialSpecularColor || DEFAULT_MATERIAL_SPECULAR_COLOR,\n        uMaterialShininess: materialShininess || DEFAULT_MATERIAL_SHININESS\n      });\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n\n      this.state.model.render(uniforms);\n    }\n  }, {\n    key: 'getPickingInfo',\n    value: function getPickingInfo(opts) {\n      var info = _get(ExtrudedChoroplethLayer64.prototype.__proto__ || Object.getPrototypeOf(ExtrudedChoroplethLayer64.prototype), 'getPickingInfo', this).call(this, opts);\n      var index = this.decodePickingColor(info.color);\n      var feature = index >= 0 ? this.props.data.features[index] : null;\n      info.feature = feature;\n      info.object = feature;\n      return info;\n    }\n  }, {\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME extruded-choropleths-layer-vertex-shader\\n\\nattribute vec4 positions;\\nattribute vec2 heights;\\nattribute vec3 normals;\\nuniform vec3 colors;\\n\\nuniform float opacity;\\nuniform float elevation;\\n\\nuniform vec3 uAmbientColor;\\nuniform float uPointLightAmbientCoefficient;\\nuniform vec3 uPointLightLocation;\\nuniform vec3 uPointLightColor;\\nuniform float uPointLightAttenuation;\\n\\nuniform vec3 uMaterialSpecularColor;\\nuniform float uMaterialShininess;\\n\\nvarying vec4 vColor;\\n\\nvec3 applyLighting(vec3 position_modelspace, vec3 normal_modelspace, vec3 color) {\\n\\n  vec3 pointLightLocation_modelspace = vec3(project_position(uPointLightLocation));\\n  vec3 lightDirection = normalize(pointLightLocation_modelspace - position_modelspace);\\n\\n  vec3 ambient = uPointLightAmbientCoefficient * color / 255.0 * uAmbientColor / 255.0;\\n\\n  float diffuseCoefficient = max(dot(normal_modelspace, lightDirection), 0.0);\\n  vec3 diffuse = diffuseCoefficient * uPointLightColor / 255. * color / 255.;\\n\\n  return ambient + uPointLightAttenuation * diffuse;\\n}\\n\\nvoid main(void) {\\n  vec2 projected_xy[2];\\n  project_position_fp64(positions, projected_xy);\\n  vec2 scaled_height = mul_fp64(heights, vec2(projectionPixelsPerUnit.x * elevation, 0.0));\\n\\n  vec2 vertex_pos_modelspace[4];\\n  vertex_pos_modelspace[0] = projected_xy[0];\\n  vertex_pos_modelspace[1] = projected_xy[1];\\n  vertex_pos_modelspace[2] = sum_fp64(scaled_height, vec2(1.0, 0.0));\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\\n\\n  vec3 color = applyLighting(\\n  \\tvec3(\\n  \\t  vertex_pos_modelspace[0].x,\\n  \\t  vertex_pos_modelspace[1].x,\\n  \\t  vertex_pos_modelspace[2].x),\\n  \\tnormals,\\n  \\tcolors\\n  );\\n  vColor = vec4(color, opacity);\\n}\\n// `;\\n',\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n/* fragment shader for the building-layer */\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n}\\n// `;\\n',\n        fp64: true,\n        project64: true\n      };\n    }\n  }, {\n    key: 'getModel',\n    value: function getModel(gl) {\n      // Make sure we have 32 bit support\n      // TODO - this could be done automatically by luma in \"draw\"\n      // when it detects 32 bit indices\n      if (!gl.getExtension('OES_element_index_uint')) {\n        throw new Error('Extruded choropleth layer needs 32 bit indices');\n      }\n\n      // Buildings are 3d so depth test should be enabled\n      // TODO - it is a little heavy handed to have a layer set this\n      // Alternatively, check depth test and warn if not set, or add a prop\n      // setDepthTest that is on by default.\n      gl.enable(__WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].DEPTH_TEST);\n      gl.depthFunc(__WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LEQUAL);\n\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      return new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: this.props.id,\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"Geometry\"]({\n          drawMode: this.props.drawWireframe ? __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].LINES : __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].TRIANGLES\n        }),\n        vertexCount: 0,\n        isIndexed: true\n      });\n    }\n\n    // each top vertex is on 3 surfaces\n    // each bottom vertex is on 2 surfaces\n\n  }, {\n    key: 'calculatePositions',\n    value: function calculatePositions(attribute) {\n      var _this2 = this;\n\n      var positions = this.state.positions;\n\n      if (!positions) {\n        positions = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(this.state.groupedVertices.map(function (vertices) {\n          var topVertices = Array.prototype.concat.apply([], vertices);\n          var baseVertices = topVertices.map(function (v) {\n            return [v[0], v[1], 0];\n          });\n          return _this2.props.drawWireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n        }));\n      }\n\n      attribute.value = new Float32Array(positions.length / 3 * 4);\n\n      for (var i = 0; i < positions.length / 3; i++) {\n        var _fp64ify = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positions[i * 3 + 0]);\n\n        var _fp64ify2 = _slicedToArray(_fp64ify, 2);\n\n        attribute.value[i * 4 + 0] = _fp64ify2[0];\n        attribute.value[i * 4 + 1] = _fp64ify2[1];\n\n        var _fp64ify3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positions[i * 3 + 1]);\n\n        var _fp64ify4 = _slicedToArray(_fp64ify3, 2);\n\n        attribute.value[i * 4 + 2] = _fp64ify4[0];\n        attribute.value[i * 4 + 3] = _fp64ify4[1];\n      }\n    }\n  }, {\n    key: 'calculateHeights',\n    value: function calculateHeights(attribute) {\n      var _this3 = this;\n\n      var positions = this.state.positions;\n\n      if (!positions) {\n        positions = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(this.state.groupedVertices.map(function (vertices) {\n          var topVertices = Array.prototype.concat.apply([], vertices);\n          var baseVertices = topVertices.map(function (v) {\n            return [v[0], v[1], 0];\n          });\n          return _this3.props.drawWireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n        }));\n      }\n\n      attribute.value = new Float32Array(positions.length / 3 * 2);\n      for (var i = 0; i < positions.length / 3; i++) {\n        var _fp64ify5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils_fp64__[\"a\" /* fp64ify */])(positions[i * 3 + 2] + 0.1);\n\n        var _fp64ify6 = _slicedToArray(_fp64ify5, 2);\n\n        attribute.value[i * 2 + 0] = _fp64ify6[0];\n        attribute.value[i * 2 + 1] = _fp64ify6[1];\n      }\n    }\n  }, {\n    key: 'calculateNormals',\n    value: function calculateNormals(attribute) {\n      var _this4 = this;\n\n      var up = [0, 1, 0];\n\n      var normals = this.state.groupedVertices.map(function (vertices, buildingIndex) {\n        var topNormals = new Array(countVertices(vertices)).fill(up);\n        var sideNormals = vertices.map(function (polygon) {\n          return _this4.calculateSideNormals(polygon);\n        });\n        var sideNormalsForward = sideNormals.map(function (n) {\n          return n[0];\n        });\n        var sideNormalsBackward = sideNormals.map(function (n) {\n          return n[1];\n        });\n\n        return _this4.props.drawWireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];\n      });\n\n      attribute.value = new Float32Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(normals));\n    }\n  }, {\n    key: 'calculateSideNormals',\n    value: function calculateSideNormals(vertices) {\n      var numVertices = vertices.length;\n      var normals = [];\n\n      for (var i = 0; i < numVertices - 1; i++) {\n        var n = getNormal(vertices[i], vertices[i + 1]);\n        normals.push(n);\n      }\n\n      return [[].concat(normals, [normals[0]]), [normals[0]].concat(normals)];\n    }\n  }, {\n    key: 'calculateIndices',\n    value: function calculateIndices(attribute) {\n      var _this5 = this;\n\n      // adjust index offset for multiple buildings\n      var multiplier = this.props.drawWireframe ? 2 : 5;\n      var offsets = this.state.groupedVertices.reduce(function (acc, vertices) {\n        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + countVertices(vertices) * multiplier]);\n      }, [0]);\n\n      var indices = this.state.groupedVertices.map(function (vertices, buildingIndex) {\n        return _this5.props.drawWireframe ?\n        // 1. get sequentially ordered indices of each building wireframe\n        // 2. offset them by the number of indices in previous buildings\n        _this5.calculateContourIndices(vertices, offsets[buildingIndex]) :\n        // 1. get triangulated indices for the internal areas\n        // 2. offset them by the number of indices in previous buildings\n        _this5.calculateSurfaceIndices(vertices, offsets[buildingIndex]);\n      });\n\n      attribute.value = new Uint32Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(indices));\n      attribute.target = __WEBPACK_IMPORTED_MODULE_3_luma_gl__[\"GL\"].ELEMENT_ARRAY_BUFFER;\n      this.state.model.setVertexCount(attribute.value.length / attribute.size);\n    }\n  }, {\n    key: 'calculateColors',\n    value: function calculateColors(attribute) {\n      var _this6 = this;\n\n      var colors = this.state.groupedVertices.map(function (vertices, buildingIndex) {\n        var color = _this6.props.color;\n\n        var baseColor = Array.isArray(color) ? color[0] : color;\n        var topColor = Array.isArray(color) ? color[color.length - 1] : color;\n        var numVertices = countVertices(vertices);\n\n        var topColors = new Array(numVertices).fill(topColor);\n        var baseColors = new Array(numVertices).fill(baseColor);\n        return _this6.props.drawWireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];\n      });\n      attribute.value = new Float32Array(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(colors));\n    }\n  }, {\n    key: 'extractExtrudedChoropleth',\n    value: function extractExtrudedChoropleth() {\n      var _this7 = this;\n\n      var data = this.props.data;\n      // Generate a flat list of buildings\n\n      this.state.buildings = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var _state$buildings;\n\n          var building = _step.value;\n          var properties = building.properties,\n              geometry = building.geometry;\n          var coordinates = geometry.coordinates,\n              type = geometry.type;\n\n          if (!properties.height) {\n            properties.height = Math.random() * 1000;\n          }\n          switch (type) {\n            case 'MultiPolygon':\n              // Maps to multiple buildings\n              var buildings = coordinates.map(function (coords) {\n                return { coordinates: coords, properties: properties };\n              });\n              (_state$buildings = _this7.state.buildings).push.apply(_state$buildings, _toConsumableArray(buildings));\n              break;\n            case 'Polygon':\n              // Maps to a single building\n              _this7.state.buildings.push({ coordinates: coordinates, properties: properties });\n              break;\n            default:\n            // We are ignoring Points for now\n          }\n        };\n\n        for (var _iterator = data.features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        }\n\n        // Generate vertices for the building list\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.state.groupedVertices = this.state.buildings.map(function (building) {\n        return building.coordinates.map(function (polygon) {\n          return polygon.map(function (coordinate) {\n            return [coordinate[0], coordinate[1], building.properties.height || 10];\n          });\n        });\n      });\n    }\n  }, {\n    key: 'calculateContourIndices',\n    value: function calculateContourIndices(vertices, offset) {\n      var stride = countVertices(vertices);\n\n      return vertices.map(function (polygon) {\n        var indices = [offset];\n        var numVertices = polygon.length;\n\n        // building top\n        // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]\n        for (var i = 1; i < numVertices - 1; i++) {\n          indices.push(i + offset, i + offset);\n        }\n        indices.push(offset);\n\n        // building sides\n        for (var _i = 0; _i < numVertices - 1; _i++) {\n          indices.push(_i + offset, _i + stride + offset);\n        }\n\n        offset += numVertices;\n        return indices;\n      });\n    }\n  }, {\n    key: 'calculateSurfaceIndices',\n    value: function calculateSurfaceIndices(vertices, offset) {\n      var stride = countVertices(vertices);\n      var holes = null;\n      var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];\n\n      if (vertices.length > 1) {\n        holes = vertices.reduce(function (acc, polygon) {\n          return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);\n        }, [0]).slice(1, vertices.length);\n      }\n\n      var topIndices = __WEBPACK_IMPORTED_MODULE_5_earcut___default()(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils__[\"b\" /* flatten */])(vertices), holes, 3).map(function (index) {\n        return index + offset;\n      });\n\n      var sideIndices = vertices.map(function (polygon) {\n        var numVertices = polygon.length;\n        // building top\n        var indices = [];\n\n        // building sides\n        for (var i = 0; i < numVertices - 1; i++) {\n          indices.push.apply(indices, _toConsumableArray(drawRectangle(i)));\n        }\n\n        offset += numVertices;\n        return indices;\n      });\n\n      return [topIndices, sideIndices];\n\n      function drawRectangle(i) {\n        return quad.map(function (v) {\n          return i + v[0] + stride * v[1] + offset;\n        });\n      }\n    }\n  }]);\n\n  return ExtrudedChoroplethLayer64;\n}(__WEBPACK_IMPORTED_MODULE_0__lib__[\"a\" /* Layer */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ExtrudedChoroplethLayer64;\n\n\nExtrudedChoroplethLayer64.layerName = 'ExtrudedChoroplethLayer64';\nExtrudedChoroplethLayer64.defaultProps = defaultProps;\n\n/*\n * helpers\n */\n// get normal vector of line segment\nfunction getNormal(p1, p2) {\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    return [1, 0, 0];\n  }\n\n  var degrees2radians = Math.PI / 180;\n\n  var lon1 = degrees2radians * p1[0];\n  var lon2 = degrees2radians * p2[0];\n  var lat1 = degrees2radians * p1[1];\n  var lat2 = degrees2radians * p2[1];\n\n  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n  return __WEBPACK_IMPORTED_MODULE_6_gl_matrix__[\"vec3\"].normalize([], [b, 0, -a]);\n}\n\n// count number of vertices in geojson polygon\nfunction countVertices(vertices) {\n  return vertices.reduce(function (count, polygon) {\n    return count + polygon.length;\n  }, 0);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci02NC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLTY0LmpzP2JjMjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQgeyBmcDY0aWZ5IH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHsgR0wsIE1vZGVsLCBHZW9tZXRyeSB9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5pbXBvcnQgeyB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG52YXIgREVGQVVMVF9DT0xPUiA9IFsxODAsIDE4MCwgMjAwXTtcbnZhciBERUZBVUxUX0FNQklFTlRfQ09MT1IgPSBbMjU1LCAyNTUsIDI1NV07XG52YXIgREVGQVVMVF9QT0lOVExJR0hUX0FNQklFTlRfQ09FRkZJQ0lFTlQgPSAwLjE7XG52YXIgREVGQVVMVF9QT0lOVExJR0hUX0xPQ0FUSU9OID0gWzQwLjQ0MDYsIC03OS45OTU5LCAxMDBdO1xudmFyIERFRkFVTFRfUE9JTlRMSUdIVF9DT0xPUiA9IFsyNTUsIDI1NSwgMjU1XTtcbnZhciBERUZBVUxUX1BPSU5UTElHSFRfQVRURU5VQVRJT04gPSAxLjA7XG52YXIgREVGQVVMVF9NQVRFUklBTF9TUEVDVUxBUl9DT0xPUiA9IFsyNTUsIDI1NSwgMjU1XTtcbnZhciBERUZBVUxUX01BVEVSSUFMX1NISU5JTkVTUyA9IDE7XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIG9wYWNpdHk6IDEsXG4gIGVsZXZhdGlvbjogMVxufTtcblxudmFyIEV4dHJ1ZGVkQ2hvcm9wbGV0aExheWVyNjQgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhFeHRydWRlZENob3JvcGxldGhMYXllcjY0LCBfTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIEV4dHJ1ZGVkQ2hvcm9wbGV0aExheWVyNjQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4dHJ1ZGVkQ2hvcm9wbGV0aExheWVyNjQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChFeHRydWRlZENob3JvcGxldGhMYXllcjY0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRXh0cnVkZWRDaG9yb3BsZXRoTGF5ZXI2NCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEV4dHJ1ZGVkQ2hvcm9wbGV0aExheWVyNjQsIFt7XG4gICAga2V5OiAnaW5pdGlhbGl6ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgICAgdmFyIGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXI7XG5cbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICAgICAgaW5kaWNlczogeyBzaXplOiAxLCBpc0luZGV4ZWQ6IHRydWUsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbmRpY2VzIH0sXG4gICAgICAgIHBvc2l0aW9uczogeyBzaXplOiA0LCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zIH0sXG4gICAgICAgIGhlaWdodHM6IHsgc2l6ZTogMiwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUhlaWdodHMgfSxcbiAgICAgICAgbm9ybWFsczogeyBzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlTm9ybWFscyB9LFxuICAgICAgICBjb2xvcnM6IHsgc2l6ZTogNCwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9ycyB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbnVtSW5zdGFuY2VzOiAwLFxuICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbChnbClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGUoX3JlZikge1xuICAgICAgdmFyIGNoYW5nZUZsYWdzID0gX3JlZi5jaGFuZ2VGbGFncztcbiAgICAgIHZhciBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyO1xuXG4gICAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5leHRyYWN0RXh0cnVkZWRDaG9yb3BsZXRoKCk7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBlbGV2YXRpb24gPSBfcHJvcHMuZWxldmF0aW9uLFxuICAgICAgICAgIGNvbG9yID0gX3Byb3BzLmNvbG9yLFxuICAgICAgICAgIGFtYmllbnRDb2xvciA9IF9wcm9wcy5hbWJpZW50Q29sb3IsXG4gICAgICAgICAgcG9pbnRMaWdodENvbG9yID0gX3Byb3BzLnBvaW50TGlnaHRDb2xvcixcbiAgICAgICAgICBwb2ludExpZ2h0TG9jYXRpb24gPSBfcHJvcHMucG9pbnRMaWdodExvY2F0aW9uLFxuICAgICAgICAgIHBvaW50TGlnaHRBbWJpZW50Q29lZmZpY2llbnQgPSBfcHJvcHMucG9pbnRMaWdodEFtYmllbnRDb2VmZmljaWVudCxcbiAgICAgICAgICBwb2ludExpZ2h0QXR0ZW51YXRpb24gPSBfcHJvcHMucG9pbnRMaWdodEF0dGVudWF0aW9uLFxuICAgICAgICAgIG1hdGVyaWFsU3BlY3VsYXJDb2xvciA9IF9wcm9wcy5tYXRlcmlhbFNwZWN1bGFyQ29sb3IsXG4gICAgICAgICAgbWF0ZXJpYWxTaGluaW5lc3MgPSBfcHJvcHMubWF0ZXJpYWxTaGluaW5lc3M7XG5cblxuICAgICAgdGhpcy5zZXRVbmlmb3Jtcyh7XG4gICAgICAgIGVsZXZhdGlvbjogTnVtYmVyLmlzRmluaXRlKGVsZXZhdGlvbikgPyBlbGV2YXRpb24gOiAxLFxuICAgICAgICBjb2xvcnM6IGNvbG9yIHx8IERFRkFVTFRfQ09MT1IsXG4gICAgICAgIHVBbWJpZW50Q29sb3I6IGFtYmllbnRDb2xvciB8fCBERUZBVUxUX0FNQklFTlRfQ09MT1IsXG4gICAgICAgIHVQb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50OiBwb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50IHx8IERFRkFVTFRfUE9JTlRMSUdIVF9BTUJJRU5UX0NPRUZGSUNJRU5ULFxuICAgICAgICB1UG9pbnRMaWdodExvY2F0aW9uOiBwb2ludExpZ2h0TG9jYXRpb24gfHwgREVGQVVMVF9QT0lOVExJR0hUX0xPQ0FUSU9OLFxuICAgICAgICB1UG9pbnRMaWdodENvbG9yOiBwb2ludExpZ2h0Q29sb3IgfHwgREVGQVVMVF9QT0lOVExJR0hUX0NPTE9SLFxuICAgICAgICB1UG9pbnRMaWdodEF0dGVudWF0aW9uOiBwb2ludExpZ2h0QXR0ZW51YXRpb24gfHwgREVGQVVMVF9QT0lOVExJR0hUX0FUVEVOVUFUSU9OLFxuICAgICAgICB1TWF0ZXJpYWxTcGVjdWxhckNvbG9yOiBtYXRlcmlhbFNwZWN1bGFyQ29sb3IgfHwgREVGQVVMVF9NQVRFUklBTF9TUEVDVUxBUl9DT0xPUixcbiAgICAgICAgdU1hdGVyaWFsU2hpbmluZXNzOiBtYXRlcmlhbFNoaW5pbmVzcyB8fCBERUZBVUxUX01BVEVSSUFMX1NISU5JTkVTU1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoX3JlZjIpIHtcbiAgICAgIHZhciB1bmlmb3JtcyA9IF9yZWYyLnVuaWZvcm1zO1xuXG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UGlja2luZ0luZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQaWNraW5nSW5mbyhvcHRzKSB7XG4gICAgICB2YXIgaW5mbyA9IF9nZXQoRXh0cnVkZWRDaG9yb3BsZXRoTGF5ZXI2NC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFeHRydWRlZENob3JvcGxldGhMYXllcjY0LnByb3RvdHlwZSksICdnZXRQaWNraW5nSW5mbycsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmRlY29kZVBpY2tpbmdDb2xvcihpbmZvLmNvbG9yKTtcbiAgICAgIHZhciBmZWF0dXJlID0gaW5kZXggPj0gMCA/IHRoaXMucHJvcHMuZGF0YS5mZWF0dXJlc1tpbmRleF0gOiBudWxsO1xuICAgICAgaW5mby5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgIGluZm8ub2JqZWN0ID0gZmVhdHVyZTtcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFNoYWRlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFkZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgZXh0cnVkZWQtY2hvcm9wbGV0aHMtbGF5ZXItdmVydGV4LXNoYWRlclxcblxcbmF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMiBoZWlnaHRzO1xcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbHM7XFxudW5pZm9ybSB2ZWMzIGNvbG9ycztcXG5cXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCBlbGV2YXRpb247XFxuXFxudW5pZm9ybSB2ZWMzIHVBbWJpZW50Q29sb3I7XFxudW5pZm9ybSBmbG9hdCB1UG9pbnRMaWdodEFtYmllbnRDb2VmZmljaWVudDtcXG51bmlmb3JtIHZlYzMgdVBvaW50TGlnaHRMb2NhdGlvbjtcXG51bmlmb3JtIHZlYzMgdVBvaW50TGlnaHRDb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVQb2ludExpZ2h0QXR0ZW51YXRpb247XFxuXFxudW5pZm9ybSB2ZWMzIHVNYXRlcmlhbFNwZWN1bGFyQ29sb3I7XFxudW5pZm9ybSBmbG9hdCB1TWF0ZXJpYWxTaGluaW5lc3M7XFxuXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG52ZWMzIGFwcGx5TGlnaHRpbmcodmVjMyBwb3NpdGlvbl9tb2RlbHNwYWNlLCB2ZWMzIG5vcm1hbF9tb2RlbHNwYWNlLCB2ZWMzIGNvbG9yKSB7XFxuXFxuICB2ZWMzIHBvaW50TGlnaHRMb2NhdGlvbl9tb2RlbHNwYWNlID0gdmVjMyhwcm9qZWN0X3Bvc2l0aW9uKHVQb2ludExpZ2h0TG9jYXRpb24pKTtcXG4gIHZlYzMgbGlnaHREaXJlY3Rpb24gPSBub3JtYWxpemUocG9pbnRMaWdodExvY2F0aW9uX21vZGVsc3BhY2UgLSBwb3NpdGlvbl9tb2RlbHNwYWNlKTtcXG5cXG4gIHZlYzMgYW1iaWVudCA9IHVQb2ludExpZ2h0QW1iaWVudENvZWZmaWNpZW50ICogY29sb3IgLyAyNTUuMCAqIHVBbWJpZW50Q29sb3IgLyAyNTUuMDtcXG5cXG4gIGZsb2F0IGRpZmZ1c2VDb2VmZmljaWVudCA9IG1heChkb3Qobm9ybWFsX21vZGVsc3BhY2UsIGxpZ2h0RGlyZWN0aW9uKSwgMC4wKTtcXG4gIHZlYzMgZGlmZnVzZSA9IGRpZmZ1c2VDb2VmZmljaWVudCAqIHVQb2ludExpZ2h0Q29sb3IgLyAyNTUuICogY29sb3IgLyAyNTUuO1xcblxcbiAgcmV0dXJuIGFtYmllbnQgKyB1UG9pbnRMaWdodEF0dGVudWF0aW9uICogZGlmZnVzZTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIHZlYzIgcHJvamVjdGVkX3h5WzJdO1xcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KHBvc2l0aW9ucywgcHJvamVjdGVkX3h5KTtcXG4gIHZlYzIgc2NhbGVkX2hlaWdodCA9IG11bF9mcDY0KGhlaWdodHMsIHZlYzIocHJvamVjdGlvblBpeGVsc1BlclVuaXQueCAqIGVsZXZhdGlvbiwgMC4wKSk7XFxuXFxuICB2ZWMyIHZlcnRleF9wb3NfbW9kZWxzcGFjZVs0XTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXSA9IHByb2plY3RlZF94eVswXTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsxXSA9IHByb2plY3RlZF94eVsxXTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVsyXSA9IHN1bV9mcDY0KHNjYWxlZF9oZWlnaHQsIHZlYzIoMS4wLCAwLjApKTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHZlcnRleF9wb3NfbW9kZWxzcGFjZSk7XFxuXFxuICB2ZWMzIGNvbG9yID0gYXBwbHlMaWdodGluZyhcXG4gIFxcdHZlYzMoXFxuICBcXHQgIHZlcnRleF9wb3NfbW9kZWxzcGFjZVswXS54LFxcbiAgXFx0ICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0ueCxcXG4gIFxcdCAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzJdLngpLFxcbiAgXFx0bm9ybWFscyxcXG4gIFxcdGNvbG9yc1xcbiAgKTtcXG4gIHZDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xcbn1cXG4vLyBgO1xcbicsXG4gICAgICAgIGZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4vKiBmcmFnbWVudCBzaGFkZXIgZm9yIHRoZSBidWlsZGluZy1sYXllciAqL1xcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XFxufVxcbi8vIGA7XFxuJyxcbiAgICAgICAgZnA2NDogdHJ1ZSxcbiAgICAgICAgcHJvamVjdDY0OiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldE1vZGVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kZWwoZ2wpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIDMyIGJpdCBzdXBwb3J0XG4gICAgICAvLyBUT0RPIC0gdGhpcyBjb3VsZCBiZSBkb25lIGF1dG9tYXRpY2FsbHkgYnkgbHVtYSBpbiBcImRyYXdcIlxuICAgICAgLy8gd2hlbiBpdCBkZXRlY3RzIDMyIGJpdCBpbmRpY2VzXG4gICAgICBpZiAoIWdsLmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0cnVkZWQgY2hvcm9wbGV0aCBsYXllciBuZWVkcyAzMiBiaXQgaW5kaWNlcycpO1xuICAgICAgfVxuXG4gICAgICAvLyBCdWlsZGluZ3MgYXJlIDNkIHNvIGRlcHRoIHRlc3Qgc2hvdWxkIGJlIGVuYWJsZWRcbiAgICAgIC8vIFRPRE8gLSBpdCBpcyBhIGxpdHRsZSBoZWF2eSBoYW5kZWQgdG8gaGF2ZSBhIGxheWVyIHNldCB0aGlzXG4gICAgICAvLyBBbHRlcm5hdGl2ZWx5LCBjaGVjayBkZXB0aCB0ZXN0IGFuZCB3YXJuIGlmIG5vdCBzZXQsIG9yIGFkZCBhIHByb3BcbiAgICAgIC8vIHNldERlcHRoVGVzdCB0aGF0IGlzIG9uIGJ5IGRlZmF1bHQuXG4gICAgICBnbC5lbmFibGUoR0wuREVQVEhfVEVTVCk7XG4gICAgICBnbC5kZXB0aEZ1bmMoR0wuTEVRVUFMKTtcblxuICAgICAgdmFyIHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgICAgcmV0dXJuIG5ldyBNb2RlbCh7XG4gICAgICAgIGdsOiBnbCxcbiAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgZHJhd01vZGU6IHRoaXMucHJvcHMuZHJhd1dpcmVmcmFtZSA/IEdMLkxJTkVTIDogR0wuVFJJQU5HTEVTXG4gICAgICAgIH0pLFxuICAgICAgICB2ZXJ0ZXhDb3VudDogMCxcbiAgICAgICAgaXNJbmRleGVkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBlYWNoIHRvcCB2ZXJ0ZXggaXMgb24gMyBzdXJmYWNlc1xuICAgIC8vIGVhY2ggYm90dG9tIHZlcnRleCBpcyBvbiAyIHN1cmZhY2VzXG5cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZVBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5zdGF0ZS5wb3NpdGlvbnM7XG5cbiAgICAgIGlmICghcG9zaXRpb25zKSB7XG4gICAgICAgIHBvc2l0aW9ucyA9IGZsYXR0ZW4odGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0aWNlcykge1xuICAgICAgICAgIHZhciB0b3BWZXJ0aWNlcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHZlcnRpY2VzKTtcbiAgICAgICAgICB2YXIgYmFzZVZlcnRpY2VzID0gdG9wVmVydGljZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gW3ZbMF0sIHZbMV0sIDBdO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBfdGhpczIucHJvcHMuZHJhd1dpcmVmcmFtZSA/IFt0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXSA6IFt0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIHRvcFZlcnRpY2VzLCBiYXNlVmVydGljZXMsIGJhc2VWZXJ0aWNlc107XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMubGVuZ3RoIC8gMyAqIDQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgICAgdmFyIF9mcDY0aWZ5ID0gZnA2NGlmeShwb3NpdGlvbnNbaSAqIDMgKyAwXSk7XG5cbiAgICAgICAgdmFyIF9mcDY0aWZ5MiA9IF9zbGljZWRUb0FycmF5KF9mcDY0aWZ5LCAyKTtcblxuICAgICAgICBhdHRyaWJ1dGUudmFsdWVbaSAqIDQgKyAwXSA9IF9mcDY0aWZ5MlswXTtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlW2kgKiA0ICsgMV0gPSBfZnA2NGlmeTJbMV07XG5cbiAgICAgICAgdmFyIF9mcDY0aWZ5MyA9IGZwNjRpZnkocG9zaXRpb25zW2kgKiAzICsgMV0pO1xuXG4gICAgICAgIHZhciBfZnA2NGlmeTQgPSBfc2xpY2VkVG9BcnJheShfZnA2NGlmeTMsIDIpO1xuXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZVtpICogNCArIDJdID0gX2ZwNjRpZnk0WzBdO1xuICAgICAgICBhdHRyaWJ1dGUudmFsdWVbaSAqIDQgKyAzXSA9IF9mcDY0aWZ5NFsxXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVIZWlnaHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSGVpZ2h0cyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5zdGF0ZS5wb3NpdGlvbnM7XG5cbiAgICAgIGlmICghcG9zaXRpb25zKSB7XG4gICAgICAgIHBvc2l0aW9ucyA9IGZsYXR0ZW4odGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0aWNlcykge1xuICAgICAgICAgIHZhciB0b3BWZXJ0aWNlcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHZlcnRpY2VzKTtcbiAgICAgICAgICB2YXIgYmFzZVZlcnRpY2VzID0gdG9wVmVydGljZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gW3ZbMF0sIHZbMV0sIDBdO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBfdGhpczMucHJvcHMuZHJhd1dpcmVmcmFtZSA/IFt0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXSA6IFt0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIHRvcFZlcnRpY2VzLCBiYXNlVmVydGljZXMsIGJhc2VWZXJ0aWNlc107XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMubGVuZ3RoIC8gMyAqIDIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSsrKSB7XG4gICAgICAgIHZhciBfZnA2NGlmeTUgPSBmcDY0aWZ5KHBvc2l0aW9uc1tpICogMyArIDJdICsgMC4xKTtcblxuICAgICAgICB2YXIgX2ZwNjRpZnk2ID0gX3NsaWNlZFRvQXJyYXkoX2ZwNjRpZnk1LCAyKTtcblxuICAgICAgICBhdHRyaWJ1dGUudmFsdWVbaSAqIDIgKyAwXSA9IF9mcDY0aWZ5NlswXTtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlW2kgKiAyICsgMV0gPSBfZnA2NGlmeTZbMV07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlTm9ybWFscycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZU5vcm1hbHMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHVwID0gWzAsIDEsIDBdO1xuXG4gICAgICB2YXIgbm9ybWFscyA9IHRoaXMuc3RhdGUuZ3JvdXBlZFZlcnRpY2VzLm1hcChmdW5jdGlvbiAodmVydGljZXMsIGJ1aWxkaW5nSW5kZXgpIHtcbiAgICAgICAgdmFyIHRvcE5vcm1hbHMgPSBuZXcgQXJyYXkoY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykpLmZpbGwodXApO1xuICAgICAgICB2YXIgc2lkZU5vcm1hbHMgPSB2ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmNhbGN1bGF0ZVNpZGVOb3JtYWxzKHBvbHlnb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNpZGVOb3JtYWxzRm9yd2FyZCA9IHNpZGVOb3JtYWxzLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBuWzBdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNpZGVOb3JtYWxzQmFja3dhcmQgPSBzaWRlTm9ybWFscy5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gblsxXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzNC5wcm9wcy5kcmF3V2lyZWZyYW1lID8gW3RvcE5vcm1hbHMsIHRvcE5vcm1hbHNdIDogW3RvcE5vcm1hbHMsIHNpZGVOb3JtYWxzRm9yd2FyZCwgc2lkZU5vcm1hbHNCYWNrd2FyZCwgc2lkZU5vcm1hbHNGb3J3YXJkLCBzaWRlTm9ybWFsc0JhY2t3YXJkXTtcbiAgICAgIH0pO1xuXG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXR0ZW4obm9ybWFscykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZVNpZGVOb3JtYWxzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlU2lkZU5vcm1hbHModmVydGljZXMpIHtcbiAgICAgIHZhciBudW1WZXJ0aWNlcyA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICAgIHZhciBub3JtYWxzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIG4gPSBnZXROb3JtYWwodmVydGljZXNbaV0sIHZlcnRpY2VzW2kgKyAxXSk7XG4gICAgICAgIG5vcm1hbHMucHVzaChuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtbXS5jb25jYXQobm9ybWFscywgW25vcm1hbHNbMF1dKSwgW25vcm1hbHNbMF1dLmNvbmNhdChub3JtYWxzKV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5kaWNlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgYnVpbGRpbmdzXG4gICAgICB2YXIgbXVsdGlwbGllciA9IHRoaXMucHJvcHMuZHJhd1dpcmVmcmFtZSA/IDIgOiA1O1xuICAgICAgdmFyIG9mZnNldHMgPSB0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdmVydGljZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWNjKSwgW2FjY1thY2MubGVuZ3RoIC0gMV0gKyBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSAqIG11bHRpcGxpZXJdKTtcbiAgICAgIH0sIFswXSk7XG5cbiAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0aWNlcywgYnVpbGRpbmdJbmRleCkge1xuICAgICAgICByZXR1cm4gX3RoaXM1LnByb3BzLmRyYXdXaXJlZnJhbWUgP1xuICAgICAgICAvLyAxLiBnZXQgc2VxdWVudGlhbGx5IG9yZGVyZWQgaW5kaWNlcyBvZiBlYWNoIGJ1aWxkaW5nIHdpcmVmcmFtZVxuICAgICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgYnVpbGRpbmdzXG4gICAgICAgIF90aGlzNS5jYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0c1tidWlsZGluZ0luZGV4XSkgOlxuICAgICAgICAvLyAxLiBnZXQgdHJpYW5ndWxhdGVkIGluZGljZXMgZm9yIHRoZSBpbnRlcm5hbCBhcmVhc1xuICAgICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgYnVpbGRpbmdzXG4gICAgICAgIF90aGlzNS5jYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0c1tidWlsZGluZ0luZGV4XSk7XG4gICAgICB9KTtcblxuICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IFVpbnQzMkFycmF5KGZsYXR0ZW4oaW5kaWNlcykpO1xuICAgICAgYXR0cmlidXRlLnRhcmdldCA9IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRWZXJ0ZXhDb3VudChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZUNvbG9ycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgY29sb3JzID0gdGhpcy5zdGF0ZS5ncm91cGVkVmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0aWNlcywgYnVpbGRpbmdJbmRleCkge1xuICAgICAgICB2YXIgY29sb3IgPSBfdGhpczYucHJvcHMuY29sb3I7XG5cbiAgICAgICAgdmFyIGJhc2VDb2xvciA9IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3JbMF0gOiBjb2xvcjtcbiAgICAgICAgdmFyIHRvcENvbG9yID0gQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvcltjb2xvci5sZW5ndGggLSAxXSA6IGNvbG9yO1xuICAgICAgICB2YXIgbnVtVmVydGljZXMgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcblxuICAgICAgICB2YXIgdG9wQ29sb3JzID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKS5maWxsKHRvcENvbG9yKTtcbiAgICAgICAgdmFyIGJhc2VDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoYmFzZUNvbG9yKTtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5wcm9wcy5kcmF3V2lyZWZyYW1lID8gW3RvcENvbG9ycywgYmFzZUNvbG9yc10gOiBbdG9wQ29sb3JzLCB0b3BDb2xvcnMsIHRvcENvbG9ycywgYmFzZUNvbG9ycywgYmFzZUNvbG9yc107XG4gICAgICB9KTtcbiAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdHRlbihjb2xvcnMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdleHRyYWN0RXh0cnVkZWRDaG9yb3BsZXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdEV4dHJ1ZGVkQ2hvcm9wbGV0aCgpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgZGF0YSA9IHRoaXMucHJvcHMuZGF0YTtcbiAgICAgIC8vIEdlbmVyYXRlIGEgZmxhdCBsaXN0IG9mIGJ1aWxkaW5nc1xuXG4gICAgICB0aGlzLnN0YXRlLmJ1aWxkaW5ncyA9IFtdO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgIHZhciBfc3RhdGUkYnVpbGRpbmdzO1xuXG4gICAgICAgICAgdmFyIGJ1aWxkaW5nID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBidWlsZGluZy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBnZW9tZXRyeSA9IGJ1aWxkaW5nLmdlb21ldHJ5O1xuICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICB0eXBlID0gZ2VvbWV0cnkudHlwZTtcblxuICAgICAgICAgIGlmICghcHJvcGVydGllcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuaGVpZ2h0ID0gTWF0aC5yYW5kb20oKSAqIDEwMDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgICAgICAgLy8gTWFwcyB0byBtdWx0aXBsZSBidWlsZGluZ3NcbiAgICAgICAgICAgICAgdmFyIGJ1aWxkaW5ncyA9IGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29vcmRpbmF0ZXM6IGNvb3JkcywgcHJvcGVydGllczogcHJvcGVydGllcyB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgKF9zdGF0ZSRidWlsZGluZ3MgPSBfdGhpczcuc3RhdGUuYnVpbGRpbmdzKS5wdXNoLmFwcGx5KF9zdGF0ZSRidWlsZGluZ3MsIF90b0NvbnN1bWFibGVBcnJheShidWlsZGluZ3MpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgICAgLy8gTWFwcyB0byBhIHNpbmdsZSBidWlsZGluZ1xuICAgICAgICAgICAgICBfdGhpczcuc3RhdGUuYnVpbGRpbmdzLnB1c2goeyBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFdlIGFyZSBpZ25vcmluZyBQb2ludHMgZm9yIG5vd1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBkYXRhLmZlYXR1cmVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSB2ZXJ0aWNlcyBmb3IgdGhlIGJ1aWxkaW5nIGxpc3RcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlLmdyb3VwZWRWZXJ0aWNlcyA9IHRoaXMuc3RhdGUuYnVpbGRpbmdzLm1hcChmdW5jdGlvbiAoYnVpbGRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkaW5nLmNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICAgIHJldHVybiBwb2x5Z29uLm1hcChmdW5jdGlvbiAoY29vcmRpbmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBidWlsZGluZy5wcm9wZXJ0aWVzLmhlaWdodCB8fCAxMF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlQ29udG91ckluZGljZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0KSB7XG4gICAgICB2YXIgc3RyaWRlID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG5cbiAgICAgIHJldHVybiB2ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSBbb2Zmc2V0XTtcbiAgICAgICAgdmFyIG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG5cbiAgICAgICAgLy8gYnVpbGRpbmcgdG9wXG4gICAgICAgIC8vIHVzZSB2ZXJ0ZXggcGFpcnMgZm9yIEdMLkxJTkVTID0+IFswLCAxLCAxLCAyLCAyLCAuLi4sIG4tMSwgbi0xLCAwXVxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGluZGljZXMucHVzaChvZmZzZXQpO1xuXG4gICAgICAgIC8vIGJ1aWxkaW5nIHNpZGVzXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1WZXJ0aWNlcyAtIDE7IF9pKyspIHtcbiAgICAgICAgICBpbmRpY2VzLnB1c2goX2kgKyBvZmZzZXQsIF9pICsgc3RyaWRlICsgb2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXQpIHtcbiAgICAgIHZhciBzdHJpZGUgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcbiAgICAgIHZhciBob2xlcyA9IG51bGw7XG4gICAgICB2YXIgcXVhZCA9IFtbMCwgMV0sIFswLCAzXSwgWzEsIDJdLCBbMSwgMl0sIFswLCAzXSwgWzEsIDRdXTtcblxuICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaG9sZXMgPSB2ZXJ0aWNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcG9seWdvbikge1xuICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFjYyksIFthY2NbYWNjLmxlbmd0aCAtIDFdICsgcG9seWdvbi5sZW5ndGhdKTtcbiAgICAgICAgfSwgWzBdKS5zbGljZSgxLCB2ZXJ0aWNlcy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9wSW5kaWNlcyA9IGVhcmN1dChmbGF0dGVuKHZlcnRpY2VzKSwgaG9sZXMsIDMpLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ICsgb2Zmc2V0O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBzaWRlSW5kaWNlcyA9IHZlcnRpY2VzLm1hcChmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICB2YXIgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcbiAgICAgICAgLy8gYnVpbGRpbmcgdG9wXG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICAgICAgLy8gYnVpbGRpbmcgc2lkZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgICAgIGluZGljZXMucHVzaC5hcHBseShpbmRpY2VzLCBfdG9Db25zdW1hYmxlQXJyYXkoZHJhd1JlY3RhbmdsZShpKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgICAgICByZXR1cm4gaW5kaWNlcztcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gW3RvcEluZGljZXMsIHNpZGVJbmRpY2VzXTtcblxuICAgICAgZnVuY3Rpb24gZHJhd1JlY3RhbmdsZShpKSB7XG4gICAgICAgIHJldHVybiBxdWFkLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiBpICsgdlswXSArIHN0cmlkZSAqIHZbMV0gKyBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFeHRydWRlZENob3JvcGxldGhMYXllcjY0O1xufShMYXllcik7XG5cbmV4cG9ydCBkZWZhdWx0IEV4dHJ1ZGVkQ2hvcm9wbGV0aExheWVyNjQ7XG5cblxuRXh0cnVkZWRDaG9yb3BsZXRoTGF5ZXI2NC5sYXllck5hbWUgPSAnRXh0cnVkZWRDaG9yb3BsZXRoTGF5ZXI2NCc7XG5FeHRydWRlZENob3JvcGxldGhMYXllcjY0LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuLypcbiAqIGhlbHBlcnNcbiAqL1xuLy8gZ2V0IG5vcm1hbCB2ZWN0b3Igb2YgbGluZSBzZWdtZW50XG5mdW5jdGlvbiBnZXROb3JtYWwocDEsIHAyKSB7XG4gIGlmIChwMVswXSA9PT0gcDJbMF0gJiYgcDFbMV0gPT09IHAyWzFdKSB7XG4gICAgcmV0dXJuIFsxLCAwLCAwXTtcbiAgfVxuXG4gIHZhciBkZWdyZWVzMnJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwO1xuXG4gIHZhciBsb24xID0gZGVncmVlczJyYWRpYW5zICogcDFbMF07XG4gIHZhciBsb24yID0gZGVncmVlczJyYWRpYW5zICogcDJbMF07XG4gIHZhciBsYXQxID0gZGVncmVlczJyYWRpYW5zICogcDFbMV07XG4gIHZhciBsYXQyID0gZGVncmVlczJyYWRpYW5zICogcDJbMV07XG5cbiAgdmFyIGEgPSBNYXRoLnNpbihsb24yIC0gbG9uMSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgdmFyIGIgPSBNYXRoLmNvcyhsYXQxKSAqIE1hdGguc2luKGxhdDIpIC0gTWF0aC5zaW4obGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGxvbjIgLSBsb24xKTtcblxuICByZXR1cm4gdmVjMy5ub3JtYWxpemUoW10sIFtiLCAwLCAtYV0pO1xufVxuXG4vLyBjb3VudCBudW1iZXIgb2YgdmVydGljZXMgaW4gZ2VvanNvbiBwb2x5Z29uXG5mdW5jdGlvbiBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gIHJldHVybiB2ZXJ0aWNlcy5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBwb2x5Z29uKSB7XG4gICAgcmV0dXJuIGNvdW50ICsgcG9seWdvbi5sZW5ndGg7XG4gIH0sIDApO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9kZXByZWNhdGVkL2V4dHJ1ZGVkLWNob3JvcGxldGgtbGF5ZXItNjQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci02NC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 44 */
/* exports provided: default */
/* exports used: default */
/*!***************************************************!*\
  !*** ./src/layers/fp64/arc-layer/arc-layer-64.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_arc_layer_arc_layer__ = __webpack_require__(/*! ../../core/arc-layer/arc-layer */ 18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_path__);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\nvar ArcLayer64 = function (_ArcLayer) {\n  _inherits(ArcLayer64, _ArcLayer);\n\n  function ArcLayer64() {\n    _classCallCheck(this, ArcLayer64);\n\n    return _possibleConstructorReturn(this, (ArcLayer64.__proto__ || Object.getPrototypeOf(ArcLayer64)).apply(this, arguments));\n  }\n\n  _createClass(ArcLayer64, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      _get(ArcLayer64.prototype.__proto__ || Object.getPrototypeOf(ArcLayer64.prototype), 'initializeState', this).call(this);\n\n      var attributeManager = this.state.attributeManager;\n\n\n      attributeManager.addInstanced({\n        instanceSourcePositions64: {\n          size: 4,\n          update: this.calculateInstanceSourcePositions64\n        },\n        instanceTargetPositions64: {\n          size: 4,\n          update: this.calculateInstanceTargetPositions64\n        }\n        // Reuse from base class\n        // instanceSourceColors: {\n        //   size: 4,\n        //   type: GL.UNSIGNED_BYTE,\n        //   update: this.calculateInstanceSourceColors\n        // },\n        // instanceTargetColors: {\n        //   size: 4,\n        //   type: GL.UNSIGNED_BYTE,\n        //   update: this.calculateInstanceTargetColors\n        // }\n      });\n    }\n  }, {\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME arc-layer-64-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec4 instanceSourceColors;\\nattribute vec4 instanceTargetColors;\\nattribute vec4 instanceSourcePositions64;\\nattribute vec4 instanceTargetPositions64;\\nattribute vec3 instancePickingColors;\\n\\nuniform float numSegments;\\nuniform vec2 screenSize;\\nuniform float strokeWidth;\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\n\\nvec2 paraboloid_fp64(vec2 source[2], vec2 target[2], float ratio) {\\n\\n  vec2 x[2];\\n  vec2_mix_fp64(source, target, ratio, x);\\n  vec2 center[2];\\n  vec2_mix_fp64(source, target, 0.5, center);\\n\\n  vec2 dSourceCenter = vec2_distance_fp64(source, center);\\n  vec2 dXCenter = vec2_distance_fp64(x, center);\\n  return mul_fp64(sum_fp64(dSourceCenter, dXCenter), sub_fp64(dSourceCenter, dXCenter));\\n}\\n\\n// offset vector by strokeWidth pixels\\n// offset_direction is -1 (left) or 1 (right)\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace * screenSize);\\n  // rotate by 90 degrees\\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n\\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\\n  vec2 offset_clipspace = offset_screenspace / screenSize * 2.0;\\n\\n  return offset_clipspace;\\n}\\n\\nfloat getSegmentRatio(float index) {\\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\\n}\\n\\nvoid get_pos_fp64(vec2 source[2], vec2 target[2], float segmentRatio, out vec2 position[4]) {\\n\\n  vec2 vertex_height = paraboloid_fp64(source, target, segmentRatio);\\n\\n  vec2 position_temp[2];\\n\\n  vec2_mix_fp64(source, target, segmentRatio, position_temp);\\n\\n  position[0] = position_temp[0];\\n  position[1] = position_temp[1];\\n\\n  if (vertex_height.x < 0.0 || (vertex_height.x == 0.0 && vertex_height.y <= 0.0)) vertex_height = vec2(0.0, 0.0);\\n\\n  position[2] = sqrt_fp64(vertex_height);\\n  position[3] = vec2(1.0, 0.0);\\n}\\n\\nvoid main(void) {\\n  vec2 projected_source_coord[2];\\n  project_position_fp64(instanceSourcePositions64, projected_source_coord);\\n  vec2 projected_target_coord[2];\\n  project_position_fp64(instanceTargetPositions64, projected_target_coord);\\n\\n  float segmentIndex = positions.x;\\n  float segmentRatio = getSegmentRatio(segmentIndex);\\n\\n  // if it\\'s the first point, use next - current as direction\\n  // otherwise use current - prev\\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\\n\\n  vec2 curr_pos_modelspace[4];\\n\\n  get_pos_fp64(projected_source_coord, projected_target_coord, segmentRatio, curr_pos_modelspace);\\n\\n  vec2 next_pos_modelspace[4];\\n\\n  get_pos_fp64(projected_source_coord, projected_target_coord, nextSegmentRatio, next_pos_modelspace);\\n\\n  vec4 curr_pos_clipspace = project_to_clipspace_fp64(curr_pos_modelspace);\\n  vec4 next_pos_clipspace = project_to_clipspace_fp64(next_pos_modelspace);\\n\\n  vec2 offset = getExtrusionOffset(next_pos_clipspace.xy - curr_pos_clipspace.xy, positions.y);\\n\\n  gl_Position = curr_pos_clipspace + vec4(offset, 0.0, 0.0);\\n\\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\\n\\n  vColor = mix(\\n    vec4(color.rgb, color.a * opacity),\\n    vec4(instancePickingColors / 255., 1.),\\n    renderPickingBuffer\\n  );\\n}\\n',\n        fs: _get(ArcLayer64.prototype.__proto__ || Object.getPrototypeOf(ArcLayer64.prototype), 'getShaders', this).call(this).fs,\n        fp64: true,\n        project64: true\n      };\n    }\n  }, {\n    key: 'calculateInstanceSourcePositions64',\n    value: function calculateInstanceSourcePositions64(attribute) {\n      var _props = this.props,\n          data = _props.data,\n          getSourcePosition = _props.getSourcePosition;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n\n          var sourcePosition = getSourcePosition(object);\n\n          var _fp64ify = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[0]);\n\n          var _fp64ify2 = _slicedToArray(_fp64ify, 2);\n\n          value[i + 0] = _fp64ify2[0];\n          value[i + 1] = _fp64ify2[1];\n\n          var _fp64ify3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[1]);\n\n          var _fp64ify4 = _slicedToArray(_fp64ify3, 2);\n\n          value[i + 2] = _fp64ify4[0];\n          value[i + 3] = _fp64ify4[1];\n\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceTargetPositions64',\n    value: function calculateInstanceTargetPositions64(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getTargetPosition = _props2.getTargetPosition;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n\n          var targetPosition = getTargetPosition(object);\n\n          var _fp64ify5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[0]);\n\n          var _fp64ify6 = _slicedToArray(_fp64ify5, 2);\n\n          value[i + 0] = _fp64ify6[0];\n          value[i + 1] = _fp64ify6[1];\n\n          var _fp64ify7 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[1]);\n\n          var _fp64ify8 = _slicedToArray(_fp64ify7, 2);\n\n          value[i + 2] = _fp64ify8[0];\n          value[i + 3] = _fp64ify8[1];\n\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }]);\n\n  return ArcLayer64;\n}(__WEBPACK_IMPORTED_MODULE_0__core_arc_layer_arc_layer__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ArcLayer64;\n\n\nArcLayer64.layerName = 'ArcLayer64';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2ZwNjQvYXJjLWxheWVyL2FyYy1sYXllci02NC5qcz83NzliIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBBcmNMYXllciBmcm9tICcuLi8uLi9jb3JlL2FyYy1sYXllci9hcmMtbGF5ZXInO1xuaW1wb3J0IHsgZnA2NGlmeSB9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG52YXIgQXJjTGF5ZXI2NCA9IGZ1bmN0aW9uIChfQXJjTGF5ZXIpIHtcbiAgX2luaGVyaXRzKEFyY0xheWVyNjQsIF9BcmNMYXllcik7XG5cbiAgZnVuY3Rpb24gQXJjTGF5ZXI2NCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXJjTGF5ZXI2NCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEFyY0xheWVyNjQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBcmNMYXllcjY0KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXJjTGF5ZXI2NCwgW3tcbiAgICBrZXk6ICdpbml0aWFsaXplU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgICBfZ2V0KEFyY0xheWVyNjQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXJjTGF5ZXI2NC5wcm90b3R5cGUpLCAnaW5pdGlhbGl6ZVN0YXRlJywgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgdmFyIGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXI7XG5cblxuICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICBpbnN0YW5jZVNvdXJjZVBvc2l0aW9uczY0OiB7XG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VQb3NpdGlvbnM2NFxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZVRhcmdldFBvc2l0aW9uczY0OiB7XG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM2NFxuICAgICAgICB9XG4gICAgICAgIC8vIFJldXNlIGZyb20gYmFzZSBjbGFzc1xuICAgICAgICAvLyBpbnN0YW5jZVNvdXJjZUNvbG9yczoge1xuICAgICAgICAvLyAgIHNpemU6IDQsXG4gICAgICAgIC8vICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgLy8gICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VDb2xvcnNcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gaW5zdGFuY2VUYXJnZXRDb2xvcnM6IHtcbiAgICAgICAgLy8gICBzaXplOiA0LFxuICAgICAgICAvLyAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIC8vICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0Q29sb3JzXG4gICAgICAgIC8vIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFNoYWRlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFkZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgYXJjLWxheWVyLTY0LXZlcnRleC1zaGFkZXJcXG5cXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VTb3VyY2VDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VUYXJnZXRDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnM2NDtcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVRhcmdldFBvc2l0aW9uczY0O1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG51bmlmb3JtIGZsb2F0IG51bVNlZ21lbnRzO1xcbnVuaWZvcm0gdmVjMiBzY3JlZW5TaXplO1xcbnVuaWZvcm0gZmxvYXQgc3Ryb2tlV2lkdGg7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnZlYzIgcGFyYWJvbG9pZF9mcDY0KHZlYzIgc291cmNlWzJdLCB2ZWMyIHRhcmdldFsyXSwgZmxvYXQgcmF0aW8pIHtcXG5cXG4gIHZlYzIgeFsyXTtcXG4gIHZlYzJfbWl4X2ZwNjQoc291cmNlLCB0YXJnZXQsIHJhdGlvLCB4KTtcXG4gIHZlYzIgY2VudGVyWzJdO1xcbiAgdmVjMl9taXhfZnA2NChzb3VyY2UsIHRhcmdldCwgMC41LCBjZW50ZXIpO1xcblxcbiAgdmVjMiBkU291cmNlQ2VudGVyID0gdmVjMl9kaXN0YW5jZV9mcDY0KHNvdXJjZSwgY2VudGVyKTtcXG4gIHZlYzIgZFhDZW50ZXIgPSB2ZWMyX2Rpc3RhbmNlX2ZwNjQoeCwgY2VudGVyKTtcXG4gIHJldHVybiBtdWxfZnA2NChzdW1fZnA2NChkU291cmNlQ2VudGVyLCBkWENlbnRlciksIHN1Yl9mcDY0KGRTb3VyY2VDZW50ZXIsIGRYQ2VudGVyKSk7XFxufVxcblxcbi8vIG9mZnNldCB2ZWN0b3IgYnkgc3Ryb2tlV2lkdGggcGl4ZWxzXFxuLy8gb2Zmc2V0X2RpcmVjdGlvbiBpcyAtMSAobGVmdCkgb3IgMSAocmlnaHQpXFxudmVjMiBnZXRFeHRydXNpb25PZmZzZXQodmVjMiBsaW5lX2NsaXBzcGFjZSwgZmxvYXQgb2Zmc2V0X2RpcmVjdGlvbikge1xcbiAgLy8gbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdGhlIGxpbmVcXG4gIHZlYzIgZGlyX3NjcmVlbnNwYWNlID0gbm9ybWFsaXplKGxpbmVfY2xpcHNwYWNlICogc2NyZWVuU2l6ZSk7XFxuICAvLyByb3RhdGUgYnkgOTAgZGVncmVlc1xcbiAgZGlyX3NjcmVlbnNwYWNlID0gdmVjMigtZGlyX3NjcmVlbnNwYWNlLnksIGRpcl9zY3JlZW5zcGFjZS54KTtcXG5cXG4gIHZlYzIgb2Zmc2V0X3NjcmVlbnNwYWNlID0gZGlyX3NjcmVlbnNwYWNlICogb2Zmc2V0X2RpcmVjdGlvbiAqIHN0cm9rZVdpZHRoIC8gMi4wO1xcbiAgdmVjMiBvZmZzZXRfY2xpcHNwYWNlID0gb2Zmc2V0X3NjcmVlbnNwYWNlIC8gc2NyZWVuU2l6ZSAqIDIuMDtcXG5cXG4gIHJldHVybiBvZmZzZXRfY2xpcHNwYWNlO1xcbn1cXG5cXG5mbG9hdCBnZXRTZWdtZW50UmF0aW8oZmxvYXQgaW5kZXgpIHtcXG4gIHJldHVybiBzbW9vdGhzdGVwKDAuMCwgMS4wLCBpbmRleCAvIChudW1TZWdtZW50cyAtIDEuMCkpO1xcbn1cXG5cXG52b2lkIGdldF9wb3NfZnA2NCh2ZWMyIHNvdXJjZVsyXSwgdmVjMiB0YXJnZXRbMl0sIGZsb2F0IHNlZ21lbnRSYXRpbywgb3V0IHZlYzIgcG9zaXRpb25bNF0pIHtcXG5cXG4gIHZlYzIgdmVydGV4X2hlaWdodCA9IHBhcmFib2xvaWRfZnA2NChzb3VyY2UsIHRhcmdldCwgc2VnbWVudFJhdGlvKTtcXG5cXG4gIHZlYzIgcG9zaXRpb25fdGVtcFsyXTtcXG5cXG4gIHZlYzJfbWl4X2ZwNjQoc291cmNlLCB0YXJnZXQsIHNlZ21lbnRSYXRpbywgcG9zaXRpb25fdGVtcCk7XFxuXFxuICBwb3NpdGlvblswXSA9IHBvc2l0aW9uX3RlbXBbMF07XFxuICBwb3NpdGlvblsxXSA9IHBvc2l0aW9uX3RlbXBbMV07XFxuXFxuICBpZiAodmVydGV4X2hlaWdodC54IDwgMC4wIHx8ICh2ZXJ0ZXhfaGVpZ2h0LnggPT0gMC4wICYmIHZlcnRleF9oZWlnaHQueSA8PSAwLjApKSB2ZXJ0ZXhfaGVpZ2h0ID0gdmVjMigwLjAsIDAuMCk7XFxuXFxuICBwb3NpdGlvblsyXSA9IHNxcnRfZnA2NCh2ZXJ0ZXhfaGVpZ2h0KTtcXG4gIHBvc2l0aW9uWzNdID0gdmVjMigxLjAsIDAuMCk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICB2ZWMyIHByb2plY3RlZF9zb3VyY2VfY29vcmRbMl07XFxuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQoaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnM2NCwgcHJvamVjdGVkX3NvdXJjZV9jb29yZCk7XFxuICB2ZWMyIHByb2plY3RlZF90YXJnZXRfY29vcmRbMl07XFxuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQoaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM2NCwgcHJvamVjdGVkX3RhcmdldF9jb29yZCk7XFxuXFxuICBmbG9hdCBzZWdtZW50SW5kZXggPSBwb3NpdGlvbnMueDtcXG4gIGZsb2F0IHNlZ21lbnRSYXRpbyA9IGdldFNlZ21lbnRSYXRpbyhzZWdtZW50SW5kZXgpO1xcblxcbiAgLy8gaWYgaXRcXCdzIHRoZSBmaXJzdCBwb2ludCwgdXNlIG5leHQgLSBjdXJyZW50IGFzIGRpcmVjdGlvblxcbiAgLy8gb3RoZXJ3aXNlIHVzZSBjdXJyZW50IC0gcHJldlxcbiAgZmxvYXQgaW5kZXhEaXIgPSBtaXgoLTEuMCwgMS4wLCBzdGVwKHNlZ21lbnRJbmRleCwgMC4wKSk7XFxuICBmbG9hdCBuZXh0U2VnbWVudFJhdGlvID0gZ2V0U2VnbWVudFJhdGlvKHNlZ21lbnRJbmRleCArIGluZGV4RGlyKTtcXG5cXG4gIHZlYzIgY3Vycl9wb3NfbW9kZWxzcGFjZVs0XTtcXG5cXG4gIGdldF9wb3NfZnA2NChwcm9qZWN0ZWRfc291cmNlX2Nvb3JkLCBwcm9qZWN0ZWRfdGFyZ2V0X2Nvb3JkLCBzZWdtZW50UmF0aW8sIGN1cnJfcG9zX21vZGVsc3BhY2UpO1xcblxcbiAgdmVjMiBuZXh0X3Bvc19tb2RlbHNwYWNlWzRdO1xcblxcbiAgZ2V0X3Bvc19mcDY0KHByb2plY3RlZF9zb3VyY2VfY29vcmQsIHByb2plY3RlZF90YXJnZXRfY29vcmQsIG5leHRTZWdtZW50UmF0aW8sIG5leHRfcG9zX21vZGVsc3BhY2UpO1xcblxcbiAgdmVjNCBjdXJyX3Bvc19jbGlwc3BhY2UgPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KGN1cnJfcG9zX21vZGVsc3BhY2UpO1xcbiAgdmVjNCBuZXh0X3Bvc19jbGlwc3BhY2UgPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KG5leHRfcG9zX21vZGVsc3BhY2UpO1xcblxcbiAgdmVjMiBvZmZzZXQgPSBnZXRFeHRydXNpb25PZmZzZXQobmV4dF9wb3NfY2xpcHNwYWNlLnh5IC0gY3Vycl9wb3NfY2xpcHNwYWNlLnh5LCBwb3NpdGlvbnMueSk7XFxuXFxuICBnbF9Qb3NpdGlvbiA9IGN1cnJfcG9zX2NsaXBzcGFjZSArIHZlYzQob2Zmc2V0LCAwLjAsIDAuMCk7XFxuXFxuICB2ZWM0IGNvbG9yID0gbWl4KGluc3RhbmNlU291cmNlQ29sb3JzLCBpbnN0YW5jZVRhcmdldENvbG9ycywgc2VnbWVudFJhdGlvKSAvIDI1NS47XFxuXFxuICB2Q29sb3IgPSBtaXgoXFxuICAgIHZlYzQoY29sb3IucmdiLCBjb2xvci5hICogb3BhY2l0eSksXFxuICAgIHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pLFxcbiAgICByZW5kZXJQaWNraW5nQnVmZmVyXFxuICApO1xcbn1cXG4nLFxuICAgICAgICBmczogX2dldChBcmNMYXllcjY0LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEFyY0xheWVyNjQucHJvdG90eXBlKSwgJ2dldFNoYWRlcnMnLCB0aGlzKS5jYWxsKHRoaXMpLmZzLFxuICAgICAgICBmcDY0OiB0cnVlLFxuICAgICAgICBwcm9qZWN0NjQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VTb3VyY2VQb3NpdGlvbnM2NCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlU291cmNlUG9zaXRpb25zNjQoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3Byb3BzLmRhdGEsXG4gICAgICAgICAgZ2V0U291cmNlUG9zaXRpb24gPSBfcHJvcHMuZ2V0U291cmNlUG9zaXRpb247XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUsXG4gICAgICAgICAgc2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgc291cmNlUG9zaXRpb24gPSBnZXRTb3VyY2VQb3NpdGlvbihvYmplY3QpO1xuXG4gICAgICAgICAgdmFyIF9mcDY0aWZ5ID0gZnA2NGlmeShzb3VyY2VQb3NpdGlvblswXSk7XG5cbiAgICAgICAgICB2YXIgX2ZwNjRpZnkyID0gX3NsaWNlZFRvQXJyYXkoX2ZwNjRpZnksIDIpO1xuXG4gICAgICAgICAgdmFsdWVbaSArIDBdID0gX2ZwNjRpZnkyWzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAxXSA9IF9mcDY0aWZ5MlsxXTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTMgPSBmcDY0aWZ5KHNvdXJjZVBvc2l0aW9uWzFdKTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTQgPSBfc2xpY2VkVG9BcnJheShfZnA2NGlmeTMsIDIpO1xuXG4gICAgICAgICAgdmFsdWVbaSArIDJdID0gX2ZwNjRpZnk0WzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAzXSA9IF9mcDY0aWZ5NFsxXTtcblxuICAgICAgICAgIGkgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM2NCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0UG9zaXRpb25zNjQoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wczIuZGF0YSxcbiAgICAgICAgICBnZXRUYXJnZXRQb3NpdGlvbiA9IF9wcm9wczIuZ2V0VGFyZ2V0UG9zaXRpb247XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUsXG4gICAgICAgICAgc2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIHRhcmdldFBvc2l0aW9uID0gZ2V0VGFyZ2V0UG9zaXRpb24ob2JqZWN0KTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTUgPSBmcDY0aWZ5KHRhcmdldFBvc2l0aW9uWzBdKTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTYgPSBfc2xpY2VkVG9BcnJheShfZnA2NGlmeTUsIDIpO1xuXG4gICAgICAgICAgdmFsdWVbaSArIDBdID0gX2ZwNjRpZnk2WzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAxXSA9IF9mcDY0aWZ5NlsxXTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTcgPSBmcDY0aWZ5KHRhcmdldFBvc2l0aW9uWzFdKTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTggPSBfc2xpY2VkVG9BcnJheShfZnA2NGlmeTcsIDIpO1xuXG4gICAgICAgICAgdmFsdWVbaSArIDJdID0gX2ZwNjRpZnk4WzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAzXSA9IF9mcDY0aWZ5OFsxXTtcblxuICAgICAgICAgIGkgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBcmNMYXllcjY0O1xufShBcmNMYXllcik7XG5cbmV4cG9ydCBkZWZhdWx0IEFyY0xheWVyNjQ7XG5cblxuQXJjTGF5ZXI2NC5sYXllck5hbWUgPSAnQXJjTGF5ZXI2NCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2ZwNjQvYXJjLWxheWVyL2FyYy1sYXllci02NC5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 45 */
/* exports provided: default */
/* exports used: default */
/*!*****************************************************!*\
  !*** ./src/layers/fp64/line-layer/line-layer-64.js ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_line_layer_line_layer__ = __webpack_require__(/*! ../../core/line-layer/line-layer */ 21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_path__);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\nvar LineLayer64 = function (_LineLayer) {\n  _inherits(LineLayer64, _LineLayer);\n\n  function LineLayer64() {\n    _classCallCheck(this, LineLayer64);\n\n    return _possibleConstructorReturn(this, (LineLayer64.__proto__ || Object.getPrototypeOf(LineLayer64)).apply(this, arguments));\n  }\n\n  _createClass(LineLayer64, [{\n    key: 'initializeState',\n    value: function initializeState() {\n      _get(LineLayer64.prototype.__proto__ || Object.getPrototypeOf(LineLayer64.prototype), 'initializeState', this).call(this);\n\n      var attributeManager = this.state.attributeManager;\n\n      attributeManager.addInstanced({\n        instanceSourcePositions64: {\n          size: 4,\n          update: this.calculateInstanceSourcePositions\n        },\n        instanceTargetPositions64: {\n          size: 4,\n          update: this.calculateInstanceTargetPositions\n        },\n        instanceElevations: {\n          size: 2,\n          update: this.calculateInstanceElevations\n        }\n      });\n    }\n  }, {\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME line-layer-64-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec4 instanceSourcePositions64;\\nattribute vec4 instanceTargetPositions64;\\nattribute vec2 instanceElevations;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform vec2 screenSize;\\nuniform float strokeWidth;\\nuniform float opacity;\\nuniform float renderPickingBuffer;\\n\\nvarying vec4 vColor;\\n\\n// offset vector by strokeWidth pixels\\n// offset_direction is -1 (left) or 1 (right)\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace * screenSize);\\n  // rotate by 90 degrees\\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n\\n  vec2 offset_screenspace = dir_screenspace * offset_direction * strokeWidth / 2.0;\\n  vec2 offset_clipspace = offset_screenspace / screenSize * 2.0;\\n\\n  return offset_clipspace;\\n}\\n\\nvoid main(void) {\\n  // Position\\n  vec2 projected_source_coord[2];\\n  project_position_fp64(instanceSourcePositions64, projected_source_coord);\\n  vec2 projected_target_coord[2];\\n  project_position_fp64(instanceTargetPositions64, projected_target_coord);\\n\\n  vec2 source_pos_modelspace[4];\\n  source_pos_modelspace[0] =  projected_source_coord[0];\\n  source_pos_modelspace[1] =  projected_source_coord[1];\\n  source_pos_modelspace[2] = vec2(project_scale(instanceElevations.x), 0.0);\\n  source_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  vec4 source_pos_clipspace = project_to_clipspace_fp64(source_pos_modelspace);\\n\\n  vec2 target_pos_modelspace[4];\\n  target_pos_modelspace[0] =  projected_target_coord[0];\\n  target_pos_modelspace[1] =  projected_target_coord[1];\\n  target_pos_modelspace[2] = vec2(project_scale(instanceElevations.y), 0.0);\\n  target_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  vec4 target_pos_clipspace = project_to_clipspace_fp64(target_pos_modelspace);\\n\\n  float segmentIndex = positions.x;\\n  vec4 p = mix(source_pos_clipspace, target_pos_clipspace, segmentIndex);\\n\\n  vec2 offset = getExtrusionOffset(target_pos_clipspace.xy - source_pos_clipspace.xy, positions.y);\\n\\n  gl_Position = p + vec4(offset, 0.0, 0.0);\\n\\n  // Color\\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n\\n  vColor = mix(\\n    color,\\n    pickingColor,\\n    renderPickingBuffer\\n  );\\n}\\n',\n        fs: _get(LineLayer64.prototype.__proto__ || Object.getPrototypeOf(LineLayer64.prototype), 'getShaders', this).call(this).fs,\n        fp64: true,\n        project64: true\n      };\n    }\n  }, {\n    key: 'calculateInstanceSourcePositions',\n    value: function calculateInstanceSourcePositions(attribute) {\n      var _props = this.props,\n          data = _props.data,\n          getSourcePosition = _props.getSourcePosition;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n\n          var sourcePosition = getSourcePosition(object);\n\n          var _fp64ify = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[0]);\n\n          var _fp64ify2 = _slicedToArray(_fp64ify, 2);\n\n          value[i + 0] = _fp64ify2[0];\n          value[i + 1] = _fp64ify2[1];\n\n          var _fp64ify3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(sourcePosition[1]);\n\n          var _fp64ify4 = _slicedToArray(_fp64ify3, 2);\n\n          value[i + 2] = _fp64ify4[0];\n          value[i + 3] = _fp64ify4[1];\n\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceTargetPositions',\n    value: function calculateInstanceTargetPositions(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getTargetPosition = _props2.getTargetPosition;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n\n          var targetPosition = getTargetPosition(object);\n\n          var _fp64ify5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[0]);\n\n          var _fp64ify6 = _slicedToArray(_fp64ify5, 2);\n\n          value[i + 0] = _fp64ify6[0];\n          value[i + 1] = _fp64ify6[1];\n\n          var _fp64ify7 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(targetPosition[1]);\n\n          var _fp64ify8 = _slicedToArray(_fp64ify7, 2);\n\n          value[i + 2] = _fp64ify8[0];\n          value[i + 3] = _fp64ify8[1];\n\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstanceElevations',\n    value: function calculateInstanceElevations(attribute) {\n      var _props3 = this.props,\n          data = _props3.data,\n          getSourcePosition = _props3.getSourcePosition,\n          getTargetPosition = _props3.getTargetPosition;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var object = _step3.value;\n\n          var sourcePosition = getSourcePosition(object);\n          var targetPosition = getTargetPosition(object);\n          value[i + 0] = sourcePosition[2] || 0;\n          value[i + 1] = targetPosition[2] || 0;\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }]);\n\n  return LineLayer64;\n}(__WEBPACK_IMPORTED_MODULE_0__core_line_layer_line_layer__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = LineLayer64;\n\n\nLineLayer64.layerName = 'LineLayer64';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2ZwNjQvbGluZS1sYXllci9saW5lLWxheWVyLTY0LmpzPzI2YzUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IExpbmVMYXllciBmcm9tICcuLi8uLi9jb3JlL2xpbmUtbGF5ZXIvbGluZS1sYXllcic7XG5pbXBvcnQgeyBmcDY0aWZ5IH0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzL2ZwNjQnO1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbnZhciBMaW5lTGF5ZXI2NCA9IGZ1bmN0aW9uIChfTGluZUxheWVyKSB7XG4gIF9pbmhlcml0cyhMaW5lTGF5ZXI2NCwgX0xpbmVMYXllcik7XG5cbiAgZnVuY3Rpb24gTGluZUxheWVyNjQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmVMYXllcjY0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTGluZUxheWVyNjQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaW5lTGF5ZXI2NCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpbmVMYXllcjY0LCBbe1xuICAgIGtleTogJ2luaXRpYWxpemVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICAgIF9nZXQoTGluZUxheWVyNjQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGluZUxheWVyNjQucHJvdG90eXBlKSwgJ2luaXRpYWxpemVTdGF0ZScsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyO1xuXG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgIGluc3RhbmNlU291cmNlUG9zaXRpb25zNjQ6IHtcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVNvdXJjZVBvc2l0aW9uc1xuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZVRhcmdldFBvc2l0aW9uczY0OiB7XG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnNcbiAgICAgICAgfSxcbiAgICAgICAgaW5zdGFuY2VFbGV2YXRpb25zOiB7XG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VFbGV2YXRpb25zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFNoYWRlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFkZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdnM6ICcvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcXG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXFxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXFxuLy8gVEhFIFNPRlRXQVJFLlxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgbGluZS1sYXllci02NC12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlU291cmNlUG9zaXRpb25zNjQ7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnM2NDtcXG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZUVsZXZhdGlvbnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcblxcbnVuaWZvcm0gdmVjMiBzY3JlZW5TaXplO1xcbnVuaWZvcm0gZmxvYXQgc3Ryb2tlV2lkdGg7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbi8vIG9mZnNldCB2ZWN0b3IgYnkgc3Ryb2tlV2lkdGggcGl4ZWxzXFxuLy8gb2Zmc2V0X2RpcmVjdGlvbiBpcyAtMSAobGVmdCkgb3IgMSAocmlnaHQpXFxudmVjMiBnZXRFeHRydXNpb25PZmZzZXQodmVjMiBsaW5lX2NsaXBzcGFjZSwgZmxvYXQgb2Zmc2V0X2RpcmVjdGlvbikge1xcbiAgLy8gbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdGhlIGxpbmVcXG4gIHZlYzIgZGlyX3NjcmVlbnNwYWNlID0gbm9ybWFsaXplKGxpbmVfY2xpcHNwYWNlICogc2NyZWVuU2l6ZSk7XFxuICAvLyByb3RhdGUgYnkgOTAgZGVncmVlc1xcbiAgZGlyX3NjcmVlbnNwYWNlID0gdmVjMigtZGlyX3NjcmVlbnNwYWNlLnksIGRpcl9zY3JlZW5zcGFjZS54KTtcXG5cXG4gIHZlYzIgb2Zmc2V0X3NjcmVlbnNwYWNlID0gZGlyX3NjcmVlbnNwYWNlICogb2Zmc2V0X2RpcmVjdGlvbiAqIHN0cm9rZVdpZHRoIC8gMi4wO1xcbiAgdmVjMiBvZmZzZXRfY2xpcHNwYWNlID0gb2Zmc2V0X3NjcmVlbnNwYWNlIC8gc2NyZWVuU2l6ZSAqIDIuMDtcXG5cXG4gIHJldHVybiBvZmZzZXRfY2xpcHNwYWNlO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgLy8gUG9zaXRpb25cXG4gIHZlYzIgcHJvamVjdGVkX3NvdXJjZV9jb29yZFsyXTtcXG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVNvdXJjZVBvc2l0aW9uczY0LCBwcm9qZWN0ZWRfc291cmNlX2Nvb3JkKTtcXG4gIHZlYzIgcHJvamVjdGVkX3RhcmdldF9jb29yZFsyXTtcXG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVRhcmdldFBvc2l0aW9uczY0LCBwcm9qZWN0ZWRfdGFyZ2V0X2Nvb3JkKTtcXG5cXG4gIHZlYzIgc291cmNlX3Bvc19tb2RlbHNwYWNlWzRdO1xcbiAgc291cmNlX3Bvc19tb2RlbHNwYWNlWzBdID0gIHByb2plY3RlZF9zb3VyY2VfY29vcmRbMF07XFxuICBzb3VyY2VfcG9zX21vZGVsc3BhY2VbMV0gPSAgcHJvamVjdGVkX3NvdXJjZV9jb29yZFsxXTtcXG4gIHNvdXJjZV9wb3NfbW9kZWxzcGFjZVsyXSA9IHZlYzIocHJvamVjdF9zY2FsZShpbnN0YW5jZUVsZXZhdGlvbnMueCksIDAuMCk7XFxuICBzb3VyY2VfcG9zX21vZGVsc3BhY2VbM10gPSB2ZWMyKDEuMCwgMC4wKTtcXG5cXG4gIHZlYzQgc291cmNlX3Bvc19jbGlwc3BhY2UgPSBwcm9qZWN0X3RvX2NsaXBzcGFjZV9mcDY0KHNvdXJjZV9wb3NfbW9kZWxzcGFjZSk7XFxuXFxuICB2ZWMyIHRhcmdldF9wb3NfbW9kZWxzcGFjZVs0XTtcXG4gIHRhcmdldF9wb3NfbW9kZWxzcGFjZVswXSA9ICBwcm9qZWN0ZWRfdGFyZ2V0X2Nvb3JkWzBdO1xcbiAgdGFyZ2V0X3Bvc19tb2RlbHNwYWNlWzFdID0gIHByb2plY3RlZF90YXJnZXRfY29vcmRbMV07XFxuICB0YXJnZXRfcG9zX21vZGVsc3BhY2VbMl0gPSB2ZWMyKHByb2plY3Rfc2NhbGUoaW5zdGFuY2VFbGV2YXRpb25zLnkpLCAwLjApO1xcbiAgdGFyZ2V0X3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XFxuXFxuICB2ZWM0IHRhcmdldF9wb3NfY2xpcHNwYWNlID0gcHJvamVjdF90b19jbGlwc3BhY2VfZnA2NCh0YXJnZXRfcG9zX21vZGVsc3BhY2UpO1xcblxcbiAgZmxvYXQgc2VnbWVudEluZGV4ID0gcG9zaXRpb25zLng7XFxuICB2ZWM0IHAgPSBtaXgoc291cmNlX3Bvc19jbGlwc3BhY2UsIHRhcmdldF9wb3NfY2xpcHNwYWNlLCBzZWdtZW50SW5kZXgpO1xcblxcbiAgdmVjMiBvZmZzZXQgPSBnZXRFeHRydXNpb25PZmZzZXQodGFyZ2V0X3Bvc19jbGlwc3BhY2UueHkgLSBzb3VyY2VfcG9zX2NsaXBzcGFjZS54eSwgcG9zaXRpb25zLnkpO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwICsgdmVjNChvZmZzZXQsIDAuMCwgMC4wKTtcXG5cXG4gIC8vIENvbG9yXFxuICB2ZWM0IGNvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XFxuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pO1xcblxcbiAgdkNvbG9yID0gbWl4KFxcbiAgICBjb2xvcixcXG4gICAgcGlja2luZ0NvbG9yLFxcbiAgICByZW5kZXJQaWNraW5nQnVmZmVyXFxuICApO1xcbn1cXG4nLFxuICAgICAgICBmczogX2dldChMaW5lTGF5ZXI2NC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaW5lTGF5ZXI2NC5wcm90b3R5cGUpLCAnZ2V0U2hhZGVycycsIHRoaXMpLmNhbGwodGhpcykuZnMsXG4gICAgICAgIGZwNjQ6IHRydWUsXG4gICAgICAgIHByb2plY3Q2NDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZVNvdXJjZVBvc2l0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlU291cmNlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wcy5kYXRhLFxuICAgICAgICAgIGdldFNvdXJjZVBvc2l0aW9uID0gX3Byb3BzLmdldFNvdXJjZVBvc2l0aW9uO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG9iamVjdCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIHNvdXJjZVBvc2l0aW9uID0gZ2V0U291cmNlUG9zaXRpb24ob2JqZWN0KTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeSA9IGZwNjRpZnkoc291cmNlUG9zaXRpb25bMF0pO1xuXG4gICAgICAgICAgdmFyIF9mcDY0aWZ5MiA9IF9zbGljZWRUb0FycmF5KF9mcDY0aWZ5LCAyKTtcblxuICAgICAgICAgIHZhbHVlW2kgKyAwXSA9IF9mcDY0aWZ5MlswXTtcbiAgICAgICAgICB2YWx1ZVtpICsgMV0gPSBfZnA2NGlmeTJbMV07XG5cbiAgICAgICAgICB2YXIgX2ZwNjRpZnkzID0gZnA2NGlmeShzb3VyY2VQb3NpdGlvblsxXSk7XG5cbiAgICAgICAgICB2YXIgX2ZwNjRpZnk0ID0gX3NsaWNlZFRvQXJyYXkoX2ZwNjRpZnkzLCAyKTtcblxuICAgICAgICAgIHZhbHVlW2kgKyAyXSA9IF9mcDY0aWZ5NFswXTtcbiAgICAgICAgICB2YWx1ZVtpICsgM10gPSBfZnA2NGlmeTRbMV07XG5cbiAgICAgICAgICBpICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0UG9zaXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wczIuZGF0YSxcbiAgICAgICAgICBnZXRUYXJnZXRQb3NpdGlvbiA9IF9wcm9wczIuZ2V0VGFyZ2V0UG9zaXRpb247XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUsXG4gICAgICAgICAgc2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIHRhcmdldFBvc2l0aW9uID0gZ2V0VGFyZ2V0UG9zaXRpb24ob2JqZWN0KTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTUgPSBmcDY0aWZ5KHRhcmdldFBvc2l0aW9uWzBdKTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTYgPSBfc2xpY2VkVG9BcnJheShfZnA2NGlmeTUsIDIpO1xuXG4gICAgICAgICAgdmFsdWVbaSArIDBdID0gX2ZwNjRpZnk2WzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAxXSA9IF9mcDY0aWZ5NlsxXTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTcgPSBmcDY0aWZ5KHRhcmdldFBvc2l0aW9uWzFdKTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTggPSBfc2xpY2VkVG9BcnJheShfZnA2NGlmeTcsIDIpO1xuXG4gICAgICAgICAgdmFsdWVbaSArIDJdID0gX2ZwNjRpZnk4WzBdO1xuICAgICAgICAgIHZhbHVlW2kgKyAzXSA9IF9mcDY0aWZ5OFsxXTtcblxuICAgICAgICAgIGkgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZUluc3RhbmNlRWxldmF0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlRWxldmF0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3Byb3BzMy5kYXRhLFxuICAgICAgICAgIGdldFNvdXJjZVBvc2l0aW9uID0gX3Byb3BzMy5nZXRTb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICBnZXRUYXJnZXRQb3NpdGlvbiA9IF9wcm9wczMuZ2V0VGFyZ2V0UG9zaXRpb247XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUsXG4gICAgICAgICAgc2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIHNvdXJjZVBvc2l0aW9uID0gZ2V0U291cmNlUG9zaXRpb24ob2JqZWN0KTtcbiAgICAgICAgICB2YXIgdGFyZ2V0UG9zaXRpb24gPSBnZXRUYXJnZXRQb3NpdGlvbihvYmplY3QpO1xuICAgICAgICAgIHZhbHVlW2kgKyAwXSA9IHNvdXJjZVBvc2l0aW9uWzJdIHx8IDA7XG4gICAgICAgICAgdmFsdWVbaSArIDFdID0gdGFyZ2V0UG9zaXRpb25bMl0gfHwgMDtcbiAgICAgICAgICBpICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluZUxheWVyNjQ7XG59KExpbmVMYXllcik7XG5cbmV4cG9ydCBkZWZhdWx0IExpbmVMYXllcjY0O1xuXG5cbkxpbmVMYXllcjY0LmxheWVyTmFtZSA9ICdMaW5lTGF5ZXI2NCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2ZwNjQvbGluZS1sYXllci9saW5lLWxheWVyLTY0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 46 */
/* exports provided: default */
/* exports used: default */
/*!*******************************************************************!*\
  !*** ./src/layers/fp64/scatterplot-layer/scatterplot-layer-64.js ***!
  \*******************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_scatterplot_layer_scatterplot_layer__ = __webpack_require__(/*! ../../core/scatterplot-layer/scatterplot-layer */ 12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_path__);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n\n\n\nvar ScatterplotLayer64 = function (_ScatterplotLayer) {\n  _inherits(ScatterplotLayer64, _ScatterplotLayer);\n\n  function ScatterplotLayer64() {\n    _classCallCheck(this, ScatterplotLayer64);\n\n    return _possibleConstructorReturn(this, (ScatterplotLayer64.__proto__ || Object.getPrototypeOf(ScatterplotLayer64)).apply(this, arguments));\n  }\n\n  _createClass(ScatterplotLayer64, [{\n    key: 'getShaders',\n\n\n    // Override the super class vertex shader\n    value: function getShaders(id) {\n      return {\n        vs: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME scatterplot-layer-64-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec4 instancePositions64xy;\\nattribute vec2 instancePositions64z;\\nattribute float instanceRadius;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\n// Only one-dimensional arrays may be declared in GLSL ES 1.0. specs p.24\\nuniform float opacity;\\nuniform float radiusScale;\\nuniform float radiusMinPixels;\\nuniform float radiusMaxPixels;\\nuniform float renderPickingBuffer;\\nuniform float outline;\\nuniform float strokeWidth;\\n\\nvarying vec4 vColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\n\\nvoid main(void) {\\n  // Multiply out radius and clamp to limits\\n  float outerRadiusPixels = clamp(\\n    project_scale(radiusScale * instanceRadius),\\n    radiusMinPixels, radiusMaxPixels\\n  );\\n\\n  // outline is centered at the radius\\n  // outer radius needs to offset by half stroke width\\n  outerRadiusPixels += outline * strokeWidth / 2.0;\\n\\n  // position on the containing square in [-1, 1] space\\n  unitPosition = positions.xy;\\n  // 0 - solid circle, 1 - stroke with lineWidth=0\\n  innerUnitRadius = outline * (1.0 - strokeWidth / outerRadiusPixels);\\n\\n  vec2 projected_coord_xy[2];\\n  project_position_fp64(instancePositions64xy, projected_coord_xy);\\n\\n  vec2 vertex_pos_localspace[4];\\n  vec4_fp64(vec4(positions * outerRadiusPixels, 0.0), vertex_pos_localspace);\\n\\n  vec2 vertex_pos_modelspace[4];\\n  vertex_pos_modelspace[0] = sum_fp64(vertex_pos_localspace[0], projected_coord_xy[0]);\\n  vertex_pos_modelspace[1] = sum_fp64(vertex_pos_localspace[1], projected_coord_xy[1]);\\n  vertex_pos_modelspace[2] = sum_fp64(vertex_pos_localspace[2], vec2(instancePositions64z.x + 1.0, instancePositions64z.y));\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_to_clipspace_fp64(vertex_pos_modelspace);\\n\\n  // Apply opacity to instance color, or return instance picking color\\n  vec4 color = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  vec4 pickingColor = vec4(instancePickingColors / 255., 1.);\\n  vColor = mix(color, pickingColor, renderPickingBuffer);\\n}\\n',\n        fs: _get(ScatterplotLayer64.prototype.__proto__ || Object.getPrototypeOf(ScatterplotLayer64.prototype), 'getShaders', this).call(this).fs,\n        fp64: true,\n        project64: true\n      };\n    }\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      // We use the model and all attributes except \"instancePositions\" of the base layer\n      _get(ScatterplotLayer64.prototype.__proto__ || Object.getPrototypeOf(ScatterplotLayer64.prototype), 'initializeState', this).call(this);\n\n      // Add the 64 bit positions\n      var attributeManager = this.state.attributeManager;\n\n      attributeManager.addInstanced({\n        instancePositions64xy: { size: 4, update: this.calculateInstancePositions64xy },\n        instancePositions64z: { size: 2, update: this.calculateInstancePositions64z }\n      });\n    }\n  }, {\n    key: 'calculateInstancePositions64xy',\n    value: function calculateInstancePositions64xy(attribute) {\n      var _props = this.props,\n          data = _props.data,\n          getPosition = _props.getPosition;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var point = _step.value;\n\n          var position = getPosition(point);\n\n          var _fp64ify = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(position[0]);\n\n          var _fp64ify2 = _slicedToArray(_fp64ify, 2);\n\n          value[i + 0] = _fp64ify2[0];\n          value[i + 1] = _fp64ify2[1];\n\n          var _fp64ify3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(position[1]);\n\n          var _fp64ify4 = _slicedToArray(_fp64ify3, 2);\n\n          value[i + 2] = _fp64ify4[0];\n          value[i + 3] = _fp64ify4[1];\n\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'calculateInstancePositions64z',\n    value: function calculateInstancePositions64z(attribute) {\n      var _props2 = this.props,\n          data = _props2.data,\n          getPosition = _props2.getPosition;\n      var value = attribute.value,\n          size = attribute.size;\n\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var point = _step2.value;\n\n          var position = getPosition(point);\n\n          var _fp64ify5 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__lib_utils_fp64__[\"a\" /* fp64ify */])(position[2] || 0);\n\n          var _fp64ify6 = _slicedToArray(_fp64ify5, 2);\n\n          value[i + 0] = _fp64ify6[0];\n          value[i + 1] = _fp64ify6[1];\n\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }]);\n\n  return ScatterplotLayer64;\n}(__WEBPACK_IMPORTED_MODULE_0__core_scatterplot_layer_scatterplot_layer__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ScatterplotLayer64;\n\n\nScatterplotLayer64.layerName = 'ScatterplotLayer64';//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2ZwNjQvc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXItNjQuanM/YWY5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgU2NhdHRlcnBsb3RMYXllciBmcm9tICcuLi8uLi9jb3JlL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyJztcbmltcG9ydCB7IGZwNjRpZnkgfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5cbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcblxudmFyIFNjYXR0ZXJwbG90TGF5ZXI2NCA9IGZ1bmN0aW9uIChfU2NhdHRlcnBsb3RMYXllcikge1xuICBfaW5oZXJpdHMoU2NhdHRlcnBsb3RMYXllcjY0LCBfU2NhdHRlcnBsb3RMYXllcik7XG5cbiAgZnVuY3Rpb24gU2NhdHRlcnBsb3RMYXllcjY0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2F0dGVycGxvdExheWVyNjQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTY2F0dGVycGxvdExheWVyNjQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY2F0dGVycGxvdExheWVyNjQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY2F0dGVycGxvdExheWVyNjQsIFt7XG4gICAga2V5OiAnZ2V0U2hhZGVycycsXG5cblxuICAgIC8vIE92ZXJyaWRlIHRoZSBzdXBlciBjbGFzcyB2ZXJ0ZXggc2hhZGVyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoYWRlcnMoaWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZzOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIHNjYXR0ZXJwbG90LWxheWVyLTY0LXZlcnRleC1zaGFkZXJcXG5cXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XFxuXFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VQb3NpdGlvbnM2NHh5O1xcbmF0dHJpYnV0ZSB2ZWMyIGluc3RhbmNlUG9zaXRpb25zNjR6O1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVJhZGl1cztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XFxuXFxuLy8gT25seSBvbmUtZGltZW5zaW9uYWwgYXJyYXlzIG1heSBiZSBkZWNsYXJlZCBpbiBHTFNMIEVTIDEuMC4gc3BlY3MgcC4yNFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IHJhZGl1c1NjYWxlO1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzTWluUGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzTWF4UGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgcmVuZGVyUGlja2luZ0J1ZmZlcjtcXG51bmlmb3JtIGZsb2F0IG91dGxpbmU7XFxudW5pZm9ybSBmbG9hdCBzdHJva2VXaWR0aDtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XFxudmFyeWluZyBmbG9hdCBpbm5lclVuaXRSYWRpdXM7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIC8vIE11bHRpcGx5IG91dCByYWRpdXMgYW5kIGNsYW1wIHRvIGxpbWl0c1xcbiAgZmxvYXQgb3V0ZXJSYWRpdXNQaXhlbHMgPSBjbGFtcChcXG4gICAgcHJvamVjdF9zY2FsZShyYWRpdXNTY2FsZSAqIGluc3RhbmNlUmFkaXVzKSxcXG4gICAgcmFkaXVzTWluUGl4ZWxzLCByYWRpdXNNYXhQaXhlbHNcXG4gICk7XFxuXFxuICAvLyBvdXRsaW5lIGlzIGNlbnRlcmVkIGF0IHRoZSByYWRpdXNcXG4gIC8vIG91dGVyIHJhZGl1cyBuZWVkcyB0byBvZmZzZXQgYnkgaGFsZiBzdHJva2Ugd2lkdGhcXG4gIG91dGVyUmFkaXVzUGl4ZWxzICs9IG91dGxpbmUgKiBzdHJva2VXaWR0aCAvIDIuMDtcXG5cXG4gIC8vIHBvc2l0aW9uIG9uIHRoZSBjb250YWluaW5nIHNxdWFyZSBpbiBbLTEsIDFdIHNwYWNlXFxuICB1bml0UG9zaXRpb24gPSBwb3NpdGlvbnMueHk7XFxuICAvLyAwIC0gc29saWQgY2lyY2xlLCAxIC0gc3Ryb2tlIHdpdGggbGluZVdpZHRoPTBcXG4gIGlubmVyVW5pdFJhZGl1cyA9IG91dGxpbmUgKiAoMS4wIC0gc3Ryb2tlV2lkdGggLyBvdXRlclJhZGl1c1BpeGVscyk7XFxuXFxuICB2ZWMyIHByb2plY3RlZF9jb29yZF94eVsyXTtcXG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChpbnN0YW5jZVBvc2l0aW9uczY0eHksIHByb2plY3RlZF9jb29yZF94eSk7XFxuXFxuICB2ZWMyIHZlcnRleF9wb3NfbG9jYWxzcGFjZVs0XTtcXG4gIHZlYzRfZnA2NCh2ZWM0KHBvc2l0aW9ucyAqIG91dGVyUmFkaXVzUGl4ZWxzLCAwLjApLCB2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2UpO1xcblxcbiAgdmVjMiB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbNF07XFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBzdW1fZnA2NCh2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbMF0sIHByb2plY3RlZF9jb29yZF94eVswXSk7XFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBzdW1fZnA2NCh2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbMV0sIHByb2plY3RlZF9jb29yZF94eVsxXSk7XFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMl0gPSBzdW1fZnA2NCh2ZXJ0ZXhfcG9zX2xvY2Fsc3BhY2VbMl0sIHZlYzIoaW5zdGFuY2VQb3NpdGlvbnM2NHoueCArIDEuMCwgaW5zdGFuY2VQb3NpdGlvbnM2NHoueSkpO1xcbiAgdmVydGV4X3Bvc19tb2RlbHNwYWNlWzNdID0gdmVjMigxLjAsIDAuMCk7XFxuXFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVydGV4X3Bvc19tb2RlbHNwYWNlKTtcXG5cXG4gIC8vIEFwcGx5IG9wYWNpdHkgdG8gaW5zdGFuY2UgY29sb3IsIG9yIHJldHVybiBpbnN0YW5jZSBwaWNraW5nIGNvbG9yXFxuICB2ZWM0IGNvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XFxuICB2ZWM0IHBpY2tpbmdDb2xvciA9IHZlYzQoaW5zdGFuY2VQaWNraW5nQ29sb3JzIC8gMjU1LiwgMS4pO1xcbiAgdkNvbG9yID0gbWl4KGNvbG9yLCBwaWNraW5nQ29sb3IsIHJlbmRlclBpY2tpbmdCdWZmZXIpO1xcbn1cXG4nLFxuICAgICAgICBmczogX2dldChTY2F0dGVycGxvdExheWVyNjQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2NhdHRlcnBsb3RMYXllcjY0LnByb3RvdHlwZSksICdnZXRTaGFkZXJzJywgdGhpcykuY2FsbCh0aGlzKS5mcyxcbiAgICAgICAgZnA2NDogdHJ1ZSxcbiAgICAgICAgcHJvamVjdDY0OiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luaXRpYWxpemVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICAgIC8vIFdlIHVzZSB0aGUgbW9kZWwgYW5kIGFsbCBhdHRyaWJ1dGVzIGV4Y2VwdCBcImluc3RhbmNlUG9zaXRpb25zXCIgb2YgdGhlIGJhc2UgbGF5ZXJcbiAgICAgIF9nZXQoU2NhdHRlcnBsb3RMYXllcjY0LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjYXR0ZXJwbG90TGF5ZXI2NC5wcm90b3R5cGUpLCAnaW5pdGlhbGl6ZVN0YXRlJywgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgLy8gQWRkIHRoZSA2NCBiaXQgcG9zaXRpb25zXG4gICAgICB2YXIgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlcjtcblxuICAgICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgICBpbnN0YW5jZVBvc2l0aW9uczY0eHk6IHsgc2l6ZTogNCwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eSB9LFxuICAgICAgICBpbnN0YW5jZVBvc2l0aW9uczY0ejogeyBzaXplOiAyLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHogfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5KGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGF0YSA9IF9wcm9wcy5kYXRhLFxuICAgICAgICAgIGdldFBvc2l0aW9uID0gX3Byb3BzLmdldFBvc2l0aW9uO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihwb2ludCk7XG5cbiAgICAgICAgICB2YXIgX2ZwNjRpZnkgPSBmcDY0aWZ5KHBvc2l0aW9uWzBdKTtcblxuICAgICAgICAgIHZhciBfZnA2NGlmeTIgPSBfc2xpY2VkVG9BcnJheShfZnA2NGlmeSwgMik7XG5cbiAgICAgICAgICB2YWx1ZVtpICsgMF0gPSBfZnA2NGlmeTJbMF07XG4gICAgICAgICAgdmFsdWVbaSArIDFdID0gX2ZwNjRpZnkyWzFdO1xuXG4gICAgICAgICAgdmFyIF9mcDY0aWZ5MyA9IGZwNjRpZnkocG9zaXRpb25bMV0pO1xuXG4gICAgICAgICAgdmFyIF9mcDY0aWZ5NCA9IF9zbGljZWRUb0FycmF5KF9mcDY0aWZ5MywgMik7XG5cbiAgICAgICAgICB2YWx1ZVtpICsgMl0gPSBfZnA2NGlmeTRbMF07XG4gICAgICAgICAgdmFsdWVbaSArIDNdID0gX2ZwNjRpZnk0WzFdO1xuXG4gICAgICAgICAgaSArPSBzaXplO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR6KGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfcHJvcHMyLmRhdGEsXG4gICAgICAgICAgZ2V0UG9zaXRpb24gPSBfcHJvcHMyLmdldFBvc2l0aW9uO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24ocG9pbnQpO1xuXG4gICAgICAgICAgdmFyIF9mcDY0aWZ5NSA9IGZwNjRpZnkocG9zaXRpb25bMl0gfHwgMCk7XG5cbiAgICAgICAgICB2YXIgX2ZwNjRpZnk2ID0gX3NsaWNlZFRvQXJyYXkoX2ZwNjRpZnk1LCAyKTtcblxuICAgICAgICAgIHZhbHVlW2kgKyAwXSA9IF9mcDY0aWZ5NlswXTtcbiAgICAgICAgICB2YWx1ZVtpICsgMV0gPSBfZnA2NGlmeTZbMV07XG5cbiAgICAgICAgICBpICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2NhdHRlcnBsb3RMYXllcjY0O1xufShTY2F0dGVycGxvdExheWVyKTtcblxuZXhwb3J0IGRlZmF1bHQgU2NhdHRlcnBsb3RMYXllcjY0O1xuXG5cblNjYXR0ZXJwbG90TGF5ZXI2NC5sYXllck5hbWUgPSAnU2NhdHRlcnBsb3RMYXllcjY0JztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvZnA2NC9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllci02NC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 47 */
/* exports provided: default */
/* exports used: default */
/*!*************************************************************************!*\
  !*** ./src/experimental/effects/reflection-effect/reflection-effect.js ***!
  \*************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_utils__ = __webpack_require__(/*! ../../../shader-utils */ 4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib__ = __webpack_require__(/*! ../../lib */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_path__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_viewports__ = __webpack_require__(/*! ../../../lib/viewports */ 16);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/* global window */\n\n\n\n\n\n// import {WebMercatorViewport} from 'viewport-mercator-project';\n\n\nvar ReflectionEffect = function (_Effect) {\n  _inherits(ReflectionEffect, _Effect);\n\n  /**\n   * @classdesc\n   * ReflectionEffect\n   *\n   * @class\n   * @param reflectivity How visible reflections should be over the map, between 0 and 1\n   * @param blur how blurry the reflection should be, between 0 and 1\n   */\n\n  function ReflectionEffect() {\n    var reflectivity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;\n    var blur = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n\n    _classCallCheck(this, ReflectionEffect);\n\n    var _this = _possibleConstructorReturn(this, (ReflectionEffect.__proto__ || Object.getPrototypeOf(ReflectionEffect)).call(this));\n\n    _this.reflectivity = reflectivity;\n    _this.blur = blur;\n    _this.framebuffer = null;\n    _this.setNeedsRedraw();\n    return _this;\n  }\n\n  _createClass(ReflectionEffect, [{\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME reflection-effect-vs\\n\\nattribute vec3 vertices;\\n\\nvarying vec2 uv;\\n\\nvoid main(void) {\\n  uv = vertices.xy;\\n  gl_Position = vec4(2. * vertices.xy - vec2(1., 1.), 1., 1.);\\n}\\n',\n        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\n\\n#define SHADER_NAME reflection-effect-fs\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nuniform sampler2D reflectionTexture;\\nuniform int reflectionTextureWidth;\\nuniform int reflectionTextureHeight;\\n\\nuniform float reflectivity;\\nuniform float blur;\\n\\n\\nvarying vec2 uv;\\n\\n#define KERNEL_SIZE 7\\n\\n/*\\n * Samples from tex with a gaussian-shaped patch, centered at uv and\\n * with standard deviation sigma.  The size of the texture in\\n * pixels must be specified by dim\\n */\\nvec4 sample_gaussian(sampler2D tex, vec2 dim, vec2 uv, float sigma) {\\n  if (sigma == 0.0) {\\n    return texture2D(tex, uv);\\n  }\\n  \\n  vec2 delta = 1.0 / dim;\\n  vec2 top_left = uv - delta * float(KERNEL_SIZE+1) / 2.0;\\n  \\n  vec4 color = vec4(0);\\n  float sum = 0.0;\\n  for (int i = 0; i <  KERNEL_SIZE; ++i) {\\n    for (int j = 0; j < KERNEL_SIZE; ++j) {\\n      vec2 uv2 = top_left + vec2(i, j) * delta;\\n      float d = length((uv2 - uv) * dim);\\n      float f = exp(-(d*d) / (2.0*sigma * sigma));\\n      color += f * texture2D(tex, uv2);\\n      sum += f;\\n    }\\n  }\\n  return color / sum;\\n}\\n\\nvoid main(void) {\\n  //map blur in [0, 1] to sigma in [0, inf]\\n  //alpha will determine the \"steepness\" of our curve.\\n  //this was picked just to make the scale feel \"natural\"\\n  //if our image is 1000 pixels wide, a blur of 0.5 should correspond\\n  //to a sigma of 1 pixels\\n  float alpha = 1000.0;\\n  float sigma = blur / (alpha * (1.0 - blur));\\n  //let this be our standard deviation in terms of screen-widths.\\n  //rewrite this in terms of pixels.\\n  sigma *= float(reflectionTextureWidth);\\n  \\n  \\n  gl_FragColor = sample_gaussian(reflectionTexture, vec2(reflectionTextureWidth, reflectionTextureHeight), vec2(uv.x, 1. - uv.y), sigma);\\n  //because our canvas expects alphas to be pre-multiplied, we multiply by whole\\n  //color vector by reflectivity, not just the alpha channel\\n  gl_FragColor *= reflectivity;\\n}\\n'\n      };\n    }\n  }, {\n    key: 'initialize',\n    value: function initialize(_ref) {\n      var gl = _ref.gl,\n          layerManager = _ref.layerManager;\n\n      var shaders = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__shader_utils__[\"a\" /* assembleShaders */])(gl, this.getShaders());\n\n      this.unitQuad = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Model\"]({\n        gl: gl,\n        id: 'reflection-effect',\n        vs: shaders.vs,\n        fs: shaders.fs,\n        geometry: new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Geometry\"]({\n          drawMode: __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].TRIANGLE_FAN,\n          vertices: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        })\n      });\n      this.framebuffer = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Framebuffer\"](gl, { depth: true });\n    }\n  }, {\n    key: 'preDraw',\n    value: function preDraw(_ref2) {\n      var gl = _ref2.gl,\n          layerManager = _ref2.layerManager;\n      var viewport = layerManager.context.viewport;\n      /*\n       * the renderer already has a reference to this, but we don't have a reference to the renderer.\n       * when we refactor the camera code, we should make sure we get a reference to the renderer so\n       * that we can keep this in one place.\n       */\n\n      var dpi = typeof window !== 'undefined' && window.devicePixelRatio || 1;\n      this.framebuffer.resize({ width: dpi * viewport.width, height: dpi * viewport.height });\n      var pitch = viewport.pitch;\n      this.framebuffer.bind();\n      /* this is a huge hack around the existing viewport class.\n       * TODO in the future, once we implement bona-fide cameras, we really need to fix this.\n       */\n      layerManager.setViewport(new __WEBPACK_IMPORTED_MODULE_4__lib_viewports__[\"a\" /* WebMercatorViewport */](Object.assign({}, viewport, { pitch: -180 - pitch })));\n      gl.clear(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].DEPTH_BUFFER_BIT);\n\n      layerManager.drawLayers({ pass: 'reflection' });\n      layerManager.setViewport(viewport);\n      this.framebuffer.unbind();\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref3) {\n      var gl = _ref3.gl,\n          layerManager = _ref3.layerManager;\n\n      /*\n       * Render our unit quad.\n       * This will cover the entire screen, but will lie behind all other geometry.\n       * This quad will sample the previously generated reflection texture\n       * in order to create the reflection effect\n       */\n      this.unitQuad.render({\n        reflectionTexture: this.framebuffer.texture,\n        reflectionTextureWidth: this.framebuffer.width,\n        reflectionTextureHeight: this.framebuffer.height,\n        reflectivity: this.reflectivity,\n        blur: this.blur\n      });\n    }\n  }, {\n    key: 'finalize',\n    value: function finalize(_ref4) {\n      /* TODO: Free resources? */\n\n      var gl = _ref4.gl,\n          layerManager = _ref4.layerManager;\n    }\n  }]);\n\n  return ReflectionEffect;\n}(__WEBPACK_IMPORTED_MODULE_2__lib__[\"b\" /* Effect */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ReflectionEffect;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QvcmVmbGVjdGlvbi1lZmZlY3QuanM/NzBiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7IEdMLCBGcmFtZWJ1ZmZlciwgTW9kZWwsIEdlb21ldHJ5IH0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgeyBhc3NlbWJsZVNoYWRlcnMgfSBmcm9tICcuLi8uLi8uLi9zaGFkZXItdXRpbHMnO1xuaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSAnLi4vLi4vbGliJztcblxuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuLy8gaW1wb3J0IHtXZWJNZXJjYXRvclZpZXdwb3J0fSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCB7IFdlYk1lcmNhdG9yVmlld3BvcnQgfSBmcm9tICcuLi8uLi8uLi9saWIvdmlld3BvcnRzJztcblxudmFyIFJlZmxlY3Rpb25FZmZlY3QgPSBmdW5jdGlvbiAoX0VmZmVjdCkge1xuICBfaW5oZXJpdHMoUmVmbGVjdGlvbkVmZmVjdCwgX0VmZmVjdCk7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogUmVmbGVjdGlvbkVmZmVjdFxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHJlZmxlY3Rpdml0eSBIb3cgdmlzaWJsZSByZWZsZWN0aW9ucyBzaG91bGQgYmUgb3ZlciB0aGUgbWFwLCBiZXR3ZWVuIDAgYW5kIDFcbiAgICogQHBhcmFtIGJsdXIgaG93IGJsdXJyeSB0aGUgcmVmbGVjdGlvbiBzaG91bGQgYmUsIGJldHdlZW4gMCBhbmQgMVxuICAgKi9cblxuICBmdW5jdGlvbiBSZWZsZWN0aW9uRWZmZWN0KCkge1xuICAgIHZhciByZWZsZWN0aXZpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDAuNTtcbiAgICB2YXIgYmx1ciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMC41O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZmxlY3Rpb25FZmZlY3QpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFJlZmxlY3Rpb25FZmZlY3QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSZWZsZWN0aW9uRWZmZWN0KSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5yZWZsZWN0aXZpdHkgPSByZWZsZWN0aXZpdHk7XG4gICAgX3RoaXMuYmx1ciA9IGJsdXI7XG4gICAgX3RoaXMuZnJhbWVidWZmZXIgPSBudWxsO1xuICAgIF90aGlzLnNldE5lZWRzUmVkcmF3KCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlZmxlY3Rpb25FZmZlY3QsIFt7XG4gICAga2V5OiAnZ2V0U2hhZGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoYWRlcnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2czogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSByZWZsZWN0aW9uLWVmZmVjdC12c1xcblxcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRpY2VzO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgdXYgPSB2ZXJ0aWNlcy54eTtcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgyLiAqIHZlcnRpY2VzLnh5IC0gdmVjMigxLiwgMS4pLCAxLiwgMS4pO1xcbn1cXG4nLFxuICAgICAgICBmczogJy8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXFxuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxcbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cXG4vLyBUSEUgU09GVFdBUkUuXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSByZWZsZWN0aW9uLWVmZmVjdC1mc1xcblxcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCByZWZsZWN0aW9uVGV4dHVyZTtcXG51bmlmb3JtIGludCByZWZsZWN0aW9uVGV4dHVyZVdpZHRoO1xcbnVuaWZvcm0gaW50IHJlZmxlY3Rpb25UZXh0dXJlSGVpZ2h0O1xcblxcbnVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1xcbnVuaWZvcm0gZmxvYXQgYmx1cjtcXG5cXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxuXFxuI2RlZmluZSBLRVJORUxfU0laRSA3XFxuXFxuLypcXG4gKiBTYW1wbGVzIGZyb20gdGV4IHdpdGggYSBnYXVzc2lhbi1zaGFwZWQgcGF0Y2gsIGNlbnRlcmVkIGF0IHV2IGFuZFxcbiAqIHdpdGggc3RhbmRhcmQgZGV2aWF0aW9uIHNpZ21hLiAgVGhlIHNpemUgb2YgdGhlIHRleHR1cmUgaW5cXG4gKiBwaXhlbHMgbXVzdCBiZSBzcGVjaWZpZWQgYnkgZGltXFxuICovXFxudmVjNCBzYW1wbGVfZ2F1c3NpYW4oc2FtcGxlcjJEIHRleCwgdmVjMiBkaW0sIHZlYzIgdXYsIGZsb2F0IHNpZ21hKSB7XFxuICBpZiAoc2lnbWEgPT0gMC4wKSB7XFxuICAgIHJldHVybiB0ZXh0dXJlMkQodGV4LCB1dik7XFxuICB9XFxuICBcXG4gIHZlYzIgZGVsdGEgPSAxLjAgLyBkaW07XFxuICB2ZWMyIHRvcF9sZWZ0ID0gdXYgLSBkZWx0YSAqIGZsb2F0KEtFUk5FTF9TSVpFKzEpIC8gMi4wO1xcbiAgXFxuICB2ZWM0IGNvbG9yID0gdmVjNCgwKTtcXG4gIGZsb2F0IHN1bSA9IDAuMDtcXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgIEtFUk5FTF9TSVpFOyArK2kpIHtcXG4gICAgZm9yIChpbnQgaiA9IDA7IGogPCBLRVJORUxfU0laRTsgKytqKSB7XFxuICAgICAgdmVjMiB1djIgPSB0b3BfbGVmdCArIHZlYzIoaSwgaikgKiBkZWx0YTtcXG4gICAgICBmbG9hdCBkID0gbGVuZ3RoKCh1djIgLSB1dikgKiBkaW0pO1xcbiAgICAgIGZsb2F0IGYgPSBleHAoLShkKmQpIC8gKDIuMCpzaWdtYSAqIHNpZ21hKSk7XFxuICAgICAgY29sb3IgKz0gZiAqIHRleHR1cmUyRCh0ZXgsIHV2Mik7XFxuICAgICAgc3VtICs9IGY7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBjb2xvciAvIHN1bTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIC8vbWFwIGJsdXIgaW4gWzAsIDFdIHRvIHNpZ21hIGluIFswLCBpbmZdXFxuICAvL2FscGhhIHdpbGwgZGV0ZXJtaW5lIHRoZSBcInN0ZWVwbmVzc1wiIG9mIG91ciBjdXJ2ZS5cXG4gIC8vdGhpcyB3YXMgcGlja2VkIGp1c3QgdG8gbWFrZSB0aGUgc2NhbGUgZmVlbCBcIm5hdHVyYWxcIlxcbiAgLy9pZiBvdXIgaW1hZ2UgaXMgMTAwMCBwaXhlbHMgd2lkZSwgYSBibHVyIG9mIDAuNSBzaG91bGQgY29ycmVzcG9uZFxcbiAgLy90byBhIHNpZ21hIG9mIDEgcGl4ZWxzXFxuICBmbG9hdCBhbHBoYSA9IDEwMDAuMDtcXG4gIGZsb2F0IHNpZ21hID0gYmx1ciAvIChhbHBoYSAqICgxLjAgLSBibHVyKSk7XFxuICAvL2xldCB0aGlzIGJlIG91ciBzdGFuZGFyZCBkZXZpYXRpb24gaW4gdGVybXMgb2Ygc2NyZWVuLXdpZHRocy5cXG4gIC8vcmV3cml0ZSB0aGlzIGluIHRlcm1zIG9mIHBpeGVscy5cXG4gIHNpZ21hICo9IGZsb2F0KHJlZmxlY3Rpb25UZXh0dXJlV2lkdGgpO1xcbiAgXFxuICBcXG4gIGdsX0ZyYWdDb2xvciA9IHNhbXBsZV9nYXVzc2lhbihyZWZsZWN0aW9uVGV4dHVyZSwgdmVjMihyZWZsZWN0aW9uVGV4dHVyZVdpZHRoLCByZWZsZWN0aW9uVGV4dHVyZUhlaWdodCksIHZlYzIodXYueCwgMS4gLSB1di55KSwgc2lnbWEpO1xcbiAgLy9iZWNhdXNlIG91ciBjYW52YXMgZXhwZWN0cyBhbHBoYXMgdG8gYmUgcHJlLW11bHRpcGxpZWQsIHdlIG11bHRpcGx5IGJ5IHdob2xlXFxuICAvL2NvbG9yIHZlY3RvciBieSByZWZsZWN0aXZpdHksIG5vdCBqdXN0IHRoZSBhbHBoYSBjaGFubmVsXFxuICBnbF9GcmFnQ29sb3IgKj0gcmVmbGVjdGl2aXR5O1xcbn1cXG4nXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luaXRpYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKF9yZWYpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgICAgbGF5ZXJNYW5hZ2VyID0gX3JlZi5sYXllck1hbmFnZXI7XG5cbiAgICAgIHZhciBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICAgIHRoaXMudW5pdFF1YWQgPSBuZXcgTW9kZWwoe1xuICAgICAgICBnbDogZ2wsXG4gICAgICAgIGlkOiAncmVmbGVjdGlvbi1lZmZlY3QnLFxuICAgICAgICB2czogc2hhZGVycy52cyxcbiAgICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRV9GQU4sXG4gICAgICAgICAgdmVydGljZXM6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEsIDAsIDAsIDEsIDEsIDAsIDAsIDEsIDBdKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYW1lYnVmZmVyID0gbmV3IEZyYW1lYnVmZmVyKGdsLCB7IGRlcHRoOiB0cnVlIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ByZURyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVEcmF3KF9yZWYyKSB7XG4gICAgICB2YXIgZ2wgPSBfcmVmMi5nbCxcbiAgICAgICAgICBsYXllck1hbmFnZXIgPSBfcmVmMi5sYXllck1hbmFnZXI7XG4gICAgICB2YXIgdmlld3BvcnQgPSBsYXllck1hbmFnZXIuY29udGV4dC52aWV3cG9ydDtcbiAgICAgIC8qXG4gICAgICAgKiB0aGUgcmVuZGVyZXIgYWxyZWFkeSBoYXMgYSByZWZlcmVuY2UgdG8gdGhpcywgYnV0IHdlIGRvbid0IGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAgICogd2hlbiB3ZSByZWZhY3RvciB0aGUgY2FtZXJhIGNvZGUsIHdlIHNob3VsZCBtYWtlIHN1cmUgd2UgZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlciBzb1xuICAgICAgICogdGhhdCB3ZSBjYW4ga2VlcCB0aGlzIGluIG9uZSBwbGFjZS5cbiAgICAgICAqL1xuXG4gICAgICB2YXIgZHBpID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIHRoaXMuZnJhbWVidWZmZXIucmVzaXplKHsgd2lkdGg6IGRwaSAqIHZpZXdwb3J0LndpZHRoLCBoZWlnaHQ6IGRwaSAqIHZpZXdwb3J0LmhlaWdodCB9KTtcbiAgICAgIHZhciBwaXRjaCA9IHZpZXdwb3J0LnBpdGNoO1xuICAgICAgdGhpcy5mcmFtZWJ1ZmZlci5iaW5kKCk7XG4gICAgICAvKiB0aGlzIGlzIGEgaHVnZSBoYWNrIGFyb3VuZCB0aGUgZXhpc3Rpbmcgdmlld3BvcnQgY2xhc3MuXG4gICAgICAgKiBUT0RPIGluIHRoZSBmdXR1cmUsIG9uY2Ugd2UgaW1wbGVtZW50IGJvbmEtZmlkZSBjYW1lcmFzLCB3ZSByZWFsbHkgbmVlZCB0byBmaXggdGhpcy5cbiAgICAgICAqL1xuICAgICAgbGF5ZXJNYW5hZ2VyLnNldFZpZXdwb3J0KG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KE9iamVjdC5hc3NpZ24oe30sIHZpZXdwb3J0LCB7IHBpdGNoOiAtMTgwIC0gcGl0Y2ggfSkpKTtcbiAgICAgIGdsLmNsZWFyKEdMLkNPTE9SX0JVRkZFUl9CSVQgfCBHTC5ERVBUSF9CVUZGRVJfQklUKTtcblxuICAgICAgbGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnMoeyBwYXNzOiAncmVmbGVjdGlvbicgfSk7XG4gICAgICBsYXllck1hbmFnZXIuc2V0Vmlld3BvcnQodmlld3BvcnQpO1xuICAgICAgdGhpcy5mcmFtZWJ1ZmZlci51bmJpbmQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhfcmVmMykge1xuICAgICAgdmFyIGdsID0gX3JlZjMuZ2wsXG4gICAgICAgICAgbGF5ZXJNYW5hZ2VyID0gX3JlZjMubGF5ZXJNYW5hZ2VyO1xuXG4gICAgICAvKlxuICAgICAgICogUmVuZGVyIG91ciB1bml0IHF1YWQuXG4gICAgICAgKiBUaGlzIHdpbGwgY292ZXIgdGhlIGVudGlyZSBzY3JlZW4sIGJ1dCB3aWxsIGxpZSBiZWhpbmQgYWxsIG90aGVyIGdlb21ldHJ5LlxuICAgICAgICogVGhpcyBxdWFkIHdpbGwgc2FtcGxlIHRoZSBwcmV2aW91c2x5IGdlbmVyYXRlZCByZWZsZWN0aW9uIHRleHR1cmVcbiAgICAgICAqIGluIG9yZGVyIHRvIGNyZWF0ZSB0aGUgcmVmbGVjdGlvbiBlZmZlY3RcbiAgICAgICAqL1xuICAgICAgdGhpcy51bml0UXVhZC5yZW5kZXIoe1xuICAgICAgICByZWZsZWN0aW9uVGV4dHVyZTogdGhpcy5mcmFtZWJ1ZmZlci50ZXh0dXJlLFxuICAgICAgICByZWZsZWN0aW9uVGV4dHVyZVdpZHRoOiB0aGlzLmZyYW1lYnVmZmVyLndpZHRoLFxuICAgICAgICByZWZsZWN0aW9uVGV4dHVyZUhlaWdodDogdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQsXG4gICAgICAgIHJlZmxlY3Rpdml0eTogdGhpcy5yZWZsZWN0aXZpdHksXG4gICAgICAgIGJsdXI6IHRoaXMuYmx1clxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmluYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZShfcmVmNCkge1xuICAgICAgLyogVE9ETzogRnJlZSByZXNvdXJjZXM/ICovXG5cbiAgICAgIHZhciBnbCA9IF9yZWY0LmdsLFxuICAgICAgICAgIGxheWVyTWFuYWdlciA9IF9yZWY0LmxheWVyTWFuYWdlcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVmbGVjdGlvbkVmZmVjdDtcbn0oRWZmZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgUmVmbGVjdGlvbkVmZmVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9leHBlcmltZW50YWwvZWZmZWN0cy9yZWZsZWN0aW9uLWVmZmVjdC9yZWZsZWN0aW9uLWVmZmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 48 */
/* exports provided: EffectManager, Effect, ReflectionEffect */
/* exports used: Effect, EffectManager */
/*!***********************************!*\
  !*** ./src/experimental/index.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ./lib */ 11);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __WEBPACK_IMPORTED_MODULE_0__lib__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__effects_reflection_effect__ = __webpack_require__(/*! ./effects/reflection-effect */ 17);\n/* unused harmony reexport ReflectionEffect */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2luZGV4LmpzPzFjZjAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgRWZmZWN0TWFuYWdlciwgRWZmZWN0IH0gZnJvbSAnLi9saWInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWZsZWN0aW9uRWZmZWN0IH0gZnJvbSAnLi9lZmZlY3RzL3JlZmxlY3Rpb24tZWZmZWN0JztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9leHBlcmltZW50YWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 49 */
/* exports provided: default */
/* exports used: default */
/*!************************************************!*\
  !*** ./src/experimental/lib/effect-manager.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable no-try-catch */\n\nvar EffectManager = function () {\n  function EffectManager(_ref) {\n    var gl = _ref.gl,\n        layerManager = _ref.layerManager;\n\n    _classCallCheck(this, EffectManager);\n\n    this.gl = gl;\n    this.layerManager = layerManager;\n    this._effects = [];\n  }\n\n  /**\n   * Adds an effect to be managed.  That effect's initialize function will\n   * be called, and the effect's preDraw and draw callbacks will be\n   * called at the appropriate times in the render loop\n   * @param {Effect} effect - the effect to be added\n   */\n\n\n  _createClass(EffectManager, [{\n    key: \"addEffect\",\n    value: function addEffect(effect) {\n      this._effects.push(effect);\n      this._sortEffects();\n      effect.initialize({ gl: this.gl, layerManager: this.layerManager });\n    }\n\n    /**\n     * Removes an effect that is already being managed.  That effect's\n     * finalize function will be called, and its callbacks will no longer\n     * be envoked in the render loop\n     * @param {Effect} effect - the effect to be removed\n     * @return {bool} - True if the effect was already being managed, and\n     * thus successfully removed; false otherwise\n     */\n\n  }, {\n    key: \"removeEffect\",\n    value: function removeEffect(effect) {\n      var i = this._effects.indexOf(effect);\n      if (i >= 0) {\n        effect.finalize({ gl: this.gl, layerManager: this.layerManager });\n        this._effects.splice(i, 1);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Envoke the preDraw callback of all managed events, in order of\n     * decreasing priority\n     */\n\n  }, {\n    key: \"preDraw\",\n    value: function preDraw() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var effect = _step.value;\n\n          if (effect.needsRedraw) {\n            effect.preDraw({ gl: this.gl, layerManager: this.layerManager });\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    /**\n     * Envoke the draw callback of all managed events, in order of\n     * decreasing priority\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._effects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var effect = _step2.value;\n\n          if (effect.needsRedraw) {\n            effect.draw({ gl: this.gl, layerManager: this.layerManager });\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_sortEffects\",\n    value: function _sortEffects() {\n      this._effects.sort(function (a, b) {\n        if (a.priority > b.priority) {\n          return -1;\n        } else if (a.priority < b.priority) {\n          return 1;\n        }\n        return a.count - b.count;\n      });\n    }\n  }]);\n\n  return EffectManager;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = EffectManager;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2xpYi9lZmZlY3QtbWFuYWdlci5qcz85MTBhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXRyeS1jYXRjaCAqL1xuXG52YXIgRWZmZWN0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRWZmZWN0TWFuYWdlcihfcmVmKSB7XG4gICAgdmFyIGdsID0gX3JlZi5nbCxcbiAgICAgICAgbGF5ZXJNYW5hZ2VyID0gX3JlZi5sYXllck1hbmFnZXI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWZmZWN0TWFuYWdlcik7XG5cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBsYXllck1hbmFnZXI7XG4gICAgdGhpcy5fZWZmZWN0cyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZWZmZWN0IHRvIGJlIG1hbmFnZWQuICBUaGF0IGVmZmVjdCdzIGluaXRpYWxpemUgZnVuY3Rpb24gd2lsbFxuICAgKiBiZSBjYWxsZWQsIGFuZCB0aGUgZWZmZWN0J3MgcHJlRHJhdyBhbmQgZHJhdyBjYWxsYmFja3Mgd2lsbCBiZVxuICAgKiBjYWxsZWQgYXQgdGhlIGFwcHJvcHJpYXRlIHRpbWVzIGluIHRoZSByZW5kZXIgbG9vcFxuICAgKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0IC0gdGhlIGVmZmVjdCB0byBiZSBhZGRlZFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhFZmZlY3RNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJhZGRFZmZlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWZmZWN0KGVmZmVjdCkge1xuICAgICAgdGhpcy5fZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgICB0aGlzLl9zb3J0RWZmZWN0cygpO1xuICAgICAgZWZmZWN0LmluaXRpYWxpemUoeyBnbDogdGhpcy5nbCwgbGF5ZXJNYW5hZ2VyOiB0aGlzLmxheWVyTWFuYWdlciB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGVmZmVjdCB0aGF0IGlzIGFscmVhZHkgYmVpbmcgbWFuYWdlZC4gIFRoYXQgZWZmZWN0J3NcbiAgICAgKiBmaW5hbGl6ZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCwgYW5kIGl0cyBjYWxsYmFja3Mgd2lsbCBubyBsb25nZXJcbiAgICAgKiBiZSBlbnZva2VkIGluIHRoZSByZW5kZXIgbG9vcFxuICAgICAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3QgLSB0aGUgZWZmZWN0IHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcmV0dXJuIHtib29sfSAtIFRydWUgaWYgdGhlIGVmZmVjdCB3YXMgYWxyZWFkeSBiZWluZyBtYW5hZ2VkLCBhbmRcbiAgICAgKiB0aHVzIHN1Y2Nlc3NmdWxseSByZW1vdmVkOyBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUVmZmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFZmZlY3QoZWZmZWN0KSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2VmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBlZmZlY3QuZmluYWxpemUoeyBnbDogdGhpcy5nbCwgbGF5ZXJNYW5hZ2VyOiB0aGlzLmxheWVyTWFuYWdlciB9KTtcbiAgICAgICAgdGhpcy5fZWZmZWN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudm9rZSB0aGUgcHJlRHJhdyBjYWxsYmFjayBvZiBhbGwgbWFuYWdlZCBldmVudHMsIGluIG9yZGVyIG9mXG4gICAgICogZGVjcmVhc2luZyBwcmlvcml0eVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlRHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVEcmF3KCkge1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMuX2VmZmVjdHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGVmZmVjdCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGVmZmVjdC5uZWVkc1JlZHJhdykge1xuICAgICAgICAgICAgZWZmZWN0LnByZURyYXcoeyBnbDogdGhpcy5nbCwgbGF5ZXJNYW5hZ2VyOiB0aGlzLmxheWVyTWFuYWdlciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVudm9rZSB0aGUgZHJhdyBjYWxsYmFjayBvZiBhbGwgbWFuYWdlZCBldmVudHMsIGluIG9yZGVyIG9mXG4gICAgICogZGVjcmVhc2luZyBwcmlvcml0eVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KCkge1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLl9lZmZlY3RzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGVmZmVjdCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIGlmIChlZmZlY3QubmVlZHNSZWRyYXcpIHtcbiAgICAgICAgICAgIGVmZmVjdC5kcmF3KHsgZ2w6IHRoaXMuZ2wsIGxheWVyTWFuYWdlcjogdGhpcy5sYXllck1hbmFnZXIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zb3J0RWZmZWN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc29ydEVmZmVjdHMoKSB7XG4gICAgICB0aGlzLl9lZmZlY3RzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEucHJpb3JpdHkgPiBiLnByaW9yaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGEucHJpb3JpdHkgPCBiLnByaW9yaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuY291bnQgLSBiLmNvdW50O1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVmZmVjdE1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEVmZmVjdE1hbmFnZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXhwZXJpbWVudGFsL2xpYi9lZmZlY3QtbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 50 */
/* exports provided: default */
/* exports used: default */
/*!****************************************!*\
  !*** ./src/experimental/lib/effect.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar counter = 0;\n\nvar Effect = function () {\n  function Effect() {\n    _classCallCheck(this, Effect);\n\n    this.count = counter++;\n    this.visible = true;\n    this.priority = 0;\n    this.needsRedraw = false;\n  }\n\n  /**\n   * subclasses should override to set up any resources needed\n   */\n\n\n  _createClass(Effect, [{\n    key: \"initialize\",\n    value: function initialize(_ref) {\n      var gl = _ref.gl,\n          layerManager = _ref.layerManager;\n    }\n    /**\n     * and subclasses should free those resources here\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize(_ref2) {\n      var gl = _ref2.gl,\n          layerManager = _ref2.layerManager;\n    }\n    /**\n     * override for a callback immediately before drawing each frame\n     */\n\n  }, {\n    key: \"preDraw\",\n    value: function preDraw(_ref3) {\n      var gl = _ref3.gl,\n          layerManager = _ref3.layerManager;\n    }\n    /**\n     * override for a callback immediately after drawing a frame's layers\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw(_ref4) {\n      var gl = _ref4.gl,\n          layerManager = _ref4.layerManager;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      this.needsRedraw = redraw;\n    }\n  }]);\n\n  return Effect;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = Effect;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXhwZXJpbWVudGFsL2xpYi9lZmZlY3QuanM/NWY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgY291bnRlciA9IDA7XG5cbnZhciBFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVmZmVjdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWZmZWN0KTtcblxuICAgIHRoaXMuY291bnQgPSBjb3VudGVyKys7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMDtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogc3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdG8gc2V0IHVwIGFueSByZXNvdXJjZXMgbmVlZGVkXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEVmZmVjdCwgW3tcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKF9yZWYpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgICAgbGF5ZXJNYW5hZ2VyID0gX3JlZi5sYXllck1hbmFnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFuZCBzdWJjbGFzc2VzIHNob3VsZCBmcmVlIHRob3NlIHJlc291cmNlcyBoZXJlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5hbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZShfcmVmMikge1xuICAgICAgdmFyIGdsID0gX3JlZjIuZ2wsXG4gICAgICAgICAgbGF5ZXJNYW5hZ2VyID0gX3JlZjIubGF5ZXJNYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvdmVycmlkZSBmb3IgYSBjYWxsYmFjayBpbW1lZGlhdGVseSBiZWZvcmUgZHJhd2luZyBlYWNoIGZyYW1lXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmVEcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZURyYXcoX3JlZjMpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYzLmdsLFxuICAgICAgICAgIGxheWVyTWFuYWdlciA9IF9yZWYzLmxheWVyTWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb3ZlcnJpZGUgZm9yIGEgY2FsbGJhY2sgaW1tZWRpYXRlbHkgYWZ0ZXIgZHJhd2luZyBhIGZyYW1lJ3MgbGF5ZXJzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoX3JlZjQpIHtcbiAgICAgIHZhciBnbCA9IF9yZWY0LmdsLFxuICAgICAgICAgIGxheWVyTWFuYWdlciA9IF9yZWY0LmxheWVyTWFuYWdlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TmVlZHNSZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TmVlZHNSZWRyYXcoKSB7XG4gICAgICB2YXIgcmVkcmF3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICB0aGlzLm5lZWRzUmVkcmF3ID0gcmVkcmF3O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFZmZlY3Q7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEVmZmVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9leHBlcmltZW50YWwvbGliL2VmZmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 51 */
/* exports provided: getGeojsonFeatures, separateGeojsonFeatures */
/* exports used: getGeojsonFeatures, separateGeojsonFeatures */
/*!**************************************************!*\
  !*** ./src/layers/core/geojson-layer/geojson.js ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib__ = __webpack_require__(/*! ../../../lib */ 2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getGeojsonFeatures;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = separateGeojsonFeatures;\n\n\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nfunction getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  var type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(geojson, 'type');\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'Polygon':\n    case 'MultiPolygon':\n    case 'GeometryCollection':\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{ type: 'Feature', properties: {}, geometry: geojson }];\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(geojson, 'features');\n    default:\n      throw new Error('Unknown geojson type');\n  }\n}\n\n// Linearize\nfunction separateGeojsonFeatures(features) {\n  var pointFeatures = [];\n  var lineFeatures = [];\n  var polygonFeatures = [];\n  var polygonOutlineFeatures = [];\n\n  __WEBPACK_IMPORTED_MODULE_1__lib_utils__[\"c\" /* Container */].forEach(features, function (feature) {\n    var type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(feature, 'geometry.type');\n    var coordinates = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(feature, 'geometry.coordinates');\n    var properties = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__lib__[\"f\" /* get */])(feature, 'properties');\n    switch (type) {\n      case 'Point':\n        pointFeatures.push(feature);\n        break;\n      case 'MultiPoint':\n        // TODO - split multipoints\n        __WEBPACK_IMPORTED_MODULE_1__lib_utils__[\"c\" /* Container */].forEach(coordinates, function (point) {\n          pointFeatures.push({ geometry: { coordinates: point }, properties: properties, feature: feature });\n        });\n        break;\n      case 'LineString':\n        lineFeatures.push(feature);\n        break;\n      case 'MultiLineString':\n        // Break multilinestrings into multiple lines with same properties\n        __WEBPACK_IMPORTED_MODULE_1__lib_utils__[\"c\" /* Container */].forEach(coordinates, function (path) {\n          lineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });\n        });\n        break;\n      case 'Polygon':\n        polygonFeatures.push(feature);\n        // Break polygon into multiple lines with same properties\n        __WEBPACK_IMPORTED_MODULE_1__lib_utils__[\"c\" /* Container */].forEach(coordinates, function (path) {\n          polygonOutlineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });\n        });\n        break;\n      case 'MultiPolygon':\n        // Break multipolygons into multiple polygons with same properties\n        __WEBPACK_IMPORTED_MODULE_1__lib_utils__[\"c\" /* Container */].forEach(coordinates, function (polygon) {\n          polygonFeatures.push({ geometry: { coordinates: polygon }, properties: properties, feature: feature });\n          // Break polygon into multiple lines with same properties\n          __WEBPACK_IMPORTED_MODULE_1__lib_utils__[\"c\" /* Container */].forEach(polygon, function (path) {\n            polygonOutlineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });\n          });\n        });\n        break;\n      // Not yet supported\n      case 'GeometryCollection':\n      default:\n        throw new Error('GeoJsonLayer: ' + type + ' not supported.');\n    }\n  });\n\n  return {\n    pointFeatures: pointFeatures,\n    lineFeatures: lineFeatures,\n    polygonFeatures: polygonFeatures,\n    polygonOutlineFeatures: polygonOutlineFeatures\n  };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvZ2VvanNvbi1sYXllci9nZW9qc29uLmpzPzA0MmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0IH0gZnJvbSAnLi4vLi4vLi4vbGliJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5cbi8qKlxuICogXCJOb3JtYWxpemVzXCIgY29tcGxldGUgb3IgcGFydGlhbCBHZW9KU09OIGRhdGEgaW50byBpdGVyYWJsZSBsaXN0IG9mIGZlYXR1cmVzXG4gKiBDYW4gYWNjZXB0IEdlb0pTT04gZ2VvbWV0cnkgb3IgXCJGZWF0dXJlXCIsIFwiRmVhdHVyZUNvbGxlY3Rpb25cIiBpbiBhZGRpdGlvblxuICogdG8gcGxhaW4gYXJyYXlzIGFuZCBpdGVyYWJsZXMuXG4gKiBXb3JrcyBieSBleHRyYWN0aW5nIHRoZSBmZWF0dXJlIGFycmF5IG9yIHdyYXBwaW5nIHNpbmdsZSBvYmplY3RzIGluIGFuIGFycmF5LFxuICogc28gdGhhdCBzdWJzZXF1ZW50IGNvZGUgY2FuIHNpbXBseSBpdGVyYXRlIG92ZXIgZmVhdHVyZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdlb2pzb24gLSBnZW9qc29uIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXRhIC0gZ2VvanNvbiBvYmplY3QgKEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlIG9yXG4gKiAgR2VvbWV0cnkpIG9yIGFycmF5IG9mIGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtBcnJheXxcIml0ZXJhdGFibGVcIn0gLSBpdGVyYWJsZSBsaXN0IG9mIGZlYXR1cmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHZW9qc29uRmVhdHVyZXMoZ2VvanNvbikge1xuICAvLyBJZiBhcnJheSwgYXNzdW1lIHRoaXMgaXMgYSBsaXN0IG9mIGZlYXR1cmVzXG4gIGlmIChBcnJheS5pc0FycmF5KGdlb2pzb24pKSB7XG4gICAgcmV0dXJuIGdlb2pzb247XG4gIH1cblxuICB2YXIgdHlwZSA9IGdldChnZW9qc29uLCAndHlwZScpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgICAvLyBXcmFwIHRoZSBnZW9tZXRyeSBvYmplY3QgaW4gYSAnRmVhdHVyZScgb2JqZWN0IGFuZCB3cmFwIGluIGFuIGFycmF5XG4gICAgICByZXR1cm4gW3sgdHlwZTogJ0ZlYXR1cmUnLCBwcm9wZXJ0aWVzOiB7fSwgZ2VvbWV0cnk6IGdlb2pzb24gfV07XG4gICAgY2FzZSAnRmVhdHVyZSc6XG4gICAgICAvLyBXcmFwIHRoZSBmZWF0dXJlIGluIGEgJ0ZlYXR1cmVzJyBhcnJheVxuICAgICAgcmV0dXJuIFtnZW9qc29uXTtcbiAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgICAvLyBKdXN0IHJldHVybiB0aGUgJ0ZlYXR1cmVzJyBhcnJheSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAgICByZXR1cm4gZ2V0KGdlb2pzb24sICdmZWF0dXJlcycpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZ2VvanNvbiB0eXBlJyk7XG4gIH1cbn1cblxuLy8gTGluZWFyaXplXG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGVHZW9qc29uRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgdmFyIHBvaW50RmVhdHVyZXMgPSBbXTtcbiAgdmFyIGxpbmVGZWF0dXJlcyA9IFtdO1xuICB2YXIgcG9seWdvbkZlYXR1cmVzID0gW107XG4gIHZhciBwb2x5Z29uT3V0bGluZUZlYXR1cmVzID0gW107XG5cbiAgQ29udGFpbmVyLmZvckVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXQoZmVhdHVyZSwgJ2dlb21ldHJ5LnR5cGUnKTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZXQoZmVhdHVyZSwgJ2dlb21ldHJ5LmNvb3JkaW5hdGVzJyk7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBnZXQoZmVhdHVyZSwgJ3Byb3BlcnRpZXMnKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgcG9pbnRGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICAvLyBUT0RPIC0gc3BsaXQgbXVsdGlwb2ludHNcbiAgICAgICAgQ29udGFpbmVyLmZvckVhY2goY29vcmRpbmF0ZXMsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgIHBvaW50RmVhdHVyZXMucHVzaCh7IGdlb21ldHJ5OiB7IGNvb3JkaW5hdGVzOiBwb2ludCB9LCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBmZWF0dXJlOiBmZWF0dXJlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgbGluZUZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgICAgLy8gQnJlYWsgbXVsdGlsaW5lc3RyaW5ncyBpbnRvIG11bHRpcGxlIGxpbmVzIHdpdGggc2FtZSBwcm9wZXJ0aWVzXG4gICAgICAgIENvbnRhaW5lci5mb3JFYWNoKGNvb3JkaW5hdGVzLCBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgIGxpbmVGZWF0dXJlcy5wdXNoKHsgZ2VvbWV0cnk6IHsgY29vcmRpbmF0ZXM6IHBhdGggfSwgcHJvcGVydGllczogcHJvcGVydGllcywgZmVhdHVyZTogZmVhdHVyZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIHBvbHlnb25GZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAvLyBCcmVhayBwb2x5Z29uIGludG8gbXVsdGlwbGUgbGluZXMgd2l0aCBzYW1lIHByb3BlcnRpZXNcbiAgICAgICAgQ29udGFpbmVyLmZvckVhY2goY29vcmRpbmF0ZXMsIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgcG9seWdvbk91dGxpbmVGZWF0dXJlcy5wdXNoKHsgZ2VvbWV0cnk6IHsgY29vcmRpbmF0ZXM6IHBhdGggfSwgcHJvcGVydGllczogcHJvcGVydGllcywgZmVhdHVyZTogZmVhdHVyZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgLy8gQnJlYWsgbXVsdGlwb2x5Z29ucyBpbnRvIG11bHRpcGxlIHBvbHlnb25zIHdpdGggc2FtZSBwcm9wZXJ0aWVzXG4gICAgICAgIENvbnRhaW5lci5mb3JFYWNoKGNvb3JkaW5hdGVzLCBmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICAgIHBvbHlnb25GZWF0dXJlcy5wdXNoKHsgZ2VvbWV0cnk6IHsgY29vcmRpbmF0ZXM6IHBvbHlnb24gfSwgcHJvcGVydGllczogcHJvcGVydGllcywgZmVhdHVyZTogZmVhdHVyZSB9KTtcbiAgICAgICAgICAvLyBCcmVhayBwb2x5Z29uIGludG8gbXVsdGlwbGUgbGluZXMgd2l0aCBzYW1lIHByb3BlcnRpZXNcbiAgICAgICAgICBDb250YWluZXIuZm9yRWFjaChwb2x5Z29uLCBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgcG9seWdvbk91dGxpbmVGZWF0dXJlcy5wdXNoKHsgZ2VvbWV0cnk6IHsgY29vcmRpbmF0ZXM6IHBhdGggfSwgcHJvcGVydGllczogcHJvcGVydGllcywgZmVhdHVyZTogZmVhdHVyZSB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gTm90IHlldCBzdXBwb3J0ZWRcbiAgICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlb0pzb25MYXllcjogJyArIHR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHBvaW50RmVhdHVyZXM6IHBvaW50RmVhdHVyZXMsXG4gICAgbGluZUZlYXR1cmVzOiBsaW5lRmVhdHVyZXMsXG4gICAgcG9seWdvbkZlYXR1cmVzOiBwb2x5Z29uRmVhdHVyZXMsXG4gICAgcG9seWdvbk91dGxpbmVGZWF0dXJlczogcG9seWdvbk91dGxpbmVGZWF0dXJlc1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL2dlb2pzb24tbGF5ZXIvZ2VvanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 52 */
/* exports provided: pointToDensityGridData */
/* exports used: pointToDensityGridData */
/*!*********************************************************************!*\
  !*** ./src/layers/core/point-density-grid-layer/grid-aggregator.js ***!
  \*********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = pointToDensityGridData;\nvar R_EARTH = 6378000;\n\n/**\n * Calculate density grid from an array of points\n * @param {array} points\n * @param {number} worldUnitSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid data, cell dimension and count range\n */\nfunction pointToDensityGridData(points, worldUnitSize, getPosition) {\n  var _pointsToGridHashing2 = _pointsToGridHashing(points, worldUnitSize, getPosition),\n      gridHash = _pointsToGridHashing2.gridHash,\n      gridOffset = _pointsToGridHashing2.gridOffset;\n\n  var layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);\n  var countRange = _getCellCountExtent(layerData);\n\n  return {\n    gridOffset: gridOffset,\n    layerData: layerData,\n    countRange: countRange\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {array} points\n * @param {number} worldUnitSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\nfunction _pointsToGridHashing(points, worldUnitSize, getPosition) {\n\n  // find the geometric center of sample points\n  var allLat = points.map(function (p) {\n    return getPosition(p)[1];\n  });\n  var latMin = Math.min.apply(null, allLat);\n  var latMax = Math.max.apply(null, allLat);\n\n  var centerLat = (latMin + latMax) / 2;\n\n  var gridOffset = _calculateGridLatLonOffset(worldUnitSize, centerLat);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return { gridHash: {}, gridOffset: gridOffset };\n  }\n  // calculate count per cell\n  var gridHash = points.reduce(function (accu, pt) {\n    var latIdx = Math.floor((getPosition(pt)[1] + 90) / gridOffset.yOffset);\n    var lonIdx = Math.floor((getPosition(pt)[0] + 180) / gridOffset.xOffset);\n    var key = latIdx + '-' + lonIdx;\n\n    accu[key] = accu[key] || { count: 0, points: [] };\n    accu[key].count += 1;\n    accu[key].points.push(pt);\n\n    return accu;\n  }, {});\n\n  return { gridHash: gridHash, gridOffset: gridOffset };\n}\n\nfunction _getGridLayerDataFromGridHash(gridHash, gridOffset) {\n  return Object.keys(gridHash).reduce(function (accu, key, i) {\n    var idxs = key.split('-');\n    var latIdx = parseInt(idxs[0], 10);\n    var lonIdx = parseInt(idxs[1], 10);\n\n    accu.push(Object.assign({\n      index: i,\n      position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]\n    }, gridHash[key]));\n\n    return accu;\n  }, []);\n}\n\nfunction _getCellCountExtent(data) {\n  return data.length ? [Math.min.apply(null, data.map(function (d) {\n    return d.count;\n  })), Math.max.apply(null, data.map(function (d) {\n    return d.count;\n  }))] : [0, 1];\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} worldUnitSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction _calculateGridLatLonOffset(worldUnitSize, latitude) {\n  var yOffset = _calculateLatOffset(worldUnitSize);\n  var xOffset = _calculateLonOffset(latitude, worldUnitSize);\n  return { yOffset: yOffset, xOffset: xOffset };\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction _calculateLatOffset(dy) {\n  return dy / R_EARTH * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction _calculateLonOffset(lat, dx) {\n  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtZGVuc2l0eS1ncmlkLWxheWVyL2dyaWQtYWdncmVnYXRvci5qcz9kMzBhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBSX0VBUlRIID0gNjM3ODAwMDtcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGVuc2l0eSBncmlkIGZyb20gYW4gYXJyYXkgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSB3b3JsZFVuaXRTaXplIC0gdW5pdCBzaXplIGluIG1ldGVyc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0UG9zaXRpb24gLSBwb3NpdGlvbiBhY2Nlc3NvclxuICogQHJldHVybnMge29iamVjdH0gLSBncmlkIGRhdGEsIGNlbGwgZGltZW5zaW9uIGFuZCBjb3VudCByYW5nZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb0RlbnNpdHlHcmlkRGF0YShwb2ludHMsIHdvcmxkVW5pdFNpemUsIGdldFBvc2l0aW9uKSB7XG4gIHZhciBfcG9pbnRzVG9HcmlkSGFzaGluZzIgPSBfcG9pbnRzVG9HcmlkSGFzaGluZyhwb2ludHMsIHdvcmxkVW5pdFNpemUsIGdldFBvc2l0aW9uKSxcbiAgICAgIGdyaWRIYXNoID0gX3BvaW50c1RvR3JpZEhhc2hpbmcyLmdyaWRIYXNoLFxuICAgICAgZ3JpZE9mZnNldCA9IF9wb2ludHNUb0dyaWRIYXNoaW5nMi5ncmlkT2Zmc2V0O1xuXG4gIHZhciBsYXllckRhdGEgPSBfZ2V0R3JpZExheWVyRGF0YUZyb21HcmlkSGFzaChncmlkSGFzaCwgZ3JpZE9mZnNldCk7XG4gIHZhciBjb3VudFJhbmdlID0gX2dldENlbGxDb3VudEV4dGVudChsYXllckRhdGEpO1xuXG4gIHJldHVybiB7XG4gICAgZ3JpZE9mZnNldDogZ3JpZE9mZnNldCxcbiAgICBsYXllckRhdGE6IGxheWVyRGF0YSxcbiAgICBjb3VudFJhbmdlOiBjb3VudFJhbmdlXG4gIH07XG59XG5cbi8qKlxuICogUHJvamVjdCBwb2ludHMgaW50byBlYWNoIGNlbGwsIHJldHVybiBhIGhhc2ggdGFibGUgb2YgY2VsbHNcbiAqIEBwYXJhbSB7YXJyYXl9IHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IHdvcmxkVW5pdFNpemUgLSB1bml0IHNpemUgaW4gbWV0ZXJzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRQb3NpdGlvbiAtIHBvc2l0aW9uIGFjY2Vzc29yXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIGdyaWQgaGFzaCBhbmQgY2VsbCBkaW1lbnNpb25cbiAqL1xuZnVuY3Rpb24gX3BvaW50c1RvR3JpZEhhc2hpbmcocG9pbnRzLCB3b3JsZFVuaXRTaXplLCBnZXRQb3NpdGlvbikge1xuXG4gIC8vIGZpbmQgdGhlIGdlb21ldHJpYyBjZW50ZXIgb2Ygc2FtcGxlIHBvaW50c1xuICB2YXIgYWxsTGF0ID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBnZXRQb3NpdGlvbihwKVsxXTtcbiAgfSk7XG4gIHZhciBsYXRNaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCBhbGxMYXQpO1xuICB2YXIgbGF0TWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgYWxsTGF0KTtcblxuICB2YXIgY2VudGVyTGF0ID0gKGxhdE1pbiArIGxhdE1heCkgLyAyO1xuXG4gIHZhciBncmlkT2Zmc2V0ID0gX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQod29ybGRVbml0U2l6ZSwgY2VudGVyTGF0KTtcblxuICBpZiAoZ3JpZE9mZnNldC54T2Zmc2V0IDw9IDAgfHwgZ3JpZE9mZnNldC55T2Zmc2V0IDw9IDApIHtcbiAgICByZXR1cm4geyBncmlkSGFzaDoge30sIGdyaWRPZmZzZXQ6IGdyaWRPZmZzZXQgfTtcbiAgfVxuICAvLyBjYWxjdWxhdGUgY291bnQgcGVyIGNlbGxcbiAgdmFyIGdyaWRIYXNoID0gcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjdSwgcHQpIHtcbiAgICB2YXIgbGF0SWR4ID0gTWF0aC5mbG9vcigoZ2V0UG9zaXRpb24ocHQpWzFdICsgOTApIC8gZ3JpZE9mZnNldC55T2Zmc2V0KTtcbiAgICB2YXIgbG9uSWR4ID0gTWF0aC5mbG9vcigoZ2V0UG9zaXRpb24ocHQpWzBdICsgMTgwKSAvIGdyaWRPZmZzZXQueE9mZnNldCk7XG4gICAgdmFyIGtleSA9IGxhdElkeCArICctJyArIGxvbklkeDtcblxuICAgIGFjY3Vba2V5XSA9IGFjY3Vba2V5XSB8fCB7IGNvdW50OiAwLCBwb2ludHM6IFtdIH07XG4gICAgYWNjdVtrZXldLmNvdW50ICs9IDE7XG4gICAgYWNjdVtrZXldLnBvaW50cy5wdXNoKHB0KTtcblxuICAgIHJldHVybiBhY2N1O1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIHsgZ3JpZEhhc2g6IGdyaWRIYXNoLCBncmlkT2Zmc2V0OiBncmlkT2Zmc2V0IH07XG59XG5cbmZ1bmN0aW9uIF9nZXRHcmlkTGF5ZXJEYXRhRnJvbUdyaWRIYXNoKGdyaWRIYXNoLCBncmlkT2Zmc2V0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhncmlkSGFzaCkucmVkdWNlKGZ1bmN0aW9uIChhY2N1LCBrZXksIGkpIHtcbiAgICB2YXIgaWR4cyA9IGtleS5zcGxpdCgnLScpO1xuICAgIHZhciBsYXRJZHggPSBwYXJzZUludChpZHhzWzBdLCAxMCk7XG4gICAgdmFyIGxvbklkeCA9IHBhcnNlSW50KGlkeHNbMV0sIDEwKTtcblxuICAgIGFjY3UucHVzaChPYmplY3QuYXNzaWduKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgcG9zaXRpb246IFstMTgwICsgZ3JpZE9mZnNldC54T2Zmc2V0ICogbG9uSWR4LCAtOTAgKyBncmlkT2Zmc2V0LnlPZmZzZXQgKiBsYXRJZHhdXG4gICAgfSwgZ3JpZEhhc2hba2V5XSkpO1xuXG4gICAgcmV0dXJuIGFjY3U7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gX2dldENlbGxDb3VudEV4dGVudChkYXRhKSB7XG4gIHJldHVybiBkYXRhLmxlbmd0aCA/IFtNYXRoLm1pbi5hcHBseShudWxsLCBkYXRhLm1hcChmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLmNvdW50O1xuICB9KSksIE1hdGgubWF4LmFwcGx5KG51bGwsIGRhdGEubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuY291bnQ7XG4gIH0pKV0gOiBbMCwgMV07XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIGdyaWQgbGF5ZXIgY2VsbCBzaXplIGluIGxhdCBsb24gYmFzZWQgb24gd29ybGQgdW5pdCBzaXplXG4gKiBhbmQgY3VycmVudCBsYXRpdHVkZVxuICogQHBhcmFtIHtudW1iZXJ9IHdvcmxkVW5pdFNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXRpdHVkZVxuICogQHJldHVybnMge29iamVjdH0gLSBsYXQgZGVsdGEgYW5kIGxvbiBkZWx0YVxuICovXG5mdW5jdGlvbiBfY2FsY3VsYXRlR3JpZExhdExvbk9mZnNldCh3b3JsZFVuaXRTaXplLCBsYXRpdHVkZSkge1xuICB2YXIgeU9mZnNldCA9IF9jYWxjdWxhdGVMYXRPZmZzZXQod29ybGRVbml0U2l6ZSk7XG4gIHZhciB4T2Zmc2V0ID0gX2NhbGN1bGF0ZUxvbk9mZnNldChsYXRpdHVkZSwgd29ybGRVbml0U2l6ZSk7XG4gIHJldHVybiB7IHlPZmZzZXQ6IHlPZmZzZXQsIHhPZmZzZXQ6IHhPZmZzZXQgfTtcbn1cblxuLyoqXG4gKiB3aXRoIGEgZ2l2ZW4geC1rbSBjaGFuZ2UsIGNhbGN1bGF0ZSB0aGUgaW5jcmVtZW50IG9mIGxhdGl0dWRlXG4gKiBiYXNlZCBvbiBzdGFja292ZXJmbG93IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQ3NzAwM1xuICogQHBhcmFtIHtudW1iZXJ9IGR5IC0gY2hhbmdlIGluIGttXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gaW5jcmVtZW50IGluIGxhdGl0dWRlXG4gKi9cbmZ1bmN0aW9uIF9jYWxjdWxhdGVMYXRPZmZzZXQoZHkpIHtcbiAgcmV0dXJuIGR5IC8gUl9FQVJUSCAqICgxODAgLyBNYXRoLlBJKTtcbn1cblxuLyoqXG4gKiB3aXRoIGEgZ2l2ZW4geC1rbSBjaGFuZ2UsIGFuZCBjdXJyZW50IGxhdGl0dWRlXG4gKiBjYWxjdWxhdGUgdGhlIGluY3JlbWVudCBvZiBsb25naXR1ZGVcbiAqIGJhc2VkIG9uIHN0YWNrb3ZlcmZsb3cgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDc3MDAzXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0IC0gbGF0aXR1ZGUgb2YgY3VycmVudCBsb2NhdGlvbiAoYmFzZWQgb24gY2l0eSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBkeCAtIGNoYW5nZSBpbiBrbVxuICogQHJldHVybiB7bnVtYmVyfSAtIGluY3JlbWVudCBpbiBsb25naXR1ZGVcbiAqL1xuZnVuY3Rpb24gX2NhbGN1bGF0ZUxvbk9mZnNldChsYXQsIGR4KSB7XG4gIHJldHVybiBkeCAvIFJfRUFSVEggKiAoMTgwIC8gTWF0aC5QSSkgLyBNYXRoLmNvcyhsYXQgKiBNYXRoLlBJIC8gMTgwKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9sYXllcnMvY29yZS9wb2ludC1kZW5zaXR5LWdyaWQtbGF5ZXIvZ3JpZC1hZ2dyZWdhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 53 */
/* exports provided: pointToHexbin, getRadiusInPixel */
/* exports used: pointToHexbin */
/*!***************************************************************************!*\
  !*** ./src/layers/core/point-density-hexagon-layer/hexagon-aggregator.js ***!
  \***************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_hexbin__ = __webpack_require__(/*! d3-hexbin */ 78);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3_hexbin___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_d3_hexbin__);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = pointToHexbin;\n/* unused harmony export getRadiusInPixel */\n\n\n/**\n * Use d3-hexbin to performs hexagonal binning from geo points to hexagons\n * @param {Array} data - array of points\n * @param {Number} radius - hexagon radius in meter\n * @param {function} getPosition - get points lon lat\n * @param {Object} viewport - current viewport object\n\n * @return {Object} - hexagons and countRange\n */\nfunction pointToHexbin(_ref, viewport) {\n  var data = _ref.data,\n      radius = _ref.radius,\n      getPosition = _ref.getPosition;\n\n  // get hexagon radius in mercator world unit\n  var radiusInPixel = getRadiusInPixel(radius, viewport);\n\n  // add world space coordinates to points\n  var screenPoints = data.map(function (pt) {\n    return Object.assign({\n      screenCoord: viewport.projectFlat(getPosition(pt))\n    }, pt);\n  });\n\n  var newHexbin = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_d3_hexbin__[\"hexbin\"])().radius(radiusInPixel).x(function (d) {\n    return d.screenCoord[0];\n  }).y(function (d) {\n    return d.screenCoord[1];\n  });\n\n  var hexagonBins = newHexbin(screenPoints);\n\n  return hexagonBins.map(function (hex) {\n    return {\n      centroid: viewport.unprojectFlat([hex.x, hex.y]),\n      points: hex\n    };\n  });\n}\n\n/**\n * Get radius in mercator world space coordinates from meter\n * @param {Number} radius - in meter\n * @param {Object} viewport - current viewport object\n\n * @return {Number} radius in mercator world spcae coordinates\n */\nfunction getRadiusInPixel(radius, viewport) {\n  var _viewport$getDistance = viewport.getDistanceScales(),\n      pixelsPerMeter = _viewport$getDistance.pixelsPerMeter;\n\n  // x, y distance should be the same\n\n\n  return radius * pixelsPerMeter[0];\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9pbnQtZGVuc2l0eS1oZXhhZ29uLWxheWVyL2hleGFnb24tYWdncmVnYXRvci5qcz9hOWQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhleGJpbiB9IGZyb20gJ2QzLWhleGJpbic7XG5cbi8qKlxuICogVXNlIGQzLWhleGJpbiB0byBwZXJmb3JtcyBoZXhhZ29uYWwgYmlubmluZyBmcm9tIGdlbyBwb2ludHMgdG8gaGV4YWdvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgLSBhcnJheSBvZiBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgLSBoZXhhZ29uIHJhZGl1cyBpbiBtZXRlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0UG9zaXRpb24gLSBnZXQgcG9pbnRzIGxvbiBsYXRcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3cG9ydCAtIGN1cnJlbnQgdmlld3BvcnQgb2JqZWN0XG5cbiAqIEByZXR1cm4ge09iamVjdH0gLSBoZXhhZ29ucyBhbmQgY291bnRSYW5nZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb0hleGJpbihfcmVmLCB2aWV3cG9ydCkge1xuICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIHJhZGl1cyA9IF9yZWYucmFkaXVzLFxuICAgICAgZ2V0UG9zaXRpb24gPSBfcmVmLmdldFBvc2l0aW9uO1xuXG4gIC8vIGdldCBoZXhhZ29uIHJhZGl1cyBpbiBtZXJjYXRvciB3b3JsZCB1bml0XG4gIHZhciByYWRpdXNJblBpeGVsID0gZ2V0UmFkaXVzSW5QaXhlbChyYWRpdXMsIHZpZXdwb3J0KTtcblxuICAvLyBhZGQgd29ybGQgc3BhY2UgY29vcmRpbmF0ZXMgdG8gcG9pbnRzXG4gIHZhciBzY3JlZW5Qb2ludHMgPSBkYXRhLm1hcChmdW5jdGlvbiAocHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICBzY3JlZW5Db29yZDogdmlld3BvcnQucHJvamVjdEZsYXQoZ2V0UG9zaXRpb24ocHQpKVxuICAgIH0sIHB0KTtcbiAgfSk7XG5cbiAgdmFyIG5ld0hleGJpbiA9IGhleGJpbigpLnJhZGl1cyhyYWRpdXNJblBpeGVsKS54KGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc2NyZWVuQ29vcmRbMF07XG4gIH0pLnkoZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zY3JlZW5Db29yZFsxXTtcbiAgfSk7XG5cbiAgdmFyIGhleGFnb25CaW5zID0gbmV3SGV4YmluKHNjcmVlblBvaW50cyk7XG5cbiAgcmV0dXJuIGhleGFnb25CaW5zLm1hcChmdW5jdGlvbiAoaGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbnRyb2lkOiB2aWV3cG9ydC51bnByb2plY3RGbGF0KFtoZXgueCwgaGV4LnldKSxcbiAgICAgIHBvaW50czogaGV4XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHJhZGl1cyBpbiBtZXJjYXRvciB3b3JsZCBzcGFjZSBjb29yZGluYXRlcyBmcm9tIG1ldGVyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gaW4gbWV0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3cG9ydCAtIGN1cnJlbnQgdmlld3BvcnQgb2JqZWN0XG5cbiAqIEByZXR1cm4ge051bWJlcn0gcmFkaXVzIGluIG1lcmNhdG9yIHdvcmxkIHNwY2FlIGNvb3JkaW5hdGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYWRpdXNJblBpeGVsKHJhZGl1cywgdmlld3BvcnQpIHtcbiAgdmFyIF92aWV3cG9ydCRnZXREaXN0YW5jZSA9IHZpZXdwb3J0LmdldERpc3RhbmNlU2NhbGVzKCksXG4gICAgICBwaXhlbHNQZXJNZXRlciA9IF92aWV3cG9ydCRnZXREaXN0YW5jZS5waXhlbHNQZXJNZXRlcjtcblxuICAvLyB4LCB5IGRpc3RhbmNlIHNob3VsZCBiZSB0aGUgc2FtZVxuXG5cbiAgcmV0dXJuIHJhZGl1cyAqIHBpeGVsc1Blck1ldGVyWzBdO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL3BvaW50LWRlbnNpdHktaGV4YWdvbi1sYXllci9oZXhhZ29uLWFnZ3JlZ2F0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 54 */
/* exports provided: PolygonTesselatorExtruded */
/* exports used: PolygonTesselatorExtruded */
/*!**********************************************************************!*\
  !*** ./src/layers/core/polygon-layer/polygon-tesselator-extruded.js ***!
  \**********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygon__ = __webpack_require__(/*! ./polygon */ 26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut__ = __webpack_require__(/*! earcut */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep__ = __webpack_require__(/*! lodash.flattendeep */ 34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_gl_matrix__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return PolygonTesselatorExtruded; });\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n// import {getPolygonVertexCount, getPolygonTriangleCount} from './polygon';\n\n\n\n\n\n// import {Container, flattenVertices, fillArray} from '../../../lib/utils';\n\nvar DEFAULT_COLOR = [0, 0, 0, 255]; // Black\n\nvar PolygonTesselatorExtruded = function () {\n  function PolygonTesselatorExtruded(_ref) {\n    var polygons = _ref.polygons,\n        _ref$getHeight = _ref.getHeight,\n        getHeight = _ref$getHeight === undefined ? function (x) {\n      return 1000;\n    } : _ref$getHeight,\n        _ref$getColor = _ref.getColor,\n        getColor = _ref$getColor === undefined ? function (x) {\n      return [0, 0, 0, 255];\n    } : _ref$getColor,\n        _ref$wireframe = _ref.wireframe,\n        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,\n        _ref$fp = _ref.fp64,\n        fp64 = _ref$fp === undefined ? false : _ref$fp;\n\n    _classCallCheck(this, PolygonTesselatorExtruded);\n\n    this.fp64 = fp64;\n\n    // Expensive operation, convert all polygons to arrays\n    polygons = __WEBPACK_IMPORTED_MODULE_5__lib_utils__[\"c\" /* Container */].map(polygons, function (complexPolygon, polygonIndex) {\n      var height = getHeight(polygonIndex) || 0;\n      return __WEBPACK_IMPORTED_MODULE_5__lib_utils__[\"c\" /* Container */].map(__WEBPACK_IMPORTED_MODULE_0__polygon__[\"a\" /* normalize */](complexPolygon), function (polygon) {\n        return __WEBPACK_IMPORTED_MODULE_5__lib_utils__[\"c\" /* Container */].map(polygon, function (coord) {\n          return [coord[0], coord[1], height];\n        });\n      });\n    });\n\n    var groupedVertices = polygons;\n    this.groupedVertices = polygons;\n    this.wireframe = wireframe;\n\n    this.attributes = {};\n\n    var positionsJS = calculatePositionsJS({ groupedVertices: groupedVertices, wireframe: wireframe });\n    Object.assign(this.attributes, {\n      positions: calculatePositions(positionsJS, this.fp64),\n      indices: calculateIndices({ groupedVertices: groupedVertices, wireframe: wireframe }),\n      normals: calculateNormals({ groupedVertices: groupedVertices, wireframe: wireframe }),\n      // colors: calculateColors({groupedVertices, wireframe, getColor}),\n      pickingColors: calculatePickingColors({ groupedVertices: groupedVertices, wireframe: wireframe })\n    });\n  }\n\n  _createClass(PolygonTesselatorExtruded, [{\n    key: 'indices',\n    value: function indices() {\n      return this.attributes.indices;\n    }\n  }, {\n    key: 'positions',\n    value: function positions() {\n      return this.attributes.positions;\n    }\n  }, {\n    key: 'normals',\n    value: function normals() {\n      return this.attributes.normals;\n    }\n  }, {\n    key: 'colors',\n    value: function colors() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$getColor = _ref2.getColor,\n          getColor = _ref2$getColor === undefined ? function (x) {\n        return DEFAULT_COLOR;\n      } : _ref2$getColor;\n\n      var groupedVertices = this.groupedVertices,\n          wireframe = this.wireframe;\n\n      return calculateColors({ groupedVertices: groupedVertices, wireframe: wireframe, getColor: getColor });\n    }\n  }, {\n    key: 'pickingColors',\n    value: function pickingColors() {\n      return this.attributes.pickingColors;\n    }\n\n    // updateTriggers: {\n    //   positions: ['getHeight'],\n    //   colors: ['getColors']\n    //   pickingColors: 'none'\n    // }\n\n  }]);\n\n  return PolygonTesselatorExtruded;\n}();\n\nfunction countVertices(vertices) {\n  return vertices.reduce(function (count, polygon) {\n    return count + polygon.length;\n  }, 0);\n}\n\nfunction calculateIndices(_ref3) {\n  var groupedVertices = _ref3.groupedVertices,\n      _ref3$wireframe = _ref3.wireframe,\n      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe;\n\n  // adjust index offset for multiple buildings\n  var multiplier = wireframe ? 2 : 5;\n  var offsets = groupedVertices.reduce(function (acc, vertices) {\n    return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + countVertices(vertices) * multiplier]);\n  }, [0]);\n\n  var indices = groupedVertices.map(function (vertices, buildingIndex) {\n    return wireframe ?\n    // 1. get sequentially ordered indices of each building wireframe\n    // 2. offset them by the number of indices in previous buildings\n    calculateContourIndices(vertices, offsets[buildingIndex]) :\n    // 1. get triangulated indices for the internal areas\n    // 2. offset them by the number of indices in previous buildings\n    calculateSurfaceIndices(vertices, offsets[buildingIndex]);\n  });\n\n  return new Uint32Array(__WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(indices));\n}\n\n// Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays\n// Remarks:\n// * each top vertex is on 3 surfaces\n// * each bottom vertex is on 2 surfaces\nfunction calculatePositionsJS(_ref4) {\n  var groupedVertices = _ref4.groupedVertices,\n      _ref4$wireframe = _ref4.wireframe,\n      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;\n\n  var positions = __WEBPACK_IMPORTED_MODULE_5__lib_utils__[\"c\" /* Container */].map(groupedVertices, function (complexPolygon) {\n    return __WEBPACK_IMPORTED_MODULE_5__lib_utils__[\"c\" /* Container */].map(complexPolygon, function (vertices) {\n      var topVertices = [].concat(vertices);\n      var baseVertices = topVertices.map(function (v) {\n        return [v[0], v[1], 0];\n      });\n      return wireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n    });\n  });\n  return __WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(positions);\n}\n\nfunction calculatePositions(positionsJS, fp64) {\n  var positionLow = void 0;\n  if (fp64) {\n    // We only need x, y component\n    positionLow = new Float32Array(positionsJS / 3 * 2);\n    for (var i = 0; i < positionsJS.length / 3; i++) {\n      positionLow[i * 2 + 0] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__[\"a\" /* fp64ify */])(positionsJS[i * 3 + 0])[1];\n      positionLow[i * 2 + 1] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__lib_utils_fp64__[\"a\" /* fp64ify */])(positionsJS[i * 3 + 1])[1];\n    }\n  }\n  return { positions: new Float32Array(positionsJS), positions64xyLow: positionLow };\n}\n\nfunction calculateNormals(_ref5) {\n  var groupedVertices = _ref5.groupedVertices,\n      wireframe = _ref5.wireframe;\n\n  var up = [0, 1, 0];\n\n  var normals = groupedVertices.map(function (vertices, buildingIndex) {\n    var topNormals = new Array(countVertices(vertices)).fill(up);\n    var sideNormals = vertices.map(function (polygon) {\n      return calculateSideNormals(polygon);\n    });\n    var sideNormalsForward = sideNormals.map(function (n) {\n      return n[0];\n    });\n    var sideNormalsBackward = sideNormals.map(function (n) {\n      return n[1];\n    });\n\n    return wireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];\n  });\n\n  return new Float32Array(__WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(normals));\n}\n\nfunction calculateSideNormals(vertices) {\n  var numVertices = vertices.length;\n  var normals = [];\n\n  for (var i = 0; i < numVertices - 1; i++) {\n    var n = getNormal(vertices[i], vertices[i + 1]);\n    normals.push(n);\n  }\n\n  return [[].concat(normals, [normals[0]]), [normals[0]].concat(normals)];\n}\n\n/*\nfunction calculateColors({polygons, pointCount, getColor}) {\n  const attribute = new Uint8Array(pointCount * 4);\n  let i = 0;\n  polygons.forEach((complexPolygon, polygonIndex) => {\n    // Calculate polygon color\n    const color = getColor(polygonIndex);\n    color[3] = Number.isFinite(color[3]) ? color[3] : 255;\n\n    const count = Polygon.getVertexCount(complexPolygon);\n    fillArray({target: attribute, source: color, start: i, count});\n    i += color.length * count;\n  });\n  return attribute;\n}\n*/\n\nfunction calculateColors(_ref6) {\n  var groupedVertices = _ref6.groupedVertices,\n      getColor = _ref6.getColor,\n      _ref6$wireframe = _ref6.wireframe,\n      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;\n\n  var colors = groupedVertices.map(function (complexPolygon, polygonIndex) {\n    var color = getColor(polygonIndex);\n    color[3] = Number.isFinite(color[3]) ? color[3] : 255;\n\n    // const baseColor = Array.isArray(color) ? color[0] : color;\n    // const topColor = Array.isArray(color) ? color[color.length - 1] : color;\n    var numVertices = countVertices(complexPolygon);\n    var topColors = new Array(numVertices).fill(color);\n    var baseColors = new Array(numVertices).fill(color);\n    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];\n  });\n  return new Uint8ClampedArray(__WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(colors));\n}\n\nfunction calculatePickingColors(_ref7) {\n  var groupedVertices = _ref7.groupedVertices,\n      _ref7$color = _ref7.color,\n      color = _ref7$color === undefined ? [0, 0, 0] : _ref7$color,\n      _ref7$wireframe = _ref7.wireframe,\n      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;\n\n  var colors = groupedVertices.map(function (vertices, buildingIndex) {\n    // const baseColor = Array.isArray(color) ? color[0] : color;\n    // const topColor = Array.isArray(color) ? color[color.length - 1] : color;\n    var numVertices = countVertices(vertices);\n    var topColors = new Array(numVertices).fill([0, 0, 0]);\n    var baseColors = new Array(numVertices).fill([0, 0, 0]);\n    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];\n  });\n  return new Uint8ClampedArray(__WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(colors));\n}\n\nfunction calculateContourIndices(vertices, offset) {\n  var stride = countVertices(vertices);\n\n  return vertices.map(function (polygon) {\n    var indices = [offset];\n    var numVertices = polygon.length;\n\n    // building top\n    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]\n    for (var i = 1; i < numVertices - 1; i++) {\n      indices.push(i + offset, i + offset);\n    }\n    indices.push(offset);\n\n    // building sides\n    for (var _i = 0; _i < numVertices - 1; _i++) {\n      indices.push(_i + offset, _i + stride + offset);\n    }\n\n    offset += numVertices;\n    return indices;\n  });\n}\n\nfunction calculateSurfaceIndices(vertices, offset) {\n  var stride = countVertices(vertices);\n  var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];\n\n  function drawRectangle(i) {\n    return quad.map(function (v) {\n      return i + v[0] + stride * v[1] + offset;\n    });\n  }\n\n  var holes = null;\n\n  if (vertices.length > 1) {\n    holes = vertices.reduce(function (acc, polygon) {\n      return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);\n    }, [0]).slice(1, vertices.length);\n  }\n\n  var topIndices = __WEBPACK_IMPORTED_MODULE_1_earcut___default()(__WEBPACK_IMPORTED_MODULE_2_lodash_flattendeep___default()(vertices), holes, 3).map(function (index) {\n    return index + offset;\n  });\n\n  var sideIndices = vertices.map(function (polygon) {\n    var numVertices = polygon.length;\n    // building top\n    var indices = [];\n\n    // building sides\n    for (var i = 0; i < numVertices - 1; i++) {\n      indices.push.apply(indices, _toConsumableArray(drawRectangle(i)));\n    }\n\n    offset += numVertices;\n    return indices;\n  });\n\n  return [topIndices, sideIndices];\n}\n\n// helpers\n\n// get normal vector of line segment\nfunction getNormal(p1, p2) {\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    return [1, 0, 0];\n  }\n\n  var degrees2radians = Math.PI / 180;\n  var lon1 = degrees2radians * p1[0];\n  var lon2 = degrees2radians * p2[0];\n  var lat1 = degrees2radians * p1[1];\n  var lat2 = degrees2radians * p2[1];\n  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n  return __WEBPACK_IMPORTED_MODULE_3_gl_matrix__[\"vec3\"].normalize([], [b, 0, -a]);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9seWdvbi1sYXllci9wb2x5Z29uLXRlc3NlbGF0b3ItZXh0cnVkZWQuanM/YTg2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuaW1wb3J0ICogYXMgUG9seWdvbiBmcm9tICcuL3BvbHlnb24nO1xuLy8gaW1wb3J0IHtnZXRQb2x5Z29uVmVydGV4Q291bnQsIGdldFBvbHlnb25UcmlhbmdsZUNvdW50fSBmcm9tICcuL3BvbHlnb24nO1xuaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xuaW1wb3J0IGZsYXR0ZW5EZWVwIGZyb20gJ2xvZGFzaC5mbGF0dGVuZGVlcCc7XG5pbXBvcnQgeyB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCB7IGZwNjRpZnkgfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuLy8gaW1wb3J0IHtDb250YWluZXIsIGZsYXR0ZW5WZXJ0aWNlcywgZmlsbEFycmF5fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuXG52YXIgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdOyAvLyBCbGFja1xuXG5leHBvcnQgdmFyIFBvbHlnb25UZXNzZWxhdG9yRXh0cnVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvbHlnb25UZXNzZWxhdG9yRXh0cnVkZWQoX3JlZikge1xuICAgIHZhciBwb2x5Z29ucyA9IF9yZWYucG9seWdvbnMsXG4gICAgICAgIF9yZWYkZ2V0SGVpZ2h0ID0gX3JlZi5nZXRIZWlnaHQsXG4gICAgICAgIGdldEhlaWdodCA9IF9yZWYkZ2V0SGVpZ2h0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIDEwMDA7XG4gICAgfSA6IF9yZWYkZ2V0SGVpZ2h0LFxuICAgICAgICBfcmVmJGdldENvbG9yID0gX3JlZi5nZXRDb2xvcixcbiAgICAgICAgZ2V0Q29sb3IgPSBfcmVmJGdldENvbG9yID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIFswLCAwLCAwLCAyNTVdO1xuICAgIH0gOiBfcmVmJGdldENvbG9yLFxuICAgICAgICBfcmVmJHdpcmVmcmFtZSA9IF9yZWYud2lyZWZyYW1lLFxuICAgICAgICB3aXJlZnJhbWUgPSBfcmVmJHdpcmVmcmFtZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHdpcmVmcmFtZSxcbiAgICAgICAgX3JlZiRmcCA9IF9yZWYuZnA2NCxcbiAgICAgICAgZnA2NCA9IF9yZWYkZnAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRmcDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkKTtcblxuICAgIHRoaXMuZnA2NCA9IGZwNjQ7XG5cbiAgICAvLyBFeHBlbnNpdmUgb3BlcmF0aW9uLCBjb252ZXJ0IGFsbCBwb2x5Z29ucyB0byBhcnJheXNcbiAgICBwb2x5Z29ucyA9IENvbnRhaW5lci5tYXAocG9seWdvbnMsIGZ1bmN0aW9uIChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gZ2V0SGVpZ2h0KHBvbHlnb25JbmRleCkgfHwgMDtcbiAgICAgIHJldHVybiBDb250YWluZXIubWFwKFBvbHlnb24ubm9ybWFsaXplKGNvbXBsZXhQb2x5Z29uKSwgZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICAgICAgcmV0dXJuIENvbnRhaW5lci5tYXAocG9seWdvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgcmV0dXJuIFtjb29yZFswXSwgY29vcmRbMV0sIGhlaWdodF07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZ3JvdXBlZFZlcnRpY2VzID0gcG9seWdvbnM7XG4gICAgdGhpcy5ncm91cGVkVmVydGljZXMgPSBwb2x5Z29ucztcbiAgICB0aGlzLndpcmVmcmFtZSA9IHdpcmVmcmFtZTtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgdmFyIHBvc2l0aW9uc0pTID0gY2FsY3VsYXRlUG9zaXRpb25zSlMoeyBncm91cGVkVmVydGljZXM6IGdyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lOiB3aXJlZnJhbWUgfSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsIHtcbiAgICAgIHBvc2l0aW9uczogY2FsY3VsYXRlUG9zaXRpb25zKHBvc2l0aW9uc0pTLCB0aGlzLmZwNjQpLFxuICAgICAgaW5kaWNlczogY2FsY3VsYXRlSW5kaWNlcyh7IGdyb3VwZWRWZXJ0aWNlczogZ3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWU6IHdpcmVmcmFtZSB9KSxcbiAgICAgIG5vcm1hbHM6IGNhbGN1bGF0ZU5vcm1hbHMoeyBncm91cGVkVmVydGljZXM6IGdyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lOiB3aXJlZnJhbWUgfSksXG4gICAgICAvLyBjb2xvcnM6IGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUsIGdldENvbG9yfSksXG4gICAgICBwaWNraW5nQ29sb3JzOiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHsgZ3JvdXBlZFZlcnRpY2VzOiBncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZTogd2lyZWZyYW1lIH0pXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9seWdvblRlc3NlbGF0b3JFeHRydWRlZCwgW3tcbiAgICBrZXk6ICdpbmRpY2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kaWNlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuaW5kaWNlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwb3NpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdub3JtYWxzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFscygpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMubm9ybWFscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb2xvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb2xvcnMoKSB7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIF9yZWYyJGdldENvbG9yID0gX3JlZjIuZ2V0Q29sb3IsXG4gICAgICAgICAgZ2V0Q29sb3IgPSBfcmVmMiRnZXRDb2xvciA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfQ09MT1I7XG4gICAgICB9IDogX3JlZjIkZ2V0Q29sb3I7XG5cbiAgICAgIHZhciBncm91cGVkVmVydGljZXMgPSB0aGlzLmdyb3VwZWRWZXJ0aWNlcyxcbiAgICAgICAgICB3aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcblxuICAgICAgcmV0dXJuIGNhbGN1bGF0ZUNvbG9ycyh7IGdyb3VwZWRWZXJ0aWNlczogZ3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWU6IHdpcmVmcmFtZSwgZ2V0Q29sb3I6IGdldENvbG9yIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BpY2tpbmdDb2xvcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaWNraW5nQ29sb3JzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5waWNraW5nQ29sb3JzO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgLy8gICBwb3NpdGlvbnM6IFsnZ2V0SGVpZ2h0J10sXG4gICAgLy8gICBjb2xvcnM6IFsnZ2V0Q29sb3JzJ11cbiAgICAvLyAgIHBpY2tpbmdDb2xvcnM6ICdub25lJ1xuICAgIC8vIH1cblxuICB9XSk7XG5cbiAgcmV0dXJuIFBvbHlnb25UZXNzZWxhdG9yRXh0cnVkZWQ7XG59KCk7XG5cbmZ1bmN0aW9uIGNvdW50VmVydGljZXModmVydGljZXMpIHtcbiAgcmV0dXJuIHZlcnRpY2VzLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIHBvbHlnb24pIHtcbiAgICByZXR1cm4gY291bnQgKyBwb2x5Z29uLmxlbmd0aDtcbiAgfSwgMCk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUluZGljZXMoX3JlZjMpIHtcbiAgdmFyIGdyb3VwZWRWZXJ0aWNlcyA9IF9yZWYzLmdyb3VwZWRWZXJ0aWNlcyxcbiAgICAgIF9yZWYzJHdpcmVmcmFtZSA9IF9yZWYzLndpcmVmcmFtZSxcbiAgICAgIHdpcmVmcmFtZSA9IF9yZWYzJHdpcmVmcmFtZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmMyR3aXJlZnJhbWU7XG5cbiAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgYnVpbGRpbmdzXG4gIHZhciBtdWx0aXBsaWVyID0gd2lyZWZyYW1lID8gMiA6IDU7XG4gIHZhciBvZmZzZXRzID0gZ3JvdXBlZFZlcnRpY2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2ZXJ0aWNlcykge1xuICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFjYyksIFthY2NbYWNjLmxlbmd0aCAtIDFdICsgY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykgKiBtdWx0aXBsaWVyXSk7XG4gIH0sIFswXSk7XG5cbiAgdmFyIGluZGljZXMgPSBncm91cGVkVmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0aWNlcywgYnVpbGRpbmdJbmRleCkge1xuICAgIHJldHVybiB3aXJlZnJhbWUgP1xuICAgIC8vIDEuIGdldCBzZXF1ZW50aWFsbHkgb3JkZXJlZCBpbmRpY2VzIG9mIGVhY2ggYnVpbGRpbmcgd2lyZWZyYW1lXG4gICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIGJ1aWxkaW5nc1xuICAgIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXRzW2J1aWxkaW5nSW5kZXhdKSA6XG4gICAgLy8gMS4gZ2V0IHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGZvciB0aGUgaW50ZXJuYWwgYXJlYXNcbiAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgYnVpbGRpbmdzXG4gICAgY2FsY3VsYXRlU3VyZmFjZUluZGljZXModmVydGljZXMsIG9mZnNldHNbYnVpbGRpbmdJbmRleF0pO1xuICB9KTtcblxuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGZsYXR0ZW5EZWVwKGluZGljZXMpKTtcbn1cblxuLy8gQ2FsY3VsYXRlIGEgZmxhdCBwb3NpdGlvbiBhcnJheSBpbiBKUyAtIGNhbiBiZSBtYXBwZWQgdG8gMzIgb3IgNjQgYml0IHR5cGVkIGFycmF5c1xuLy8gUmVtYXJrczpcbi8vICogZWFjaCB0b3AgdmVydGV4IGlzIG9uIDMgc3VyZmFjZXNcbi8vICogZWFjaCBib3R0b20gdmVydGV4IGlzIG9uIDIgc3VyZmFjZXNcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uc0pTKF9yZWY0KSB7XG4gIHZhciBncm91cGVkVmVydGljZXMgPSBfcmVmNC5ncm91cGVkVmVydGljZXMsXG4gICAgICBfcmVmNCR3aXJlZnJhbWUgPSBfcmVmNC53aXJlZnJhbWUsXG4gICAgICB3aXJlZnJhbWUgPSBfcmVmNCR3aXJlZnJhbWUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjQkd2lyZWZyYW1lO1xuXG4gIHZhciBwb3NpdGlvbnMgPSBDb250YWluZXIubWFwKGdyb3VwZWRWZXJ0aWNlcywgZnVuY3Rpb24gKGNvbXBsZXhQb2x5Z29uKSB7XG4gICAgcmV0dXJuIENvbnRhaW5lci5tYXAoY29tcGxleFBvbHlnb24sIGZ1bmN0aW9uICh2ZXJ0aWNlcykge1xuICAgICAgdmFyIHRvcFZlcnRpY2VzID0gW10uY29uY2F0KHZlcnRpY2VzKTtcbiAgICAgIHZhciBiYXNlVmVydGljZXMgPSB0b3BWZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIFt2WzBdLCB2WzFdLCAwXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHdpcmVmcmFtZSA/IFt0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXSA6IFt0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIHRvcFZlcnRpY2VzLCBiYXNlVmVydGljZXMsIGJhc2VWZXJ0aWNlc107XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmxhdHRlbkRlZXAocG9zaXRpb25zKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zKHBvc2l0aW9uc0pTLCBmcDY0KSB7XG4gIHZhciBwb3NpdGlvbkxvdyA9IHZvaWQgMDtcbiAgaWYgKGZwNjQpIHtcbiAgICAvLyBXZSBvbmx5IG5lZWQgeCwgeSBjb21wb25lbnRcbiAgICBwb3NpdGlvbkxvdyA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zSlMgLyAzICogMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnNKUy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgIHBvc2l0aW9uTG93W2kgKiAyICsgMF0gPSBmcDY0aWZ5KHBvc2l0aW9uc0pTW2kgKiAzICsgMF0pWzFdO1xuICAgICAgcG9zaXRpb25Mb3dbaSAqIDIgKyAxXSA9IGZwNjRpZnkocG9zaXRpb25zSlNbaSAqIDMgKyAxXSlbMV07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnNKUyksIHBvc2l0aW9uczY0eHlMb3c6IHBvc2l0aW9uTG93IH07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vcm1hbHMoX3JlZjUpIHtcbiAgdmFyIGdyb3VwZWRWZXJ0aWNlcyA9IF9yZWY1Lmdyb3VwZWRWZXJ0aWNlcyxcbiAgICAgIHdpcmVmcmFtZSA9IF9yZWY1LndpcmVmcmFtZTtcblxuICB2YXIgdXAgPSBbMCwgMSwgMF07XG5cbiAgdmFyIG5vcm1hbHMgPSBncm91cGVkVmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0aWNlcywgYnVpbGRpbmdJbmRleCkge1xuICAgIHZhciB0b3BOb3JtYWxzID0gbmV3IEFycmF5KGNvdW50VmVydGljZXModmVydGljZXMpKS5maWxsKHVwKTtcbiAgICB2YXIgc2lkZU5vcm1hbHMgPSB2ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICAgIHJldHVybiBjYWxjdWxhdGVTaWRlTm9ybWFscyhwb2x5Z29uKTtcbiAgICB9KTtcbiAgICB2YXIgc2lkZU5vcm1hbHNGb3J3YXJkID0gc2lkZU5vcm1hbHMubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gblswXTtcbiAgICB9KTtcbiAgICB2YXIgc2lkZU5vcm1hbHNCYWNrd2FyZCA9IHNpZGVOb3JtYWxzLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG5bMV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gd2lyZWZyYW1lID8gW3RvcE5vcm1hbHMsIHRvcE5vcm1hbHNdIDogW3RvcE5vcm1hbHMsIHNpZGVOb3JtYWxzRm9yd2FyZCwgc2lkZU5vcm1hbHNCYWNrd2FyZCwgc2lkZU5vcm1hbHNGb3J3YXJkLCBzaWRlTm9ybWFsc0JhY2t3YXJkXTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZmxhdHRlbkRlZXAobm9ybWFscykpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTaWRlTm9ybWFscyh2ZXJ0aWNlcykge1xuICB2YXIgbnVtVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gIHZhciBub3JtYWxzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgIHZhciBuID0gZ2V0Tm9ybWFsKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tpICsgMV0pO1xuICAgIG5vcm1hbHMucHVzaChuKTtcbiAgfVxuXG4gIHJldHVybiBbW10uY29uY2F0KG5vcm1hbHMsIFtub3JtYWxzWzBdXSksIFtub3JtYWxzWzBdXS5jb25jYXQobm9ybWFscyldO1xufVxuXG4vKlxuZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3JzKHtwb2x5Z29ucywgcG9pbnRDb3VudCwgZ2V0Q29sb3J9KSB7XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBVaW50OEFycmF5KHBvaW50Q291bnQgKiA0KTtcbiAgbGV0IGkgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgLy8gQ2FsY3VsYXRlIHBvbHlnb24gY29sb3JcbiAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgY29sb3JbM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTU7XG5cbiAgICBjb25zdCBjb3VudCA9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQoY29tcGxleFBvbHlnb24pO1xuICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBhdHRyaWJ1dGUsIHNvdXJjZTogY29sb3IsIHN0YXJ0OiBpLCBjb3VudH0pO1xuICAgIGkgKz0gY29sb3IubGVuZ3RoICogY291bnQ7XG4gIH0pO1xuICByZXR1cm4gYXR0cmlidXRlO1xufVxuKi9cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3JzKF9yZWY2KSB7XG4gIHZhciBncm91cGVkVmVydGljZXMgPSBfcmVmNi5ncm91cGVkVmVydGljZXMsXG4gICAgICBnZXRDb2xvciA9IF9yZWY2LmdldENvbG9yLFxuICAgICAgX3JlZjYkd2lyZWZyYW1lID0gX3JlZjYud2lyZWZyYW1lLFxuICAgICAgd2lyZWZyYW1lID0gX3JlZjYkd2lyZWZyYW1lID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWY2JHdpcmVmcmFtZTtcblxuICB2YXIgY29sb3JzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcChmdW5jdGlvbiAoY29tcGxleFBvbHlnb24sIHBvbHlnb25JbmRleCkge1xuICAgIHZhciBjb2xvciA9IGdldENvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgY29sb3JbM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTU7XG5cbiAgICAvLyBjb25zdCBiYXNlQ29sb3IgPSBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yWzBdIDogY29sb3I7XG4gICAgLy8gY29uc3QgdG9wQ29sb3IgPSBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yW2NvbG9yLmxlbmd0aCAtIDFdIDogY29sb3I7XG4gICAgdmFyIG51bVZlcnRpY2VzID0gY291bnRWZXJ0aWNlcyhjb21wbGV4UG9seWdvbik7XG4gICAgdmFyIHRvcENvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChjb2xvcik7XG4gICAgdmFyIGJhc2VDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIHJldHVybiB3aXJlZnJhbWUgPyBbdG9wQ29sb3JzLCBiYXNlQ29sb3JzXSA6IFt0b3BDb2xvcnMsIHRvcENvbG9ycywgdG9wQ29sb3JzLCBiYXNlQ29sb3JzLCBiYXNlQ29sb3JzXTtcbiAgfSk7XG4gIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkoZmxhdHRlbkRlZXAoY29sb3JzKSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoX3JlZjcpIHtcbiAgdmFyIGdyb3VwZWRWZXJ0aWNlcyA9IF9yZWY3Lmdyb3VwZWRWZXJ0aWNlcyxcbiAgICAgIF9yZWY3JGNvbG9yID0gX3JlZjcuY29sb3IsXG4gICAgICBjb2xvciA9IF9yZWY3JGNvbG9yID09PSB1bmRlZmluZWQgPyBbMCwgMCwgMF0gOiBfcmVmNyRjb2xvcixcbiAgICAgIF9yZWY3JHdpcmVmcmFtZSA9IF9yZWY3LndpcmVmcmFtZSxcbiAgICAgIHdpcmVmcmFtZSA9IF9yZWY3JHdpcmVmcmFtZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmNyR3aXJlZnJhbWU7XG5cbiAgdmFyIGNvbG9ycyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHZlcnRpY2VzLCBidWlsZGluZ0luZGV4KSB7XG4gICAgLy8gY29uc3QgYmFzZUNvbG9yID0gQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvclswXSA6IGNvbG9yO1xuICAgIC8vIGNvbnN0IHRvcENvbG9yID0gQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvcltjb2xvci5sZW5ndGggLSAxXSA6IGNvbG9yO1xuICAgIHZhciBudW1WZXJ0aWNlcyA9IGNvdW50VmVydGljZXModmVydGljZXMpO1xuICAgIHZhciB0b3BDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoWzAsIDAsIDBdKTtcbiAgICB2YXIgYmFzZUNvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChbMCwgMCwgMF0pO1xuICAgIHJldHVybiB3aXJlZnJhbWUgPyBbdG9wQ29sb3JzLCBiYXNlQ29sb3JzXSA6IFt0b3BDb2xvcnMsIHRvcENvbG9ycywgdG9wQ29sb3JzLCBiYXNlQ29sb3JzLCBiYXNlQ29sb3JzXTtcbiAgfSk7XG4gIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkoZmxhdHRlbkRlZXAoY29sb3JzKSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXQpIHtcbiAgdmFyIHN0cmlkZSA9IGNvdW50VmVydGljZXModmVydGljZXMpO1xuXG4gIHJldHVybiB2ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICB2YXIgaW5kaWNlcyA9IFtvZmZzZXRdO1xuICAgIHZhciBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuXG4gICAgLy8gYnVpbGRpbmcgdG9wXG4gICAgLy8gdXNlIHZlcnRleCBwYWlycyBmb3IgR0wuTElORVMgPT4gWzAsIDEsIDEsIDIsIDIsIC4uLiwgbi0xLCBuLTEsIDBdXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2gob2Zmc2V0KTtcblxuICAgIC8vIGJ1aWxkaW5nIHNpZGVzXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bVZlcnRpY2VzIC0gMTsgX2krKykge1xuICAgICAgaW5kaWNlcy5wdXNoKF9pICsgb2Zmc2V0LCBfaSArIHN0cmlkZSArIG9mZnNldCk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU3VyZmFjZUluZGljZXModmVydGljZXMsIG9mZnNldCkge1xuICB2YXIgc3RyaWRlID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG4gIHZhciBxdWFkID0gW1swLCAxXSwgWzAsIDNdLCBbMSwgMl0sIFsxLCAyXSwgWzAsIDNdLCBbMSwgNF1dO1xuXG4gIGZ1bmN0aW9uIGRyYXdSZWN0YW5nbGUoaSkge1xuICAgIHJldHVybiBxdWFkLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIGkgKyB2WzBdICsgc3RyaWRlICogdlsxXSArIG9mZnNldDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBob2xlcyA9IG51bGw7XG5cbiAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICBob2xlcyA9IHZlcnRpY2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwb2x5Z29uKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhY2MpLCBbYWNjW2FjYy5sZW5ndGggLSAxXSArIHBvbHlnb24ubGVuZ3RoXSk7XG4gICAgfSwgWzBdKS5zbGljZSgxLCB2ZXJ0aWNlcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvcEluZGljZXMgPSBlYXJjdXQoZmxhdHRlbkRlZXAodmVydGljZXMpLCBob2xlcywgMykubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCArIG9mZnNldDtcbiAgfSk7XG5cbiAgdmFyIHNpZGVJbmRpY2VzID0gdmVydGljZXMubWFwKGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgdmFyIG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG4gICAgLy8gYnVpbGRpbmcgdG9wXG4gICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgIC8vIGJ1aWxkaW5nIHNpZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoLmFwcGx5KGluZGljZXMsIF90b0NvbnN1bWFibGVBcnJheShkcmF3UmVjdGFuZ2xlKGkpKSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9KTtcblxuICByZXR1cm4gW3RvcEluZGljZXMsIHNpZGVJbmRpY2VzXTtcbn1cblxuLy8gaGVscGVyc1xuXG4vLyBnZXQgbm9ybWFsIHZlY3RvciBvZiBsaW5lIHNlZ21lbnRcbmZ1bmN0aW9uIGdldE5vcm1hbChwMSwgcDIpIHtcbiAgaWYgKHAxWzBdID09PSBwMlswXSAmJiBwMVsxXSA9PT0gcDJbMV0pIHtcbiAgICByZXR1cm4gWzEsIDAsIDBdO1xuICB9XG5cbiAgdmFyIGRlZ3JlZXMycmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG4gIHZhciBsb24xID0gZGVncmVlczJyYWRpYW5zICogcDFbMF07XG4gIHZhciBsb24yID0gZGVncmVlczJyYWRpYW5zICogcDJbMF07XG4gIHZhciBsYXQxID0gZGVncmVlczJyYWRpYW5zICogcDFbMV07XG4gIHZhciBsYXQyID0gZGVncmVlczJyYWRpYW5zICogcDJbMV07XG4gIHZhciBhID0gTWF0aC5zaW4obG9uMiAtIGxvbjEpICogTWF0aC5jb3MobGF0Mik7XG4gIHZhciBiID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsYXQyKSAtIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcyhsb24yIC0gbG9uMSk7XG4gIHJldHVybiB2ZWMzLm5vcm1hbGl6ZShbXSwgW2IsIDAsIC1hXSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGF5ZXJzL2NvcmUvcG9seWdvbi1sYXllci9wb2x5Z29uLXRlc3NlbGF0b3ItZXh0cnVkZWQuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 55 */
/* exports provided: PolygonTesselator, flattenVertices2 */
/* exports used: PolygonTesselator */
/*!*************************************************************!*\
  !*** ./src/layers/core/polygon-layer/polygon-tesselator.js ***!
  \*************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygon__ = __webpack_require__(/*! ./polygon */ 26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut__ = __webpack_require__(/*! earcut */ 10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_earcut__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__ = __webpack_require__(/*! ../../../lib/utils/fp64 */ 5);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return PolygonTesselator; });\n/* unused harmony export flattenVertices2 */\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\n\n\n\n\n\n// Maybe deck.gl or luma.gl needs to export this\nfunction getPickingColor(index) {\n  return [(index + 1) % 256, Math.floor((index + 1) / 256) % 256, Math.floor((index + 1) / 256 / 256) % 256];\n}\n\nvar DEFAULT_COLOR = [0, 0, 0, 255]; // Black\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nvar PolygonTesselator = function () {\n  function PolygonTesselator(_ref) {\n    var polygons = _ref.polygons,\n        _ref$fp = _ref.fp64,\n        fp64 = _ref$fp === undefined ? false : _ref$fp;\n\n    _classCallCheck(this, PolygonTesselator);\n\n    // Normalize all polygons\n    this.polygons = __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"c\" /* Container */].map(polygons, function (polygon) {\n      return __WEBPACK_IMPORTED_MODULE_0__polygon__[\"a\" /* normalize */](polygon);\n    });\n    // Count all polygon vertices\n    this.pointCount = getPointCount(this.polygons);\n    this.fp64 = fp64;\n  }\n\n  _createClass(PolygonTesselator, [{\n    key: 'indices',\n    value: function indices() {\n      var polygons = this.polygons,\n          indexCount = this.indexCount;\n\n      return calculateIndices({ polygons: polygons, indexCount: indexCount });\n    }\n  }, {\n    key: 'positions',\n    value: function positions() {\n      var polygons = this.polygons,\n          pointCount = this.pointCount;\n\n      return calculatePositions({ polygons: polygons, pointCount: pointCount, fp64: this.fp64 });\n    }\n  }, {\n    key: 'normals',\n    value: function normals() {\n      var polygons = this.polygons,\n          pointCount = this.pointCount;\n\n      return calculateNormals({ polygons: polygons, pointCount: pointCount });\n    }\n  }, {\n    key: 'colors',\n    value: function colors() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$getColor = _ref2.getColor,\n          getColor = _ref2$getColor === undefined ? function (x) {\n        return DEFAULT_COLOR;\n      } : _ref2$getColor;\n\n      var polygons = this.polygons,\n          pointCount = this.pointCount;\n\n      return calculateColors({ polygons: polygons, pointCount: pointCount, getColor: getColor });\n    }\n  }, {\n    key: 'pickingColors',\n    value: function pickingColors() {\n      var polygons = this.polygons,\n          pointCount = this.pointCount;\n\n      return calculatePickingColors({ polygons: polygons, pointCount: pointCount });\n    }\n\n    // getAttribute({size, accessor}) {\n    //   const {polygons, pointCount} = this;\n    //   return calculateAttribute({polygons, pointCount, size, accessor});\n    // }\n\n  }]);\n\n  return PolygonTesselator;\n}();\n\n// Count number of points in a list of complex polygons\nfunction getPointCount(polygons) {\n  return polygons.reduce(function (sum, polygon) {\n    return sum + __WEBPACK_IMPORTED_MODULE_0__polygon__[\"b\" /* getVertexCount */](polygon);\n  }, 0);\n}\n\n// COunt number of triangles in a list of complex polygons\nfunction getTriangleCount(polygons) {\n  return polygons.reduce(function (count, polygon) {\n    return count + __WEBPACK_IMPORTED_MODULE_0__polygon__[\"c\" /* getTriangleCount */](polygon);\n  }, 0);\n}\n\n// Returns the offsets of each complex polygon in the combined array of all polygons\nfunction getPolygonOffsets(polygons) {\n  var offsets = new Array(polygons.length + 1);\n  offsets[0] = 0;\n  var offset = 0;\n  polygons.forEach(function (polygon, i) {\n    offset += __WEBPACK_IMPORTED_MODULE_0__polygon__[\"b\" /* getVertexCount */](polygon);\n    offsets[i + 1] = offset;\n  });\n  return offsets;\n}\n\n// Returns the offset of each hole polygon in the flattened array for that polygon\nfunction getHoleIndices(complexPolygon) {\n  var holeIndices = null;\n  if (complexPolygon.length > 1) {\n    (function () {\n      var polygonStartIndex = 0;\n      holeIndices = [];\n      __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"c\" /* Container */].forEach(complexPolygon, function (polygon) {\n        polygonStartIndex += polygon.length;\n        holeIndices.push(polygonStartIndex);\n      });\n      // Last element points to end of the flat array, remove it\n      holeIndices.pop();\n    })();\n  }\n  return holeIndices;\n}\n\nfunction calculateIndices(_ref3) {\n  var polygons = _ref3.polygons,\n      _ref3$IndexType = _ref3.IndexType,\n      IndexType = _ref3$IndexType === undefined ? Uint32Array : _ref3$IndexType;\n\n  // Calculate length of index array (3 * number of triangles)\n  var indexCount = 3 * getTriangleCount(polygons);\n  var offsets = getPolygonOffsets(polygons);\n\n  // Allocate the attribute\n  // TODO it's not the index count but the vertex count that must be checked\n  if (IndexType === Uint16Array && indexCount > 65535) {\n    throw new Error('Vertex count exceeds browser\\'s limit');\n  }\n  var attribute = new IndexType(indexCount);\n\n  // 1. get triangulated indices for the internal areas\n  // 2. offset them by the number of indices in previous polygons\n  var i = 0;\n  polygons.forEach(function (polygon, polygonIndex) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = calculateSurfaceIndices(polygon)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var index = _step.value;\n\n        attribute[i++] = index + offsets[polygonIndex];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n\n  return attribute;\n}\n\n/*\n * Get vertex indices for drawing complexPolygon mesh\n * @private\n * @param {[Number,Number,Number][][]} complexPolygon\n * @returns {[Number]} indices\n */\nfunction calculateSurfaceIndices(complexPolygon) {\n  // Prepare an array of hole indices as expected by earcut\n  var holeIndices = getHoleIndices(complexPolygon);\n  // Flatten the polygon as expected by earcut\n  var verts = flattenVertices2(complexPolygon);\n  // Let earcut triangulate the polygon\n  return __WEBPACK_IMPORTED_MODULE_1_earcut___default()(verts, holeIndices, 3);\n}\n\n// Flattens nested array of vertices, padding third coordinate as needed\nfunction flattenVertices2(nestedArray) {\n  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref4$result = _ref4.result,\n      result = _ref4$result === undefined ? [] : _ref4$result,\n      _ref4$dimensions = _ref4.dimensions,\n      dimensions = _ref4$dimensions === undefined ? 3 : _ref4$dimensions;\n\n  var index = -1;\n  var vertexLength = 0;\n  var length = __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"c\" /* Container */].count(nestedArray);\n  while (++index < length) {\n    var value = __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"c\" /* Container */].get(nestedArray, index);\n    if (__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"c\" /* Container */].isContainer(value)) {\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"i\" /* flattenVertices */])(value, { result: result, dimensions: dimensions });\n    } else {\n      if (vertexLength < dimensions) {\n        // eslint-disable-line\n        result.push(value);\n        vertexLength++;\n      }\n    }\n  }\n  // Add a third coordinate if needed\n  if (vertexLength > 0 && vertexLength < dimensions) {\n    result.push(0);\n  }\n  return result;\n}\n\nfunction calculatePositions(_ref5) {\n  var polygons = _ref5.polygons,\n      pointCount = _ref5.pointCount,\n      fp64 = _ref5.fp64;\n\n  // Flatten out all the vertices of all the sub subPolygons\n  var attribute = new Float32Array(pointCount * 3);\n  var attributeLow = void 0;\n  if (fp64) {\n    // We only need x, y component\n    attributeLow = new Float32Array(pointCount * 2);\n  }\n  var i = 0;\n  var j = 0;\n  __WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"c\" /* Container */].forEach(polygons, function (polygon) {\n    return __WEBPACK_IMPORTED_MODULE_0__polygon__[\"d\" /* forEachVertex */](polygon, function (vertex) {\n      attribute[i++] = vertex[0];\n      attribute[i++] = vertex[1];\n      attribute[i++] = vertex[2] || 0;\n      if (fp64) {\n        attributeLow[j++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(vertex[0])[1];\n        attributeLow[j++] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__lib_utils_fp64__[\"a\" /* fp64ify */])(vertex[1])[1];\n      }\n    });\n  });\n  // for (const complexPolygon of polygons) {\n  //   for (const simplePolygon of complexPolygon) {\n  //     for (const vertex of simplePolygon) {\n  //       attribute[i++] = vertex[0];\n  //       attribute[i++] = vertex[1];\n  //       attribute[i++] = vertex[2] || 0;\n  //     }\n  //   }\n  // }\n  return { positions: attribute, positions64xyLow: attributeLow };\n}\n\nfunction calculateNormals(_ref6) {\n  var polygons = _ref6.polygons,\n      pointCount = _ref6.pointCount;\n\n  // TODO - use generic vertex attribute?\n  var attribute = new Float32Array(pointCount * 3);\n  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"j\" /* fillArray */])({ target: attribute, source: [0, 1, 0], start: 0, pointCount: pointCount });\n  return attribute;\n}\n\nfunction calculateColors(_ref7) {\n  var polygons = _ref7.polygons,\n      pointCount = _ref7.pointCount,\n      getColor = _ref7.getColor;\n\n  var attribute = new Uint8Array(pointCount * 4);\n  var i = 0;\n  polygons.forEach(function (complexPolygon, polygonIndex) {\n    // Calculate polygon color\n    var color = getColor(polygonIndex);\n    color[3] = Number.isFinite(color[3]) ? color[3] : 255;\n\n    var count = __WEBPACK_IMPORTED_MODULE_0__polygon__[\"b\" /* getVertexCount */](complexPolygon);\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"j\" /* fillArray */])({ target: attribute, source: color, start: i, count: count });\n    i += color.length * count;\n  });\n  return attribute;\n}\n\nfunction calculatePickingColors(_ref8) {\n  var polygons = _ref8.polygons,\n      pointCount = _ref8.pointCount;\n\n  var attribute = new Uint8Array(pointCount * 3);\n  var i = 0;\n  polygons.forEach(function (complexPolygon, polygonIndex) {\n    var color = getPickingColor(polygonIndex);\n    var count = __WEBPACK_IMPORTED_MODULE_0__polygon__[\"b\" /* getVertexCount */](complexPolygon);\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__lib_utils__[\"j\" /* fillArray */])({ target: attribute, source: color, start: i, count: count });\n    i += color.length * count;\n  });\n  return attribute;\n}\n\n// TODO - extremely slow for some reason - to big for JS compiler?\n// return calculateAttribute({\n//   polygons,\n//   attribute,\n//   size: 4,\n//   accessor: getColor,\n//   defaultValue: [0, 0, 0, 255]\n// });\n\n/* eslint-disable complexity\nfunction calculateAttribute4({\n  polygons, attribute, size, accessor, defaultValue = [0, 0, 0, 0]\n}) {\n  let i = 0;\n  polygons.forEach((complexPolygon, polygonIndex) => {\n    const value = accessor(polygonIndex) || defaultValue;\n    value[3] = (Number.isFinite(value[3]) ? value[3] : defaultValue[3]);\n\n    // Copy polygon's value into the flattened vertices of the simple polygons\n    // TODO - use version of flatten that can take an offset and a target array?\n    for (const simplePolygon of complexPolygon) {\n      for (const vertex of simplePolygon) { // eslint-disable-line\n        attribute[i++] = value[0];\n        attribute[i++] = value[1];\n        attribute[i++] = value[2];\n        attribute[i++] = value[3];\n      }\n    }\n  });\n  return attribute;\n}\n*///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2NvcmUvcG9seWdvbi1sYXllci9wb2x5Z29uLXRlc3NlbGF0b3IuanM/MzdlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBIYW5kbGVzIHRlc3NlbGF0aW9uIG9mIHBvbHlnb25zIHdpdGggaG9sZXNcbi8vIC0gMkQgc3VyZmFjZXNcbi8vIC0gMkQgb3V0bGluZXNcbi8vIC0gM0Qgc3VyZmFjZXMgKHRvcCBhbmQgc2lkZXMgb25seSlcbi8vIC0gM0Qgd2lyZWZyYW1lcyAobm90IHlldClcbmltcG9ydCAqIGFzIFBvbHlnb24gZnJvbSAnLi9wb2x5Z29uJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcbmltcG9ydCB7IENvbnRhaW5lciwgZmxhdHRlblZlcnRpY2VzLCBmaWxsQXJyYXkgfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHsgZnA2NGlmeSB9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscy9mcDY0JztcblxuLy8gTWF5YmUgZGVjay5nbCBvciBsdW1hLmdsIG5lZWRzIHRvIGV4cG9ydCB0aGlzXG5mdW5jdGlvbiBnZXRQaWNraW5nQ29sb3IoaW5kZXgpIHtcbiAgcmV0dXJuIFsoaW5kZXggKyAxKSAlIDI1NiwgTWF0aC5mbG9vcigoaW5kZXggKyAxKSAvIDI1NikgJSAyNTYsIE1hdGguZmxvb3IoKGluZGV4ICsgMSkgLyAyNTYgLyAyNTYpICUgMjU2XTtcbn1cblxudmFyIERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTsgLy8gQmxhY2tcblxuLy8gVGhpcyBjbGFzcyBpcyBzZXQgdXAgdG8gYWxsb3cgcXVlcnlpbmcgb25lIGF0dHJpYnV0ZSBhdCBhIHRpbWVcbi8vIHRoZSB3YXkgdGhlIEF0dHJpYnV0ZU1hbmFnZXIgZXhwZWN0cyBpdFxuZXhwb3J0IHZhciBQb2x5Z29uVGVzc2VsYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9seWdvblRlc3NlbGF0b3IoX3JlZikge1xuICAgIHZhciBwb2x5Z29ucyA9IF9yZWYucG9seWdvbnMsXG4gICAgICAgIF9yZWYkZnAgPSBfcmVmLmZwNjQsXG4gICAgICAgIGZwNjQgPSBfcmVmJGZwID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkZnA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9seWdvblRlc3NlbGF0b3IpO1xuXG4gICAgLy8gTm9ybWFsaXplIGFsbCBwb2x5Z29uc1xuICAgIHRoaXMucG9seWdvbnMgPSBDb250YWluZXIubWFwKHBvbHlnb25zLCBmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgcmV0dXJuIFBvbHlnb24ubm9ybWFsaXplKHBvbHlnb24pO1xuICAgIH0pO1xuICAgIC8vIENvdW50IGFsbCBwb2x5Z29uIHZlcnRpY2VzXG4gICAgdGhpcy5wb2ludENvdW50ID0gZ2V0UG9pbnRDb3VudCh0aGlzLnBvbHlnb25zKTtcbiAgICB0aGlzLmZwNjQgPSBmcDY0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvbHlnb25UZXNzZWxhdG9yLCBbe1xuICAgIGtleTogJ2luZGljZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRpY2VzKCkge1xuICAgICAgdmFyIHBvbHlnb25zID0gdGhpcy5wb2x5Z29ucyxcbiAgICAgICAgICBpbmRleENvdW50ID0gdGhpcy5pbmRleENvdW50O1xuXG4gICAgICByZXR1cm4gY2FsY3VsYXRlSW5kaWNlcyh7IHBvbHlnb25zOiBwb2x5Z29ucywgaW5kZXhDb3VudDogaW5kZXhDb3VudCB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwb3NpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbnMoKSB7XG4gICAgICB2YXIgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zLFxuICAgICAgICAgIHBvaW50Q291bnQgPSB0aGlzLnBvaW50Q291bnQ7XG5cbiAgICAgIHJldHVybiBjYWxjdWxhdGVQb3NpdGlvbnMoeyBwb2x5Z29uczogcG9seWdvbnMsIHBvaW50Q291bnQ6IHBvaW50Q291bnQsIGZwNjQ6IHRoaXMuZnA2NCB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdub3JtYWxzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFscygpIHtcbiAgICAgIHZhciBwb2x5Z29ucyA9IHRoaXMucG9seWdvbnMsXG4gICAgICAgICAgcG9pbnRDb3VudCA9IHRoaXMucG9pbnRDb3VudDtcblxuICAgICAgcmV0dXJuIGNhbGN1bGF0ZU5vcm1hbHMoeyBwb2x5Z29uczogcG9seWdvbnMsIHBvaW50Q291bnQ6IHBvaW50Q291bnQgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29sb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3JzKCkge1xuICAgICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmMiRnZXRDb2xvciA9IF9yZWYyLmdldENvbG9yLFxuICAgICAgICAgIGdldENvbG9yID0gX3JlZjIkZ2V0Q29sb3IgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0NPTE9SO1xuICAgICAgfSA6IF9yZWYyJGdldENvbG9yO1xuXG4gICAgICB2YXIgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zLFxuICAgICAgICAgIHBvaW50Q291bnQgPSB0aGlzLnBvaW50Q291bnQ7XG5cbiAgICAgIHJldHVybiBjYWxjdWxhdGVDb2xvcnMoeyBwb2x5Z29uczogcG9seWdvbnMsIHBvaW50Q291bnQ6IHBvaW50Q291bnQsIGdldENvbG9yOiBnZXRDb2xvciB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwaWNraW5nQ29sb3JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGlja2luZ0NvbG9ycygpIHtcbiAgICAgIHZhciBwb2x5Z29ucyA9IHRoaXMucG9seWdvbnMsXG4gICAgICAgICAgcG9pbnRDb3VudCA9IHRoaXMucG9pbnRDb3VudDtcblxuICAgICAgcmV0dXJuIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoeyBwb2x5Z29uczogcG9seWdvbnMsIHBvaW50Q291bnQ6IHBvaW50Q291bnQgfSk7XG4gICAgfVxuXG4gICAgLy8gZ2V0QXR0cmlidXRlKHtzaXplLCBhY2Nlc3Nvcn0pIHtcbiAgICAvLyAgIGNvbnN0IHtwb2x5Z29ucywgcG9pbnRDb3VudH0gPSB0aGlzO1xuICAgIC8vICAgcmV0dXJuIGNhbGN1bGF0ZUF0dHJpYnV0ZSh7cG9seWdvbnMsIHBvaW50Q291bnQsIHNpemUsIGFjY2Vzc29yfSk7XG4gICAgLy8gfVxuXG4gIH1dKTtcblxuICByZXR1cm4gUG9seWdvblRlc3NlbGF0b3I7XG59KCk7XG5cbi8vIENvdW50IG51bWJlciBvZiBwb2ludHMgaW4gYSBsaXN0IG9mIGNvbXBsZXggcG9seWdvbnNcbmZ1bmN0aW9uIGdldFBvaW50Q291bnQocG9seWdvbnMpIHtcbiAgcmV0dXJuIHBvbHlnb25zLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBwb2x5Z29uKSB7XG4gICAgcmV0dXJuIHN1bSArIFBvbHlnb24uZ2V0VmVydGV4Q291bnQocG9seWdvbik7XG4gIH0sIDApO1xufVxuXG4vLyBDT3VudCBudW1iZXIgb2YgdHJpYW5nbGVzIGluIGEgbGlzdCBvZiBjb21wbGV4IHBvbHlnb25zXG5mdW5jdGlvbiBnZXRUcmlhbmdsZUNvdW50KHBvbHlnb25zKSB7XG4gIHJldHVybiBwb2x5Z29ucy5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBwb2x5Z29uKSB7XG4gICAgcmV0dXJuIGNvdW50ICsgUG9seWdvbi5nZXRUcmlhbmdsZUNvdW50KHBvbHlnb24pO1xuICB9LCAwKTtcbn1cblxuLy8gUmV0dXJucyB0aGUgb2Zmc2V0cyBvZiBlYWNoIGNvbXBsZXggcG9seWdvbiBpbiB0aGUgY29tYmluZWQgYXJyYXkgb2YgYWxsIHBvbHlnb25zXG5mdW5jdGlvbiBnZXRQb2x5Z29uT2Zmc2V0cyhwb2x5Z29ucykge1xuICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShwb2x5Z29ucy5sZW5ndGggKyAxKTtcbiAgb2Zmc2V0c1swXSA9IDA7XG4gIHZhciBvZmZzZXQgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uIChwb2x5Z29uLCBpKSB7XG4gICAgb2Zmc2V0ICs9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQocG9seWdvbik7XG4gICAgb2Zmc2V0c1tpICsgMV0gPSBvZmZzZXQ7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLy8gUmV0dXJucyB0aGUgb2Zmc2V0IG9mIGVhY2ggaG9sZSBwb2x5Z29uIGluIHRoZSBmbGF0dGVuZWQgYXJyYXkgZm9yIHRoYXQgcG9seWdvblxuZnVuY3Rpb24gZ2V0SG9sZUluZGljZXMoY29tcGxleFBvbHlnb24pIHtcbiAgdmFyIGhvbGVJbmRpY2VzID0gbnVsbDtcbiAgaWYgKGNvbXBsZXhQb2x5Z29uLmxlbmd0aCA+IDEpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvbHlnb25TdGFydEluZGV4ID0gMDtcbiAgICAgIGhvbGVJbmRpY2VzID0gW107XG4gICAgICBDb250YWluZXIuZm9yRWFjaChjb21wbGV4UG9seWdvbiwgZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICAgICAgcG9seWdvblN0YXJ0SW5kZXggKz0gcG9seWdvbi5sZW5ndGg7XG4gICAgICAgIGhvbGVJbmRpY2VzLnB1c2gocG9seWdvblN0YXJ0SW5kZXgpO1xuICAgICAgfSk7XG4gICAgICAvLyBMYXN0IGVsZW1lbnQgcG9pbnRzIHRvIGVuZCBvZiB0aGUgZmxhdCBhcnJheSwgcmVtb3ZlIGl0XG4gICAgICBob2xlSW5kaWNlcy5wb3AoKTtcbiAgICB9KSgpO1xuICB9XG4gIHJldHVybiBob2xlSW5kaWNlcztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSW5kaWNlcyhfcmVmMykge1xuICB2YXIgcG9seWdvbnMgPSBfcmVmMy5wb2x5Z29ucyxcbiAgICAgIF9yZWYzJEluZGV4VHlwZSA9IF9yZWYzLkluZGV4VHlwZSxcbiAgICAgIEluZGV4VHlwZSA9IF9yZWYzJEluZGV4VHlwZSA9PT0gdW5kZWZpbmVkID8gVWludDMyQXJyYXkgOiBfcmVmMyRJbmRleFR5cGU7XG5cbiAgLy8gQ2FsY3VsYXRlIGxlbmd0aCBvZiBpbmRleCBhcnJheSAoMyAqIG51bWJlciBvZiB0cmlhbmdsZXMpXG4gIHZhciBpbmRleENvdW50ID0gMyAqIGdldFRyaWFuZ2xlQ291bnQocG9seWdvbnMpO1xuICB2YXIgb2Zmc2V0cyA9IGdldFBvbHlnb25PZmZzZXRzKHBvbHlnb25zKTtcblxuICAvLyBBbGxvY2F0ZSB0aGUgYXR0cmlidXRlXG4gIC8vIFRPRE8gaXQncyBub3QgdGhlIGluZGV4IGNvdW50IGJ1dCB0aGUgdmVydGV4IGNvdW50IHRoYXQgbXVzdCBiZSBjaGVja2VkXG4gIGlmIChJbmRleFR5cGUgPT09IFVpbnQxNkFycmF5ICYmIGluZGV4Q291bnQgPiA2NTUzNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IGNvdW50IGV4Y2VlZHMgYnJvd3NlclxcJ3MgbGltaXQnKTtcbiAgfVxuICB2YXIgYXR0cmlidXRlID0gbmV3IEluZGV4VHlwZShpbmRleENvdW50KTtcblxuICAvLyAxLiBnZXQgdHJpYW5ndWxhdGVkIGluZGljZXMgZm9yIHRoZSBpbnRlcm5hbCBhcmVhc1xuICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgcG9seWdvbnNcbiAgdmFyIGkgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uIChwb2x5Z29uLCBwb2x5Z29uSW5kZXgpIHtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHBvbHlnb24pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICBhdHRyaWJ1dGVbaSsrXSA9IGluZGV4ICsgb2Zmc2V0c1twb2x5Z29uSW5kZXhdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZTtcbn1cblxuLypcbiAqIEdldCB2ZXJ0ZXggaW5kaWNlcyBmb3IgZHJhd2luZyBjb21wbGV4UG9seWdvbiBtZXNoXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXX0gY29tcGxleFBvbHlnb25cbiAqIEByZXR1cm5zIHtbTnVtYmVyXX0gaW5kaWNlc1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyhjb21wbGV4UG9seWdvbikge1xuICAvLyBQcmVwYXJlIGFuIGFycmF5IG9mIGhvbGUgaW5kaWNlcyBhcyBleHBlY3RlZCBieSBlYXJjdXRcbiAgdmFyIGhvbGVJbmRpY2VzID0gZ2V0SG9sZUluZGljZXMoY29tcGxleFBvbHlnb24pO1xuICAvLyBGbGF0dGVuIHRoZSBwb2x5Z29uIGFzIGV4cGVjdGVkIGJ5IGVhcmN1dFxuICB2YXIgdmVydHMgPSBmbGF0dGVuVmVydGljZXMyKGNvbXBsZXhQb2x5Z29uKTtcbiAgLy8gTGV0IGVhcmN1dCB0cmlhbmd1bGF0ZSB0aGUgcG9seWdvblxuICByZXR1cm4gZWFyY3V0KHZlcnRzLCBob2xlSW5kaWNlcywgMyk7XG59XG5cbi8vIEZsYXR0ZW5zIG5lc3RlZCBhcnJheSBvZiB2ZXJ0aWNlcywgcGFkZGluZyB0aGlyZCBjb29yZGluYXRlIGFzIG5lZWRlZFxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5WZXJ0aWNlczIobmVzdGVkQXJyYXkpIHtcbiAgdmFyIF9yZWY0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWY0JHJlc3VsdCA9IF9yZWY0LnJlc3VsdCxcbiAgICAgIHJlc3VsdCA9IF9yZWY0JHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gW10gOiBfcmVmNCRyZXN1bHQsXG4gICAgICBfcmVmNCRkaW1lbnNpb25zID0gX3JlZjQuZGltZW5zaW9ucyxcbiAgICAgIGRpbWVuc2lvbnMgPSBfcmVmNCRkaW1lbnNpb25zID09PSB1bmRlZmluZWQgPyAzIDogX3JlZjQkZGltZW5zaW9ucztcblxuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIHZlcnRleExlbmd0aCA9IDA7XG4gIHZhciBsZW5ndGggPSBDb250YWluZXIuY291bnQobmVzdGVkQXJyYXkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IENvbnRhaW5lci5nZXQobmVzdGVkQXJyYXksIGluZGV4KTtcbiAgICBpZiAoQ29udGFpbmVyLmlzQ29udGFpbmVyKHZhbHVlKSkge1xuICAgICAgZmxhdHRlblZlcnRpY2VzKHZhbHVlLCB7IHJlc3VsdDogcmVzdWx0LCBkaW1lbnNpb25zOiBkaW1lbnNpb25zIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmVydGV4TGVuZ3RoIDwgZGltZW5zaW9ucykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgdmVydGV4TGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFkZCBhIHRoaXJkIGNvb3JkaW5hdGUgaWYgbmVlZGVkXG4gIGlmICh2ZXJ0ZXhMZW5ndGggPiAwICYmIHZlcnRleExlbmd0aCA8IGRpbWVuc2lvbnMpIHtcbiAgICByZXN1bHQucHVzaCgwKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbnMoX3JlZjUpIHtcbiAgdmFyIHBvbHlnb25zID0gX3JlZjUucG9seWdvbnMsXG4gICAgICBwb2ludENvdW50ID0gX3JlZjUucG9pbnRDb3VudCxcbiAgICAgIGZwNjQgPSBfcmVmNS5mcDY0O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFsbCB0aGUgdmVydGljZXMgb2YgYWxsIHRoZSBzdWIgc3ViUG9seWdvbnNcbiAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRDb3VudCAqIDMpO1xuICB2YXIgYXR0cmlidXRlTG93ID0gdm9pZCAwO1xuICBpZiAoZnA2NCkge1xuICAgIC8vIFdlIG9ubHkgbmVlZCB4LCB5IGNvbXBvbmVudFxuICAgIGF0dHJpYnV0ZUxvdyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRDb3VudCAqIDIpO1xuICB9XG4gIHZhciBpID0gMDtcbiAgdmFyIGogPSAwO1xuICBDb250YWluZXIuZm9yRWFjaChwb2x5Z29ucywgZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICByZXR1cm4gUG9seWdvbi5mb3JFYWNoVmVydGV4KHBvbHlnb24sIGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgIGF0dHJpYnV0ZVtpKytdID0gdmVydGV4WzBdO1xuICAgICAgYXR0cmlidXRlW2krK10gPSB2ZXJ0ZXhbMV07XG4gICAgICBhdHRyaWJ1dGVbaSsrXSA9IHZlcnRleFsyXSB8fCAwO1xuICAgICAgaWYgKGZwNjQpIHtcbiAgICAgICAgYXR0cmlidXRlTG93W2orK10gPSBmcDY0aWZ5KHZlcnRleFswXSlbMV07XG4gICAgICAgIGF0dHJpYnV0ZUxvd1tqKytdID0gZnA2NGlmeSh2ZXJ0ZXhbMV0pWzFdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgLy8gZm9yIChjb25zdCBjb21wbGV4UG9seWdvbiBvZiBwb2x5Z29ucykge1xuICAvLyAgIGZvciAoY29uc3Qgc2ltcGxlUG9seWdvbiBvZiBjb21wbGV4UG9seWdvbikge1xuICAvLyAgICAgZm9yIChjb25zdCB2ZXJ0ZXggb2Ygc2ltcGxlUG9seWdvbikge1xuICAvLyAgICAgICBhdHRyaWJ1dGVbaSsrXSA9IHZlcnRleFswXTtcbiAgLy8gICAgICAgYXR0cmlidXRlW2krK10gPSB2ZXJ0ZXhbMV07XG4gIC8vICAgICAgIGF0dHJpYnV0ZVtpKytdID0gdmVydGV4WzJdIHx8IDA7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyB9XG4gIHJldHVybiB7IHBvc2l0aW9uczogYXR0cmlidXRlLCBwb3NpdGlvbnM2NHh5TG93OiBhdHRyaWJ1dGVMb3cgfTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTm9ybWFscyhfcmVmNikge1xuICB2YXIgcG9seWdvbnMgPSBfcmVmNi5wb2x5Z29ucyxcbiAgICAgIHBvaW50Q291bnQgPSBfcmVmNi5wb2ludENvdW50O1xuXG4gIC8vIFRPRE8gLSB1c2UgZ2VuZXJpYyB2ZXJ0ZXggYXR0cmlidXRlP1xuICB2YXIgYXR0cmlidXRlID0gbmV3IEZsb2F0MzJBcnJheShwb2ludENvdW50ICogMyk7XG4gIGZpbGxBcnJheSh7IHRhcmdldDogYXR0cmlidXRlLCBzb3VyY2U6IFswLCAxLCAwXSwgc3RhcnQ6IDAsIHBvaW50Q291bnQ6IHBvaW50Q291bnQgfSk7XG4gIHJldHVybiBhdHRyaWJ1dGU7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9ycyhfcmVmNykge1xuICB2YXIgcG9seWdvbnMgPSBfcmVmNy5wb2x5Z29ucyxcbiAgICAgIHBvaW50Q291bnQgPSBfcmVmNy5wb2ludENvdW50LFxuICAgICAgZ2V0Q29sb3IgPSBfcmVmNy5nZXRDb2xvcjtcblxuICB2YXIgYXR0cmlidXRlID0gbmV3IFVpbnQ4QXJyYXkocG9pbnRDb3VudCAqIDQpO1xuICB2YXIgaSA9IDA7XG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbXBsZXhQb2x5Z29uLCBwb2x5Z29uSW5kZXgpIHtcbiAgICAvLyBDYWxjdWxhdGUgcG9seWdvbiBjb2xvclxuICAgIHZhciBjb2xvciA9IGdldENvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgY29sb3JbM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTU7XG5cbiAgICB2YXIgY291bnQgPSBQb2x5Z29uLmdldFZlcnRleENvdW50KGNvbXBsZXhQb2x5Z29uKTtcbiAgICBmaWxsQXJyYXkoeyB0YXJnZXQ6IGF0dHJpYnV0ZSwgc291cmNlOiBjb2xvciwgc3RhcnQ6IGksIGNvdW50OiBjb3VudCB9KTtcbiAgICBpICs9IGNvbG9yLmxlbmd0aCAqIGNvdW50O1xuICB9KTtcbiAgcmV0dXJuIGF0dHJpYnV0ZTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGlja2luZ0NvbG9ycyhfcmVmOCkge1xuICB2YXIgcG9seWdvbnMgPSBfcmVmOC5wb2x5Z29ucyxcbiAgICAgIHBvaW50Q291bnQgPSBfcmVmOC5wb2ludENvdW50O1xuXG4gIHZhciBhdHRyaWJ1dGUgPSBuZXcgVWludDhBcnJheShwb2ludENvdW50ICogMyk7XG4gIHZhciBpID0gMDtcbiAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbiAoY29tcGxleFBvbHlnb24sIHBvbHlnb25JbmRleCkge1xuICAgIHZhciBjb2xvciA9IGdldFBpY2tpbmdDb2xvcihwb2x5Z29uSW5kZXgpO1xuICAgIHZhciBjb3VudCA9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQoY29tcGxleFBvbHlnb24pO1xuICAgIGZpbGxBcnJheSh7IHRhcmdldDogYXR0cmlidXRlLCBzb3VyY2U6IGNvbG9yLCBzdGFydDogaSwgY291bnQ6IGNvdW50IH0pO1xuICAgIGkgKz0gY29sb3IubGVuZ3RoICogY291bnQ7XG4gIH0pO1xuICByZXR1cm4gYXR0cmlidXRlO1xufVxuXG4vLyBUT0RPIC0gZXh0cmVtZWx5IHNsb3cgZm9yIHNvbWUgcmVhc29uIC0gdG8gYmlnIGZvciBKUyBjb21waWxlcj9cbi8vIHJldHVybiBjYWxjdWxhdGVBdHRyaWJ1dGUoe1xuLy8gICBwb2x5Z29ucyxcbi8vICAgYXR0cmlidXRlLFxuLy8gICBzaXplOiA0LFxuLy8gICBhY2Nlc3NvcjogZ2V0Q29sb3IsXG4vLyAgIGRlZmF1bHRWYWx1ZTogWzAsIDAsIDAsIDI1NV1cbi8vIH0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBjYWxjdWxhdGVBdHRyaWJ1dGU0KHtcbiAgcG9seWdvbnMsIGF0dHJpYnV0ZSwgc2l6ZSwgYWNjZXNzb3IsIGRlZmF1bHRWYWx1ZSA9IFswLCAwLCAwLCAwXVxufSkge1xuICBsZXQgaSA9IDA7XG4gIHBvbHlnb25zLmZvckVhY2goKGNvbXBsZXhQb2x5Z29uLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGFjY2Vzc29yKHBvbHlnb25JbmRleCkgfHwgZGVmYXVsdFZhbHVlO1xuICAgIHZhbHVlWzNdID0gKE51bWJlci5pc0Zpbml0ZSh2YWx1ZVszXSkgPyB2YWx1ZVszXSA6IGRlZmF1bHRWYWx1ZVszXSk7XG5cbiAgICAvLyBDb3B5IHBvbHlnb24ncyB2YWx1ZSBpbnRvIHRoZSBmbGF0dGVuZWQgdmVydGljZXMgb2YgdGhlIHNpbXBsZSBwb2x5Z29uc1xuICAgIC8vIFRPRE8gLSB1c2UgdmVyc2lvbiBvZiBmbGF0dGVuIHRoYXQgY2FuIHRha2UgYW4gb2Zmc2V0IGFuZCBhIHRhcmdldCBhcnJheT9cbiAgICBmb3IgKGNvbnN0IHNpbXBsZVBvbHlnb24gb2YgY29tcGxleFBvbHlnb24pIHtcbiAgICAgIGZvciAoY29uc3QgdmVydGV4IG9mIHNpbXBsZVBvbHlnb24pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBhdHRyaWJ1dGVbaSsrXSA9IHZhbHVlWzBdO1xuICAgICAgICBhdHRyaWJ1dGVbaSsrXSA9IHZhbHVlWzFdO1xuICAgICAgICBhdHRyaWJ1dGVbaSsrXSA9IHZhbHVlWzJdO1xuICAgICAgICBhdHRyaWJ1dGVbaSsrXSA9IHZhbHVlWzNdO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhdHRyaWJ1dGU7XG59XG4qL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9jb3JlL3BvbHlnb24tbGF5ZXIvcG9seWdvbi10ZXNzZWxhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 56 */
/* exports provided: getGeojsonFeatures, featureToPolygons, extractPolygons, normalizeGeojson */
/* exports used: extractPolygons */
/*!***********************************************************!*\
  !*** ./src/layers/deprecated/choropleth-layer/geojson.js ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_utils__ = __webpack_require__(/*! ../../../lib/utils */ 3);\n/* unused harmony export getGeojsonFeatures */\n/* unused harmony export featureToPolygons */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = extractPolygons;\n/* unused harmony export normalizeGeojson */\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nfunction getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  var type = __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].get(geojson, 'type');\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'Polygon':\n    case 'MultiPolygon':\n    case 'GeometryCollection':\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{ type: 'Feature', properties: {}, geometry: geojson }];\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      return __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].get(geojson, 'features');\n    default:\n      throw new Error('Unknown geojson type');\n  }\n}\n\n/*\n * converts a GeoJSON \"Feature\" object to a list of GeoJSON polygon-style coordinates\n * @param {Object | Array} data - geojson object or array of feature\n * @returns {[Number,Number,Number][][][]} array of choropleths\n */\nfunction featureToPolygons(feature) {\n  var geometry = __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].get(feature, 'geometry');\n  // If no geometry field, assume that \"feature\" is the polygon list\n  if (geometry === undefined) {\n    return feature;\n  }\n\n  var type = __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].get(geometry, 'type');\n  var coordinates = __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].get(geometry, 'coordinates');\n\n  var polygons = void 0;\n  switch (type) {\n    case 'MultiPolygon':\n      polygons = coordinates;\n      break;\n    case 'Polygon':\n      polygons = [coordinates];\n      break;\n    case 'LineString':\n      // TODO - should lines really be handled in this switch?\n      polygons = [[coordinates]];\n      break;\n    case 'MultiLineString':\n      // TODO - should lines really be handled in this switch?\n      polygons = __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].map(coordinates, function (coords) {\n        return [coords];\n      });\n      break;\n    default:\n      polygons = [];\n  }\n  return polygons;\n}\n\n// DEPRECATED - USED BY OLD CHOROPLETH LAYERS\n\n/*\n * converts list of features from a GeoJSON object to a list of GeoJSON\n * polygon-style coordinates\n * @param {Object} data - geojson object\n * @returns {[Number,Number,Number][][][]} array of choropleths\n */\nfunction extractPolygons(data) {\n  var normalizedGeojson = normalizeGeojson(data);\n  var features = __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].get(normalizedGeojson, 'features');\n\n  var result = [];\n  features.forEach(function (feature, featureIndex) {\n    var choropleths = featureToPolygons(feature);\n\n    /* eslint-disable max-nested-callbacks */\n    choropleths = __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].map(choropleths, function (choropleth) {\n      return __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].map(choropleth, function (polygon) {\n        return __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].map(polygon, function (coord) {\n          return [__WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].get(coord, 0), __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].get(coord, 1), __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].get(coord, 2) || 0];\n        });\n      });\n    });\n    /* eslint-enable max-nested-callbacks */\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = choropleths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var choropleth = _step.value;\n\n        choropleth.featureIndex = featureIndex;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    result.push.apply(result, _toConsumableArray(choropleths));\n  });\n  return result;\n}\n\n/**\n * \"Normalizes\" a GeoJSON geometry or \"Feature\" into a \"FeatureCollection\",\n * by wrapping it in an extra object/array.\n *\n * @param {object} geojson - geojson data\n * @return {object} - normalized geojson data\n */\nfunction normalizeGeojson(geojson) {\n  var type = __WEBPACK_IMPORTED_MODULE_0__lib_utils__[\"c\" /* Container */].get(geojson, 'type');\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'Polygon':\n    case 'MultiPolygon':\n    case 'GeometryCollection':\n      // Wrap the geometry object in a \"Feature\" and add the feature to a \"FeatureCollection\"\n      return {\n        type: 'FeatureCollection',\n        features: [{ type: 'Feature', properties: {}, geometry: geojson }]\n      };\n    case 'Feature':\n      // Add the feature to a \"FeatureCollection\"\n      return {\n        type: 'FeatureCollection',\n        features: [geojson]\n      };\n    case 'FeatureCollection':\n      // Just return the feature collection\n      return geojson;\n    default:\n      throw new Error('Unknown geojson type');\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci9nZW9qc29uLmpzPzhlZTQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5cbi8qKlxuICogXCJOb3JtYWxpemVzXCIgY29tcGxldGUgb3IgcGFydGlhbCBHZW9KU09OIGRhdGEgaW50byBpdGVyYWJsZSBsaXN0IG9mIGZlYXR1cmVzXG4gKiBDYW4gYWNjZXB0IEdlb0pTT04gZ2VvbWV0cnkgb3IgXCJGZWF0dXJlXCIsIFwiRmVhdHVyZUNvbGxlY3Rpb25cIiBpbiBhZGRpdGlvblxuICogdG8gcGxhaW4gYXJyYXlzIGFuZCBpdGVyYWJsZXMuXG4gKiBXb3JrcyBieSBleHRyYWN0aW5nIHRoZSBmZWF0dXJlIGFycmF5IG9yIHdyYXBwaW5nIHNpbmdsZSBvYmplY3RzIGluIGFuIGFycmF5LFxuICogc28gdGhhdCBzdWJzZXF1ZW50IGNvZGUgY2FuIHNpbXBseSBpdGVyYXRlIG92ZXIgZmVhdHVyZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdlb2pzb24gLSBnZW9qc29uIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXRhIC0gZ2VvanNvbiBvYmplY3QgKEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlIG9yXG4gKiAgR2VvbWV0cnkpIG9yIGFycmF5IG9mIGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtBcnJheXxcIml0ZXJhdGFibGVcIn0gLSBpdGVyYWJsZSBsaXN0IG9mIGZlYXR1cmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHZW9qc29uRmVhdHVyZXMoZ2VvanNvbikge1xuICAvLyBJZiBhcnJheSwgYXNzdW1lIHRoaXMgaXMgYSBsaXN0IG9mIGZlYXR1cmVzXG4gIGlmIChBcnJheS5pc0FycmF5KGdlb2pzb24pKSB7XG4gICAgcmV0dXJuIGdlb2pzb247XG4gIH1cblxuICB2YXIgdHlwZSA9IENvbnRhaW5lci5nZXQoZ2VvanNvbiwgJ3R5cGUnKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxuICAgICAgLy8gV3JhcCB0aGUgZ2VvbWV0cnkgb2JqZWN0IGluIGEgJ0ZlYXR1cmUnIG9iamVjdCBhbmQgd3JhcCBpbiBhbiBhcnJheVxuICAgICAgcmV0dXJuIFt7IHR5cGU6ICdGZWF0dXJlJywgcHJvcGVydGllczoge30sIGdlb21ldHJ5OiBnZW9qc29uIH1dO1xuICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgLy8gV3JhcCB0aGUgZmVhdHVyZSBpbiBhICdGZWF0dXJlcycgYXJyYXlcbiAgICAgIHJldHVybiBbZ2VvanNvbl07XG4gICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgLy8gSnVzdCByZXR1cm4gdGhlICdGZWF0dXJlcycgYXJyYXkgZnJvbSB0aGUgY29sbGVjdGlvblxuICAgICAgcmV0dXJuIENvbnRhaW5lci5nZXQoZ2VvanNvbiwgJ2ZlYXR1cmVzJyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBnZW9qc29uIHR5cGUnKTtcbiAgfVxufVxuXG4vKlxuICogY29udmVydHMgYSBHZW9KU09OIFwiRmVhdHVyZVwiIG9iamVjdCB0byBhIGxpc3Qgb2YgR2VvSlNPTiBwb2x5Z29uLXN0eWxlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBkYXRhIC0gZ2VvanNvbiBvYmplY3Qgb3IgYXJyYXkgb2YgZmVhdHVyZVxuICogQHJldHVybnMge1tOdW1iZXIsTnVtYmVyLE51bWJlcl1bXVtdW119IGFycmF5IG9mIGNob3JvcGxldGhzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmZWF0dXJlVG9Qb2x5Z29ucyhmZWF0dXJlKSB7XG4gIHZhciBnZW9tZXRyeSA9IENvbnRhaW5lci5nZXQoZmVhdHVyZSwgJ2dlb21ldHJ5Jyk7XG4gIC8vIElmIG5vIGdlb21ldHJ5IGZpZWxkLCBhc3N1bWUgdGhhdCBcImZlYXR1cmVcIiBpcyB0aGUgcG9seWdvbiBsaXN0XG4gIGlmIChnZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZlYXR1cmU7XG4gIH1cblxuICB2YXIgdHlwZSA9IENvbnRhaW5lci5nZXQoZ2VvbWV0cnksICd0eXBlJyk7XG4gIHZhciBjb29yZGluYXRlcyA9IENvbnRhaW5lci5nZXQoZ2VvbWV0cnksICdjb29yZGluYXRlcycpO1xuXG4gIHZhciBwb2x5Z29ucyA9IHZvaWQgMDtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgIHBvbHlnb25zID0gY29vcmRpbmF0ZXM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgIHBvbHlnb25zID0gW2Nvb3JkaW5hdGVzXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgLy8gVE9ETyAtIHNob3VsZCBsaW5lcyByZWFsbHkgYmUgaGFuZGxlZCBpbiB0aGlzIHN3aXRjaD9cbiAgICAgIHBvbHlnb25zID0gW1tjb29yZGluYXRlc11dO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgIC8vIFRPRE8gLSBzaG91bGQgbGluZXMgcmVhbGx5IGJlIGhhbmRsZWQgaW4gdGhpcyBzd2l0Y2g/XG4gICAgICBwb2x5Z29ucyA9IENvbnRhaW5lci5tYXAoY29vcmRpbmF0ZXMsIGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIFtjb29yZHNdO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcG9seWdvbnMgPSBbXTtcbiAgfVxuICByZXR1cm4gcG9seWdvbnM7XG59XG5cbi8vIERFUFJFQ0FURUQgLSBVU0VEIEJZIE9MRCBDSE9ST1BMRVRIIExBWUVSU1xuXG4vKlxuICogY29udmVydHMgbGlzdCBvZiBmZWF0dXJlcyBmcm9tIGEgR2VvSlNPTiBvYmplY3QgdG8gYSBsaXN0IG9mIEdlb0pTT05cbiAqIHBvbHlnb24tc3R5bGUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZ2VvanNvbiBvYmplY3RcbiAqIEByZXR1cm5zIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXVtdfSBhcnJheSBvZiBjaG9yb3BsZXRoc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBvbHlnb25zKGRhdGEpIHtcbiAgdmFyIG5vcm1hbGl6ZWRHZW9qc29uID0gbm9ybWFsaXplR2VvanNvbihkYXRhKTtcbiAgdmFyIGZlYXR1cmVzID0gQ29udGFpbmVyLmdldChub3JtYWxpemVkR2VvanNvbiwgJ2ZlYXR1cmVzJyk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlLCBmZWF0dXJlSW5kZXgpIHtcbiAgICB2YXIgY2hvcm9wbGV0aHMgPSBmZWF0dXJlVG9Qb2x5Z29ucyhmZWF0dXJlKTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1uZXN0ZWQtY2FsbGJhY2tzICovXG4gICAgY2hvcm9wbGV0aHMgPSBDb250YWluZXIubWFwKGNob3JvcGxldGhzLCBmdW5jdGlvbiAoY2hvcm9wbGV0aCkge1xuICAgICAgcmV0dXJuIENvbnRhaW5lci5tYXAoY2hvcm9wbGV0aCwgZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICAgICAgcmV0dXJuIENvbnRhaW5lci5tYXAocG9seWdvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgcmV0dXJuIFtDb250YWluZXIuZ2V0KGNvb3JkLCAwKSwgQ29udGFpbmVyLmdldChjb29yZCwgMSksIENvbnRhaW5lci5nZXQoY29vcmQsIDIpIHx8IDBdO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LW5lc3RlZC1jYWxsYmFja3MgKi9cblxuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gY2hvcm9wbGV0aHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgIHZhciBjaG9yb3BsZXRoID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgY2hvcm9wbGV0aC5mZWF0dXJlSW5kZXggPSBmZWF0dXJlSW5kZXg7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfdG9Db25zdW1hYmxlQXJyYXkoY2hvcm9wbGV0aHMpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogXCJOb3JtYWxpemVzXCIgYSBHZW9KU09OIGdlb21ldHJ5IG9yIFwiRmVhdHVyZVwiIGludG8gYSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiBieSB3cmFwcGluZyBpdCBpbiBhbiBleHRyYSBvYmplY3QvYXJyYXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdlb2pzb24gLSBnZW9qc29uIGRhdGFcbiAqIEByZXR1cm4ge29iamVjdH0gLSBub3JtYWxpemVkIGdlb2pzb24gZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplR2VvanNvbihnZW9qc29uKSB7XG4gIHZhciB0eXBlID0gQ29udGFpbmVyLmdldChnZW9qc29uLCAndHlwZScpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgICAvLyBXcmFwIHRoZSBnZW9tZXRyeSBvYmplY3QgaW4gYSBcIkZlYXR1cmVcIiBhbmQgYWRkIHRoZSBmZWF0dXJlIHRvIGEgXCJGZWF0dXJlQ29sbGVjdGlvblwiXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICBmZWF0dXJlczogW3sgdHlwZTogJ0ZlYXR1cmUnLCBwcm9wZXJ0aWVzOiB7fSwgZ2VvbWV0cnk6IGdlb2pzb24gfV1cbiAgICAgIH07XG4gICAgY2FzZSAnRmVhdHVyZSc6XG4gICAgICAvLyBBZGQgdGhlIGZlYXR1cmUgdG8gYSBcIkZlYXR1cmVDb2xsZWN0aW9uXCJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgIGZlYXR1cmVzOiBbZ2VvanNvbl1cbiAgICAgIH07XG4gICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIGZlYXR1cmUgY29sbGVjdGlvblxuICAgICAgcmV0dXJuIGdlb2pzb247XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBnZW9qc29uIHR5cGUnKTtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVycy9kZXByZWNhdGVkL2Nob3JvcGxldGgtbGF5ZXIvZ2VvanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 57 */
/* exports provided: default */
/* exports used: default */
/*!************************************!*\
  !*** ./src/lib/composite-layer.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__layer__ = __webpack_require__(/*! ./layer */ 14);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\nvar CompositeLayer = function (_Layer) {\n  _inherits(CompositeLayer, _Layer);\n\n  function CompositeLayer(props) {\n    _classCallCheck(this, CompositeLayer);\n\n    return _possibleConstructorReturn(this, (CompositeLayer.__proto__ || Object.getPrototypeOf(CompositeLayer)).call(this, props));\n  }\n\n  _createClass(CompositeLayer, [{\n    key: 'getPickingInfo',\n    value: function getPickingInfo(opts) {\n      // do not call onHover/onClick on the container\n      return null;\n    }\n  }]);\n\n  return CompositeLayer;\n}(__WEBPACK_IMPORTED_MODULE_0__layer__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = CompositeLayer;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2NvbXBvc2l0ZS1sYXllci5qcz8xMTU4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IExheWVyIGZyb20gJy4vbGF5ZXInO1xuXG52YXIgQ29tcG9zaXRlTGF5ZXIgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhDb21wb3NpdGVMYXllciwgX0xheWVyKTtcblxuICBmdW5jdGlvbiBDb21wb3NpdGVMYXllcihwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb3NpdGVMYXllcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbXBvc2l0ZUxheWVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29tcG9zaXRlTGF5ZXIpKS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29tcG9zaXRlTGF5ZXIsIFt7XG4gICAga2V5OiAnZ2V0UGlja2luZ0luZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQaWNraW5nSW5mbyhvcHRzKSB7XG4gICAgICAvLyBkbyBub3QgY2FsbCBvbkhvdmVyL29uQ2xpY2sgb24gdGhlIGNvbnRhaW5lclxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbXBvc2l0ZUxheWVyO1xufShMYXllcik7XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvc2l0ZUxheWVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi9jb21wb3NpdGUtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 58 */
/* exports provided: drawLayers, pickLayers */
/* exports used: drawLayers, pickLayers */
/*!**********************************!*\
  !*** ./src/lib/draw-and-pick.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__ = __webpack_require__(/*! ./viewport-uniforms */ 67);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(/*! ./utils */ 3);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = drawLayers;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = pickLayers;\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global window */\n\n\n\n\nvar EMPTY_PIXEL = new Uint8Array(4);\nvar renderCount = 0;\n\nfunction drawLayers(_ref) {\n  var layers = _ref.layers,\n      pass = _ref.pass;\n\n  __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(2, 'DRAWING ' + layers.length + ' layers');\n\n  // render layers in normal colors\n  var visibleCount = 0;\n  // render layers in normal colors\n  layers.forEach(function (layer, layerIndex) {\n    if (layer.props.visible) {\n      layer.drawLayer({\n        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__[\"a\" /* getUniformsFromViewport */])(layer.context.viewport, layer.props), { layerIndex: layerIndex })\n      });\n      visibleCount++;\n    }\n  });\n\n  __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* log */].log(1, 'RENDER PASS ' + pass + ': ' + renderCount++ + ' \\n    ' + visibleCount + ' visible, ' + layers.length + ' total');\n}\n\n/* eslint-disable max-depth, max-statements */\nfunction pickLayers(gl, _ref2) {\n  var layers = _ref2.layers,\n      pickingFBO = _ref2.pickingFBO,\n      _ref2$uniforms = _ref2.uniforms,\n      uniforms = _ref2$uniforms === undefined ? {} : _ref2$uniforms,\n      x = _ref2.x,\n      y = _ref2.y,\n      viewport = _ref2.viewport,\n      mode = _ref2.mode,\n      lastPickedInfo = _ref2.lastPickedInfo;\n\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n  var deviceX = x * pixelRatio;\n  var deviceY = gl.canvas.height - y * pixelRatio;\n\n  // TODO - just return glContextWithState once luma updates\n  var unhandledPickInfos = [];\n\n  // Make sure we clear scissor test and fbo bindings in case of exceptions\n  // We are only interested in one pixel, no need to render anything else\n  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"glContextWithState\"])(gl, {\n    frameBuffer: pickingFBO,\n    framebuffer: pickingFBO,\n    scissorTest: { x: deviceX, y: deviceY, w: 1, h: 1 }\n  }, function () {\n\n    // Picking process start\n    // Clear the frame buffer\n    gl.clear(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].COLOR_BUFFER_BIT | __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].DEPTH_BUFFER_BIT);\n    // Save current blend settings\n    var oldBlendMode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"d\" /* getBlendMode */])(gl);\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    gl.enable(gl.BLEND);\n    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO);\n    gl.blendEquation(gl.FUNC_ADD);\n\n    // Render all pickable layers in picking colors\n    layers.forEach(function (layer, layerIndex) {\n      if (layer.props.visible && layer.props.pickable) {\n\n        // Encode layerIndex with alpha\n        gl.blendColor(0, 0, 0, (layerIndex + 1) / 255);\n\n        layer.drawLayer({\n          uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__viewport_uniforms__[\"a\" /* getUniformsFromViewport */])(layer.context.viewport, layer.props), { layerIndex: layerIndex })\n        });\n      }\n    });\n\n    // Read color in the central pixel, to be mapped with picking colors\n    var pickedColor = new Uint8Array(4);\n    gl.readPixels(deviceX, deviceY, 1, 1, __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].RGBA, __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"GL\"].UNSIGNED_BYTE, pickedColor);\n\n    // restore blend mode\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils__[\"e\" /* setBlendMode */])(gl, oldBlendMode);\n    // Picking process end\n\n    // Process picked info start\n    // Decode picked color\n    var pickedLayerIndex = pickedColor[3] - 1;\n    var pickedLayer = pickedLayerIndex >= 0 ? layers[pickedLayerIndex] : null;\n    var pickedObjectIndex = pickedLayer ? pickedLayer.decodePickingColor(pickedColor) : -1;\n    var pickedLayerId = pickedLayer && pickedLayer.props.id;\n    var affectedLayers = pickedLayer ? [pickedLayer] : [];\n\n    if (mode === 'hover') {\n      var _ret = function () {\n        // only invoke onHover events if picked object has changed\n        var lastPickedObjectIndex = lastPickedInfo.index;\n        var lastPickedLayerId = lastPickedInfo.layerId;\n\n        if (pickedLayerId === lastPickedLayerId && pickedObjectIndex === lastPickedObjectIndex) {\n          // picked object did not change, no need to proceed\n          return {\n            v: void 0\n          };\n        }\n\n        if (pickedLayerId !== lastPickedLayerId) {\n          // We cannot store a ref to lastPickedLayer in the context because\n          // the state of an outdated layer is no longer valid\n          // and the props may have changed\n          var lastPickedLayer = layers.find(function (l) {\n            return l.props.id === lastPickedLayerId;\n          });\n          if (lastPickedLayer) {\n            // Let leave event fire before enter event\n            affectedLayers.unshift(lastPickedLayer);\n          }\n        }\n\n        // Update layer manager context\n        lastPickedInfo.layerId = pickedLayerId;\n        lastPickedInfo.index = pickedObjectIndex;\n      }();\n\n      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n\n    var baseInfo = createInfo([x, y], viewport);\n    baseInfo.devicePixel = [deviceX, deviceY];\n    baseInfo.pixelRatio = pixelRatio;\n\n    affectedLayers.forEach(function (layer) {\n      var info = Object.assign({}, baseInfo);\n      info.layer = layer;\n\n      if (layer === pickedLayer) {\n        info.color = pickedColor;\n        info.index = pickedObjectIndex;\n        info.picked = true;\n      }\n\n      // Let layers populate its own info object\n      info = layer.pickLayer({ info: info, mode: mode });\n\n      // If layer.getPickingInfo() returns null, do not proceed\n      if (info) {\n        var handled = false;\n\n        // Calling callbacks can have async interactions with React\n        // which nullifies layer.state.\n        switch (mode) {\n          case 'click':\n            handled = layer.props.onClick(info);break;\n          case 'hover':\n            handled = layer.props.onHover(info);break;\n          default:\n            throw new Error('unknown pick type');\n        }\n\n        if (!handled) {\n          unhandledPickInfos.push(info);\n        }\n      }\n    });\n  });\n\n  return unhandledPickInfos;\n}\n/* eslint-enable max-depth, max-statements */\n\nfunction createInfo(pixel, viewport) {\n  // Assign a number of potentially useful props to the \"info\" object\n  return {\n    color: EMPTY_PIXEL,\n    index: -1,\n    picked: false,\n    x: pixel[0],\n    y: pixel[1],\n    pixel: pixel,\n    lngLat: viewport.unproject(pixel)\n  };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2RyYXctYW5kLXBpY2suanM/ZGQ0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7IEdMLCBnbENvbnRleHRXaXRoU3RhdGUgfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7IGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0IH0gZnJvbSAnLi92aWV3cG9ydC11bmlmb3Jtcyc7XG5pbXBvcnQgeyBsb2csIGdldEJsZW5kTW9kZSwgc2V0QmxlbmRNb2RlIH0gZnJvbSAnLi91dGlscyc7XG5cbnZhciBFTVBUWV9QSVhFTCA9IG5ldyBVaW50OEFycmF5KDQpO1xudmFyIHJlbmRlckNvdW50ID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdMYXllcnMoX3JlZikge1xuICB2YXIgbGF5ZXJzID0gX3JlZi5sYXllcnMsXG4gICAgICBwYXNzID0gX3JlZi5wYXNzO1xuXG4gIGxvZy5sb2coMiwgJ0RSQVdJTkcgJyArIGxheWVycy5sZW5ndGggKyAnIGxheWVycycpO1xuXG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICB2YXIgdmlzaWJsZUNvdW50ID0gMDtcbiAgLy8gcmVuZGVyIGxheWVycyBpbiBub3JtYWwgY29sb3JzXG4gIGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllciwgbGF5ZXJJbmRleCkge1xuICAgIGlmIChsYXllci5wcm9wcy52aXNpYmxlKSB7XG4gICAgICBsYXllci5kcmF3TGF5ZXIoe1xuICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7IHJlbmRlclBpY2tpbmdCdWZmZXI6IDAsIHBpY2tpbmdFbmFibGVkOiAwIH0sIGxheWVyLmNvbnRleHQudW5pZm9ybXMsIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KGxheWVyLmNvbnRleHQudmlld3BvcnQsIGxheWVyLnByb3BzKSwgeyBsYXllckluZGV4OiBsYXllckluZGV4IH0pXG4gICAgICB9KTtcbiAgICAgIHZpc2libGVDb3VudCsrO1xuICAgIH1cbiAgfSk7XG5cbiAgbG9nLmxvZygxLCAnUkVOREVSIFBBU1MgJyArIHBhc3MgKyAnOiAnICsgcmVuZGVyQ291bnQrKyArICcgXFxuICAgICcgKyB2aXNpYmxlQ291bnQgKyAnIHZpc2libGUsICcgKyBsYXllcnMubGVuZ3RoICsgJyB0b3RhbCcpO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG5leHBvcnQgZnVuY3Rpb24gcGlja0xheWVycyhnbCwgX3JlZjIpIHtcbiAgdmFyIGxheWVycyA9IF9yZWYyLmxheWVycyxcbiAgICAgIHBpY2tpbmdGQk8gPSBfcmVmMi5waWNraW5nRkJPLFxuICAgICAgX3JlZjIkdW5pZm9ybXMgPSBfcmVmMi51bmlmb3JtcyxcbiAgICAgIHVuaWZvcm1zID0gX3JlZjIkdW5pZm9ybXMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZjIkdW5pZm9ybXMsXG4gICAgICB4ID0gX3JlZjIueCxcbiAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgdmlld3BvcnQgPSBfcmVmMi52aWV3cG9ydCxcbiAgICAgIG1vZGUgPSBfcmVmMi5tb2RlLFxuICAgICAgbGFzdFBpY2tlZEluZm8gPSBfcmVmMi5sYXN0UGlja2VkSW5mbztcblxuICAvLyBDb252ZXJ0IGZyb20gY2FudmFzIHRvcC1sZWZ0IHRvIFdlYkdMIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzXG4gIC8vIEFuZCBjb21wZW5zYXRlIGZvciBwaXhlbFJhdGlvXG4gIHZhciBwaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gIHZhciBkZXZpY2VYID0geCAqIHBpeGVsUmF0aW87XG4gIHZhciBkZXZpY2VZID0gZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvO1xuXG4gIC8vIFRPRE8gLSBqdXN0IHJldHVybiBnbENvbnRleHRXaXRoU3RhdGUgb25jZSBsdW1hIHVwZGF0ZXNcbiAgdmFyIHVuaGFuZGxlZFBpY2tJbmZvcyA9IFtdO1xuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciBzY2lzc29yIHRlc3QgYW5kIGZibyBiaW5kaW5ncyBpbiBjYXNlIG9mIGV4Y2VwdGlvbnNcbiAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBvbmUgcGl4ZWwsIG5vIG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nIGVsc2VcbiAgZ2xDb250ZXh0V2l0aFN0YXRlKGdsLCB7XG4gICAgZnJhbWVCdWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgZnJhbWVidWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgc2Npc3NvclRlc3Q6IHsgeDogZGV2aWNlWCwgeTogZGV2aWNlWSwgdzogMSwgaDogMSB9XG4gIH0sIGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIFBpY2tpbmcgcHJvY2VzcyBzdGFydFxuICAgIC8vIENsZWFyIHRoZSBmcmFtZSBidWZmZXJcbiAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgLy8gU2F2ZSBjdXJyZW50IGJsZW5kIHNldHRpbmdzXG4gICAgdmFyIG9sZEJsZW5kTW9kZSA9IGdldEJsZW5kTW9kZShnbCk7XG4gICAgLy8gU2V0IGJsZW5kIG1vZGUgZm9yIHBpY2tpbmdcbiAgICAvLyBhbHdheXMgb3ZlcndyaXRlIGV4aXN0aW5nIHBpeGVsIHdpdGggW3IsZyxiLGxheWVySW5kZXhdXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5PTkUsIGdsLlpFUk8sIGdsLkNPTlNUQU5UX0FMUEhBLCBnbC5aRVJPKTtcbiAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcGlja2FibGUgbGF5ZXJzIGluIHBpY2tpbmcgY29sb3JzXG4gICAgbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyLCBsYXllckluZGV4KSB7XG4gICAgICBpZiAobGF5ZXIucHJvcHMudmlzaWJsZSAmJiBsYXllci5wcm9wcy5waWNrYWJsZSkge1xuXG4gICAgICAgIC8vIEVuY29kZSBsYXllckluZGV4IHdpdGggYWxwaGFcbiAgICAgICAgZ2wuYmxlbmRDb2xvcigwLCAwLCAwLCAobGF5ZXJJbmRleCArIDEpIC8gMjU1KTtcblxuICAgICAgICBsYXllci5kcmF3TGF5ZXIoe1xuICAgICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHsgcmVuZGVyUGlja2luZ0J1ZmZlcjogMSwgcGlja2luZ0VuYWJsZWQ6IDEgfSwgbGF5ZXIuY29udGV4dC51bmlmb3JtcywgZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQobGF5ZXIuY29udGV4dC52aWV3cG9ydCwgbGF5ZXIucHJvcHMpLCB7IGxheWVySW5kZXg6IGxheWVySW5kZXggfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWFkIGNvbG9yIGluIHRoZSBjZW50cmFsIHBpeGVsLCB0byBiZSBtYXBwZWQgd2l0aCBwaWNraW5nIGNvbG9yc1xuICAgIHZhciBwaWNrZWRDb2xvciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoZGV2aWNlWCwgZGV2aWNlWSwgMSwgMSwgR0wuUkdCQSwgR0wuVU5TSUdORURfQllURSwgcGlja2VkQ29sb3IpO1xuXG4gICAgLy8gcmVzdG9yZSBibGVuZCBtb2RlXG4gICAgc2V0QmxlbmRNb2RlKGdsLCBvbGRCbGVuZE1vZGUpO1xuICAgIC8vIFBpY2tpbmcgcHJvY2VzcyBlbmRcblxuICAgIC8vIFByb2Nlc3MgcGlja2VkIGluZm8gc3RhcnRcbiAgICAvLyBEZWNvZGUgcGlja2VkIGNvbG9yXG4gICAgdmFyIHBpY2tlZExheWVySW5kZXggPSBwaWNrZWRDb2xvclszXSAtIDE7XG4gICAgdmFyIHBpY2tlZExheWVyID0gcGlja2VkTGF5ZXJJbmRleCA+PSAwID8gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdIDogbnVsbDtcbiAgICB2YXIgcGlja2VkT2JqZWN0SW5kZXggPSBwaWNrZWRMYXllciA/IHBpY2tlZExheWVyLmRlY29kZVBpY2tpbmdDb2xvcihwaWNrZWRDb2xvcikgOiAtMTtcbiAgICB2YXIgcGlja2VkTGF5ZXJJZCA9IHBpY2tlZExheWVyICYmIHBpY2tlZExheWVyLnByb3BzLmlkO1xuICAgIHZhciBhZmZlY3RlZExheWVycyA9IHBpY2tlZExheWVyID8gW3BpY2tlZExheWVyXSA6IFtdO1xuXG4gICAgaWYgKG1vZGUgPT09ICdob3ZlcicpIHtcbiAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBvbmx5IGludm9rZSBvbkhvdmVyIGV2ZW50cyBpZiBwaWNrZWQgb2JqZWN0IGhhcyBjaGFuZ2VkXG4gICAgICAgIHZhciBsYXN0UGlja2VkT2JqZWN0SW5kZXggPSBsYXN0UGlja2VkSW5mby5pbmRleDtcbiAgICAgICAgdmFyIGxhc3RQaWNrZWRMYXllcklkID0gbGFzdFBpY2tlZEluZm8ubGF5ZXJJZDtcblxuICAgICAgICBpZiAocGlja2VkTGF5ZXJJZCA9PT0gbGFzdFBpY2tlZExheWVySWQgJiYgcGlja2VkT2JqZWN0SW5kZXggPT09IGxhc3RQaWNrZWRPYmplY3RJbmRleCkge1xuICAgICAgICAgIC8vIHBpY2tlZCBvYmplY3QgZGlkIG5vdCBjaGFuZ2UsIG5vIG5lZWQgdG8gcHJvY2VlZFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2OiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBpY2tlZExheWVySWQgIT09IGxhc3RQaWNrZWRMYXllcklkKSB7XG4gICAgICAgICAgLy8gV2UgY2Fubm90IHN0b3JlIGEgcmVmIHRvIGxhc3RQaWNrZWRMYXllciBpbiB0aGUgY29udGV4dCBiZWNhdXNlXG4gICAgICAgICAgLy8gdGhlIHN0YXRlIG9mIGFuIG91dGRhdGVkIGxheWVyIGlzIG5vIGxvbmdlciB2YWxpZFxuICAgICAgICAgIC8vIGFuZCB0aGUgcHJvcHMgbWF5IGhhdmUgY2hhbmdlZFxuICAgICAgICAgIHZhciBsYXN0UGlja2VkTGF5ZXIgPSBsYXllcnMuZmluZChmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgcmV0dXJuIGwucHJvcHMuaWQgPT09IGxhc3RQaWNrZWRMYXllcklkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChsYXN0UGlja2VkTGF5ZXIpIHtcbiAgICAgICAgICAgIC8vIExldCBsZWF2ZSBldmVudCBmaXJlIGJlZm9yZSBlbnRlciBldmVudFxuICAgICAgICAgICAgYWZmZWN0ZWRMYXllcnMudW5zaGlmdChsYXN0UGlja2VkTGF5ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBsYXllciBtYW5hZ2VyIGNvbnRleHRcbiAgICAgICAgbGFzdFBpY2tlZEluZm8ubGF5ZXJJZCA9IHBpY2tlZExheWVySWQ7XG4gICAgICAgIGxhc3RQaWNrZWRJbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICB9XG5cbiAgICB2YXIgYmFzZUluZm8gPSBjcmVhdGVJbmZvKFt4LCB5XSwgdmlld3BvcnQpO1xuICAgIGJhc2VJbmZvLmRldmljZVBpeGVsID0gW2RldmljZVgsIGRldmljZVldO1xuICAgIGJhc2VJbmZvLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXG4gICAgYWZmZWN0ZWRMYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIHZhciBpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUluZm8pO1xuICAgICAgaW5mby5sYXllciA9IGxheWVyO1xuXG4gICAgICBpZiAobGF5ZXIgPT09IHBpY2tlZExheWVyKSB7XG4gICAgICAgIGluZm8uY29sb3IgPSBwaWNrZWRDb2xvcjtcbiAgICAgICAgaW5mby5pbmRleCA9IHBpY2tlZE9iamVjdEluZGV4O1xuICAgICAgICBpbmZvLnBpY2tlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIExldCBsYXllcnMgcG9wdWxhdGUgaXRzIG93biBpbmZvIG9iamVjdFxuICAgICAgaW5mbyA9IGxheWVyLnBpY2tMYXllcih7IGluZm86IGluZm8sIG1vZGU6IG1vZGUgfSk7XG5cbiAgICAgIC8vIElmIGxheWVyLmdldFBpY2tpbmdJbmZvKCkgcmV0dXJucyBudWxsLCBkbyBub3QgcHJvY2VlZFxuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgdmFyIGhhbmRsZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBDYWxsaW5nIGNhbGxiYWNrcyBjYW4gaGF2ZSBhc3luYyBpbnRlcmFjdGlvbnMgd2l0aCBSZWFjdFxuICAgICAgICAvLyB3aGljaCBudWxsaWZpZXMgbGF5ZXIuc3RhdGUuXG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgIGhhbmRsZWQgPSBsYXllci5wcm9wcy5vbkNsaWNrKGluZm8pO2JyZWFrO1xuICAgICAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgICAgIGhhbmRsZWQgPSBsYXllci5wcm9wcy5vbkhvdmVyKGluZm8pO2JyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGljayB0eXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhbmRsZWQpIHtcbiAgICAgICAgICB1bmhhbmRsZWRQaWNrSW5mb3MucHVzaChpbmZvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdW5oYW5kbGVkUGlja0luZm9zO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUluZm8ocGl4ZWwsIHZpZXdwb3J0KSB7XG4gIC8vIEFzc2lnbiBhIG51bWJlciBvZiBwb3RlbnRpYWxseSB1c2VmdWwgcHJvcHMgdG8gdGhlIFwiaW5mb1wiIG9iamVjdFxuICByZXR1cm4ge1xuICAgIGNvbG9yOiBFTVBUWV9QSVhFTCxcbiAgICBpbmRleDogLTEsXG4gICAgcGlja2VkOiBmYWxzZSxcbiAgICB4OiBwaXhlbFswXSxcbiAgICB5OiBwaXhlbFsxXSxcbiAgICBwaXhlbDogcGl4ZWwsXG4gICAgbG5nTGF0OiB2aWV3cG9ydC51bnByb2plY3QocGl4ZWwpXG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL2RyYXctYW5kLXBpY2suanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 59 */
/* unknown exports provided */
/*!*************************!*\
  !*** ./src/lib/init.js ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_globals__ = __webpack_require__(/*! ./utils/globals */ 66);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_globals___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_globals__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_log__ = __webpack_require__(/*! ./utils/log */ 29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__package_json__ = __webpack_require__(/*! ../../package.json */ 77);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__package_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__package_json__);\n\n\n\n// Version detection\n// TODO - this imports a rather large JSON file, we only need one field\n\n\nvar STARTUP_MESSAGE = 'set deck.log.priority=2 to trace attribute updates';\n\nif (__WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck && __WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck.VERSION !== __WEBPACK_IMPORTED_MODULE_2__package_json__[\"version\"]) {\n  throw new Error('deck.gl - multiple versions detected: ' + __WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck.VERSION + ' vs ' + __WEBPACK_IMPORTED_MODULE_2__package_json__[\"version\"]);\n}\n\nif (!__WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck) {\n  /* global console */\n  /* eslint-disable no-console */\n  console.log('deck.gl ' + __WEBPACK_IMPORTED_MODULE_2__package_json__[\"version\"] + ' - ' + STARTUP_MESSAGE);\n\n  __WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck = __WEBPACK_IMPORTED_MODULE_0__utils_globals__[\"global\"].deck || {\n    VERSION: __WEBPACK_IMPORTED_MODULE_2__package_json__[\"version\"],\n    log: __WEBPACK_IMPORTED_MODULE_1__utils_log__[\"a\" /* default */]\n  };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2luaXQuanM/ZjhkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnbG9iYWwgfSBmcm9tICcuL3V0aWxzL2dsb2JhbHMnO1xuaW1wb3J0IGxvZyBmcm9tICcuL3V0aWxzL2xvZyc7XG5cbi8vIFZlcnNpb24gZGV0ZWN0aW9uXG4vLyBUT0RPIC0gdGhpcyBpbXBvcnRzIGEgcmF0aGVyIGxhcmdlIEpTT04gZmlsZSwgd2Ugb25seSBuZWVkIG9uZSBmaWVsZFxuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbic7XG5cbnZhciBTVEFSVFVQX01FU1NBR0UgPSAnc2V0IGRlY2subG9nLnByaW9yaXR5PTIgdG8gdHJhY2UgYXR0cmlidXRlIHVwZGF0ZXMnO1xuXG5pZiAoZ2xvYmFsLmRlY2sgJiYgZ2xvYmFsLmRlY2suVkVSU0lPTiAhPT0gdmVyc2lvbikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2RlY2suZ2wgLSBtdWx0aXBsZSB2ZXJzaW9ucyBkZXRlY3RlZDogJyArIGdsb2JhbC5kZWNrLlZFUlNJT04gKyAnIHZzICcgKyB2ZXJzaW9uKTtcbn1cblxuaWYgKCFnbG9iYWwuZGVjaykge1xuICAvKiBnbG9iYWwgY29uc29sZSAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGNvbnNvbGUubG9nKCdkZWNrLmdsICcgKyB2ZXJzaW9uICsgJyAtICcgKyBTVEFSVFVQX01FU1NBR0UpO1xuXG4gIGdsb2JhbC5kZWNrID0gZ2xvYmFsLmRlY2sgfHwge1xuICAgIFZFUlNJT046IHZlcnNpb24sXG4gICAgbG9nOiBsb2dcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvaW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 60 */
/* exports provided: default */
/* exports used: default */
/*!**********************************!*\
  !*** ./src/lib/layer-manager.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__layer__ = __webpack_require__(/*! ./layer */ 14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(/*! ./utils */ 3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assert__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__draw_and_pick__ = __webpack_require__(/*! ./draw-and-pick */ 58);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__viewports__ = __webpack_require__(/*! ./viewports */ 16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_luma_gl__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// IMLEMENTATION NOTES: Why new layers are created on every render\n//\n// The key here is to understand the declarative / functional\n// programming nature of \"reactive\" applications.\n//\n// - In a reactive application, the entire \"UI tree\"\n//   is re-rendered every time something in the application changes.\n//\n// - The UI framework (such as React or deck.gl) then diffs the rendered\n//   tree of UI elements (React Elements or deck.gl Layers) against the\n//   previously tree and makes optimized changes (to the DOM or to WebGL state).\n//\n// - Deck.gl layers are not based on React.\n//   But it should be possible to wrap deck.gl layers in React components to\n//   enable use of JSX.\n//\n// The deck.gl model that for the app creates a new set of on layers on every\n// render.\n// Internally, the new layers are efficiently matched against existing layers\n// using layer ids.\n//\n// All calculated state (programs, attributes etc) are stored in a state object\n// and this state object is moved forward to the match layer on every render\n// cycle.  The new layer ends up with the state of the old layer (and the\n// props of the new layer), while the old layer is simply discarded for\n// garbage collecion.\n//\n/* eslint-disable no-try-catch */\n\n\n\n\n// import {Viewport} from 'viewport-mercator-project';\n\n\n\n\nvar LayerManager = function () {\n  function LayerManager(_ref) {\n    var gl = _ref.gl;\n\n    _classCallCheck(this, LayerManager);\n\n    this.prevLayers = [];\n    this.layers = [];\n    // Tracks if any layers were drawn last update\n    // Needed to ensure that screen is cleared when no layers are shown\n    this.screenCleared = false;\n    this.oldContext = {};\n    this.context = {\n      gl: gl,\n      uniforms: {},\n      viewport: null,\n      viewportChanged: true,\n      pickingFBO: null,\n      lastPickedInfo: {\n        index: -1,\n        layerId: null\n      }\n    };\n    Object.seal(this.context);\n  }\n\n  _createClass(LayerManager, [{\n    key: 'setViewport',\n    value: function setViewport(viewport) {\n      __WEBPACK_IMPORTED_MODULE_2_assert___default()(viewport instanceof __WEBPACK_IMPORTED_MODULE_4__viewports__[\"b\" /* Viewport */], 'Invalid viewport');\n\n      // TODO - viewport change detection breaks METER_OFFSETS mode\n      // const oldViewport = this.context.viewport;\n      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);\n\n      var viewportChanged = true;\n\n      if (viewportChanged) {\n        Object.assign(this.oldContext, this.context);\n        this.context.viewport = viewport;\n        this.context.viewportChanged = true;\n        this.context.uniforms = {};\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(4, viewport);\n      }\n\n      return this;\n    }\n  }, {\n    key: 'updateLayers',\n    value: function updateLayers(_ref2) {\n      var newLayers = _ref2.newLayers;\n\n      /* eslint-disable */\n      __WEBPACK_IMPORTED_MODULE_2_assert___default()(this.context.viewport, 'LayerManager.updateLayers: viewport not set');\n\n      // Filter out any null layers\n      newLayers = newLayers.filter(function (newLayer) {\n        return newLayer !== null;\n      });\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var layer = _step.value;\n\n          layer.context = this.context;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.prevLayers = this.layers;\n\n      var _updateLayers2 = this._updateLayers({\n        oldLayers: this.prevLayers,\n        newLayers: newLayers\n      }),\n          error = _updateLayers2.error,\n          generatedLayers = _updateLayers2.generatedLayers;\n\n      this.layers = generatedLayers;\n      // Throw first error found, if any\n      if (error) {\n        throw error;\n      }\n      return this;\n    }\n  }, {\n    key: 'drawLayers',\n    value: function drawLayers(_ref3) {\n      var pass = _ref3.pass;\n\n      __WEBPACK_IMPORTED_MODULE_2_assert___default()(this.context.viewport, 'LayerManager.drawLayers: viewport not set');\n\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__draw_and_pick__[\"a\" /* drawLayers */])({ layers: this.layers, pass: pass });\n\n      return this;\n    }\n  }, {\n    key: 'pickLayer',\n    value: function pickLayer(_ref4) {\n      var x = _ref4.x,\n          y = _ref4.y,\n          mode = _ref4.mode;\n      var _context = this.context,\n          gl = _context.gl,\n          uniforms = _context.uniforms;\n\n      // Set up a frame buffer if needed\n\n      if (this.context.pickingFBO === null || gl.canvas.width !== this.context.pickingFBO.width || gl.canvas.height !== this.context.pickingFBO.height) {\n        this.context.pickingFBO = new __WEBPACK_IMPORTED_MODULE_5_luma_gl__[\"FramebufferObject\"](gl, {\n          width: gl.canvas.width,\n          height: gl.canvas.height\n        });\n      }\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__draw_and_pick__[\"b\" /* pickLayers */])(gl, {\n        x: x,\n        y: y,\n        uniforms: {\n          renderPickingBuffer: true,\n          picking_uEnable: true\n        },\n        layers: this.layers,\n        mode: mode,\n        viewport: this.context.viewport,\n        pickingFBO: this.context.pickingFBO,\n        lastPickedInfo: this.context.lastPickedInfo\n      });\n    }\n  }, {\n    key: 'needsRedraw',\n    value: function needsRedraw() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref5$clearRedrawFlag = _ref5.clearRedrawFlags,\n          clearRedrawFlags = _ref5$clearRedrawFlag === undefined ? false : _ref5$clearRedrawFlag;\n\n      if (!this.context.viewport) {\n        return false;\n      }\n\n      var redraw = false;\n\n      // Make sure that buffer is cleared once when layer list becomes empty\n      if (this.layers.length === 0) {\n        if (this.screenCleared === false) {\n          redraw = true;\n          this.screenCleared = true;\n          return true;\n        }\n      } else {\n        if (this.screenCleared === true) {\n          this.screenCleared = false;\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var layer = _step2.value;\n\n          redraw = redraw || layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return redraw;\n    }\n\n    // PRIVATE METHODS\n\n    // Match all layers, checking for caught errors\n    // To avoid having an exception in one layer disrupt other layers\n\n  }, {\n    key: '_updateLayers',\n    value: function _updateLayers(_ref6) {\n      var oldLayers = _ref6.oldLayers,\n          newLayers = _ref6.newLayers;\n\n      // Create old layer map\n      var oldLayerMap = {};\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = oldLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var oldLayer = _step3.value;\n\n          if (oldLayerMap[oldLayer.id]) {\n            __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, 'Multipe old layers with same id ' + layerName(oldLayer));\n          } else {\n            oldLayerMap[oldLayer.id] = oldLayer;\n          }\n        }\n\n        // Allocate array for generated layers\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var generatedLayers = [];\n\n      // Match sublayers\n      var error = this._matchSublayers({\n        newLayers: newLayers, oldLayerMap: oldLayerMap, generatedLayers: generatedLayers\n      });\n\n      var error2 = this._finalizeOldLayers(oldLayers);\n      var firstError = error || error2;\n      return { error: firstError, generatedLayers: generatedLayers };\n    }\n\n    /* eslint-disable max-statements */\n\n  }, {\n    key: '_matchSublayers',\n    value: function _matchSublayers(_ref7) {\n      var newLayers = _ref7.newLayers,\n          oldLayerMap = _ref7.oldLayerMap,\n          generatedLayers = _ref7.generatedLayers;\n\n      // Filter out any null layers\n      newLayers = newLayers.filter(function (newLayer) {\n        return newLayer !== null;\n      });\n\n      var error = null;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = newLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var newLayer = _step4.value;\n\n          newLayer.context = this.context;\n\n          try {\n            // 1. given a new coming layer, find its matching layer\n            var oldLayer = oldLayerMap[newLayer.id];\n            oldLayerMap[newLayer.id] = null;\n\n            if (oldLayer === null) {\n              __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, 'Multipe new layers with same id ' + layerName(newLayer));\n            }\n\n            // Only transfer state at this stage. We must not generate exceptions\n            // until all layers' state have been transferred\n            if (oldLayer) {\n              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(3, 'matched ' + layerName(newLayer), oldLayer, '=>', newLayer);\n              this._transferLayerState(oldLayer, newLayer);\n              this._updateLayer(newLayer);\n            } else {\n              this._initializeNewLayer(newLayer);\n            }\n            generatedLayers.push(newLayer);\n\n            // Call layer lifecycle method: render sublayers\n            var sublayers = newLayer.renderLayers();\n            // End layer lifecycle method: render sublayers\n\n            if (sublayers) {\n              sublayers = Array.isArray(sublayers) ? sublayers : [sublayers];\n              this._matchSublayers({\n                newLayers: sublayers,\n                oldLayerMap: oldLayerMap,\n                generatedLayers: generatedLayers\n              });\n            }\n          } catch (err) {\n            __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, 'deck.gl error during matching of ' + layerName(newLayer) + ' ' + err, err);\n            // Save first error\n            error = error || err;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return error;\n    }\n  }, {\n    key: '_transferLayerState',\n    value: function _transferLayerState(oldLayer, newLayer) {\n      var state = oldLayer.state,\n          props = oldLayer.props;\n\n      // sanity check\n\n      __WEBPACK_IMPORTED_MODULE_2_assert___default()(state, 'deck.gl sanity check - Matching layer has no state');\n      __WEBPACK_IMPORTED_MODULE_2_assert___default()(oldLayer !== newLayer, 'deck.gl sanity check - Matching layer is same');\n\n      // Move state\n      newLayer.state = state;\n      state.layer = newLayer;\n\n      // Update model layer reference\n      if (state.model) {\n        state.model.userData.layer = newLayer;\n      }\n      // Keep a temporary ref to the old props, for prop comparison\n      newLayer.oldProps = props;\n      oldLayer.state = null;\n    }\n\n    // Update the old layers that were not matched\n\n  }, {\n    key: '_finalizeOldLayers',\n    value: function _finalizeOldLayers(oldLayers) {\n      var error = null;\n      // Unmatched layers still have state, it will be discarded\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = oldLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var layer = _step5.value;\n\n          if (layer.state) {\n            error = error || this._finalizeLayer(layer);\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return error;\n    }\n\n    // Initializes a single layer, calling layer methods\n\n  }, {\n    key: '_initializeNewLayer',\n    value: function _initializeNewLayer(layer) {\n      var error = null;\n      // Check if new layer, and initialize it's state\n      if (!layer.state) {\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(1, 'initializing ' + layerName(layer));\n        try {\n          layer.initializeLayer({\n            oldProps: {},\n            props: layer.props,\n            oldContext: this.oldContext,\n            context: this.context,\n            changeFlags: layer.diffProps({}, layer.props, this.context)\n          });\n        } catch (err) {\n          __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, 'deck.gl error during initialization of ' + layerName(layer) + ' ' + err, err);\n          // Save first error\n          error = error || err;\n        }\n        // Set back pointer (used in picking)\n        if (layer.state) {\n          layer.state.layer = layer;\n          // Save layer on model for picking purposes\n          // TODO - store on model.userData rather than directly on model\n        }\n        if (layer.state && layer.state.model) {\n          layer.state.model.userData.layer = layer;\n        }\n      }\n      return error;\n    }\n\n    // Updates a single layer, calling layer methods\n\n  }, {\n    key: '_updateLayer',\n    value: function _updateLayer(layer) {\n      var oldProps = layer.oldProps,\n          props = layer.props;\n\n      var error = null;\n      if (oldProps) {\n        try {\n          layer.updateLayer({\n            oldProps: oldProps,\n            props: props,\n            context: this.context,\n            oldContext: this.oldContext,\n            changeFlags: layer.diffProps(oldProps, layer.props, this.context)\n          });\n        } catch (err) {\n          __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, 'deck.gl error during update of ' + layerName(layer), err);\n          // Save first error\n          error = err;\n        }\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(2, 'updating ' + layerName(layer));\n      }\n      return error;\n    }\n\n    // Finalizes a single layer\n\n  }, {\n    key: '_finalizeLayer',\n    value: function _finalizeLayer(layer) {\n      var error = null;\n      var state = layer.state;\n\n      if (state) {\n        try {\n          layer.finalizeLayer();\n        } catch (err) {\n          __WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */].once(0, 'deck.gl error during finalization of ' + layerName(layer), err);\n          // Save first error\n          error = err;\n        }\n        layer.state = null;\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* log */])(1, 'finalizing ' + layerName(layer));\n      }\n      return error;\n    }\n  }]);\n\n  return LayerManager;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = LayerManager;\n\n\nfunction layerName(layer) {\n  if (layer instanceof __WEBPACK_IMPORTED_MODULE_0__layer__[\"a\" /* default */]) {\n    return '' + layer;\n  }\n  return !layer ? 'null layer' : 'invalid layer';\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2xheWVyLW1hbmFnZXIuanM/OGIxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBJTUxFTUVOVEFUSU9OIE5PVEVTOiBXaHkgbmV3IGxheWVycyBhcmUgY3JlYXRlZCBvbiBldmVyeSByZW5kZXJcbi8vXG4vLyBUaGUga2V5IGhlcmUgaXMgdG8gdW5kZXJzdGFuZCB0aGUgZGVjbGFyYXRpdmUgLyBmdW5jdGlvbmFsXG4vLyBwcm9ncmFtbWluZyBuYXR1cmUgb2YgXCJyZWFjdGl2ZVwiIGFwcGxpY2F0aW9ucy5cbi8vXG4vLyAtIEluIGEgcmVhY3RpdmUgYXBwbGljYXRpb24sIHRoZSBlbnRpcmUgXCJVSSB0cmVlXCJcbi8vICAgaXMgcmUtcmVuZGVyZWQgZXZlcnkgdGltZSBzb21ldGhpbmcgaW4gdGhlIGFwcGxpY2F0aW9uIGNoYW5nZXMuXG4vL1xuLy8gLSBUaGUgVUkgZnJhbWV3b3JrIChzdWNoIGFzIFJlYWN0IG9yIGRlY2suZ2wpIHRoZW4gZGlmZnMgdGhlIHJlbmRlcmVkXG4vLyAgIHRyZWUgb2YgVUkgZWxlbWVudHMgKFJlYWN0IEVsZW1lbnRzIG9yIGRlY2suZ2wgTGF5ZXJzKSBhZ2FpbnN0IHRoZVxuLy8gICBwcmV2aW91c2x5IHRyZWUgYW5kIG1ha2VzIG9wdGltaXplZCBjaGFuZ2VzICh0byB0aGUgRE9NIG9yIHRvIFdlYkdMIHN0YXRlKS5cbi8vXG4vLyAtIERlY2suZ2wgbGF5ZXJzIGFyZSBub3QgYmFzZWQgb24gUmVhY3QuXG4vLyAgIEJ1dCBpdCBzaG91bGQgYmUgcG9zc2libGUgdG8gd3JhcCBkZWNrLmdsIGxheWVycyBpbiBSZWFjdCBjb21wb25lbnRzIHRvXG4vLyAgIGVuYWJsZSB1c2Ugb2YgSlNYLlxuLy9cbi8vIFRoZSBkZWNrLmdsIG1vZGVsIHRoYXQgZm9yIHRoZSBhcHAgY3JlYXRlcyBhIG5ldyBzZXQgb2Ygb24gbGF5ZXJzIG9uIGV2ZXJ5XG4vLyByZW5kZXIuXG4vLyBJbnRlcm5hbGx5LCB0aGUgbmV3IGxheWVycyBhcmUgZWZmaWNpZW50bHkgbWF0Y2hlZCBhZ2FpbnN0IGV4aXN0aW5nIGxheWVyc1xuLy8gdXNpbmcgbGF5ZXIgaWRzLlxuLy9cbi8vIEFsbCBjYWxjdWxhdGVkIHN0YXRlIChwcm9ncmFtcywgYXR0cmlidXRlcyBldGMpIGFyZSBzdG9yZWQgaW4gYSBzdGF0ZSBvYmplY3Rcbi8vIGFuZCB0aGlzIHN0YXRlIG9iamVjdCBpcyBtb3ZlZCBmb3J3YXJkIHRvIHRoZSBtYXRjaCBsYXllciBvbiBldmVyeSByZW5kZXJcbi8vIGN5Y2xlLiAgVGhlIG5ldyBsYXllciBlbmRzIHVwIHdpdGggdGhlIHN0YXRlIG9mIHRoZSBvbGQgbGF5ZXIgKGFuZCB0aGVcbi8vIHByb3BzIG9mIHRoZSBuZXcgbGF5ZXIpLCB3aGlsZSB0aGUgb2xkIGxheWVyIGlzIHNpbXBseSBkaXNjYXJkZWQgZm9yXG4vLyBnYXJiYWdlIGNvbGxlY2lvbi5cbi8vXG4vKiBlc2xpbnQtZGlzYWJsZSBuby10cnktY2F0Y2ggKi9cbmltcG9ydCBMYXllciBmcm9tICcuL2xheWVyJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgZHJhd0xheWVycyBhcyBfZHJhd0xheWVycywgcGlja0xheWVycyB9IGZyb20gJy4vZHJhdy1hbmQtcGljayc7XG4vLyBpbXBvcnQge1ZpZXdwb3J0fSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcbmltcG9ydCB7IFZpZXdwb3J0IH0gZnJvbSAnLi92aWV3cG9ydHMnO1xuXG5pbXBvcnQgeyBGcmFtZWJ1ZmZlck9iamVjdCB9IGZyb20gJ2x1bWEuZ2wnO1xuXG52YXIgTGF5ZXJNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYXllck1hbmFnZXIoX3JlZikge1xuICAgIHZhciBnbCA9IF9yZWYuZ2w7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5ZXJNYW5hZ2VyKTtcblxuICAgIHRoaXMucHJldkxheWVycyA9IFtdO1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgLy8gVHJhY2tzIGlmIGFueSBsYXllcnMgd2VyZSBkcmF3biBsYXN0IHVwZGF0ZVxuICAgIC8vIE5lZWRlZCB0byBlbnN1cmUgdGhhdCBzY3JlZW4gaXMgY2xlYXJlZCB3aGVuIG5vIGxheWVycyBhcmUgc2hvd25cbiAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9sZENvbnRleHQgPSB7fTtcbiAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICBnbDogZ2wsXG4gICAgICB1bmlmb3Jtczoge30sXG4gICAgICB2aWV3cG9ydDogbnVsbCxcbiAgICAgIHZpZXdwb3J0Q2hhbmdlZDogdHJ1ZSxcbiAgICAgIHBpY2tpbmdGQk86IG51bGwsXG4gICAgICBsYXN0UGlja2VkSW5mbzoge1xuICAgICAgICBpbmRleDogLTEsXG4gICAgICAgIGxheWVySWQ6IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5zZWFsKHRoaXMuY29udGV4dCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGF5ZXJNYW5hZ2VyLCBbe1xuICAgIGtleTogJ3NldFZpZXdwb3J0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgIGFzc2VydCh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0LCAnSW52YWxpZCB2aWV3cG9ydCcpO1xuXG4gICAgICAvLyBUT0RPIC0gdmlld3BvcnQgY2hhbmdlIGRldGVjdGlvbiBicmVha3MgTUVURVJfT0ZGU0VUUyBtb2RlXG4gICAgICAvLyBjb25zdCBvbGRWaWV3cG9ydCA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcbiAgICAgIC8vIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9ICFvbGRWaWV3cG9ydCB8fCAhdmlld3BvcnQuZXF1YWxzKG9sZFZpZXdwb3J0KTtcblxuICAgICAgdmFyIHZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG5cbiAgICAgIGlmICh2aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9sZENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLmNvbnRleHQudmlld3BvcnRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnVuaWZvcm1zID0ge307XG4gICAgICAgIGxvZyg0LCB2aWV3cG9ydCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUxheWVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUxheWVycyhfcmVmMikge1xuICAgICAgdmFyIG5ld0xheWVycyA9IF9yZWYyLm5ld0xheWVycztcblxuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgIGFzc2VydCh0aGlzLmNvbnRleHQudmlld3BvcnQsICdMYXllck1hbmFnZXIudXBkYXRlTGF5ZXJzOiB2aWV3cG9ydCBub3Qgc2V0Jyk7XG5cbiAgICAgIC8vIEZpbHRlciBvdXQgYW55IG51bGwgbGF5ZXJzXG4gICAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuZmlsdGVyKGZ1bmN0aW9uIChuZXdMYXllcikge1xuICAgICAgICByZXR1cm4gbmV3TGF5ZXIgIT09IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG5ld0xheWVyc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgbGF5ZXIgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGxheWVyLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnByZXZMYXllcnMgPSB0aGlzLmxheWVycztcblxuICAgICAgdmFyIF91cGRhdGVMYXllcnMyID0gdGhpcy5fdXBkYXRlTGF5ZXJzKHtcbiAgICAgICAgb2xkTGF5ZXJzOiB0aGlzLnByZXZMYXllcnMsXG4gICAgICAgIG5ld0xheWVyczogbmV3TGF5ZXJzXG4gICAgICB9KSxcbiAgICAgICAgICBlcnJvciA9IF91cGRhdGVMYXllcnMyLmVycm9yLFxuICAgICAgICAgIGdlbmVyYXRlZExheWVycyA9IF91cGRhdGVMYXllcnMyLmdlbmVyYXRlZExheWVycztcblxuICAgICAgdGhpcy5sYXllcnMgPSBnZW5lcmF0ZWRMYXllcnM7XG4gICAgICAvLyBUaHJvdyBmaXJzdCBlcnJvciBmb3VuZCwgaWYgYW55XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3TGF5ZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xheWVycyhfcmVmMykge1xuICAgICAgdmFyIHBhc3MgPSBfcmVmMy5wYXNzO1xuXG4gICAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnM6IHZpZXdwb3J0IG5vdCBzZXQnKTtcblxuICAgICAgX2RyYXdMYXllcnMoeyBsYXllcnM6IHRoaXMubGF5ZXJzLCBwYXNzOiBwYXNzIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwaWNrTGF5ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaWNrTGF5ZXIoX3JlZjQpIHtcbiAgICAgIHZhciB4ID0gX3JlZjQueCxcbiAgICAgICAgICB5ID0gX3JlZjQueSxcbiAgICAgICAgICBtb2RlID0gX3JlZjQubW9kZTtcbiAgICAgIHZhciBfY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBnbCA9IF9jb250ZXh0LmdsLFxuICAgICAgICAgIHVuaWZvcm1zID0gX2NvbnRleHQudW5pZm9ybXM7XG5cbiAgICAgIC8vIFNldCB1cCBhIGZyYW1lIGJ1ZmZlciBpZiBuZWVkZWRcblxuICAgICAgaWYgKHRoaXMuY29udGV4dC5waWNraW5nRkJPID09PSBudWxsIHx8IGdsLmNhbnZhcy53aWR0aCAhPT0gdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8ud2lkdGggfHwgZ2wuY2FudmFzLmhlaWdodCAhPT0gdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8uaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5waWNraW5nRkJPID0gbmV3IEZyYW1lYnVmZmVyT2JqZWN0KGdsLCB7XG4gICAgICAgICAgd2lkdGg6IGdsLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGdsLmNhbnZhcy5oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGlja0xheWVycyhnbCwge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHJlbmRlclBpY2tpbmdCdWZmZXI6IHRydWUsXG4gICAgICAgICAgcGlja2luZ191RW5hYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyczogdGhpcy5sYXllcnMsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHZpZXdwb3J0OiB0aGlzLmNvbnRleHQudmlld3BvcnQsXG4gICAgICAgIHBpY2tpbmdGQk86IHRoaXMuY29udGV4dC5waWNraW5nRkJPLFxuICAgICAgICBsYXN0UGlja2VkSW5mbzogdGhpcy5jb250ZXh0Lmxhc3RQaWNrZWRJbmZvXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduZWVkc1JlZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZWRzUmVkcmF3KCkge1xuICAgICAgdmFyIF9yZWY1ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmNSRjbGVhclJlZHJhd0ZsYWcgPSBfcmVmNS5jbGVhclJlZHJhd0ZsYWdzLFxuICAgICAgICAgIGNsZWFyUmVkcmF3RmxhZ3MgPSBfcmVmNSRjbGVhclJlZHJhd0ZsYWcgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjUkY2xlYXJSZWRyYXdGbGFnO1xuXG4gICAgICBpZiAoIXRoaXMuY29udGV4dC52aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWRyYXcgPSBmYWxzZTtcblxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzIGNsZWFyZWQgb25jZSB3aGVuIGxheWVyIGxpc3QgYmVjb21lcyBlbXB0eVxuICAgICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5zY3JlZW5DbGVhcmVkID09PSBmYWxzZSkge1xuICAgICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zY3JlZW5DbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc2NyZWVuQ2xlYXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdGhpcy5sYXllcnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgbGF5ZXIgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICByZWRyYXcgPSByZWRyYXcgfHwgbGF5ZXIuZ2V0TmVlZHNSZWRyYXcoeyBjbGVhclJlZHJhd0ZsYWdzOiBjbGVhclJlZHJhd0ZsYWdzIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWRyYXc7XG4gICAgfVxuXG4gICAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgICAvLyBNYXRjaCBhbGwgbGF5ZXJzLCBjaGVja2luZyBmb3IgY2F1Z2h0IGVycm9yc1xuICAgIC8vIFRvIGF2b2lkIGhhdmluZyBhbiBleGNlcHRpb24gaW4gb25lIGxheWVyIGRpc3J1cHQgb3RoZXIgbGF5ZXJzXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVMYXllcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTGF5ZXJzKF9yZWY2KSB7XG4gICAgICB2YXIgb2xkTGF5ZXJzID0gX3JlZjYub2xkTGF5ZXJzLFxuICAgICAgICAgIG5ld0xheWVycyA9IF9yZWY2Lm5ld0xheWVycztcblxuICAgICAgLy8gQ3JlYXRlIG9sZCBsYXllciBtYXBcbiAgICAgIHZhciBvbGRMYXllck1hcCA9IHt9O1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBvbGRMYXllcnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2xkTGF5ZXIgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICBpZiAob2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdKSB7XG4gICAgICAgICAgICBsb2cub25jZSgwLCAnTXVsdGlwZSBvbGQgbGF5ZXJzIHdpdGggc2FtZSBpZCAnICsgbGF5ZXJOYW1lKG9sZExheWVyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9sZExheWVyTWFwW29sZExheWVyLmlkXSA9IG9sZExheWVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG9jYXRlIGFycmF5IGZvciBnZW5lcmF0ZWQgbGF5ZXJzXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBnZW5lcmF0ZWRMYXllcnMgPSBbXTtcblxuICAgICAgLy8gTWF0Y2ggc3VibGF5ZXJzXG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLl9tYXRjaFN1YmxheWVycyh7XG4gICAgICAgIG5ld0xheWVyczogbmV3TGF5ZXJzLCBvbGRMYXllck1hcDogb2xkTGF5ZXJNYXAsIGdlbmVyYXRlZExheWVyczogZ2VuZXJhdGVkTGF5ZXJzXG4gICAgICB9KTtcblxuICAgICAgdmFyIGVycm9yMiA9IHRoaXMuX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVycyk7XG4gICAgICB2YXIgZmlyc3RFcnJvciA9IGVycm9yIHx8IGVycm9yMjtcbiAgICAgIHJldHVybiB7IGVycm9yOiBmaXJzdEVycm9yLCBnZW5lcmF0ZWRMYXllcnM6IGdlbmVyYXRlZExheWVycyB9O1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgfSwge1xuICAgIGtleTogJ19tYXRjaFN1YmxheWVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXRjaFN1YmxheWVycyhfcmVmNykge1xuICAgICAgdmFyIG5ld0xheWVycyA9IF9yZWY3Lm5ld0xheWVycyxcbiAgICAgICAgICBvbGRMYXllck1hcCA9IF9yZWY3Lm9sZExheWVyTWFwLFxuICAgICAgICAgIGdlbmVyYXRlZExheWVycyA9IF9yZWY3LmdlbmVyYXRlZExheWVycztcblxuICAgICAgLy8gRmlsdGVyIG91dCBhbnkgbnVsbCBsYXllcnNcbiAgICAgIG5ld0xheWVycyA9IG5ld0xheWVycy5maWx0ZXIoZnVuY3Rpb24gKG5ld0xheWVyKSB7XG4gICAgICAgIHJldHVybiBuZXdMYXllciAhPT0gbnVsbDtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBuZXdMYXllcnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgbmV3TGF5ZXIgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICBuZXdMYXllci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDEuIGdpdmVuIGEgbmV3IGNvbWluZyBsYXllciwgZmluZCBpdHMgbWF0Y2hpbmcgbGF5ZXJcbiAgICAgICAgICAgIHZhciBvbGRMYXllciA9IG9sZExheWVyTWFwW25ld0xheWVyLmlkXTtcbiAgICAgICAgICAgIG9sZExheWVyTWFwW25ld0xheWVyLmlkXSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChvbGRMYXllciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBsb2cub25jZSgwLCAnTXVsdGlwZSBuZXcgbGF5ZXJzIHdpdGggc2FtZSBpZCAnICsgbGF5ZXJOYW1lKG5ld0xheWVyKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdHJhbnNmZXIgc3RhdGUgYXQgdGhpcyBzdGFnZS4gV2UgbXVzdCBub3QgZ2VuZXJhdGUgZXhjZXB0aW9uc1xuICAgICAgICAgICAgLy8gdW50aWwgYWxsIGxheWVycycgc3RhdGUgaGF2ZSBiZWVuIHRyYW5zZmVycmVkXG4gICAgICAgICAgICBpZiAob2xkTGF5ZXIpIHtcbiAgICAgICAgICAgICAgbG9nKDMsICdtYXRjaGVkICcgKyBsYXllck5hbWUobmV3TGF5ZXIpLCBvbGRMYXllciwgJz0+JywgbmV3TGF5ZXIpO1xuICAgICAgICAgICAgICB0aGlzLl90cmFuc2ZlckxheWVyU3RhdGUob2xkTGF5ZXIsIG5ld0xheWVyKTtcbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXIobmV3TGF5ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU5ld0xheWVyKG5ld0xheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbmVyYXRlZExheWVycy5wdXNoKG5ld0xheWVyKTtcblxuICAgICAgICAgICAgLy8gQ2FsbCBsYXllciBsaWZlY3ljbGUgbWV0aG9kOiByZW5kZXIgc3VibGF5ZXJzXG4gICAgICAgICAgICB2YXIgc3VibGF5ZXJzID0gbmV3TGF5ZXIucmVuZGVyTGF5ZXJzKCk7XG4gICAgICAgICAgICAvLyBFbmQgbGF5ZXIgbGlmZWN5Y2xlIG1ldGhvZDogcmVuZGVyIHN1YmxheWVyc1xuXG4gICAgICAgICAgICBpZiAoc3VibGF5ZXJzKSB7XG4gICAgICAgICAgICAgIHN1YmxheWVycyA9IEFycmF5LmlzQXJyYXkoc3VibGF5ZXJzKSA/IHN1YmxheWVycyA6IFtzdWJsYXllcnNdO1xuICAgICAgICAgICAgICB0aGlzLl9tYXRjaFN1YmxheWVycyh7XG4gICAgICAgICAgICAgICAgbmV3TGF5ZXJzOiBzdWJsYXllcnMsXG4gICAgICAgICAgICAgICAgb2xkTGF5ZXJNYXA6IG9sZExheWVyTWFwLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlZExheWVyczogZ2VuZXJhdGVkTGF5ZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nLm9uY2UoMCwgJ2RlY2suZ2wgZXJyb3IgZHVyaW5nIG1hdGNoaW5nIG9mICcgKyBsYXllck5hbWUobmV3TGF5ZXIpICsgJyAnICsgZXJyLCBlcnIpO1xuICAgICAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfdHJhbnNmZXJMYXllclN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zZmVyTGF5ZXJTdGF0ZShvbGRMYXllciwgbmV3TGF5ZXIpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG9sZExheWVyLnN0YXRlLFxuICAgICAgICAgIHByb3BzID0gb2xkTGF5ZXIucHJvcHM7XG5cbiAgICAgIC8vIHNhbml0eSBjaGVja1xuXG4gICAgICBhc3NlcnQoc3RhdGUsICdkZWNrLmdsIHNhbml0eSBjaGVjayAtIE1hdGNoaW5nIGxheWVyIGhhcyBubyBzdGF0ZScpO1xuICAgICAgYXNzZXJ0KG9sZExheWVyICE9PSBuZXdMYXllciwgJ2RlY2suZ2wgc2FuaXR5IGNoZWNrIC0gTWF0Y2hpbmcgbGF5ZXIgaXMgc2FtZScpO1xuXG4gICAgICAvLyBNb3ZlIHN0YXRlXG4gICAgICBuZXdMYXllci5zdGF0ZSA9IHN0YXRlO1xuICAgICAgc3RhdGUubGF5ZXIgPSBuZXdMYXllcjtcblxuICAgICAgLy8gVXBkYXRlIG1vZGVsIGxheWVyIHJlZmVyZW5jZVxuICAgICAgaWYgKHN0YXRlLm1vZGVsKSB7XG4gICAgICAgIHN0YXRlLm1vZGVsLnVzZXJEYXRhLmxheWVyID0gbmV3TGF5ZXI7XG4gICAgICB9XG4gICAgICAvLyBLZWVwIGEgdGVtcG9yYXJ5IHJlZiB0byB0aGUgb2xkIHByb3BzLCBmb3IgcHJvcCBjb21wYXJpc29uXG4gICAgICBuZXdMYXllci5vbGRQcm9wcyA9IHByb3BzO1xuICAgICAgb2xkTGF5ZXIuc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgb2xkIGxheWVycyB0aGF0IHdlcmUgbm90IG1hdGNoZWRcblxuICB9LCB7XG4gICAga2V5OiAnX2ZpbmFsaXplT2xkTGF5ZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVycykge1xuICAgICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICAgIC8vIFVubWF0Y2hlZCBsYXllcnMgc3RpbGwgaGF2ZSBzdGF0ZSwgaXQgd2lsbCBiZSBkaXNjYXJkZWRcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I1ID0gb2xkTGF5ZXJzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGxheWVyID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGxheWVyLnN0YXRlKSB7XG4gICAgICAgICAgICBlcnJvciA9IGVycm9yIHx8IHRoaXMuX2ZpbmFsaXplTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yNSA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZXMgYSBzaW5nbGUgbGF5ZXIsIGNhbGxpbmcgbGF5ZXIgbWV0aG9kc1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfaW5pdGlhbGl6ZU5ld0xheWVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRpYWxpemVOZXdMYXllcihsYXllcikge1xuICAgICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICAgIC8vIENoZWNrIGlmIG5ldyBsYXllciwgYW5kIGluaXRpYWxpemUgaXQncyBzdGF0ZVxuICAgICAgaWYgKCFsYXllci5zdGF0ZSkge1xuICAgICAgICBsb2coMSwgJ2luaXRpYWxpemluZyAnICsgbGF5ZXJOYW1lKGxheWVyKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGF5ZXIuaW5pdGlhbGl6ZUxheWVyKHtcbiAgICAgICAgICAgIG9sZFByb3BzOiB7fSxcbiAgICAgICAgICAgIHByb3BzOiBsYXllci5wcm9wcyxcbiAgICAgICAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICAgIGNoYW5nZUZsYWdzOiBsYXllci5kaWZmUHJvcHMoe30sIGxheWVyLnByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZy5vbmNlKDAsICdkZWNrLmdsIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbiBvZiAnICsgbGF5ZXJOYW1lKGxheWVyKSArICcgJyArIGVyciwgZXJyKTtcbiAgICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGJhY2sgcG9pbnRlciAodXNlZCBpbiBwaWNraW5nKVxuICAgICAgICBpZiAobGF5ZXIuc3RhdGUpIHtcbiAgICAgICAgICBsYXllci5zdGF0ZS5sYXllciA9IGxheWVyO1xuICAgICAgICAgIC8vIFNhdmUgbGF5ZXIgb24gbW9kZWwgZm9yIHBpY2tpbmcgcHVycG9zZXNcbiAgICAgICAgICAvLyBUT0RPIC0gc3RvcmUgb24gbW9kZWwudXNlckRhdGEgcmF0aGVyIHRoYW4gZGlyZWN0bHkgb24gbW9kZWxcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5ZXIuc3RhdGUgJiYgbGF5ZXIuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgICBsYXllci5zdGF0ZS5tb2RlbC51c2VyRGF0YS5sYXllciA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlcyBhIHNpbmdsZSBsYXllciwgY2FsbGluZyBsYXllciBtZXRob2RzXG5cbiAgfSwge1xuICAgIGtleTogJ191cGRhdGVMYXllcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVMYXllcihsYXllcikge1xuICAgICAgdmFyIG9sZFByb3BzID0gbGF5ZXIub2xkUHJvcHMsXG4gICAgICAgICAgcHJvcHMgPSBsYXllci5wcm9wcztcblxuICAgICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICAgIGlmIChvbGRQcm9wcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxheWVyLnVwZGF0ZUxheWVyKHtcbiAgICAgICAgICAgIG9sZFByb3BzOiBvbGRQcm9wcyxcbiAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCxcbiAgICAgICAgICAgIGNoYW5nZUZsYWdzOiBsYXllci5kaWZmUHJvcHMob2xkUHJvcHMsIGxheWVyLnByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZy5vbmNlKDAsICdkZWNrLmdsIGVycm9yIGR1cmluZyB1cGRhdGUgb2YgJyArIGxheWVyTmFtZShsYXllciksIGVycik7XG4gICAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGxvZygyLCAndXBkYXRpbmcgJyArIGxheWVyTmFtZShsYXllcikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIC8vIEZpbmFsaXplcyBhIHNpbmdsZSBsYXllclxuXG4gIH0sIHtcbiAgICBrZXk6ICdfZmluYWxpemVMYXllcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5hbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgICAgdmFyIHN0YXRlID0gbGF5ZXIuc3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxheWVyLmZpbmFsaXplTGF5ZXIoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nLm9uY2UoMCwgJ2RlY2suZ2wgZXJyb3IgZHVyaW5nIGZpbmFsaXphdGlvbiBvZiAnICsgbGF5ZXJOYW1lKGxheWVyKSwgZXJyKTtcbiAgICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXIuc3RhdGUgPSBudWxsO1xuICAgICAgICBsb2coMSwgJ2ZpbmFsaXppbmcgJyArIGxheWVyTmFtZShsYXllcikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXllck1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyTWFuYWdlcjtcblxuXG5mdW5jdGlvbiBsYXllck5hbWUobGF5ZXIpIHtcbiAgaWYgKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICByZXR1cm4gJycgKyBsYXllcjtcbiAgfVxuICByZXR1cm4gIWxheWVyID8gJ251bGwgbGF5ZXInIDogJ2ludmFsaWQgbGF5ZXInO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi9sYXllci1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 61 */
/* exports provided: getBlendMode, setBlendMode */
/* exports used: getBlendMode, setBlendMode */
/*!********************************!*\
  !*** ./src/lib/utils/blend.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getBlendMode;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = setBlendMode;\n// get current blending settings\nfunction getBlendMode(gl) {\n  return {\n    enabled: gl.getParameter(gl.BLEND),\n    equationRGB: gl.getParameter(gl.BLEND_EQUATION_RGB),\n    equationAlpha: gl.getParameter(gl.BLEND_EQUATION_ALPHA),\n    srcRGB: gl.getParameter(gl.BLEND_SRC_RGB),\n    dstRGB: gl.getParameter(gl.BLEND_DST_RGB),\n    srcAlpha: gl.getParameter(gl.BLEND_SRC_ALPHA),\n    dstAlpha: gl.getParameter(gl.BLEND_DST_ALPHA)\n  };\n}\n\n// apply blending settings\nfunction setBlendMode(gl, settings) {\n  if (settings.enabled) {\n    gl.enable(gl.BLEND);\n  } else {\n    gl.disable(gl.BLEND);\n  }\n  gl.blendEquationSeparate(settings.equationRGB, settings.equationAlpha);\n  gl.blendFuncSeparate(settings.srcRGB, settings.dstRGB, settings.srcAlpha, settings.dstAlpha);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2JsZW5kLmpzPzc4ODYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2V0IGN1cnJlbnQgYmxlbmRpbmcgc2V0dGluZ3NcbmV4cG9ydCBmdW5jdGlvbiBnZXRCbGVuZE1vZGUoZ2wpIHtcbiAgcmV0dXJuIHtcbiAgICBlbmFibGVkOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkQpLFxuICAgIGVxdWF0aW9uUkdCOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkRfRVFVQVRJT05fUkdCKSxcbiAgICBlcXVhdGlvbkFscGhhOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkRfRVFVQVRJT05fQUxQSEEpLFxuICAgIHNyY1JHQjogZ2wuZ2V0UGFyYW1ldGVyKGdsLkJMRU5EX1NSQ19SR0IpLFxuICAgIGRzdFJHQjogZ2wuZ2V0UGFyYW1ldGVyKGdsLkJMRU5EX0RTVF9SR0IpLFxuICAgIHNyY0FscGhhOiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQkxFTkRfU1JDX0FMUEhBKSxcbiAgICBkc3RBbHBoYTogZ2wuZ2V0UGFyYW1ldGVyKGdsLkJMRU5EX0RTVF9BTFBIQSlcbiAgfTtcbn1cblxuLy8gYXBwbHkgYmxlbmRpbmcgc2V0dGluZ3NcbmV4cG9ydCBmdW5jdGlvbiBzZXRCbGVuZE1vZGUoZ2wsIHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncy5lbmFibGVkKSB7XG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgfSBlbHNlIHtcbiAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgfVxuICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoc2V0dGluZ3MuZXF1YXRpb25SR0IsIHNldHRpbmdzLmVxdWF0aW9uQWxwaGEpO1xuICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShzZXR0aW5ncy5zcmNSR0IsIHNldHRpbmdzLmRzdFJHQiwgc2V0dGluZ3Muc3JjQWxwaGEsIHNldHRpbmdzLmRzdEFscGhhKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdXRpbHMvYmxlbmQuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 62 */
/* exports provided: parseColor, parseHexColor, setOpacity, applyOpacity */
/*!********************************!*\
  !*** ./src/lib/utils/color.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* unused harmony export parseColor */\n/* unused harmony export parseHexColor */\n/* unused harmony export setOpacity */\n/* unused harmony export applyOpacity */\n\n// Parse array or string color\nfunction parseColor(color) {\n  if (Array.isArray(color)) {\n    if (color.length === 3) {\n      return [color[0], color[1], color[2], 255];\n    }\n    return color;\n  }\n  if (typeof color === 'string') {\n    return parseHexColor(color);\n  }\n  return null;\n}\n\n// Parse a hex color\nfunction parseHexColor(color) {\n  var array = new Uint8ClampedArray(4);\n  if (color.length === 7) {\n    var value = parseInt(color.substring(1), 16);\n    array[0] = value / 65536;\n    array[1] = value / 256 % 256;\n    array[2] = value % 256;\n    array[3] = 255;\n  } else if (color.length === 9) {\n    var _value = parseInt(color.substring(1), 16);\n    array[0] = _value / 16777216;\n    array[1] = _value / 65536 % 256;\n    array[2] = _value / 256 % 256;\n    array[3] = _value % 256;\n  }\n  return array;\n}\n\nfunction setOpacity(color) {\n  var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 127;\n\n  return [color[0], color[1], color[2], opacity];\n}\n\nfunction applyOpacity(color) {\n  var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 127;\n\n  return [color[0], color[1], color[2], opacity];\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2NvbG9yLmpzP2NiZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBQYXJzZSBhcnJheSBvciBzdHJpbmcgY29sb3JcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbG9yKGNvbG9yKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBbY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgMjU1XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlSGV4Q29sb3IoY29sb3IpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBQYXJzZSBhIGhleCBjb2xvclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSGV4Q29sb3IoY29sb3IpIHtcbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDQpO1xuICBpZiAoY29sb3IubGVuZ3RoID09PSA3KSB7XG4gICAgdmFyIHZhbHVlID0gcGFyc2VJbnQoY29sb3Iuc3Vic3RyaW5nKDEpLCAxNik7XG4gICAgYXJyYXlbMF0gPSB2YWx1ZSAvIDY1NTM2O1xuICAgIGFycmF5WzFdID0gdmFsdWUgLyAyNTYgJSAyNTY7XG4gICAgYXJyYXlbMl0gPSB2YWx1ZSAlIDI1NjtcbiAgICBhcnJheVszXSA9IDI1NTtcbiAgfSBlbHNlIGlmIChjb2xvci5sZW5ndGggPT09IDkpIHtcbiAgICB2YXIgX3ZhbHVlID0gcGFyc2VJbnQoY29sb3Iuc3Vic3RyaW5nKDEpLCAxNik7XG4gICAgYXJyYXlbMF0gPSBfdmFsdWUgLyAxNjc3NzIxNjtcbiAgICBhcnJheVsxXSA9IF92YWx1ZSAvIDY1NTM2ICUgMjU2O1xuICAgIGFycmF5WzJdID0gX3ZhbHVlIC8gMjU2ICUgMjU2O1xuICAgIGFycmF5WzNdID0gX3ZhbHVlICUgMjU2O1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wYWNpdHkoY29sb3IpIHtcbiAgdmFyIG9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEyNztcblxuICByZXR1cm4gW2NvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlPcGFjaXR5KGNvbG9yKSB7XG4gIHZhciBvcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMjc7XG5cbiAgcmV0dXJuIFtjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5XTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdXRpbHMvY29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 63 */
/* exports provided: compareArrays, checkArray */
/*!*****************************************!*\
  !*** ./src/lib/utils/compare-arrays.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* unused harmony export compareArrays */\n/* unused harmony export checkArray */\nfunction compareArrays(array1, array2) {\n\n  var length = Math.min(array1.length, array2.length);\n  for (var i = 0; i < length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return \"Arrays are different in element \" + i + \": \" + array1[i] + \" vs \" + array2[i];\n    }\n  }\n\n  if (array1.length !== array2.length) {\n    return \"Arrays have different length \" + array1.length + \" vs \" + array2.length;\n  }\n\n  return null;\n}\n\nfunction checkArray(array) {\n  for (var i = 0; i < array.length; ++i) {\n    if (!Number.isFinite(array[i])) {\n      throw new Error(\"Array has invalid element \" + i + \": \" + array[i]);\n    }\n  }\n  return null;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2NvbXBhcmUtYXJyYXlzLmpzP2NiYWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIpIHtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcbiAgICAgIHJldHVybiBcIkFycmF5cyBhcmUgZGlmZmVyZW50IGluIGVsZW1lbnQgXCIgKyBpICsgXCI6IFwiICsgYXJyYXkxW2ldICsgXCIgdnMgXCIgKyBhcnJheTJbaV07XG4gICAgfVxuICB9XG5cbiAgaWYgKGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpIHtcbiAgICByZXR1cm4gXCJBcnJheXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RoIFwiICsgYXJyYXkxLmxlbmd0aCArIFwiIHZzIFwiICsgYXJyYXkyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tBcnJheShhcnJheSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYXJyYXlbaV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheSBoYXMgaW52YWxpZCBlbGVtZW50IFwiICsgaSArIFwiOiBcIiArIGFycmF5W2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL3V0aWxzL2NvbXBhcmUtYXJyYXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 64 */
/* exports provided: compareProps, areEqualShallow */
/* exports used: compareProps */
/*!******************************************!*\
  !*** ./src/lib/utils/compare-objects.js ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assert__);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = compareProps;\n/* unused harmony export areEqualShallow */\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * @param {Object} opt.oldProps - object with old key/value pairs\n * @param {Object} opt.newProps - object with new key/value pairs\n * @param {Object} opt.ignoreProps={} - object, keys that should not be compared\n * @returns {null|String} - null when values of all keys are strictly equal.\n *   if unequal, returns a string explaining what changed.\n */\n/* eslint-disable max-statements, complexity */\nfunction compareProps() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      oldProps = _ref.oldProps,\n      newProps = _ref.newProps,\n      _ref$ignoreProps = _ref.ignoreProps,\n      ignoreProps = _ref$ignoreProps === undefined ? {} : _ref$ignoreProps;\n\n  __WEBPACK_IMPORTED_MODULE_0_assert___default()(oldProps !== undefined && newProps !== undefined, 'compareProps args');\n\n  if (oldProps === newProps) {\n    return null;\n  }\n\n  if ((typeof oldProps === 'undefined' ? 'undefined' : _typeof(oldProps)) !== 'object' || oldProps === null) {\n    return 'old props is not an object';\n  }\n  if ((typeof newProps === 'undefined' ? 'undefined' : _typeof(newProps)) !== 'object' || newProps === null) {\n    return 'new props is not an object';\n  }\n\n  // Test if new props different from old props\n  for (var key in oldProps) {\n    if (!(key in ignoreProps)) {\n      if (!newProps.hasOwnProperty(key)) {\n        return 'prop ' + key + ' dropped: ' + oldProps[key] + ' -> (undefined)';\n      } else if (oldProps[key] !== newProps[key]) {\n        return 'prop ' + key + ' changed: ' + oldProps[key] + ' -> ' + newProps[key];\n      }\n    }\n  }\n\n  // Test if any new props have been added\n  for (var _key in newProps) {\n    if (!(_key in ignoreProps)) {\n      if (!oldProps.hasOwnProperty(_key)) {\n        return 'prop ' + _key + ' added: (undefined) -> ' + newProps[_key];\n      }\n    }\n  }\n\n  return null;\n}\n/* eslint-enable max-statements, complexity */\n\n// Shallow compare\n/* eslint-disable complexity */\nfunction areEqualShallow(a, b) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref2$ignore = _ref2.ignore,\n      ignore = _ref2$ignore === undefined ? {} : _ref2$ignore;\n\n  if (a === b) {\n    return true;\n  }\n\n  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== 'object' || a === null || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) !== 'object' || b === null) {\n    return false;\n  }\n\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (var key in a) {\n    if (!(key in ignore) && (!(key in b) || a[key] !== b[key])) {\n      return false;\n    }\n  }\n  for (var _key2 in b) {\n    if (!(_key2 in ignore) && !(_key2 in a)) {\n      return false;\n    }\n  }\n  return true;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2NvbXBhcmUtb2JqZWN0cy5qcz8yODM2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdC5vbGRQcm9wcyAtIG9iamVjdCB3aXRoIG9sZCBrZXkvdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQubmV3UHJvcHMgLSBvYmplY3Qgd2l0aCBuZXcga2V5L3ZhbHVlIHBhaXJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0Lmlnbm9yZVByb3BzPXt9IC0gb2JqZWN0LCBrZXlzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb21wYXJlZFxuICogQHJldHVybnMge251bGx8U3RyaW5nfSAtIG51bGwgd2hlbiB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICogICBpZiB1bmVxdWFsLCByZXR1cm5zIGEgc3RyaW5nIGV4cGxhaW5pbmcgd2hhdCBjaGFuZ2VkLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVQcm9wcygpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgb2xkUHJvcHMgPSBfcmVmLm9sZFByb3BzLFxuICAgICAgbmV3UHJvcHMgPSBfcmVmLm5ld1Byb3BzLFxuICAgICAgX3JlZiRpZ25vcmVQcm9wcyA9IF9yZWYuaWdub3JlUHJvcHMsXG4gICAgICBpZ25vcmVQcm9wcyA9IF9yZWYkaWdub3JlUHJvcHMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZiRpZ25vcmVQcm9wcztcblxuICBhc3NlcnQob2xkUHJvcHMgIT09IHVuZGVmaW5lZCAmJiBuZXdQcm9wcyAhPT0gdW5kZWZpbmVkLCAnY29tcGFyZVByb3BzIGFyZ3MnKTtcblxuICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBvbGRQcm9wcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2xkUHJvcHMpKSAhPT0gJ29iamVjdCcgfHwgb2xkUHJvcHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ29sZCBwcm9wcyBpcyBub3QgYW4gb2JqZWN0JztcbiAgfVxuICBpZiAoKHR5cGVvZiBuZXdQcm9wcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmV3UHJvcHMpKSAhPT0gJ29iamVjdCcgfHwgbmV3UHJvcHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ25ldyBwcm9wcyBpcyBub3QgYW4gb2JqZWN0JztcbiAgfVxuXG4gIC8vIFRlc3QgaWYgbmV3IHByb3BzIGRpZmZlcmVudCBmcm9tIG9sZCBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gaWdub3JlUHJvcHMpKSB7XG4gICAgICBpZiAoIW5ld1Byb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuICdwcm9wICcgKyBrZXkgKyAnIGRyb3BwZWQ6ICcgKyBvbGRQcm9wc1trZXldICsgJyAtPiAodW5kZWZpbmVkKSc7XG4gICAgICB9IGVsc2UgaWYgKG9sZFByb3BzW2tleV0gIT09IG5ld1Byb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuICdwcm9wICcgKyBrZXkgKyAnIGNoYW5nZWQ6ICcgKyBvbGRQcm9wc1trZXldICsgJyAtPiAnICsgbmV3UHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUZXN0IGlmIGFueSBuZXcgcHJvcHMgaGF2ZSBiZWVuIGFkZGVkXG4gIGZvciAodmFyIF9rZXkgaW4gbmV3UHJvcHMpIHtcbiAgICBpZiAoIShfa2V5IGluIGlnbm9yZVByb3BzKSkge1xuICAgICAgaWYgKCFvbGRQcm9wcy5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICByZXR1cm4gJ3Byb3AgJyArIF9rZXkgKyAnIGFkZGVkOiAodW5kZWZpbmVkKSAtPiAnICsgbmV3UHJvcHNbX2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5cbi8vIFNoYWxsb3cgY29tcGFyZVxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyZUVxdWFsU2hhbGxvdyhhLCBiKSB7XG4gIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICBfcmVmMiRpZ25vcmUgPSBfcmVmMi5pZ25vcmUsXG4gICAgICBpZ25vcmUgPSBfcmVmMiRpZ25vcmUgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZjIkaWdub3JlO1xuXG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKSkgIT09ICdvYmplY3QnIHx8IGEgPT09IG51bGwgfHwgKHR5cGVvZiBiID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihiKSkgIT09ICdvYmplY3QnIHx8IGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgIGlmICghKGtleSBpbiBpZ25vcmUpICYmICghKGtleSBpbiBiKSB8fCBhW2tleV0gIT09IGJba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgX2tleTIgaW4gYikge1xuICAgIGlmICghKF9rZXkyIGluIGlnbm9yZSkgJiYgIShfa2V5MiBpbiBhKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdXRpbHMvY29tcGFyZS1vYmplY3RzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 65 */
/* exports provided: flatten, countVertices, flattenVertices, fillArray */
/* exports used: flatten, flattenVertices, fillArray */
/*!**********************************!*\
  !*** ./src/lib/utils/flatten.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = flatten;\n/* unused harmony export countVertices */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = flattenVertices;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = fillArray;\n/**\n * Flattens a nested array into a single level array\n * @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]\n * @param {Array} array The array to flatten.\n * @return {Array} Returns the new flattened array.\n */\nfunction flatten(array) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  var index = -1;\n  while (++index < array.length) {\n    var value = array[index];\n    if (Array.isArray(value)) {\n      flatten(value, result);\n    } else {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nfunction countVertices(nestedArray) {\n  var count = 0;\n  var index = -1;\n  while (++index < nestedArray.length) {\n    var value = nestedArray[index];\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      count += countVertices(value);\n    } else {\n      count++;\n    }\n  }\n  return count;\n}\n\n// Flattens nested array of vertices, padding third coordinate as needed\nfunction flattenVertices(nestedArray) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$result = _ref.result,\n      result = _ref$result === undefined ? [] : _ref$result,\n      _ref$dimensions = _ref.dimensions,\n      dimensions = _ref$dimensions === undefined ? 3 : _ref$dimensions;\n\n  var index = -1;\n  var vertexLength = 0;\n  while (++index < nestedArray.length) {\n    var value = nestedArray[index];\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      flattenVertices(value, { result: result, dimensions: dimensions });\n    } else {\n      if (vertexLength < dimensions) {\n        // eslint-disable-line\n        result.push(value);\n        vertexLength++;\n      }\n    }\n  }\n  // Add a third coordinate if needed\n  if (vertexLength > 0 && vertexLength < dimensions) {\n    result.push(0);\n  }\n  return result;\n}\n\n// Uses copyWithin to significantly speed up typed array value filling\nfunction fillArray(_ref2) {\n  var target = _ref2.target,\n      source = _ref2.source,\n      _ref2$start = _ref2.start,\n      start = _ref2$start === undefined ? 0 : _ref2$start,\n      _ref2$count = _ref2.count,\n      count = _ref2$count === undefined ? 1 : _ref2$count;\n\n  var total = count * source.length;\n  var copied = 0;\n  for (var i = 0; i < source.length; ++i) {\n    target[start + copied++] = source[i];\n  }\n\n  while (copied < total) {\n    // If we have copied less than half, copy everything we got\n    // else copy remaining in one operation\n    if (copied < total - copied) {\n      target.copyWithin(start + copied, start, start + copied);\n      copied *= 2;\n    } else {\n      target.copyWithin(start + copied, start, start + total - copied);\n      copied = total;\n    }\n  }\n\n  return target;\n}\n\n// Flattens nested array of vertices, padding third coordinate as needed\n/*\nexport function flattenTypedVertices(nestedArray, {\n  result = [],\n  Type = Float32Array,\n  start = 0,\n  dimensions = 3\n} = {}) {\n  let index = -1;\n  let vertexLength = 0;\n  while (++index < nestedArray.length) {\n    const value = nestedArray[index];\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      start = flattenTypedVertices(value, {result, start, dimensions});\n    } else {\n      if (vertexLength < dimensions) { // eslint-disable-line\n        result[start++] = value;\n        vertexLength++;\n      }\n    }\n  }\n  // Add a third coordinate if needed\n  if (vertexLength > 0 && vertexLength < dimensions) {\n    result[start++] = 0;\n  }\n  return start;\n}\n*///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2ZsYXR0ZW4uanM/MzQxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5IGludG8gYSBzaW5nbGUgbGV2ZWwgYXJyYXlcbiAqIEBleGFtcGxlIGZsYXR0ZW4oW1sxLCBbMl1dLCBbM10sIDRdKSA9PiBbMSwgMiwgMywgNF1cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciByZXN1bHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gIHZhciBpbmRleCA9IC0xO1xuICB3aGlsZSAoKytpbmRleCA8IGFycmF5Lmxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZsYXR0ZW4odmFsdWUsIHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50VmVydGljZXMobmVzdGVkQXJyYXkpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHdoaWxlICgrK2luZGV4IDwgbmVzdGVkQXJyYXkubGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gbmVzdGVkQXJyYXlbaW5kZXhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICBjb3VudCArPSBjb3VudFZlcnRpY2VzKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vLyBGbGF0dGVucyBuZXN0ZWQgYXJyYXkgb2YgdmVydGljZXMsIHBhZGRpbmcgdGhpcmQgY29vcmRpbmF0ZSBhcyBuZWVkZWRcbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuVmVydGljZXMobmVzdGVkQXJyYXkpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZiRyZXN1bHQgPSBfcmVmLnJlc3VsdCxcbiAgICAgIHJlc3VsdCA9IF9yZWYkcmVzdWx0ID09PSB1bmRlZmluZWQgPyBbXSA6IF9yZWYkcmVzdWx0LFxuICAgICAgX3JlZiRkaW1lbnNpb25zID0gX3JlZi5kaW1lbnNpb25zLFxuICAgICAgZGltZW5zaW9ucyA9IF9yZWYkZGltZW5zaW9ucyA9PT0gdW5kZWZpbmVkID8gMyA6IF9yZWYkZGltZW5zaW9ucztcblxuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIHZlcnRleExlbmd0aCA9IDA7XG4gIHdoaWxlICgrK2luZGV4IDwgbmVzdGVkQXJyYXkubGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gbmVzdGVkQXJyYXlbaW5kZXhdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICBmbGF0dGVuVmVydGljZXModmFsdWUsIHsgcmVzdWx0OiByZXN1bHQsIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB2ZXJ0ZXhMZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQWRkIGEgdGhpcmQgY29vcmRpbmF0ZSBpZiBuZWVkZWRcbiAgaWYgKHZlcnRleExlbmd0aCA+IDAgJiYgdmVydGV4TGVuZ3RoIDwgZGltZW5zaW9ucykge1xuICAgIHJlc3VsdC5wdXNoKDApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIFVzZXMgY29weVdpdGhpbiB0byBzaWduaWZpY2FudGx5IHNwZWVkIHVwIHR5cGVkIGFycmF5IHZhbHVlIGZpbGxpbmdcbmV4cG9ydCBmdW5jdGlvbiBmaWxsQXJyYXkoX3JlZjIpIHtcbiAgdmFyIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIF9yZWYyJHN0YXJ0ID0gX3JlZjIuc3RhcnQsXG4gICAgICBzdGFydCA9IF9yZWYyJHN0YXJ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjIkc3RhcnQsXG4gICAgICBfcmVmMiRjb3VudCA9IF9yZWYyLmNvdW50LFxuICAgICAgY291bnQgPSBfcmVmMiRjb3VudCA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYyJGNvdW50O1xuXG4gIHZhciB0b3RhbCA9IGNvdW50ICogc291cmNlLmxlbmd0aDtcbiAgdmFyIGNvcGllZCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0W3N0YXJ0ICsgY29waWVkKytdID0gc291cmNlW2ldO1xuICB9XG5cbiAgd2hpbGUgKGNvcGllZCA8IHRvdGFsKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBjb3BpZWQgbGVzcyB0aGFuIGhhbGYsIGNvcHkgZXZlcnl0aGluZyB3ZSBnb3RcbiAgICAvLyBlbHNlIGNvcHkgcmVtYWluaW5nIGluIG9uZSBvcGVyYXRpb25cbiAgICBpZiAoY29waWVkIDwgdG90YWwgLSBjb3BpZWQpIHtcbiAgICAgIHRhcmdldC5jb3B5V2l0aGluKHN0YXJ0ICsgY29waWVkLCBzdGFydCwgc3RhcnQgKyBjb3BpZWQpO1xuICAgICAgY29waWVkICo9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5jb3B5V2l0aGluKHN0YXJ0ICsgY29waWVkLCBzdGFydCwgc3RhcnQgKyB0b3RhbCAtIGNvcGllZCk7XG4gICAgICBjb3BpZWQgPSB0b3RhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBGbGF0dGVucyBuZXN0ZWQgYXJyYXkgb2YgdmVydGljZXMsIHBhZGRpbmcgdGhpcmQgY29vcmRpbmF0ZSBhcyBuZWVkZWRcbi8qXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlblR5cGVkVmVydGljZXMobmVzdGVkQXJyYXksIHtcbiAgcmVzdWx0ID0gW10sXG4gIFR5cGUgPSBGbG9hdDMyQXJyYXksXG4gIHN0YXJ0ID0gMCxcbiAgZGltZW5zaW9ucyA9IDNcbn0gPSB7fSkge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IHZlcnRleExlbmd0aCA9IDA7XG4gIHdoaWxlICgrK2luZGV4IDwgbmVzdGVkQXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXN0ZWRBcnJheVtpbmRleF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgIHN0YXJ0ID0gZmxhdHRlblR5cGVkVmVydGljZXModmFsdWUsIHtyZXN1bHQsIHN0YXJ0LCBkaW1lbnNpb25zfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVzdWx0W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICAgIHZlcnRleExlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBBZGQgYSB0aGlyZCBjb29yZGluYXRlIGlmIG5lZWRlZFxuICBpZiAodmVydGV4TGVuZ3RoID4gMCAmJiB2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7XG4gICAgcmVzdWx0W3N0YXJ0KytdID0gMDtcbiAgfVxuICByZXR1cm4gc3RhcnQ7XG59XG4qL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi91dGlscy9mbGF0dGVuLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 66 */
/* unknown exports provided */
/* exports used: global */
/*!**********************************!*\
  !*** ./src/lib/utils/globals.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/* global window, global, document */\nmodule.exports = {\n  window: typeof window !== 'undefined' ? window : global,\n  global: typeof global !== 'undefined' ? global : window,\n  document: typeof document !== 'undefined' ? document : {}\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../~/webpack/buildin/global.js */ 76)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3V0aWxzL2dsb2JhbHMuanM/YzZhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgd2luZG93LCBnbG9iYWwsIGRvY3VtZW50ICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd2luZG93OiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCxcbiAgZ2xvYmFsOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyxcbiAgZG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHt9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xpYi91dGlscy9nbG9iYWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 67 */
/* exports provided: getUniformsFromViewport */
/* exports used: getUniformsFromViewport */
/*!**************************************!*\
  !*** ./src/lib/viewport-uniforms.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert__ = __webpack_require__(/*! assert */ 6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assert__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(/*! ./constants */ 28);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getUniformsFromViewport;\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\n\n\n\nfunction fp64ify(a) {\n  var hiPart = Math.fround(a);\n  var loPart = a - Math.fround(a);\n  return [hiPart, loPart];\n}\n\n// To quickly set a vector to zero\nvar ZERO_VECTOR = [0, 0, 0, 0];\n// 4x4 matrix that drops 4th component of vector\nvar VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\n\nfunction calculateMatrixAndOffset(_ref) {\n  var projectionMode = _ref.projectionMode,\n      positionOrigin = _ref.positionOrigin,\n      viewport = _ref.viewport,\n      modelMatrix = _ref.modelMatrix;\n  var viewMatrixUncentered = viewport.viewMatrixUncentered,\n      viewMatrix = viewport.viewMatrix,\n      projectionMatrix = viewport.projectionMatrix;\n\n\n  var projectionCenter = void 0;\n  var modelViewProjectionMatrix = void 0;\n\n  var modelViewMatrixInv = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Matrix4\"](viewMatrix);\n  var viewProjectionMatrix = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Matrix4\"](projectionMatrix).multiplyRight(viewMatrix);\n\n  switch (projectionMode) {\n\n    case __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* COORDINATE_SYSTEM */].LNGLAT:\n      projectionCenter = ZERO_VECTOR;\n      modelViewProjectionMatrix = viewProjectionMatrix;\n      if (modelMatrix) {\n        // Apply model matrix if supplied\n        // modelViewProjectionMatrix = modelViewProjectionMatrix.clone();\n        modelViewProjectionMatrix.multiplyRight(modelMatrix);\n        modelViewMatrixInv.multiplyRight(modelMatrix);\n      }\n      modelViewMatrixInv.invert();\n      break;\n\n    // TODO: make lighitng work for meter offset mode\n    case __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* COORDINATE_SYSTEM */].METER_OFFSETS:\n      // Calculate transformed projectionCenter (in 64 bit precision)\n      // This is the key to offset mode precision (avoids doing this\n      // addition in 32 bit precision)\n      var positionPixels = viewport.projectFlat(positionOrigin);\n      projectionCenter = viewProjectionMatrix.transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n\n      modelViewProjectionMatrix = new __WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"Matrix4\"](projectionMatrix)\n      // Always apply uncentered projection matrix (shader adds center)\n      .multiplyRight(viewMatrixUncentered)\n      // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n      .multiplyRight(VECTOR_TO_POINT_MATRIX);\n\n      if (modelMatrix) {\n        // Apply model matrix if supplied\n        modelViewProjectionMatrix.multiplyRight(modelMatrix);\n      }\n      break;\n\n    default:\n      throw new Error('Unknown projection mode');\n  }\n\n  var cameraPos = [modelViewMatrixInv[12], modelViewMatrixInv[13], modelViewMatrixInv[14]];\n\n  return {\n    modelViewProjectionMatrix: modelViewProjectionMatrix,\n    projectionCenter: projectionCenter,\n    cameraPos: cameraPos\n  };\n}\n\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\nfunction getUniformsFromViewport(viewport) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$modelMatrix = _ref2.modelMatrix,\n      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,\n      _ref2$projectionMode = _ref2.projectionMode,\n      projectionMode = _ref2$projectionMode === undefined ? __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* COORDINATE_SYSTEM */].LNGLAT : _ref2$projectionMode,\n      _ref2$positionOrigin = _ref2.positionOrigin,\n      positionOrigin = _ref2$positionOrigin === undefined ? [0, 0] : _ref2$positionOrigin;\n\n  __WEBPACK_IMPORTED_MODULE_1_assert___default()(viewport.scale, 'Viewport scale missing');\n\n  var _calculateMatrixAndOf = calculateMatrixAndOffset({ projectionMode: projectionMode, positionOrigin: positionOrigin, modelMatrix: modelMatrix, viewport: viewport }),\n      projectionCenter = _calculateMatrixAndOf.projectionCenter,\n      modelViewProjectionMatrix = _calculateMatrixAndOf.modelViewProjectionMatrix,\n      cameraPos = _calculateMatrixAndOf.cameraPos;\n\n  __WEBPACK_IMPORTED_MODULE_1_assert___default()(modelViewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');\n\n  // Calculate projection pixels per unit\n  var projectionPixelsPerUnit = viewport.getDistanceScales().pixelsPerMeter;\n  __WEBPACK_IMPORTED_MODULE_1_assert___default()(projectionPixelsPerUnit, 'Viewport missing pixelsPerMeter');\n\n  // calculate WebGL matrices\n\n  // Convert to Float32\n  var glProjectionMatrix = new Float32Array(modelViewProjectionMatrix);\n\n  // \"Float64Array\"\n  // Transpose the projection matrix to column major for GLSL.\n  var glProjectionMatrixFP64 = new Float32Array(32);\n  for (var i = 0; i < 4; ++i) {\n    for (var j = 0; j < 4; ++j) {\n      var _fp64ify = fp64ify(modelViewProjectionMatrix[j * 4 + i]);\n\n      var _fp64ify2 = _slicedToArray(_fp64ify, 2);\n\n      glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];\n      glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];\n    }\n  }\n\n  return {\n    // Projection mode values\n    projectionMode: projectionMode,\n    projectionCenter: projectionCenter,\n\n    // modelMatrix: modelMatrix || new Matrix4().identity(),\n\n    // Main projection matrices\n    projectionMatrix: glProjectionMatrix,\n    projectionMatrixUncentered: glProjectionMatrix,\n    projectionFP64: glProjectionMatrixFP64,\n    projectionPixelsPerUnit: projectionPixelsPerUnit,\n\n    // This is the mercator scale (2 ** zoom)\n    projectionScale: viewport.scale,\n\n    // Deprecated?\n    projectionScaleFP64: fp64ify(viewport.scale),\n\n    // This is for lighting calculations\n    cameraPos: new Float32Array(cameraPos)\n\n  };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZpZXdwb3J0LXVuaWZvcm1zLmpzP2VjNjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7IENPT1JESU5BVEVfU1lTVEVNIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5mdW5jdGlvbiBmcDY0aWZ5KGEpIHtcbiAgdmFyIGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICB2YXIgbG9QYXJ0ID0gYSAtIE1hdGguZnJvdW5kKGEpO1xuICByZXR1cm4gW2hpUGFydCwgbG9QYXJ0XTtcbn1cblxuLy8gVG8gcXVpY2tseSBzZXQgYSB2ZWN0b3IgdG8gemVyb1xudmFyIFpFUk9fVkVDVE9SID0gWzAsIDAsIDAsIDBdO1xuLy8gNHg0IG1hdHJpeCB0aGF0IGRyb3BzIDR0aCBjb21wb25lbnQgb2YgdmVjdG9yXG52YXIgVkVDVE9SX1RPX1BPSU5UX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwXTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0KF9yZWYpIHtcbiAgdmFyIHByb2plY3Rpb25Nb2RlID0gX3JlZi5wcm9qZWN0aW9uTW9kZSxcbiAgICAgIHBvc2l0aW9uT3JpZ2luID0gX3JlZi5wb3NpdGlvbk9yaWdpbixcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIG1vZGVsTWF0cml4ID0gX3JlZi5tb2RlbE1hdHJpeDtcbiAgdmFyIHZpZXdNYXRyaXhVbmNlbnRlcmVkID0gdmlld3BvcnQudmlld01hdHJpeFVuY2VudGVyZWQsXG4gICAgICB2aWV3TWF0cml4ID0gdmlld3BvcnQudmlld01hdHJpeCxcbiAgICAgIHByb2plY3Rpb25NYXRyaXggPSB2aWV3cG9ydC5wcm9qZWN0aW9uTWF0cml4O1xuXG5cbiAgdmFyIHByb2plY3Rpb25DZW50ZXIgPSB2b2lkIDA7XG4gIHZhciBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdm9pZCAwO1xuXG4gIHZhciBtb2RlbFZpZXdNYXRyaXhJbnYgPSBuZXcgTWF0cml4NCh2aWV3TWF0cml4KTtcbiAgdmFyIHZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQocHJvamVjdGlvbk1hdHJpeCkubXVsdGlwbHlSaWdodCh2aWV3TWF0cml4KTtcblxuICBzd2l0Y2ggKHByb2plY3Rpb25Nb2RlKSB7XG5cbiAgICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVDpcbiAgICAgIHByb2plY3Rpb25DZW50ZXIgPSBaRVJPX1ZFQ1RPUjtcbiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSB2aWV3UHJvamVjdGlvbk1hdHJpeDtcbiAgICAgIGlmIChtb2RlbE1hdHJpeCkge1xuICAgICAgICAvLyBBcHBseSBtb2RlbCBtYXRyaXggaWYgc3VwcGxpZWRcbiAgICAgICAgLy8gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXguY2xvbmUoKTtcbiAgICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeC5tdWx0aXBseVJpZ2h0KG1vZGVsTWF0cml4KTtcbiAgICAgICAgbW9kZWxWaWV3TWF0cml4SW52Lm11bHRpcGx5UmlnaHQobW9kZWxNYXRyaXgpO1xuICAgICAgfVxuICAgICAgbW9kZWxWaWV3TWF0cml4SW52LmludmVydCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBUT0RPOiBtYWtlIGxpZ2hpdG5nIHdvcmsgZm9yIG1ldGVyIG9mZnNldCBtb2RlXG4gICAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5NRVRFUl9PRkZTRVRTOlxuICAgICAgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybWVkIHByb2plY3Rpb25DZW50ZXIgKGluIDY0IGJpdCBwcmVjaXNpb24pXG4gICAgICAvLyBUaGlzIGlzIHRoZSBrZXkgdG8gb2Zmc2V0IG1vZGUgcHJlY2lzaW9uIChhdm9pZHMgZG9pbmcgdGhpc1xuICAgICAgLy8gYWRkaXRpb24gaW4gMzIgYml0IHByZWNpc2lvbilcbiAgICAgIHZhciBwb3NpdGlvblBpeGVscyA9IHZpZXdwb3J0LnByb2plY3RGbGF0KHBvc2l0aW9uT3JpZ2luKTtcbiAgICAgIHByb2plY3Rpb25DZW50ZXIgPSB2aWV3UHJvamVjdGlvbk1hdHJpeC50cmFuc2Zvcm1WZWN0b3IoW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdKTtcblxuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpXG4gICAgICAvLyBBbHdheXMgYXBwbHkgdW5jZW50ZXJlZCBwcm9qZWN0aW9uIG1hdHJpeCAoc2hhZGVyIGFkZHMgY2VudGVyKVxuICAgICAgLm11bHRpcGx5UmlnaHQodmlld01hdHJpeFVuY2VudGVyZWQpXG4gICAgICAvLyBaZXJvIG91dCA0dGggY29vcmRpbmF0ZSAoXCJhZnRlclwiIG1vZGVsIG1hdHJpeCkgLSBhdm9pZHMgZnVydGhlciB0cmFuc2xhdGlvbnNcbiAgICAgIC5tdWx0aXBseVJpZ2h0KFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuXG4gICAgICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAgICAgLy8gQXBwbHkgbW9kZWwgbWF0cml4IGlmIHN1cHBsaWVkXG4gICAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgubXVsdGlwbHlSaWdodChtb2RlbE1hdHJpeCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvamVjdGlvbiBtb2RlJyk7XG4gIH1cblxuICB2YXIgY2FtZXJhUG9zID0gW21vZGVsVmlld01hdHJpeEludlsxMl0sIG1vZGVsVmlld01hdHJpeEludlsxM10sIG1vZGVsVmlld01hdHJpeEludlsxNF1dO1xuXG4gIHJldHVybiB7XG4gICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDogbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICBwcm9qZWN0aW9uQ2VudGVyOiBwcm9qZWN0aW9uQ2VudGVyLFxuICAgIGNhbWVyYVBvczogY2FtZXJhUG9zXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh2aWV3cG9ydCkge1xuICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZjIkbW9kZWxNYXRyaXggPSBfcmVmMi5tb2RlbE1hdHJpeCxcbiAgICAgIG1vZGVsTWF0cml4ID0gX3JlZjIkbW9kZWxNYXRyaXggPT09IHVuZGVmaW5lZCA/IG51bGwgOiBfcmVmMiRtb2RlbE1hdHJpeCxcbiAgICAgIF9yZWYyJHByb2plY3Rpb25Nb2RlID0gX3JlZjIucHJvamVjdGlvbk1vZGUsXG4gICAgICBwcm9qZWN0aW9uTW9kZSA9IF9yZWYyJHByb2plY3Rpb25Nb2RlID09PSB1bmRlZmluZWQgPyBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQgOiBfcmVmMiRwcm9qZWN0aW9uTW9kZSxcbiAgICAgIF9yZWYyJHBvc2l0aW9uT3JpZ2luID0gX3JlZjIucG9zaXRpb25PcmlnaW4sXG4gICAgICBwb3NpdGlvbk9yaWdpbiA9IF9yZWYyJHBvc2l0aW9uT3JpZ2luID09PSB1bmRlZmluZWQgPyBbMCwgMF0gOiBfcmVmMiRwb3NpdGlvbk9yaWdpbjtcblxuICBhc3NlcnQodmlld3BvcnQuc2NhbGUsICdWaWV3cG9ydCBzY2FsZSBtaXNzaW5nJyk7XG5cbiAgdmFyIF9jYWxjdWxhdGVNYXRyaXhBbmRPZiA9IGNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCh7IHByb2plY3Rpb25Nb2RlOiBwcm9qZWN0aW9uTW9kZSwgcG9zaXRpb25PcmlnaW46IHBvc2l0aW9uT3JpZ2luLCBtb2RlbE1hdHJpeDogbW9kZWxNYXRyaXgsIHZpZXdwb3J0OiB2aWV3cG9ydCB9KSxcbiAgICAgIHByb2plY3Rpb25DZW50ZXIgPSBfY2FsY3VsYXRlTWF0cml4QW5kT2YucHJvamVjdGlvbkNlbnRlcixcbiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBfY2FsY3VsYXRlTWF0cml4QW5kT2YubW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIGNhbWVyYVBvcyA9IF9jYWxjdWxhdGVNYXRyaXhBbmRPZi5jYW1lcmFQb3M7XG5cbiAgYXNzZXJ0KG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsICdWaWV3cG9ydCBtaXNzaW5nIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgnKTtcblxuICAvLyBDYWxjdWxhdGUgcHJvamVjdGlvbiBwaXhlbHMgcGVyIHVuaXRcbiAgdmFyIHByb2plY3Rpb25QaXhlbHNQZXJVbml0ID0gdmlld3BvcnQuZ2V0RGlzdGFuY2VTY2FsZXMoKS5waXhlbHNQZXJNZXRlcjtcbiAgYXNzZXJ0KHByb2plY3Rpb25QaXhlbHNQZXJVbml0LCAnVmlld3BvcnQgbWlzc2luZyBwaXhlbHNQZXJNZXRlcicpO1xuXG4gIC8vIGNhbGN1bGF0ZSBXZWJHTCBtYXRyaWNlc1xuXG4gIC8vIENvbnZlcnQgdG8gRmxvYXQzMlxuICB2YXIgZ2xQcm9qZWN0aW9uTWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICAvLyBcIkZsb2F0NjRBcnJheVwiXG4gIC8vIFRyYW5zcG9zZSB0aGUgcHJvamVjdGlvbiBtYXRyaXggdG8gY29sdW1uIG1ham9yIGZvciBHTFNMLlxuICB2YXIgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCA9IG5ldyBGbG9hdDMyQXJyYXkoMzIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgKytqKSB7XG4gICAgICB2YXIgX2ZwNjRpZnkgPSBmcDY0aWZ5KG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhbaiAqIDQgKyBpXSk7XG5cbiAgICAgIHZhciBfZnA2NGlmeTIgPSBfc2xpY2VkVG9BcnJheShfZnA2NGlmeSwgMik7XG5cbiAgICAgIGdsUHJvamVjdGlvbk1hdHJpeEZQNjRbKGkgKiA0ICsgaikgKiAyXSA9IF9mcDY0aWZ5MlswXTtcbiAgICAgIGdsUHJvamVjdGlvbk1hdHJpeEZQNjRbKGkgKiA0ICsgaikgKiAyICsgMV0gPSBfZnA2NGlmeTJbMV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBQcm9qZWN0aW9uIG1vZGUgdmFsdWVzXG4gICAgcHJvamVjdGlvbk1vZGU6IHByb2plY3Rpb25Nb2RlLFxuICAgIHByb2plY3Rpb25DZW50ZXI6IHByb2plY3Rpb25DZW50ZXIsXG5cbiAgICAvLyBtb2RlbE1hdHJpeDogbW9kZWxNYXRyaXggfHwgbmV3IE1hdHJpeDQoKS5pZGVudGl0eSgpLFxuXG4gICAgLy8gTWFpbiBwcm9qZWN0aW9uIG1hdHJpY2VzXG4gICAgcHJvamVjdGlvbk1hdHJpeDogZ2xQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkOiBnbFByb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkZQNjQ6IGdsUHJvamVjdGlvbk1hdHJpeEZQNjQsXG4gICAgcHJvamVjdGlvblBpeGVsc1BlclVuaXQ6IHByb2plY3Rpb25QaXhlbHNQZXJVbml0LFxuXG4gICAgLy8gVGhpcyBpcyB0aGUgbWVyY2F0b3Igc2NhbGUgKDIgKiogem9vbSlcbiAgICBwcm9qZWN0aW9uU2NhbGU6IHZpZXdwb3J0LnNjYWxlLFxuXG4gICAgLy8gRGVwcmVjYXRlZD9cbiAgICBwcm9qZWN0aW9uU2NhbGVGUDY0OiBmcDY0aWZ5KHZpZXdwb3J0LnNjYWxlKSxcblxuICAgIC8vIFRoaXMgaXMgZm9yIGxpZ2h0aW5nIGNhbGN1bGF0aW9uc1xuICAgIGNhbWVyYVBvczogbmV3IEZsb2F0MzJBcnJheShjYW1lcmFQb3MpXG5cbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdmlld3BvcnQtdW5pZm9ybXMuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 68 */
/* exports provided: default */
/*!****************************************************!*\
  !*** ./src/lib/viewports/orthographic-viewport.js ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(/*! ./viewport */ 9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\nvar OrthographicViewport = function (_Viewport) {\n  _inherits(OrthographicViewport, _Viewport);\n\n  function OrthographicViewport(_ref) {\n    var width = _ref.width,\n        height = _ref.height,\n        eye = _ref.eye,\n        _ref$lookAt = _ref.lookAt,\n        lookAt = _ref$lookAt === undefined ? [0, 0, 0] : _ref$lookAt,\n        _ref$up = _ref.up,\n        up = _ref$up === undefined ? [0, 1, 0] : _ref$up,\n        _ref$near = _ref.near,\n        near = _ref$near === undefined ? 1 : _ref$near,\n        _ref$far = _ref.far,\n        far = _ref$far === undefined ? 100 : _ref$far,\n        _ref$fovy = _ref.fovy,\n        fovy = _ref$fovy === undefined ? 75 : _ref$fovy,\n        left = _ref.left,\n        top = _ref.top,\n        _ref$right = _ref.right,\n        right = _ref$right === undefined ? null : _ref$right,\n        _ref$bottom = _ref.bottom,\n        bottom = _ref$bottom === undefined ? null : _ref$bottom;\n\n    _classCallCheck(this, OrthographicViewport);\n\n    right = Number.isFinite(right) ? right : left + width;\n    bottom = Number.isFinite(bottom) ? right : top + height;\n    return _possibleConstructorReturn(this, (OrthographicViewport.__proto__ || Object.getPrototypeOf(OrthographicViewport)).call(this, {\n      viewMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].lookAt([], eye, lookAt, up),\n      projectionMatrix: __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].ortho([], left, right, bottom, top, near, far),\n      width: width,\n      height: height\n    }));\n  }\n\n  return OrthographicViewport;\n}(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"a\" /* default */]);\n\n/* unused harmony default export */ var _unused_webpack_default_export = OrthographicViewport;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZpZXdwb3J0cy9vcnRob2dyYXBoaWMtdmlld3BvcnQuanM/MTkzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBWaWV3cG9ydCBmcm9tICcuL3ZpZXdwb3J0JztcbmltcG9ydCB7IG1hdDQgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG52YXIgT3J0aG9ncmFwaGljVmlld3BvcnQgPSBmdW5jdGlvbiAoX1ZpZXdwb3J0KSB7XG4gIF9pbmhlcml0cyhPcnRob2dyYXBoaWNWaWV3cG9ydCwgX1ZpZXdwb3J0KTtcblxuICBmdW5jdGlvbiBPcnRob2dyYXBoaWNWaWV3cG9ydChfcmVmKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICAgIGV5ZSA9IF9yZWYuZXllLFxuICAgICAgICBfcmVmJGxvb2tBdCA9IF9yZWYubG9va0F0LFxuICAgICAgICBsb29rQXQgPSBfcmVmJGxvb2tBdCA9PT0gdW5kZWZpbmVkID8gWzAsIDAsIDBdIDogX3JlZiRsb29rQXQsXG4gICAgICAgIF9yZWYkdXAgPSBfcmVmLnVwLFxuICAgICAgICB1cCA9IF9yZWYkdXAgPT09IHVuZGVmaW5lZCA/IFswLCAxLCAwXSA6IF9yZWYkdXAsXG4gICAgICAgIF9yZWYkbmVhciA9IF9yZWYubmVhcixcbiAgICAgICAgbmVhciA9IF9yZWYkbmVhciA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkbmVhcixcbiAgICAgICAgX3JlZiRmYXIgPSBfcmVmLmZhcixcbiAgICAgICAgZmFyID0gX3JlZiRmYXIgPT09IHVuZGVmaW5lZCA/IDEwMCA6IF9yZWYkZmFyLFxuICAgICAgICBfcmVmJGZvdnkgPSBfcmVmLmZvdnksXG4gICAgICAgIGZvdnkgPSBfcmVmJGZvdnkgPT09IHVuZGVmaW5lZCA/IDc1IDogX3JlZiRmb3Z5LFxuICAgICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgICAgX3JlZiRyaWdodCA9IF9yZWYucmlnaHQsXG4gICAgICAgIHJpZ2h0ID0gX3JlZiRyaWdodCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IF9yZWYkcmlnaHQsXG4gICAgICAgIF9yZWYkYm90dG9tID0gX3JlZi5ib3R0b20sXG4gICAgICAgIGJvdHRvbSA9IF9yZWYkYm90dG9tID09PSB1bmRlZmluZWQgPyBudWxsIDogX3JlZiRib3R0b207XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3J0aG9ncmFwaGljVmlld3BvcnQpO1xuXG4gICAgcmlnaHQgPSBOdW1iZXIuaXNGaW5pdGUocmlnaHQpID8gcmlnaHQgOiBsZWZ0ICsgd2lkdGg7XG4gICAgYm90dG9tID0gTnVtYmVyLmlzRmluaXRlKGJvdHRvbSkgPyByaWdodCA6IHRvcCArIGhlaWdodDtcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE9ydGhvZ3JhcGhpY1ZpZXdwb3J0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3J0aG9ncmFwaGljVmlld3BvcnQpKS5jYWxsKHRoaXMsIHtcbiAgICAgIHZpZXdNYXRyaXg6IG1hdDQubG9va0F0KFtdLCBleWUsIGxvb2tBdCwgdXApLFxuICAgICAgcHJvamVjdGlvbk1hdHJpeDogbWF0NC5vcnRobyhbXSwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gT3J0aG9ncmFwaGljVmlld3BvcnQ7XG59KFZpZXdwb3J0KTtcblxuZXhwb3J0IGRlZmF1bHQgT3J0aG9ncmFwaGljVmlld3BvcnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvbGliL3ZpZXdwb3J0cy9vcnRob2dyYXBoaWMtdmlld3BvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 69 */
/* exports provided: default */
/* exports used: default */
/*!****************************************************!*\
  !*** ./src/lib/viewports/web-mercator-viewport.js ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__viewport__ = __webpack_require__(/*! ./viewport */ 9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix__ = __webpack_require__(/*! gl-matrix */ 7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_gl_matrix___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_gl_matrix__);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// View and Projection Matrix calculations for mapbox-js style\n// map view properties\n\n\n\n// CONSTANTS\nvar PI = Math.PI;\nvar PI_4 = PI / 4;\nvar DEGREES_TO_RADIANS = PI / 180;\nvar RADIANS_TO_DEGREES = 180 / PI;\nvar TILE_SIZE = 512;\nvar WORLD_SCALE = TILE_SIZE / (2 * PI);\n\nvar DEFAULT_MAP_STATE = {\n  latitude: 37,\n  longitude: -122,\n  zoom: 11,\n  pitch: 0,\n  bearing: 0,\n  altitude: 1.5\n};\n\nvar WebMercatorViewport = function (_Viewport) {\n  _inherits(WebMercatorViewport, _Viewport);\n\n  /**\n   * @classdesc\n   * Creates view/projection matrices from mercator params\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   *\n   * @class\n   * @param {Object} opt - options\n   * @param {Boolean} mercator=true - Whether to use mercator projection\n   *\n   * @param {Number} opt.width=1 - Width of \"viewport\" or window\n   * @param {Number} opt.height=1 - Height of \"viewport\" or window\n   * @param {Array} opt.center=[0, 0] - Center of viewport\n   *   [longitude, latitude] or [x, y]\n   * @param {Number} opt.scale=1 - Either use scale or zoom\n   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)\n   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)\n   * @param {Number} opt.altitude= - Altitude of camera in screen units\n   *\n   * Web mercator projection short-hand parameters\n   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)\n    * Notes:\n   *  - Only one of center or [latitude, longitude] can be specified\n   *  - [latitude, longitude] can only be specified when \"mercator\" is true\n   *  - Altitude has a default value that matches assumptions in mapbox-gl\n   *  - width and height are forced to 1 if supplied as 0, to avoid\n   *    division by zero. This is intended to reduce the burden of apps to\n   *    to check values before instantiating a Viewport.\n   */\n  /* eslint-disable complexity, max-statements */\n  function WebMercatorViewport() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        width = _ref.width,\n        height = _ref.height,\n        latitude = _ref.latitude,\n        longitude = _ref.longitude,\n        zoom = _ref.zoom,\n        pitch = _ref.pitch,\n        bearing = _ref.bearing,\n        altitude = _ref.altitude,\n        mercatorEnabled = _ref.mercatorEnabled;\n\n    _classCallCheck(this, WebMercatorViewport);\n\n    // Viewport - support undefined arguments\n    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;\n    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;\n    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;\n    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;\n    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;\n    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;\n    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;\n    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;\n\n    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n    width = width || 1;\n    height = height || 1;\n\n    var scale = Math.pow(2, zoom);\n    // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n    altitude = Math.max(0.75, altitude);\n\n    var distanceScales = calculateDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });\n\n    var projectionMatrix = makeProjectionMatrixFromMercatorParams({\n      width: width,\n      height: height,\n      pitch: pitch,\n      bearing: bearing,\n      altitude: altitude\n    });\n\n    var _makeViewMatrixFromMe = makeViewMatrixFromMercatorParams({\n      width: width,\n      height: height,\n      longitude: longitude,\n      latitude: latitude,\n      zoom: zoom,\n      pitch: pitch,\n      bearing: bearing,\n      altitude: altitude,\n      distanceScales: distanceScales\n    }),\n        viewMatrix = _makeViewMatrixFromMe.viewMatrix,\n        viewMatrixUncentered = _makeViewMatrixFromMe.viewMatrixUncentered,\n        viewCenter = _makeViewMatrixFromMe.viewCenter;\n\n    // Add additional matrices\n    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix }));\n\n    _this.viewMatrixUncentered = viewMatrixUncentered;\n    _this.viewCenter = viewCenter;\n\n    // Save parameters\n    _this.latitude = latitude;\n    _this.longitude = longitude;\n    _this.zoom = zoom;\n    _this.pitch = pitch;\n    _this.bearing = bearing;\n    _this.altitude = altitude;\n\n    _this.scale = scale;\n\n    _this._distanceScales = distanceScales;\n\n    _this.getDistanceScales = _this.getDistanceScales.bind(_this);\n    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind(_this);\n    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind(_this);\n    _this.addMetersToLngLat = _this.addMetersToLngLat.bind(_this);\n    return _this;\n  }\n  /* eslint-enable complexity, max-statements */\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   *\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n\n\n  _createClass(WebMercatorViewport, [{\n    key: '_projectFlat',\n    value: function _projectFlat(lngLat) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n\n      return projectFlat(lngLat, scale);\n    }\n\n    /**\n     * Unproject world point [x,y] on map onto {lat, lon} on sphere\n     *\n     * @param {object|Vector} xy - object with {x,y} members\n     *  representing point on projected map plane\n     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n     *   Has toArray method if you need a GeoJSON Array.\n     *   Per cartographic tradition, lat and lon are specified as degrees.\n     */\n\n  }, {\n    key: '_unprojectFlat',\n    value: function _unprojectFlat(xy) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n\n      return unprojectFlat(xy, scale);\n    }\n  }, {\n    key: 'getDistanceScales',\n    value: function getDistanceScales() {\n      return this._distanceScales;\n    }\n\n    /**\n     * Converts a meter offset to a lnglat offset\n     *\n     * Note: Uses simple linear approximation around the viewport center\n     * Error increases with size of offset (roughly 1% per 100km)\n     *\n     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas\n     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas\n     */\n\n  }, {\n    key: 'metersToLngLatDelta',\n    value: function metersToLngLatDelta(xyz) {\n      var _xyz = _slicedToArray(xyz, 3),\n          x = _xyz[0],\n          y = _xyz[1],\n          _xyz$ = _xyz[2],\n          z = _xyz$ === undefined ? 0 : _xyz$;\n\n      var _distanceScales = this._distanceScales,\n          pixelsPerMeter = _distanceScales.pixelsPerMeter,\n          degreesPerPixel = _distanceScales.degreesPerPixel;\n\n      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];\n      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];\n      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];\n    }\n\n    /**\n     * Converts a lnglat offset to a meter offset\n     *\n     * Note: Uses simple linear approximation around the viewport center\n     * Error increases with size of offset (roughly 1% per 100km)\n     *\n     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas\n     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas\n     */\n\n  }, {\n    key: 'lngLatDeltaToMeters',\n    value: function lngLatDeltaToMeters(deltaLngLatZ) {\n      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),\n          deltaLng = _deltaLngLatZ[0],\n          deltaLat = _deltaLngLatZ[1],\n          _deltaLngLatZ$ = _deltaLngLatZ[2],\n          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;\n\n      var _distanceScales2 = this._distanceScales,\n          pixelsPerDegree = _distanceScales2.pixelsPerDegree,\n          metersPerPixel = _distanceScales2.metersPerPixel;\n\n      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];\n      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];\n      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];\n    }\n\n    /**\n     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array\n     *\n     * Note: Uses simple linear approximation around the viewport center\n     * Error increases with size of offset (roughly 1% per 100km)\n     *\n     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate\n     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas\n     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas\n     */\n\n  }, {\n    key: 'addMetersToLngLat',\n    value: function addMetersToLngLat(lngLatZ, xyz) {\n      var _lngLatZ = _slicedToArray(lngLatZ, 3),\n          lng = _lngLatZ[0],\n          lat = _lngLatZ[1],\n          _lngLatZ$ = _lngLatZ[2],\n          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;\n\n      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),\n          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),\n          deltaLng = _metersToLngLatDelta2[0],\n          deltaLat = _metersToLngLatDelta2[1],\n          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],\n          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;\n\n      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];\n    }\n\n    // INTERNAL METHODS\n\n  }, {\n    key: '_getParams',\n    value: function _getParams() {\n      return this._distanceScales;\n    }\n  }]);\n\n  return WebMercatorViewport;\n}(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"a\" /* default */]);\n\n/**\n * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n * Performs the nonlinear part of the web mercator projection.\n * Remaining projection is done with 4x4 matrices which also handles\n * perspective.\n *\n * @param {Array} lngLat - [lng, lat] coordinates\n *   Specifies a point on the sphere to project onto the map.\n * @return {Array} [x,y] coordinates.\n */\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = WebMercatorViewport;\nfunction projectFlat(_ref2, scale) {\n  var _ref3 = _slicedToArray(_ref2, 2),\n      lng = _ref3[0],\n      lat = _ref3[1];\n\n  scale = scale * WORLD_SCALE;\n  var lambda2 = lng * DEGREES_TO_RADIANS;\n  var phi2 = lat * DEGREES_TO_RADIANS;\n  var x = scale * (lambda2 + PI);\n  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5)));\n  return [x, y];\n}\n\n/**\n * Unproject world point [x,y] on map onto {lat, lon} on sphere\n *\n * @param {object|Vector} xy - object with {x,y} members\n *  representing point on projected map plane\n * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n *   Has toArray method if you need a GeoJSON Array.\n *   Per cartographic tradition, lat and lon are specified as degrees.\n */\nfunction unprojectFlat(_ref4, scale) {\n  var _ref5 = _slicedToArray(_ref4, 2),\n      x = _ref5[0],\n      y = _ref5[1];\n\n  scale = scale * WORLD_SCALE;\n  var lambda2 = x / scale - PI;\n  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\n\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\nfunction calculateDistanceScales(_ref6) {\n  var latitude = _ref6.latitude,\n      longitude = _ref6.longitude,\n      scale = _ref6.scale;\n\n  // Approximately 111km per degree at equator\n  var METERS_PER_DEGREE = 111000;\n\n  var latCosine = Math.cos(latitude * Math.PI / 180);\n\n  var metersPerDegree = METERS_PER_DEGREE * latCosine;\n\n  // Calculate number of pixels occupied by one degree longitude\n  // around current lat/lon\n  var pixelsPerDegreeX = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"vec2\"].distance(projectFlat([longitude + 0.5, latitude]), projectFlat([longitude - 0.5, latitude]));\n  // Calculate number of pixels occupied by one degree latitude\n  // around current lat/lon\n  var pixelsPerDegreeY = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"vec2\"].distance(projectFlat([longitude, latitude + 0.5]), projectFlat([longitude, latitude - 0.5]));\n\n  var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;\n  var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;\n  var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;\n  // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];\n\n  var worldSize = TILE_SIZE * scale;\n  var altPixelsPerMeter = worldSize / (4e7 * latCosine);\n  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];\n  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];\n\n  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];\n  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ];\n\n  // Main results, used for converting meters to latlng deltas and scaling offsets\n  return {\n    pixelsPerMeter: pixelsPerMeter,\n    metersPerPixel: metersPerPixel,\n    pixelsPerDegree: pixelsPerDegree,\n    degreesPerPixel: degreesPerPixel\n  };\n}\n\n// ATTRIBUTION:\n// view and projection matrix creation is intentionally kept compatible with\n// mapbox-gl's implementation to ensure that seamless interoperation\n// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js\nfunction makeProjectionMatrixFromMercatorParams(_ref7) {\n  var width = _ref7.width,\n      height = _ref7.height,\n      pitch = _ref7.pitch,\n      altitude = _ref7.altitude;\n\n  var pitchRadians = pitch * DEGREES_TO_RADIANS;\n\n  // PROJECTION MATRIX: PROJECTS FROM CAMERA SPACE TO CLIPSPACE\n  // Find the distance from the center point to the center top\n  // in altitude units using law of sines.\n  var halfFov = Math.atan(0.5 / altitude);\n  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);\n\n  // Calculate z value of the farthest fragment that should be rendered.\n  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;\n\n  var projectionMatrix = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].perspective(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"b\" /* createMat4 */])(), 2 * Math.atan(height / 2 / altitude), // fov in radians\n  width / height, // aspect ratio\n  0.1, // near plane\n  farZ * 10.0 // far plane\n  );\n\n  return projectionMatrix;\n}\n\nfunction makeViewMatrixFromMercatorParams(_ref8) {\n  var width = _ref8.width,\n      height = _ref8.height,\n      longitude = _ref8.longitude,\n      latitude = _ref8.latitude,\n      zoom = _ref8.zoom,\n      pitch = _ref8.pitch,\n      bearing = _ref8.bearing,\n      altitude = _ref8.altitude;\n\n  // Center x, y\n  var scale = Math.pow(2, zoom);\n  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE\n  // Note: As usual, matrix operation orders should be read in reverse\n  // since vectors will be multiplied from the right during transformation\n  var vm = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__viewport__[\"b\" /* createMat4 */])();\n\n  // Move camera to altitude\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].translate(vm, vm, [0, 0, -altitude]);\n\n  // After the rotateX, z values are in pixel units. Convert them to\n  // altitude units. 1 altitude unit = the screen height.\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].scale(vm, vm, [1, -1, 1 / height]);\n\n  // Rotate by bearing, and then by pitch (which tilts the view)\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);\n  __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS);\n\n  var _projectFlat2 = projectFlat([longitude, latitude], scale),\n      _projectFlat3 = _slicedToArray(_projectFlat2, 2),\n      centerX = _projectFlat3[0],\n      centerY = _projectFlat3[1];\n\n  var center = [-centerX, -centerY, 0, 1];\n  var viewCenter = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"vec4\"].transformMat4([], center, vm);\n\n  var vmCentered = __WEBPACK_IMPORTED_MODULE_1_gl_matrix__[\"mat4\"].translate([], vm, [-centerX, -centerY, 0]);\n\n  return {\n    viewMatrix: vmCentered,\n    viewMatrixUncentered: vm,\n    viewCenter: viewCenter\n  };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL3ZpZXdwb3J0cy93ZWItbWVyY2F0b3Itdmlld3BvcnQuanM/NTM2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gVmlldyBhbmQgUHJvamVjdGlvbiBNYXRyaXggY2FsY3VsYXRpb25zIGZvciBtYXBib3gtanMgc3R5bGVcbi8vIG1hcCB2aWV3IHByb3BlcnRpZXNcbmltcG9ydCBWaWV3cG9ydCwgeyBjcmVhdGVNYXQ0IH0gZnJvbSAnLi92aWV3cG9ydCc7XG5pbXBvcnQgeyBtYXQ0LCB2ZWM0LCB2ZWMyIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuLy8gQ09OU1RBTlRTXG52YXIgUEkgPSBNYXRoLlBJO1xudmFyIFBJXzQgPSBQSSAvIDQ7XG52YXIgREVHUkVFU19UT19SQURJQU5TID0gUEkgLyAxODA7XG52YXIgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG52YXIgVElMRV9TSVpFID0gNTEyO1xudmFyIFdPUkxEX1NDQUxFID0gVElMRV9TSVpFIC8gKDIgKiBQSSk7XG5cbnZhciBERUZBVUxUX01BUF9TVEFURSA9IHtcbiAgbGF0aXR1ZGU6IDM3LFxuICBsb25naXR1ZGU6IC0xMjIsXG4gIHpvb206IDExLFxuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxudmFyIFdlYk1lcmNhdG9yVmlld3BvcnQgPSBmdW5jdGlvbiAoX1ZpZXdwb3J0KSB7XG4gIF9pbmhlcml0cyhXZWJNZXJjYXRvclZpZXdwb3J0LCBfVmlld3BvcnQpO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIENyZWF0ZXMgdmlldy9wcm9qZWN0aW9uIG1hdHJpY2VzIGZyb20gbWVyY2F0b3IgcGFyYW1zXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1lcmNhdG9yPXRydWUgLSBXaGV0aGVyIHRvIHVzZSBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQud2lkdGg9MSAtIFdpZHRoIG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5oZWlnaHQ9MSAtIEhlaWdodCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wdC5jZW50ZXI9WzAsIDBdIC0gQ2VudGVyIG9mIHZpZXdwb3J0XG4gICAqICAgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIG9yIFt4LCB5XVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnNjYWxlPTEgLSBFaXRoZXIgdXNlIHNjYWxlIG9yIHpvb21cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5waXRjaD0wIC0gQ2FtZXJhIGFuZ2xlIGluIGRlZ3JlZXMgKDAgaXMgc3RyYWlnaHQgZG93bilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5iZWFyaW5nPTAgLSBNYXAgcm90YXRpb24gaW4gZGVncmVlcyAoMCBtZWFucyBub3J0aCBpcyB1cClcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5hbHRpdHVkZT0gLSBBbHRpdHVkZSBvZiBjYW1lcmEgaW4gc2NyZWVuIHVuaXRzXG4gICAqXG4gICAqIFdlYiBtZXJjYXRvciBwcm9qZWN0aW9uIHNob3J0LWhhbmQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxhdGl0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sb25naXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0Lnpvb20gLSBTY2FsZSA9IE1hdGgucG93KDIsem9vbSkgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuc2NhbGUpXG4gICAgKiBOb3RlczpcbiAgICogIC0gT25seSBvbmUgb2YgY2VudGVyIG9yIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBjYW4gYmUgc3BlY2lmaWVkXG4gICAqICAtIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBjYW4gb25seSBiZSBzcGVjaWZpZWQgd2hlbiBcIm1lcmNhdG9yXCIgaXMgdHJ1ZVxuICAgKiAgLSBBbHRpdHVkZSBoYXMgYSBkZWZhdWx0IHZhbHVlIHRoYXQgbWF0Y2hlcyBhc3N1bXB0aW9ucyBpbiBtYXBib3gtZ2xcbiAgICogIC0gd2lkdGggYW5kIGhlaWdodCBhcmUgZm9yY2VkIHRvIDEgaWYgc3VwcGxpZWQgYXMgMCwgdG8gYXZvaWRcbiAgICogICAgZGl2aXNpb24gYnkgemVyby4gVGhpcyBpcyBpbnRlbmRlZCB0byByZWR1Y2UgdGhlIGJ1cmRlbiBvZiBhcHBzIHRvXG4gICAqICAgIHRvIGNoZWNrIHZhbHVlcyBiZWZvcmUgaW5zdGFudGlhdGluZyBhIFZpZXdwb3J0LlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cbiAgZnVuY3Rpb24gV2ViTWVyY2F0b3JWaWV3cG9ydCgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICAgIGxhdGl0dWRlID0gX3JlZi5sYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlID0gX3JlZi5sb25naXR1ZGUsXG4gICAgICAgIHpvb20gPSBfcmVmLnpvb20sXG4gICAgICAgIHBpdGNoID0gX3JlZi5waXRjaCxcbiAgICAgICAgYmVhcmluZyA9IF9yZWYuYmVhcmluZyxcbiAgICAgICAgYWx0aXR1ZGUgPSBfcmVmLmFsdGl0dWRlLFxuICAgICAgICBtZXJjYXRvckVuYWJsZWQgPSBfcmVmLm1lcmNhdG9yRW5hYmxlZDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJNZXJjYXRvclZpZXdwb3J0KTtcblxuICAgIC8vIFZpZXdwb3J0IC0gc3VwcG9ydCB1bmRlZmluZWQgYXJndW1lbnRzXG4gICAgd2lkdGggPSB3aWR0aCAhPT0gdW5kZWZpbmVkID8gd2lkdGggOiBERUZBVUxUX01BUF9TVEFURS53aWR0aDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IERFRkFVTFRfTUFQX1NUQVRFLmhlaWdodDtcbiAgICB6b29tID0gem9vbSAhPT0gdW5kZWZpbmVkID8gem9vbSA6IERFRkFVTFRfTUFQX1NUQVRFLnpvb207XG4gICAgbGF0aXR1ZGUgPSBsYXRpdHVkZSAhPT0gdW5kZWZpbmVkID8gbGF0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sYXRpdHVkZTtcbiAgICBsb25naXR1ZGUgPSBsb25naXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxvbmdpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmxvbmdpdHVkZTtcbiAgICBiZWFyaW5nID0gYmVhcmluZyAhPT0gdW5kZWZpbmVkID8gYmVhcmluZyA6IERFRkFVTFRfTUFQX1NUQVRFLmJlYXJpbmc7XG4gICAgcGl0Y2ggPSBwaXRjaCAhPT0gdW5kZWZpbmVkID8gcGl0Y2ggOiBERUZBVUxUX01BUF9TVEFURS5waXRjaDtcbiAgICBhbHRpdHVkZSA9IGFsdGl0dWRlICE9PSB1bmRlZmluZWQgPyBhbHRpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmFsdGl0dWRlO1xuXG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMCB0byBmYWNpbGl0YXRlIGlzb21vcnBoaWMgcmVuZGVyIGV0Y1xuICAgIHdpZHRoID0gd2lkdGggfHwgMTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMTtcblxuICAgIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgIC8vIEFsdGl0dWRlIC0gcHJldmVudCBkaXZpc2lvbiBieSAwXG4gICAgLy8gVE9ETyAtIGp1c3QgdGhyb3cgYW4gRXJyb3IgaW5zdGVhZD9cbiAgICBhbHRpdHVkZSA9IE1hdGgubWF4KDAuNzUsIGFsdGl0dWRlKTtcblxuICAgIHZhciBkaXN0YW5jZVNjYWxlcyA9IGNhbGN1bGF0ZURpc3RhbmNlU2NhbGVzKHsgbGF0aXR1ZGU6IGxhdGl0dWRlLCBsb25naXR1ZGU6IGxvbmdpdHVkZSwgc2NhbGU6IHNjYWxlIH0pO1xuXG4gICAgdmFyIHByb2plY3Rpb25NYXRyaXggPSBtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBpdGNoOiBwaXRjaCxcbiAgICAgIGJlYXJpbmc6IGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZTogYWx0aXR1ZGVcbiAgICB9KTtcblxuICAgIHZhciBfbWFrZVZpZXdNYXRyaXhGcm9tTWUgPSBtYWtlVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgICAgem9vbTogem9vbSxcbiAgICAgIHBpdGNoOiBwaXRjaCxcbiAgICAgIGJlYXJpbmc6IGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZTogYWx0aXR1ZGUsXG4gICAgICBkaXN0YW5jZVNjYWxlczogZGlzdGFuY2VTY2FsZXNcbiAgICB9KSxcbiAgICAgICAgdmlld01hdHJpeCA9IF9tYWtlVmlld01hdHJpeEZyb21NZS52aWV3TWF0cml4LFxuICAgICAgICB2aWV3TWF0cml4VW5jZW50ZXJlZCA9IF9tYWtlVmlld01hdHJpeEZyb21NZS52aWV3TWF0cml4VW5jZW50ZXJlZCxcbiAgICAgICAgdmlld0NlbnRlciA9IF9tYWtlVmlld01hdHJpeEZyb21NZS52aWV3Q2VudGVyO1xuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgbWF0cmljZXNcbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoV2ViTWVyY2F0b3JWaWV3cG9ydC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFdlYk1lcmNhdG9yVmlld3BvcnQpKS5jYWxsKHRoaXMsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgdmlld01hdHJpeDogdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeDogcHJvamVjdGlvbk1hdHJpeCB9KSk7XG5cbiAgICBfdGhpcy52aWV3TWF0cml4VW5jZW50ZXJlZCA9IHZpZXdNYXRyaXhVbmNlbnRlcmVkO1xuICAgIF90aGlzLnZpZXdDZW50ZXIgPSB2aWV3Q2VudGVyO1xuXG4gICAgLy8gU2F2ZSBwYXJhbWV0ZXJzXG4gICAgX3RoaXMubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgICBfdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgX3RoaXMuem9vbSA9IHpvb207XG4gICAgX3RoaXMucGl0Y2ggPSBwaXRjaDtcbiAgICBfdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICBfdGhpcy5hbHRpdHVkZSA9IGFsdGl0dWRlO1xuXG4gICAgX3RoaXMuc2NhbGUgPSBzY2FsZTtcblxuICAgIF90aGlzLl9kaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzO1xuXG4gICAgX3RoaXMuZ2V0RGlzdGFuY2VTY2FsZXMgPSBfdGhpcy5nZXREaXN0YW5jZVNjYWxlcy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhID0gX3RoaXMubWV0ZXJzVG9MbmdMYXREZWx0YS5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5sbmdMYXREZWx0YVRvTWV0ZXJzID0gX3RoaXMubG5nTGF0RGVsdGFUb01ldGVycy5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5hZGRNZXRlcnNUb0xuZ0xhdCA9IF90aGlzLmFkZE1ldGVyc1RvTG5nTGF0LmJpbmQoX3RoaXMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhXZWJNZXJjYXRvclZpZXdwb3J0LCBbe1xuICAgIGtleTogJ19wcm9qZWN0RmxhdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9qZWN0RmxhdChsbmdMYXQpIHtcbiAgICAgIHZhciBzY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zY2FsZTtcblxuICAgICAgcmV0dXJuIHByb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICAgKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICAgICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ191bnByb2plY3RGbGF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VucHJvamVjdEZsYXQoeHkpIHtcbiAgICAgIHZhciBzY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zY2FsZTtcblxuICAgICAgcmV0dXJuIHVucHJvamVjdEZsYXQoeHksIHNjYWxlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXREaXN0YW5jZVNjYWxlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlU2NhbGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbWV0ZXIgb2Zmc2V0IHRvIGEgbG5nbGF0IG9mZnNldFxuICAgICAqXG4gICAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgLSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWV0ZXJzVG9MbmdMYXREZWx0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ldGVyc1RvTG5nTGF0RGVsdGEoeHl6KSB7XG4gICAgICB2YXIgX3h5eiA9IF9zbGljZWRUb0FycmF5KHh5eiwgMyksXG4gICAgICAgICAgeCA9IF94eXpbMF0sXG4gICAgICAgICAgeSA9IF94eXpbMV0sXG4gICAgICAgICAgX3h5eiQgPSBfeHl6WzJdLFxuICAgICAgICAgIHogPSBfeHl6JCA9PT0gdW5kZWZpbmVkID8gMCA6IF94eXokO1xuXG4gICAgICB2YXIgX2Rpc3RhbmNlU2NhbGVzID0gdGhpcy5fZGlzdGFuY2VTY2FsZXMsXG4gICAgICAgICAgcGl4ZWxzUGVyTWV0ZXIgPSBfZGlzdGFuY2VTY2FsZXMucGl4ZWxzUGVyTWV0ZXIsXG4gICAgICAgICAgZGVncmVlc1BlclBpeGVsID0gX2Rpc3RhbmNlU2NhbGVzLmRlZ3JlZXNQZXJQaXhlbDtcblxuICAgICAgdmFyIGRlbHRhTG5nID0geCAqIHBpeGVsc1Blck1ldGVyWzBdICogZGVncmVlc1BlclBpeGVsWzBdO1xuICAgICAgdmFyIGRlbHRhTGF0ID0geSAqIHBpeGVsc1Blck1ldGVyWzFdICogZGVncmVlc1BlclBpeGVsWzFdO1xuICAgICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbZGVsdGFMbmcsIGRlbHRhTGF0XSA6IFtkZWx0YUxuZywgZGVsdGFMYXQsIHpdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbG5nbGF0IG9mZnNldCB0byBhIG1ldGVyIG9mZnNldFxuICAgICAqXG4gICAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBkZWx0YUxuZ0xhdFogLSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbG5nTGF0RGVsdGFUb01ldGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxuZ0xhdERlbHRhVG9NZXRlcnMoZGVsdGFMbmdMYXRaKSB7XG4gICAgICB2YXIgX2RlbHRhTG5nTGF0WiA9IF9zbGljZWRUb0FycmF5KGRlbHRhTG5nTGF0WiwgMyksXG4gICAgICAgICAgZGVsdGFMbmcgPSBfZGVsdGFMbmdMYXRaWzBdLFxuICAgICAgICAgIGRlbHRhTGF0ID0gX2RlbHRhTG5nTGF0WlsxXSxcbiAgICAgICAgICBfZGVsdGFMbmdMYXRaJCA9IF9kZWx0YUxuZ0xhdFpbMl0sXG4gICAgICAgICAgZGVsdGFaID0gX2RlbHRhTG5nTGF0WiQgPT09IHVuZGVmaW5lZCA/IDAgOiBfZGVsdGFMbmdMYXRaJDtcblxuICAgICAgdmFyIF9kaXN0YW5jZVNjYWxlczIgPSB0aGlzLl9kaXN0YW5jZVNjYWxlcyxcbiAgICAgICAgICBwaXhlbHNQZXJEZWdyZWUgPSBfZGlzdGFuY2VTY2FsZXMyLnBpeGVsc1BlckRlZ3JlZSxcbiAgICAgICAgICBtZXRlcnNQZXJQaXhlbCA9IF9kaXN0YW5jZVNjYWxlczIubWV0ZXJzUGVyUGl4ZWw7XG5cbiAgICAgIHZhciBkZWx0YVggPSBkZWx0YUxuZyAqIHBpeGVsc1BlckRlZ3JlZVswXSAqIG1ldGVyc1BlclBpeGVsWzBdO1xuICAgICAgdmFyIGRlbHRhWSA9IGRlbHRhTGF0ICogcGl4ZWxzUGVyRGVncmVlWzFdICogbWV0ZXJzUGVyUGl4ZWxbMV07XG4gICAgICByZXR1cm4gZGVsdGFMbmdMYXRaLmxlbmd0aCA9PT0gMiA/IFtkZWx0YVgsIGRlbHRhWV0gOiBbZGVsdGFYLCBkZWx0YVksIGRlbHRhWl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbWV0ZXIgZGVsdGEgdG8gYSBiYXNlIGxuZ2xhdCBjb29yZGluYXRlLCByZXR1cm5pbmcgYSBuZXcgbG5nbGF0IGFycmF5XG4gICAgICpcbiAgICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGxuZ0xhdFogLSBiYXNlIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZE1ldGVyc1RvTG5nTGF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTWV0ZXJzVG9MbmdMYXQobG5nTGF0WiwgeHl6KSB7XG4gICAgICB2YXIgX2xuZ0xhdFogPSBfc2xpY2VkVG9BcnJheShsbmdMYXRaLCAzKSxcbiAgICAgICAgICBsbmcgPSBfbG5nTGF0WlswXSxcbiAgICAgICAgICBsYXQgPSBfbG5nTGF0WlsxXSxcbiAgICAgICAgICBfbG5nTGF0WiQgPSBfbG5nTGF0WlsyXSxcbiAgICAgICAgICBaID0gX2xuZ0xhdFokID09PSB1bmRlZmluZWQgPyAwIDogX2xuZ0xhdFokO1xuXG4gICAgICB2YXIgX21ldGVyc1RvTG5nTGF0RGVsdGEgPSB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEoeHl6KSxcbiAgICAgICAgICBfbWV0ZXJzVG9MbmdMYXREZWx0YTIgPSBfc2xpY2VkVG9BcnJheShfbWV0ZXJzVG9MbmdMYXREZWx0YSwgMyksXG4gICAgICAgICAgZGVsdGFMbmcgPSBfbWV0ZXJzVG9MbmdMYXREZWx0YTJbMF0sXG4gICAgICAgICAgZGVsdGFMYXQgPSBfbWV0ZXJzVG9MbmdMYXREZWx0YTJbMV0sXG4gICAgICAgICAgX21ldGVyc1RvTG5nTGF0RGVsdGEzID0gX21ldGVyc1RvTG5nTGF0RGVsdGEyWzJdLFxuICAgICAgICAgIGRlbHRhWiA9IF9tZXRlcnNUb0xuZ0xhdERlbHRhMyA9PT0gdW5kZWZpbmVkID8gMCA6IF9tZXRlcnNUb0xuZ0xhdERlbHRhMztcblxuICAgICAgcmV0dXJuIGxuZ0xhdFoubGVuZ3RoID09PSAyID8gW2xuZyArIGRlbHRhTG5nLCBsYXQgKyBkZWx0YUxhdF0gOiBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0LCBaICsgZGVsdGFaXTtcbiAgICB9XG5cbiAgICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgfSwge1xuICAgIGtleTogJ19nZXRQYXJhbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UGFyYW1zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJNZXJjYXRvclZpZXdwb3J0O1xufShWaWV3cG9ydCk7XG5cbi8qKlxuICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICogcGVyc3BlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgV2ViTWVyY2F0b3JWaWV3cG9ydDtcbmZ1bmN0aW9uIHByb2plY3RGbGF0KF9yZWYyLCBzY2FsZSkge1xuICB2YXIgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMiksXG4gICAgICBsbmcgPSBfcmVmM1swXSxcbiAgICAgIGxhdCA9IF9yZWYzWzFdO1xuXG4gIHNjYWxlID0gc2NhbGUgKiBXT1JMRF9TQ0FMRTtcbiAgdmFyIGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIHZhciBwaGkyID0gbGF0ICogREVHUkVFU19UT19SQURJQU5TO1xuICB2YXIgeCA9IHNjYWxlICogKGxhbWJkYTIgKyBQSSk7XG4gIHZhciB5ID0gc2NhbGUgKiAoUEkgLSBNYXRoLmxvZyhNYXRoLnRhbihQSV80ICsgcGhpMiAqIDAuNSkpKTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLyoqXG4gKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAqXG4gKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICovXG5mdW5jdGlvbiB1bnByb2plY3RGbGF0KF9yZWY0LCBzY2FsZSkge1xuICB2YXIgX3JlZjUgPSBfc2xpY2VkVG9BcnJheShfcmVmNCwgMiksXG4gICAgICB4ID0gX3JlZjVbMF0sXG4gICAgICB5ID0gX3JlZjVbMV07XG5cbiAgc2NhbGUgPSBzY2FsZSAqIFdPUkxEX1NDQUxFO1xuICB2YXIgbGFtYmRhMiA9IHggLyBzY2FsZSAtIFBJO1xuICB2YXIgcGhpMiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKFBJIC0geSAvIHNjYWxlKSkgLSBQSV80KTtcbiAgcmV0dXJuIFtsYW1iZGEyICogUkFESUFOU19UT19ERUdSRUVTLCBwaGkyICogUkFESUFOU19UT19ERUdSRUVTXTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZGlzdGFuY2Ugc2NhbGVzIGluIG1ldGVycyBhcm91bmQgY3VycmVudCBsYXQvbG9uLCBib3RoIGZvclxuICogZGVncmVlcyBhbmQgcGl4ZWxzLlxuICogSW4gbWVyY2F0b3IgcHJvamVjdGlvbiBtb2RlLCB0aGUgZGlzdGFuY2Ugc2NhbGVzIHZhcnkgc2lnbmlmaWNhbnRseVxuICogd2l0aCBsYXRpdHVkZS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2VTY2FsZXMoX3JlZjYpIHtcbiAgdmFyIGxhdGl0dWRlID0gX3JlZjYubGF0aXR1ZGUsXG4gICAgICBsb25naXR1ZGUgPSBfcmVmNi5sb25naXR1ZGUsXG4gICAgICBzY2FsZSA9IF9yZWY2LnNjYWxlO1xuXG4gIC8vIEFwcHJveGltYXRlbHkgMTExa20gcGVyIGRlZ3JlZSBhdCBlcXVhdG9yXG4gIHZhciBNRVRFUlNfUEVSX0RFR1JFRSA9IDExMTAwMDtcblxuICB2YXIgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBNYXRoLlBJIC8gMTgwKTtcblxuICB2YXIgbWV0ZXJzUGVyRGVncmVlID0gTUVURVJTX1BFUl9ERUdSRUUgKiBsYXRDb3NpbmU7XG5cbiAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgb25lIGRlZ3JlZSBsb25naXR1ZGVcbiAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICB2YXIgcGl4ZWxzUGVyRGVncmVlWCA9IHZlYzIuZGlzdGFuY2UocHJvamVjdEZsYXQoW2xvbmdpdHVkZSArIDAuNSwgbGF0aXR1ZGVdKSwgcHJvamVjdEZsYXQoW2xvbmdpdHVkZSAtIDAuNSwgbGF0aXR1ZGVdKSk7XG4gIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgbGF0aXR1ZGVcbiAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICB2YXIgcGl4ZWxzUGVyRGVncmVlWSA9IHZlYzIuZGlzdGFuY2UocHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGUgKyAwLjVdKSwgcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGUgLSAwLjVdKSk7XG5cbiAgdmFyIHBpeGVsc1Blck1ldGVyWCA9IHBpeGVsc1BlckRlZ3JlZVggLyBtZXRlcnNQZXJEZWdyZWU7XG4gIHZhciBwaXhlbHNQZXJNZXRlclkgPSBwaXhlbHNQZXJEZWdyZWVZIC8gbWV0ZXJzUGVyRGVncmVlO1xuICB2YXIgcGl4ZWxzUGVyTWV0ZXJaID0gKHBpeGVsc1Blck1ldGVyWCArIHBpeGVsc1Blck1ldGVyWSkgLyAyO1xuICAvLyBjb25zdCBwaXhlbHNQZXJNZXRlciA9IFtwaXhlbHNQZXJNZXRlclgsIHBpeGVsc1Blck1ldGVyWSwgcGl4ZWxzUGVyTWV0ZXJaXTtcblxuICB2YXIgd29ybGRTaXplID0gVElMRV9TSVpFICogc2NhbGU7XG4gIHZhciBhbHRQaXhlbHNQZXJNZXRlciA9IHdvcmxkU2l6ZSAvICg0ZTcgKiBsYXRDb3NpbmUpO1xuICB2YXIgcGl4ZWxzUGVyTWV0ZXIgPSBbYWx0UGl4ZWxzUGVyTWV0ZXIsIGFsdFBpeGVsc1Blck1ldGVyLCBhbHRQaXhlbHNQZXJNZXRlcl07XG4gIHZhciBtZXRlcnNQZXJQaXhlbCA9IFsxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBhbHRQaXhlbHNQZXJNZXRlciwgMSAvIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgdmFyIHBpeGVsc1BlckRlZ3JlZSA9IFtwaXhlbHNQZXJEZWdyZWVYLCBwaXhlbHNQZXJEZWdyZWVZLCBwaXhlbHNQZXJNZXRlclpdO1xuICB2YXIgZGVncmVlc1BlclBpeGVsID0gWzEgLyBwaXhlbHNQZXJEZWdyZWVYLCAxIC8gcGl4ZWxzUGVyRGVncmVlWSwgMSAvIHBpeGVsc1Blck1ldGVyWl07XG5cbiAgLy8gTWFpbiByZXN1bHRzLCB1c2VkIGZvciBjb252ZXJ0aW5nIG1ldGVycyB0byBsYXRsbmcgZGVsdGFzIGFuZCBzY2FsaW5nIG9mZnNldHNcbiAgcmV0dXJuIHtcbiAgICBwaXhlbHNQZXJNZXRlcjogcGl4ZWxzUGVyTWV0ZXIsXG4gICAgbWV0ZXJzUGVyUGl4ZWw6IG1ldGVyc1BlclBpeGVsLFxuICAgIHBpeGVsc1BlckRlZ3JlZTogcGl4ZWxzUGVyRGVncmVlLFxuICAgIGRlZ3JlZXNQZXJQaXhlbDogZGVncmVlc1BlclBpeGVsXG4gIH07XG59XG5cbi8vIEFUVFJJQlVUSU9OOlxuLy8gdmlldyBhbmQgcHJvamVjdGlvbiBtYXRyaXggY3JlYXRpb24gaXMgaW50ZW50aW9uYWxseSBrZXB0IGNvbXBhdGlibGUgd2l0aFxuLy8gbWFwYm94LWdsJ3MgaW1wbGVtZW50YXRpb24gdG8gZW5zdXJlIHRoYXQgc2VhbWxlc3MgaW50ZXJvcGVyYXRpb25cbi8vIHdpdGggbWFwYm94IGFuZCByZWFjdC1tYXAtZ2wuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanNcbmZ1bmN0aW9uIG1ha2VQcm9qZWN0aW9uTWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKF9yZWY3KSB7XG4gIHZhciB3aWR0aCA9IF9yZWY3LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZjcuaGVpZ2h0LFxuICAgICAgcGl0Y2ggPSBfcmVmNy5waXRjaCxcbiAgICAgIGFsdGl0dWRlID0gX3JlZjcuYWx0aXR1ZGU7XG5cbiAgdmFyIHBpdGNoUmFkaWFucyA9IHBpdGNoICogREVHUkVFU19UT19SQURJQU5TO1xuXG4gIC8vIFBST0pFQ1RJT04gTUFUUklYOiBQUk9KRUNUUyBGUk9NIENBTUVSQSBTUEFDRSBUTyBDTElQU1BBQ0VcbiAgLy8gRmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHBvaW50IHRvIHRoZSBjZW50ZXIgdG9wXG4gIC8vIGluIGFsdGl0dWRlIHVuaXRzIHVzaW5nIGxhdyBvZiBzaW5lcy5cbiAgdmFyIGhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gYWx0aXR1ZGUpO1xuICB2YXIgdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSA9IE1hdGguc2luKGhhbGZGb3YpICogYWx0aXR1ZGUgLyBNYXRoLnNpbihNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucyAtIGhhbGZGb3YpO1xuXG4gIC8vIENhbGN1bGF0ZSB6IHZhbHVlIG9mIHRoZSBmYXJ0aGVzdCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgdmFyIGZhclogPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucykgKiB0b3BIYWxmU3VyZmFjZURpc3RhbmNlICsgYWx0aXR1ZGU7XG5cbiAgdmFyIHByb2plY3Rpb25NYXRyaXggPSBtYXQ0LnBlcnNwZWN0aXZlKGNyZWF0ZU1hdDQoKSwgMiAqIE1hdGguYXRhbihoZWlnaHQgLyAyIC8gYWx0aXR1ZGUpLCAvLyBmb3YgaW4gcmFkaWFuc1xuICB3aWR0aCAvIGhlaWdodCwgLy8gYXNwZWN0IHJhdGlvXG4gIDAuMSwgLy8gbmVhciBwbGFuZVxuICBmYXJaICogMTAuMCAvLyBmYXIgcGxhbmVcbiAgKTtcblxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cblxuZnVuY3Rpb24gbWFrZVZpZXdNYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoX3JlZjgpIHtcbiAgdmFyIHdpZHRoID0gX3JlZjgud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmOC5oZWlnaHQsXG4gICAgICBsb25naXR1ZGUgPSBfcmVmOC5sb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSA9IF9yZWY4LmxhdGl0dWRlLFxuICAgICAgem9vbSA9IF9yZWY4Lnpvb20sXG4gICAgICBwaXRjaCA9IF9yZWY4LnBpdGNoLFxuICAgICAgYmVhcmluZyA9IF9yZWY4LmJlYXJpbmcsXG4gICAgICBhbHRpdHVkZSA9IF9yZWY4LmFsdGl0dWRlO1xuXG4gIC8vIENlbnRlciB4LCB5XG4gIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAvLyBWSUVXIE1BVFJJWDogUFJPSkVDVFMgRlJPTSBWSVJUVUFMIFBJWEVMUyBUTyBDQU1FUkEgU1BBQ0VcbiAgLy8gTm90ZTogQXMgdXN1YWwsIG1hdHJpeCBvcGVyYXRpb24gb3JkZXJzIHNob3VsZCBiZSByZWFkIGluIHJldmVyc2VcbiAgLy8gc2luY2UgdmVjdG9ycyB3aWxsIGJlIG11bHRpcGxpZWQgZnJvbSB0aGUgcmlnaHQgZHVyaW5nIHRyYW5zZm9ybWF0aW9uXG4gIHZhciB2bSA9IGNyZWF0ZU1hdDQoKTtcblxuICAvLyBNb3ZlIGNhbWVyYSB0byBhbHRpdHVkZVxuICBtYXQ0LnRyYW5zbGF0ZSh2bSwgdm0sIFswLCAwLCAtYWx0aXR1ZGVdKTtcblxuICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICBtYXQ0LnNjYWxlKHZtLCB2bSwgWzEsIC0xLCAxIC8gaGVpZ2h0XSk7XG5cbiAgLy8gUm90YXRlIGJ5IGJlYXJpbmcsIGFuZCB0aGVuIGJ5IHBpdGNoICh3aGljaCB0aWx0cyB0aGUgdmlldylcbiAgbWF0NC5yb3RhdGVYKHZtLCB2bSwgcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0LnJvdGF0ZVoodm0sIHZtLCAtYmVhcmluZyAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG5cbiAgdmFyIF9wcm9qZWN0RmxhdDIgPSBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHNjYWxlKSxcbiAgICAgIF9wcm9qZWN0RmxhdDMgPSBfc2xpY2VkVG9BcnJheShfcHJvamVjdEZsYXQyLCAyKSxcbiAgICAgIGNlbnRlclggPSBfcHJvamVjdEZsYXQzWzBdLFxuICAgICAgY2VudGVyWSA9IF9wcm9qZWN0RmxhdDNbMV07XG5cbiAgdmFyIGNlbnRlciA9IFstY2VudGVyWCwgLWNlbnRlclksIDAsIDFdO1xuICB2YXIgdmlld0NlbnRlciA9IHZlYzQudHJhbnNmb3JtTWF0NChbXSwgY2VudGVyLCB2bSk7XG5cbiAgdmFyIHZtQ2VudGVyZWQgPSBtYXQ0LnRyYW5zbGF0ZShbXSwgdm0sIFstY2VudGVyWCwgLWNlbnRlclksIDBdKTtcblxuICByZXR1cm4ge1xuICAgIHZpZXdNYXRyaXg6IHZtQ2VudGVyZWQsXG4gICAgdmlld01hdHJpeFVuY2VudGVyZWQ6IHZtLFxuICAgIHZpZXdDZW50ZXI6IHZpZXdDZW50ZXJcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9saWIvdmlld3BvcnRzL3dlYi1tZXJjYXRvci12aWV3cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 70 */
/* exports provided: default */
/* exports used: default */
/*!*************************************!*\
  !*** ./src/react/webgl-renderer.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(/*! react */ 35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__autobind__ = __webpack_require__(/*! ./autobind */ 30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_luma_gl__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global window */\n\n\n\n/* global requestAnimationFrame, cancelAnimationFrame */\n\nvar DEFAULT_PIXEL_RATIO = typeof window !== 'undefined' && window.devicePixelRatio || 1;\n\nvar propTypes = {\n  id: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].string.isRequired,\n\n  width: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  height: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number.isRequired,\n  style: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n\n  pixelRatio: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].number,\n  viewport: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object.isRequired,\n  events: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  gl: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  glOptions: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].object,\n  debug: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].bool,\n\n  onInitializationFailed: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onRendererInitialized: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func.isRequired,\n  onRenderFrame: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onMouseMove: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func,\n  onClick: __WEBPACK_IMPORTED_MODULE_0_react__[\"PropTypes\"].func\n};\n\nvar defaultProps = {\n  style: {},\n  gl: null,\n  glOptions: { preserveDrawingBuffer: true },\n  debug: false,\n  pixelRatio: DEFAULT_PIXEL_RATIO,\n\n  onInitializationFailed: function onInitializationFailed(error) {\n    throw error;\n  },\n  onRendererInitialized: function onRendererInitialized() {},\n  onRenderFrame: function onRenderFrame() {}\n};\n\nvar WebGLRenderer = function (_React$Component) {\n  _inherits(WebGLRenderer, _React$Component);\n\n  /**\n   * @classdesc\n   * Small react component that uses Luma.GL to initialize a WebGL context.\n   *\n   * Returns a canvas, creates a basic WebGL context\n   * sets up a renderloop, and registers some basic event handlers\n   *\n   * @class\n   * @param {Object} props - see propTypes documentation\n   */\n  function WebGLRenderer(props) {\n    _classCallCheck(this, WebGLRenderer);\n\n    var _this = _possibleConstructorReturn(this, (WebGLRenderer.__proto__ || Object.getPrototypeOf(WebGLRenderer)).call(this, props));\n\n    _this.state = {};\n    _this._animationFrame = null;\n    _this.gl = null;\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__autobind__[\"a\" /* default */])(_this);\n    return _this;\n  }\n\n  _createClass(WebGLRenderer, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var canvas = this.refs.overlay;\n      this._initWebGL(canvas);\n      this._animationLoop();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this._cancelAnimationLoop();\n    }\n\n    /**\n     * Initialize LumaGL library and through it WebGL\n     * @param {string} canvas\n     */\n\n  }, {\n    key: '_initWebGL',\n    value: function _initWebGL(canvas) {\n      var _props = this.props,\n          debug = _props.debug,\n          glOptions = _props.glOptions;\n\n      // Create context if not supplied\n\n      var gl = this.props.gl;\n      if (!gl) {\n        try {\n          gl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_luma_gl__[\"createGLContext\"])(Object.assign({ canvas: canvas, debug: debug }, glOptions));\n        } catch (error) {\n          this.props.onInitializationFailed(error);\n          return;\n        }\n      }\n\n      this.gl = gl;\n\n      // Call callback last, in case it throws\n      this.props.onRendererInitialized({ canvas: canvas, gl: gl });\n    }\n\n    /**\n     * Main WebGL animation loop\n     */\n\n  }, {\n    key: '_animationLoop',\n    value: function _animationLoop() {\n      this._renderFrame();\n      // Keep registering ourselves for the next animation frame\n      if (typeof window !== 'undefined') {\n        this._animationFrame = requestAnimationFrame(this._animationLoop);\n      }\n    }\n  }, {\n    key: '_cancelAnimationLoop',\n    value: function _cancelAnimationLoop() {\n      if (this._animationFrame) {\n        cancelAnimationFrame(this._animationFrame);\n      }\n    }\n\n    // Updates WebGL viewport to latest props\n    // for clean logging, only calls gl.viewport if props have changed\n\n  }, {\n    key: '_updateGLViewport',\n    value: function _updateGLViewport() {\n      var _props$viewport = this.props.viewport,\n          x = _props$viewport.x,\n          y = _props$viewport.y,\n          w = _props$viewport.width,\n          h = _props$viewport.height;\n      var dpr = this.props.pixelRatio;\n      var gl = this.gl;\n\n\n      x = x * dpr;\n      y = y * dpr;\n      w = w * dpr;\n      h = h * dpr;\n\n      if (x !== this.x || y !== this.y || w !== this.w || h !== this.h) {\n        gl.viewport(x, y, w, h);\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n      }\n    }\n  }, {\n    key: '_renderFrame',\n    value: function _renderFrame() {\n      var _props$viewport2 = this.props.viewport,\n          width = _props$viewport2.width,\n          height = _props$viewport2.height;\n      var gl = this.gl;\n\n      // Check for reasons not to draw\n\n      if (!gl || !(width > 0) || !(height > 0)) {\n        return;\n      }\n\n      this._updateGLViewport();\n\n      // Call render callback\n      this.props.onRenderFrame({ gl: gl });\n\n      this.props.onAfterRender(this.refs.overlay);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props2 = this.props,\n          id = _props2.id,\n          width = _props2.width,\n          height = _props2.height,\n          pixelRatio = _props2.pixelRatio,\n          style = _props2.style;\n\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_react__[\"createElement\"])('canvas', {\n        ref: 'overlay',\n        key: 'overlay',\n        id: id,\n        width: width * pixelRatio,\n        height: height * pixelRatio,\n        style: Object.assign({}, style, { width: width, height: height })\n      });\n    }\n  }]);\n\n  return WebGLRenderer;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = WebGLRenderer;\n\n\nWebGLRenderer.propTypes = propTypes;\nWebGLRenderer.defaultProps = defaultProps;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVhY3Qvd2ViZ2wtcmVuZGVyZXIuanM/Njk0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8vIENvcHlyaWdodCAoYykgMjAxNSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBSZWFjdCwgeyBQcm9wVHlwZXMsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi9hdXRvYmluZCc7XG5pbXBvcnQgeyBjcmVhdGVHTENvbnRleHQgfSBmcm9tICdsdW1hLmdsJztcbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lICovXG5cbnZhciBERUZBVUxUX1BJWEVMX1JBVElPID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxudmFyIHByb3BUeXBlcyA9IHtcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgcGl4ZWxSYXRpbzogUHJvcFR5cGVzLm51bWJlcixcbiAgdmlld3BvcnQ6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgZXZlbnRzOiBQcm9wVHlwZXMub2JqZWN0LFxuICBnbDogUHJvcFR5cGVzLm9iamVjdCxcbiAgZ2xPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxuICBkZWJ1ZzogUHJvcFR5cGVzLmJvb2wsXG5cbiAgb25Jbml0aWFsaXphdGlvbkZhaWxlZDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uUmVuZGVyZXJJbml0aWFsaXplZDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgb25SZW5kZXJGcmFtZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VNb3ZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIHN0eWxlOiB7fSxcbiAgZ2w6IG51bGwsXG4gIGdsT3B0aW9uczogeyBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUgfSxcbiAgZGVidWc6IGZhbHNlLFxuICBwaXhlbFJhdGlvOiBERUZBVUxUX1BJWEVMX1JBVElPLFxuXG4gIG9uSW5pdGlhbGl6YXRpb25GYWlsZWQ6IGZ1bmN0aW9uIG9uSW5pdGlhbGl6YXRpb25GYWlsZWQoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSxcbiAgb25SZW5kZXJlckluaXRpYWxpemVkOiBmdW5jdGlvbiBvblJlbmRlcmVySW5pdGlhbGl6ZWQoKSB7fSxcbiAgb25SZW5kZXJGcmFtZTogZnVuY3Rpb24gb25SZW5kZXJGcmFtZSgpIHt9XG59O1xuXG52YXIgV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhXZWJHTFJlbmRlcmVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBTbWFsbCByZWFjdCBjb21wb25lbnQgdGhhdCB1c2VzIEx1bWEuR0wgdG8gaW5pdGlhbGl6ZSBhIFdlYkdMIGNvbnRleHQuXG4gICAqXG4gICAqIFJldHVybnMgYSBjYW52YXMsIGNyZWF0ZXMgYSBiYXNpYyBXZWJHTCBjb250ZXh0XG4gICAqIHNldHMgdXAgYSByZW5kZXJsb29wLCBhbmQgcmVnaXN0ZXJzIHNvbWUgYmFzaWMgZXZlbnQgaGFuZGxlcnNcbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIHNlZSBwcm9wVHlwZXMgZG9jdW1lbnRhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gV2ViR0xSZW5kZXJlcihwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTFJlbmRlcmVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChXZWJHTFJlbmRlcmVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoV2ViR0xSZW5kZXJlcikpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge307XG4gICAgX3RoaXMuX2FuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgICBfdGhpcy5nbCA9IG51bGw7XG4gICAgYXV0b2JpbmQoX3RoaXMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXZWJHTFJlbmRlcmVyLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5yZWZzLm92ZXJsYXk7XG4gICAgICB0aGlzLl9pbml0V2ViR0woY2FudmFzKTtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkxvb3AoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uTG9vcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgTHVtYUdMIGxpYnJhcnkgYW5kIHRocm91Z2ggaXQgV2ViR0xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ19pbml0V2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdFdlYkdMKGNhbnZhcykge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZGVidWcgPSBfcHJvcHMuZGVidWcsXG4gICAgICAgICAgZ2xPcHRpb25zID0gX3Byb3BzLmdsT3B0aW9ucztcblxuICAgICAgLy8gQ3JlYXRlIGNvbnRleHQgaWYgbm90IHN1cHBsaWVkXG5cbiAgICAgIHZhciBnbCA9IHRoaXMucHJvcHMuZ2w7XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2wgPSBjcmVhdGVHTENvbnRleHQoT2JqZWN0LmFzc2lnbih7IGNhbnZhczogY2FudmFzLCBkZWJ1ZzogZGVidWcgfSwgZ2xPcHRpb25zKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5wcm9wcy5vbkluaXRpYWxpemF0aW9uRmFpbGVkKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgICAvLyBDYWxsIGNhbGxiYWNrIGxhc3QsIGluIGNhc2UgaXQgdGhyb3dzXG4gICAgICB0aGlzLnByb3BzLm9uUmVuZGVyZXJJbml0aWFsaXplZCh7IGNhbnZhczogY2FudmFzLCBnbDogZ2wgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFpbiBXZWJHTCBhbmltYXRpb24gbG9vcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfYW5pbWF0aW9uTG9vcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hbmltYXRpb25Mb29wKCkge1xuICAgICAgdGhpcy5fcmVuZGVyRnJhbWUoKTtcbiAgICAgIC8vIEtlZXAgcmVnaXN0ZXJpbmcgb3Vyc2VsdmVzIGZvciB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWVcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9hbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25Mb29wKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY2FuY2VsQW5pbWF0aW9uTG9vcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYW5jZWxBbmltYXRpb25Mb29wKCkge1xuICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGVzIFdlYkdMIHZpZXdwb3J0IHRvIGxhdGVzdCBwcm9wc1xuICAgIC8vIGZvciBjbGVhbiBsb2dnaW5nLCBvbmx5IGNhbGxzIGdsLnZpZXdwb3J0IGlmIHByb3BzIGhhdmUgY2hhbmdlZFxuXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlR0xWaWV3cG9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVHTFZpZXdwb3J0KCkge1xuICAgICAgdmFyIF9wcm9wcyR2aWV3cG9ydCA9IHRoaXMucHJvcHMudmlld3BvcnQsXG4gICAgICAgICAgeCA9IF9wcm9wcyR2aWV3cG9ydC54LFxuICAgICAgICAgIHkgPSBfcHJvcHMkdmlld3BvcnQueSxcbiAgICAgICAgICB3ID0gX3Byb3BzJHZpZXdwb3J0LndpZHRoLFxuICAgICAgICAgIGggPSBfcHJvcHMkdmlld3BvcnQuaGVpZ2h0O1xuICAgICAgdmFyIGRwciA9IHRoaXMucHJvcHMucGl4ZWxSYXRpbztcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cblxuICAgICAgeCA9IHggKiBkcHI7XG4gICAgICB5ID0geSAqIGRwcjtcbiAgICAgIHcgPSB3ICogZHByO1xuICAgICAgaCA9IGggKiBkcHI7XG5cbiAgICAgIGlmICh4ICE9PSB0aGlzLnggfHwgeSAhPT0gdGhpcy55IHx8IHcgIT09IHRoaXMudyB8fCBoICE9PSB0aGlzLmgpIHtcbiAgICAgICAgZ2wudmlld3BvcnQoeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgICAgIHRoaXMuaCA9IGg7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlckZyYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckZyYW1lKCkge1xuICAgICAgdmFyIF9wcm9wcyR2aWV3cG9ydDIgPSB0aGlzLnByb3BzLnZpZXdwb3J0LFxuICAgICAgICAgIHdpZHRoID0gX3Byb3BzJHZpZXdwb3J0Mi53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfcHJvcHMkdmlld3BvcnQyLmhlaWdodDtcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgIC8vIENoZWNrIGZvciByZWFzb25zIG5vdCB0byBkcmF3XG5cbiAgICAgIGlmICghZ2wgfHwgISh3aWR0aCA+IDApIHx8ICEoaGVpZ2h0ID4gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVHTFZpZXdwb3J0KCk7XG5cbiAgICAgIC8vIENhbGwgcmVuZGVyIGNhbGxiYWNrXG4gICAgICB0aGlzLnByb3BzLm9uUmVuZGVyRnJhbWUoeyBnbDogZ2wgfSk7XG5cbiAgICAgIHRoaXMucHJvcHMub25BZnRlclJlbmRlcih0aGlzLnJlZnMub3ZlcmxheSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGlkID0gX3Byb3BzMi5pZCxcbiAgICAgICAgICB3aWR0aCA9IF9wcm9wczIud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3Byb3BzMi5oZWlnaHQsXG4gICAgICAgICAgcGl4ZWxSYXRpbyA9IF9wcm9wczIucGl4ZWxSYXRpbyxcbiAgICAgICAgICBzdHlsZSA9IF9wcm9wczIuc3R5bGU7XG5cbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdjYW52YXMnLCB7XG4gICAgICAgIHJlZjogJ292ZXJsYXknLFxuICAgICAgICBrZXk6ICdvdmVybGF5JyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB3aWR0aDogd2lkdGggKiBwaXhlbFJhdGlvLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIHBpeGVsUmF0aW8sXG4gICAgICAgIHN0eWxlOiBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViR0xSZW5kZXJlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgV2ViR0xSZW5kZXJlcjtcblxuXG5XZWJHTFJlbmRlcmVyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbldlYkdMUmVuZGVyZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3JlYWN0L3dlYmdsLXJlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 71 */
/* exports provided: checkRendererVendor, getPlatformShaderDefines, assembleShaders */
/* exports used: assembleShaders */
/*!**********************************************!*\
  !*** ./src/shader-utils/assemble-shaders.js ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl__ = __webpack_require__(/*! luma.gl */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_luma_gl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_luma_gl__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_chunks__ = __webpack_require__(/*! ./shader-chunks */ 31);\n/* unused harmony export checkRendererVendor */\n/* unused harmony export getPlatformShaderDefines */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = assembleShaders;\n\n\n// Load shader chunks\n// import SHADER_CHUNKS from '../../dist/shaderlib/shader-chunks';\n\n\nfunction checkRendererVendor(debugInfo, gpuVendor) {\n  var vendor = debugInfo.vendor,\n      renderer = debugInfo.renderer;\n\n  var result = void 0;\n  switch (gpuVendor) {\n    case 'nvidia':\n      result = vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i);\n      break;\n    case 'intel':\n      result = vendor.match(/INTEL/i) || renderer.match(/INTEL/i);\n      break;\n    case 'amd':\n      result = vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i);\n      break;\n    default:\n      result = false;\n  }\n  return result;\n}\n\nfunction getPlatformShaderDefines(gl) {\n  /* eslint-disable */\n  var platformDefines = '';\n  var debugInfo = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_luma_gl__[\"glGetDebugInfo\"])(gl);\n\n  if (checkRendererVendor(debugInfo, 'nvidia')) {\n    platformDefines += '#define NVIDIA_GPU\\n#define NVIDIA_FP64_WORKAROUND 1\\n#define NVIDIA_EQUATION_WORKAROUND 1\\n';\n  } else if (checkRendererVendor(debugInfo, 'intel')) {\n    platformDefines += '#define INTEL_GPU\\n#define INTEL_FP64_WORKAROUND 1\\n#define NVIDIA_EQUATION_WORKAROUND 1\\n #define INTEL_TAN_WORKAROUND 1\\n';\n  } else if (checkRendererVendor(debugInfo, 'amd')) {\n    platformDefines += '#define AMD_GPU\\n';\n  } else {\n    platformDefines += '#define DEFAULT_GPU\\n';\n  }\n\n  return platformDefines;\n}\n\nfunction assembleShader(gl) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _opts = opts,\n      vs = _opts.vs,\n      _opts$project = _opts.project,\n      project = _opts$project === undefined ? true : _opts$project,\n      _opts$project2 = _opts.project64,\n      project64 = _opts$project2 === undefined ? false : _opts$project2;\n  var _opts2 = opts,\n      _opts2$fp = _opts2.fp64,\n      fp64 = _opts2$fp === undefined ? false : _opts2$fp;\n\n  if (project64 === true) {\n    fp64 = true;\n  }\n  var source = getPlatformShaderDefines(gl) + '\\n';\n  opts = Object.assign({}, opts, { project: project, project64: project64, fp64: fp64 });\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Object.keys(__WEBPACK_IMPORTED_MODULE_1__shader_chunks__)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var chunkName = _step.value;\n\n      if (opts[chunkName]) {\n        source += __WEBPACK_IMPORTED_MODULE_1__shader_chunks__[chunkName].source + '\\n';\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = (opts.modules || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _chunkName = _step2.value;\n\n      if (__WEBPACK_IMPORTED_MODULE_1__shader_chunks__[_chunkName]) {\n        source += __WEBPACK_IMPORTED_MODULE_1__shader_chunks__[_chunkName].source + '\\n';\n      } else {\n        throw new Error('Shader module ' + _chunkName + ' not found');\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  source += vs;\n  return source;\n}\n\nfunction assembleShaders(gl, opts) {\n  return {\n    gl: gl,\n    vs: assembleShader(gl, opts),\n    fs: opts.fs\n  };\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVyLXV0aWxzL2Fzc2VtYmxlLXNoYWRlcnMuanM/NGM1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnbEdldERlYnVnSW5mbyB9IGZyb20gJ2x1bWEuZ2wnO1xuXG4vLyBMb2FkIHNoYWRlciBjaHVua3Ncbi8vIGltcG9ydCBTSEFERVJfQ0hVTktTIGZyb20gJy4uLy4uL2Rpc3Qvc2hhZGVybGliL3NoYWRlci1jaHVua3MnO1xuaW1wb3J0ICogYXMgU0hBREVSX0NIVU5LUyBmcm9tICcuL3NoYWRlci1jaHVua3MnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZW5kZXJlclZlbmRvcihkZWJ1Z0luZm8sIGdwdVZlbmRvcikge1xuICB2YXIgdmVuZG9yID0gZGVidWdJbmZvLnZlbmRvcixcbiAgICAgIHJlbmRlcmVyID0gZGVidWdJbmZvLnJlbmRlcmVyO1xuXG4gIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gIHN3aXRjaCAoZ3B1VmVuZG9yKSB7XG4gICAgY2FzZSAnbnZpZGlhJzpcbiAgICAgIHJlc3VsdCA9IHZlbmRvci5tYXRjaCgvTlZJRElBL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9OVklESUEvaSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnRlbCc6XG4gICAgICByZXN1bHQgPSB2ZW5kb3IubWF0Y2goL0lOVEVML2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9JTlRFTC9pKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FtZCc6XG4gICAgICByZXN1bHQgPSB2ZW5kb3IubWF0Y2goL0FNRC9pKSB8fCByZW5kZXJlci5tYXRjaCgvQU1EL2kpIHx8IHZlbmRvci5tYXRjaCgvQVRJL2kpIHx8IHJlbmRlcmVyLm1hdGNoKC9BVEkvaSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyhnbCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICB2YXIgcGxhdGZvcm1EZWZpbmVzID0gJyc7XG4gIHZhciBkZWJ1Z0luZm8gPSBnbEdldERlYnVnSW5mbyhnbCk7XG5cbiAgaWYgKGNoZWNrUmVuZGVyZXJWZW5kb3IoZGVidWdJbmZvLCAnbnZpZGlhJykpIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gJyNkZWZpbmUgTlZJRElBX0dQVVxcbiNkZWZpbmUgTlZJRElBX0ZQNjRfV09SS0FST1VORCAxXFxuI2RlZmluZSBOVklESUFfRVFVQVRJT05fV09SS0FST1VORCAxXFxuJztcbiAgfSBlbHNlIGlmIChjaGVja1JlbmRlcmVyVmVuZG9yKGRlYnVnSW5mbywgJ2ludGVsJykpIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gJyNkZWZpbmUgSU5URUxfR1BVXFxuI2RlZmluZSBJTlRFTF9GUDY0X1dPUktBUk9VTkQgMVxcbiNkZWZpbmUgTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQgMVxcbiAjZGVmaW5lIElOVEVMX1RBTl9XT1JLQVJPVU5EIDFcXG4nO1xuICB9IGVsc2UgaWYgKGNoZWNrUmVuZGVyZXJWZW5kb3IoZGVidWdJbmZvLCAnYW1kJykpIHtcbiAgICBwbGF0Zm9ybURlZmluZXMgKz0gJyNkZWZpbmUgQU1EX0dQVVxcbic7XG4gIH0gZWxzZSB7XG4gICAgcGxhdGZvcm1EZWZpbmVzICs9ICcjZGVmaW5lIERFRkFVTFRfR1BVXFxuJztcbiAgfVxuXG4gIHJldHVybiBwbGF0Zm9ybURlZmluZXM7XG59XG5cbmZ1bmN0aW9uIGFzc2VtYmxlU2hhZGVyKGdsKSB7XG4gIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9vcHRzID0gb3B0cyxcbiAgICAgIHZzID0gX29wdHMudnMsXG4gICAgICBfb3B0cyRwcm9qZWN0ID0gX29wdHMucHJvamVjdCxcbiAgICAgIHByb2plY3QgPSBfb3B0cyRwcm9qZWN0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogX29wdHMkcHJvamVjdCxcbiAgICAgIF9vcHRzJHByb2plY3QyID0gX29wdHMucHJvamVjdDY0LFxuICAgICAgcHJvamVjdDY0ID0gX29wdHMkcHJvamVjdDIgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdHMkcHJvamVjdDI7XG4gIHZhciBfb3B0czIgPSBvcHRzLFxuICAgICAgX29wdHMyJGZwID0gX29wdHMyLmZwNjQsXG4gICAgICBmcDY0ID0gX29wdHMyJGZwID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRzMiRmcDtcblxuICBpZiAocHJvamVjdDY0ID09PSB0cnVlKSB7XG4gICAgZnA2NCA9IHRydWU7XG4gIH1cbiAgdmFyIHNvdXJjZSA9IGdldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyhnbCkgKyAnXFxuJztcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHsgcHJvamVjdDogcHJvamVjdCwgcHJvamVjdDY0OiBwcm9qZWN0NjQsIGZwNjQ6IGZwNjQgfSk7XG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKFNIQURFUl9DSFVOS1MpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGNodW5rTmFtZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAob3B0c1tjaHVua05hbWVdKSB7XG4gICAgICAgIHNvdXJjZSArPSBTSEFERVJfQ0hVTktTW2NodW5rTmFtZV0uc291cmNlICsgJ1xcbic7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSAob3B0cy5tb2R1bGVzIHx8IFtdKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgdmFyIF9jaHVua05hbWUgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgIGlmIChTSEFERVJfQ0hVTktTW19jaHVua05hbWVdKSB7XG4gICAgICAgIHNvdXJjZSArPSBTSEFERVJfQ0hVTktTW19jaHVua05hbWVdLnNvdXJjZSArICdcXG4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkZXIgbW9kdWxlICcgKyBfY2h1bmtOYW1lICsgJyBub3QgZm91bmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZSArPSB2cztcbiAgcmV0dXJuIHNvdXJjZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlU2hhZGVycyhnbCwgb3B0cykge1xuICByZXR1cm4ge1xuICAgIGdsOiBnbCxcbiAgICB2czogYXNzZW1ibGVTaGFkZXIoZ2wsIG9wdHMpLFxuICAgIGZzOiBvcHRzLmZzXG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVyLXV0aWxzL2Fzc2VtYmxlLXNoYWRlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 72 */
/* exports provided: fp64 */
/* exports used: fp64 */
/*!*************************************!*\
  !*** ./src/shaderlib/fp64/index.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return fp64; });\n\n\nvar fp64 = {\n  interface: 'fp64',\n  source: '// Copyright (c) 2016 Uber Technologies, Inc.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \"Software\"), to deal\\n// in the Software without restriction, including without limitation the rights\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n// copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n// THE SOFTWARE.\\nuniform float ONE;\\n\\nconst vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\\n\\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\\n\\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\\n\\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!\\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!\\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!\\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!\\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!\\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!\\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!\\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!\\n\\nfloat nint(float d) {\\n    if (d == floor(d)) return d;\\n    return floor(d + 0.5);\\n}\\n\\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\\nvec2 split(float a) {\\n  const float SPLIT = 4097.0;\\n  float t = a * SPLIT;\\n  float a_hi = t * ONE - (t - a);\\n  float a_lo = a * ONE - a_hi;\\n  return vec2(a_hi, a_lo);\\n}\\n#else\\nvec2 split(float a) {\\n  const float SPLIT = 4097.0;\\n  float t = a * SPLIT;\\n  float a_hi = t - (t - a);\\n  float a_lo = a - a_hi;\\n  return vec2(a_hi, a_lo);\\n}\\n#endif\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\nvec2 quickTwoSum(float a, float b) {\\n  float sum = (a + b) * ONE;\\n  float err = b - (sum - a) * ONE;\\n  return vec2(sum, err);\\n}\\n#else\\nvec2 quickTwoSum(float a, float b) {\\n  float sum = a + b;\\n  float err = b - (sum - a);\\n  return vec2(sum, err);\\n}\\n#endif\\n\\nvec2 nint_fp64(vec2 a) {\\n    float hi = nint(a.x);\\n    float lo;\\n    vec2 tmp;\\n    if (hi == a.x) {\\n        lo = nint(a.y);\\n        tmp = quickTwoSum(hi, lo);\\n    } else {\\n        lo = 0.0;\\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\\n            hi -= 1.0;\\n        }\\n        tmp = vec2(hi, lo);\\n    }\\n    return tmp;\\n}\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\n\\n/* The purpose of this workaround is to prevent compilers from\\noptimizing away necessary arithmetic operations by swapping their sequences\\nor transform the equation to some \\'equivalent\\' from.\\n\\nThe method is to multiply an artifical variable, ONE, which will be known to\\nthe compiler to be one only at the runtime. The whole expression is then represented\\nas a polynomial with respective to ONE. In the coefficients of all terms, only one a\\nand one b should appear\\n\\nerr = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE\\n*/\\n\\nvec2 twoSum(float a, float b) {\\n  float s = (a + b);\\n  float v = (s * ONE - a) * ONE;\\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\\n  return vec2(s, err);\\n}\\n#else\\nvec2 twoSum(float a, float b) {\\n  float s = a + b;\\n  float v = s - a;\\n  float err = (a - (s - v)) + (b - v);\\n  return vec2(s, err);\\n}\\n#endif\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\n/* Same thing as in twoSum() */\\nvec2 twoSub(float a, float b) {\\n  float s = (a - b);\\n  float v = (s * ONE - a) * ONE;\\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\\n  return vec2(s, err);\\n}\\n#else\\nvec2 twoSub(float a, float b) {\\n  float s = a - b;\\n  float v = s - a;\\n  float err = (a - (s - v)) - (b + v);\\n  return vec2(s, err);\\n}\\n#endif\\n\\nvec2 twoProd(float a, float b) {\\n  float prod = a * b;\\n  vec2 a_fp64 = split(a);\\n  vec2 b_fp64 = split(b);\\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\\n  return vec2(prod, err);\\n}\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\nvec2 twoSqr(float a) {\\n  float prod = a * a;\\n  vec2 a_fp64 = split(a);\\n\\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x * a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\\n  return vec2(prod, err);\\n}\\n#else\\nvec2 twoSqr(float a) {\\n  float prod = a * a;\\n  vec2 a_fp64 = split(a);\\n\\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\\n  return vec2(prod, err);\\n}\\n#endif\\n\\nvec2 sum_fp64(vec2 a, vec2 b) {\\n  vec2 s, t;\\n  s = twoSum(a.x, b.x);\\n  t = twoSum(a.y, b.y);\\n  s.y += t.x;\\n  s = quickTwoSum(s.x, s.y);\\n  s.y += t.y;\\n  s = quickTwoSum(s.x, s.y);\\n  return s;\\n}\\n\\nvec2 sub_fp64(vec2 a, vec2 b) {\\n  vec2 s, t;\\n  s = twoSub(a.x, b.x);\\n  t = twoSub(a.y, b.y);\\n  s.y += t.x;\\n  s = quickTwoSum(s.x, s.y);\\n  s.y += t.y;\\n  s = quickTwoSum(s.x, s.y);\\n  return s;\\n}\\n\\nvec2 mul_fp64(vec2 a, vec2 b) {\\n  vec2 prod = twoProd(a.x, b.x);\\n  // y component is for the error\\n  prod.y += a.x * b.y;\\n  prod.y += a.y * b.x;\\n  prod = quickTwoSum(prod.x, prod.y);\\n  return prod;\\n}\\n\\nvec2 div_fp64(vec2 a, vec2 b) {\\n  float xn = 1.0 / b.x;\\n  vec2 yn = a * xn;\\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\\n  vec2 prod = twoProd(xn, diff);\\n  return sum_fp64(yn, prod);\\n}\\n\\nvec2 sqrt_fp64(vec2 a) {\\n\\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\\n\\n  float x = 1.0 / sqrt(a.x);\\n  float yn = a.x * x;\\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\\n  vec2 yn_sqr = twoSqr(yn) * ONE;\\n#else\\n  vec2 yn_sqr = twoSqr(yn);\\n#endif\\n  float diff = sub_fp64(a, yn_sqr).x;\\n  vec2 prod = twoProd(x * 0.5, diff);\\n  return sum_fp64(vec2(yn, 0.0), prod);\\n}\\n\\n/* k_power controls how much range reduction we would like to have\\nRange reduction uses the following method:\\nassume a = k_power * r + m * log(2), k and m being integers.\\nSet k_power = 4 (we can choose other k to trade accuracy with performance.\\nwe only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;\\n*/\\n\\nvec2 exp_fp64(vec2 a) {\\n  // We need to make sure these two numbers match\\n  // as bit-wise shift is not available in GLSL 1.0\\n  const int k_power = 4;\\n  const float k = 16.0;\\n\\n  const float inv_k = 1.0 / k;\\n\\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\\n\\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\\n  vec2 s, t, p;\\n\\n  p = mul_fp64(r, r);\\n  s = sum_fp64(r, p * 0.5);\\n  p = mul_fp64(p, r);\\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\\n\\n  s = sum_fp64(s, t);\\n  p = mul_fp64(p, r);\\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\\n\\n  s = sum_fp64(s, t);\\n  p = mul_fp64(p, r);\\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\\n\\n  // s = sum_fp64(s, t);\\n  // p = mul_fp64(p, r);\\n  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);\\n\\n  // s = sum_fp64(s, t);\\n  // p = mul_fp64(p, r);\\n  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);\\n\\n  s = sum_fp64(s, t);\\n\\n\\n  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.\\n  for (int i = 0; i < k_power; i++) {\\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\\n  }\\n\\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\\n  s = sum_fp64(s, vec2(ONE, 0.0));\\n#else\\n  s = sum_fp64(s, vec2(1.0, 0.0));\\n#endif\\n\\n  return s * pow(2.0, m);\\n//   return r;\\n}\\n\\nvec2 log_fp64(vec2 a)\\n{\\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\\n  vec2 x = vec2(log(a.x), 0.0);\\n  vec2 s;\\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\\n  s = vec2(ONE, 0.0);\\n#else\\n  s = vec2(1.0, 0.0);\\n#endif\\n\\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\\n  return x;\\n}\\n\\nvec2 sin_taylor_fp64(vec2 a) {\\n  vec2 r, s, t, x;\\n\\n  if (a.x == 0.0 && a.y == 0.0) {\\n    return vec2(0.0, 0.0);\\n  }\\n\\n  x = -mul_fp64(a, a);\\n  s = a;\\n  r = a;\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\\n  s = sum_fp64(s, t);\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\\n  s = sum_fp64(s, t);\\n\\n  /* keep the following commented code in case we need them\\n  for extra accuracy from the Taylor expansion*/\\n\\n  // r = mul_fp64(r, x);\\n  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);\\n  // s = sum_fp64(s, t);\\n\\n  // r = mul_fp64(r, x);\\n  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);\\n  // s = sum_fp64(s, t);\\n\\n  return s;\\n}\\n\\nvec2 cos_taylor_fp64(vec2 a) {\\n  vec2 r, s, t, x;\\n\\n  if (a.x == 0.0 && a.y == 0.0) {\\n    return vec2(1.0, 0.0);\\n  }\\n\\n  x = -mul_fp64(a, a);\\n  r = x;\\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\\n  s = sum_fp64(s, t);\\n\\n  r = mul_fp64(r, x);\\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\\n  s = sum_fp64(s, t);\\n\\n  /* keep the following commented code in case we need them\\n  for extra accuracy from the Taylor expansion*/\\n\\n  // r = mul_fp64(r, x);\\n  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);\\n  // s = sum_fp64(s, t);\\n\\n  // r = mul_fp64(r, x);\\n  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);\\n  // s = sum_fp64(s, t);\\n\\n  return s;\\n}\\n\\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\\n  if (a.x == 0.0 && a.y == 0.0) {\\n    sin_t = vec2(0.0, 0.0);\\n    cos_t = vec2(1.0, 0.0);\\n  }\\n\\n  sin_t = sin_taylor_fp64(a);\\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\\n}\\n\\nvec2 sin_fp64(vec2 a) {\\n    if (a.x == 0.0 && a.y == 0.0) {\\n        return vec2(0.0, 0.0);\\n    }\\n\\n    // 2pi range reduction\\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\\n\\n    vec2 t;\\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\\n    int j = int(q);\\n\\n    if (j < -2 || j > 2) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    }\\n\\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\\n\\n    q = floor(t.x / PI_16_FP64.x + 0.5);\\n    int k = int(q);\\n\\n    if (k == 0) {\\n        if (j == 0) {\\n            return sin_taylor_fp64(t);\\n        } else if (j == 1) {\\n            return cos_taylor_fp64(t);\\n        } else if (j == -1) {\\n            return -cos_taylor_fp64(t);\\n        } else {\\n            return -sin_taylor_fp64(t);\\n        }\\n    }\\n\\n    int abs_k = int(abs(float(k)));\\n\\n    if (abs_k > 4) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    } else {\\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\\n    }\\n\\n    vec2 u = vec2(0.0, 0.0);\\n    vec2 v = vec2(0.0, 0.0);\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\n    if (abs(float(abs_k) - 1.0) < 0.5) {\\n        u = COS_TABLE_0_FP64;\\n        v = SIN_TABLE_0_FP64;\\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\\n        u = COS_TABLE_1_FP64;\\n        v = SIN_TABLE_1_FP64;\\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\\n        u = COS_TABLE_2_FP64;\\n        v = SIN_TABLE_2_FP64;\\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\\n        u = COS_TABLE_3_FP64;\\n        v = SIN_TABLE_3_FP64;\\n    }\\n#else\\n    if (abs_k == 1) {\\n        u = COS_TABLE_0_FP64;\\n        v = SIN_TABLE_0_FP64;\\n    } else if (abs_k == 2) {\\n        u = COS_TABLE_1_FP64;\\n        v = SIN_TABLE_1_FP64;\\n    } else if (abs_k == 3) {\\n        u = COS_TABLE_2_FP64;\\n        v = SIN_TABLE_2_FP64;\\n    } else if (abs_k == 4) {\\n        u = COS_TABLE_3_FP64;\\n        v = SIN_TABLE_3_FP64;\\n    }\\n#endif\\n\\n    vec2 sin_t, cos_t;\\n    sincos_taylor_fp64(t, sin_t, cos_t);\\n\\n\\n\\n    vec2 result = vec2(0.0, 0.0);\\n    if (j == 0) {\\n        if (k > 0) {\\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        } else {\\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        }\\n    } else if (j == 1) {\\n        if (k > 0) {\\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        } else {\\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        }\\n    } else if (j == -1) {\\n        if (k > 0) {\\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\\n        } else {\\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\\n        }\\n    } else {\\n        if (k > 0) {\\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        } else {\\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\\n        }\\n    }\\n\\n    return result;\\n}\\n\\nvec2 cos_fp64(vec2 a) {\\n    if (a.x == 0.0 && a.y == 0.0) {\\n        return vec2(1.0, 0.0);\\n    }\\n\\n    // 2pi range reduction\\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\\n\\n    vec2 t;\\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\\n    int j = int(q);\\n\\n    if (j < -2 || j > 2) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    }\\n\\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\\n\\n    q = floor(t.x / PI_16_FP64.x + 0.5);\\n    int k = int(q);\\n\\n    if (k == 0) {\\n        if (j == 0) {\\n            return cos_taylor_fp64(t);\\n        } else if (j == 1) {\\n            return -sin_taylor_fp64(t);\\n        } else if (j == -1) {\\n            return sin_taylor_fp64(t);\\n        } else {\\n            return -cos_taylor_fp64(t);\\n        }\\n    }\\n\\n    int abs_k = int(abs(float(k)));\\n\\n    if (abs_k > 4) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    } else {\\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\\n    }\\n\\n    vec2 u = vec2(0.0, 0.0);\\n    vec2 v = vec2(0.0, 0.0);\\n\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\n    if (abs(float(abs_k) - 1.0) < 0.5) {\\n        u = COS_TABLE_0_FP64;\\n        v = SIN_TABLE_0_FP64;\\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\\n        u = COS_TABLE_1_FP64;\\n        v = SIN_TABLE_1_FP64;\\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\\n        u = COS_TABLE_2_FP64;\\n        v = SIN_TABLE_2_FP64;\\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\\n        u = COS_TABLE_3_FP64;\\n        v = SIN_TABLE_3_FP64;\\n    }\\n#else\\n    if (abs_k == 1) {\\n        u = COS_TABLE_0_FP64;\\n        v = SIN_TABLE_0_FP64;\\n    } else if (abs_k == 2) {\\n        u = COS_TABLE_1_FP64;\\n        v = SIN_TABLE_1_FP64;\\n    } else if (abs_k == 3) {\\n        u = COS_TABLE_2_FP64;\\n        v = SIN_TABLE_2_FP64;\\n    } else if (abs_k == 4) {\\n        u = COS_TABLE_3_FP64;\\n        v = SIN_TABLE_3_FP64;\\n    }\\n#endif\\n\\n    vec2 sin_t, cos_t;\\n    sincos_taylor_fp64(t, sin_t, cos_t);\\n\\n    vec2 result = vec2(0.0, 0.0);\\n    if (j == 0) {\\n        if (k > 0) {\\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        } else {\\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        }\\n    } else if (j == 1) {\\n        if (k > 0) {\\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        } else {\\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\\n        }\\n    } else if (j == -1) {\\n        if (k > 0) {\\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        } else {\\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n        }\\n    } else {\\n        if (k > 0) {\\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\\n        } else {\\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        }\\n    }\\n\\n    return result;\\n}\\n\\nvec2 tan_fp64(vec2 a) {\\n    vec2 sin_a;\\n    vec2 cos_a;\\n\\n    if (a.x == 0.0 && a.y == 0.0) {\\n        return vec2(0.0, 0.0);\\n    }\\n\\n    // 2pi range reduction\\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\\n\\n    vec2 t;\\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\\n    int j = int(q);\\n\\n\\n    if (j < -2 || j > 2) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    }\\n\\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\\n\\n    q = floor(t.x / PI_16_FP64.x + 0.5);\\n    int k = int(q);\\n    int abs_k = int(abs(float(k)));\\n\\n    // We just can\\'t get PI/16 * 3.0 very accurately.\\n    // so let\\'s just store it\\n    if (abs_k > 4) {\\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\\n    } else {\\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\\n    }\\n\\n\\n    vec2 u = vec2(0.0, 0.0);\\n    vec2 v = vec2(0.0, 0.0);\\n\\n    vec2 sin_t, cos_t;\\n    vec2 s, c;\\n    sincos_taylor_fp64(t, sin_t, cos_t);\\n\\n    if (k == 0) {\\n        s = sin_t;\\n        c = cos_t;\\n    } else {\\n#if defined(NVIDIA_EQUATION_WORKAROUND) || defined(INTEL_EQUATION_WORKAROUND)\\n        if (abs(float(abs_k) - 1.0) < 0.5) {\\n            u = COS_TABLE_0_FP64;\\n            v = SIN_TABLE_0_FP64;\\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\\n            u = COS_TABLE_1_FP64;\\n            v = SIN_TABLE_1_FP64;\\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\\n            u = COS_TABLE_2_FP64;\\n            v = SIN_TABLE_2_FP64;\\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\\n            u = COS_TABLE_3_FP64;\\n            v = SIN_TABLE_3_FP64;\\n        }\\n#else\\n        if (abs_k == 1) {\\n            u = COS_TABLE_0_FP64;\\n            v = SIN_TABLE_0_FP64;\\n        } else if (abs_k == 2) {\\n            u = COS_TABLE_1_FP64;\\n            v = SIN_TABLE_1_FP64;\\n        } else if (abs_k == 3) {\\n            u = COS_TABLE_2_FP64;\\n            v = SIN_TABLE_2_FP64;\\n        } else if (abs_k == 4) {\\n            u = COS_TABLE_3_FP64;\\n            v = SIN_TABLE_3_FP64;\\n        }\\n#endif\\n        if (k > 0) {\\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        } else {\\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\\n        }\\n    }\\n\\n    if (j == 0) {\\n        sin_a = s;\\n        cos_a = c;\\n    } else if (j == 1) {\\n        sin_a = c;\\n        cos_a = -s;\\n    } else if (j == -1) {\\n        sin_a = -c;\\n        cos_a = s;\\n    } else {\\n        sin_a = -s;\\n        cos_a = -c;\\n    }\\n    return div_fp64(sin_a, cos_a);\\n}\\n\\nvec2 radians_fp64(vec2 degree) {\\n  return mul_fp64(degree, PI_180_FP64);\\n}\\n\\n// Vector functions\\n// vec2 functions\\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\\n    out_val[0] = sum_fp64(a[0], b[0]);\\n    out_val[1] = sum_fp64(a[1], b[1]);\\n}\\n\\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\\n    out_val[0] = sub_fp64(a[0], b[0]);\\n    out_val[1] = sub_fp64(a[1], b[1]);\\n}\\n\\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\\n  vec2 range[2];\\n  vec2_sub_fp64(y, x, range);\\n  vec2 portion[2];\\n  portion[0] = range[0] * a;\\n  portion[1] = range[1] * a;\\n  vec2_sum_fp64(x, portion, out_val);\\n}\\n\\nvec2 vec2_length_fp64(vec2 x[2]) {\\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\\n}\\n\\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\\n  vec2 diff[2];\\n  vec2_sub_fp64(x, y, diff);\\n  return vec2_length_fp64(diff);\\n}\\n\\n// vec3 functions\\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\\n  for (int i = 0; i < 3; i++) {\\n    out_val[i] = sum_fp64(a[i], b[i]);\\n  }\\n}\\n\\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\\n  for (int i = 0; i < 3; i++) {\\n    out_val[i] = sum_fp64(a[i], b[i]);\\n  }\\n}\\n\\nvec2 vec3_length_fp64(vec2 x[3]) {\\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])), mul_fp64(x[2], x[2])));\\n}\\n\\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\\n  vec2 diff[3];\\n  vec3_sub_fp64(x, y, diff);\\n  return vec3_length_fp64(diff);\\n}\\n\\n// vec4 functions\\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\\n  out_val[0].x = a[0];\\n  out_val[0].y = 0.0;\\n\\n  out_val[1].x = a[1];\\n  out_val[1].y = 0.0;\\n\\n  out_val[2].x = a[2];\\n  out_val[2].y = 0.0;\\n\\n  out_val[3].x = a[3];\\n  out_val[3].y = 0.0;\\n}\\n\\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\\n  out_val[0] = mul_fp64(a[0], b);\\n  out_val[1] = mul_fp64(a[1], b);\\n  out_val[2] = mul_fp64(a[2], b);\\n  out_val[3] = mul_fp64(a[3], b);\\n}\\n\\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\\n  for (int i = 0; i < 4; i++) {\\n    out_val[i] = sum_fp64(a[i], b[i]);\\n  }\\n}\\n\\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\\n  vec2 v[4];\\n\\n  v[0] = mul_fp64(a[0], b[0]);\\n  v[1] = mul_fp64(a[1], b[1]);\\n  v[2] = mul_fp64(a[2], b[2]);\\n  v[3] = mul_fp64(a[3], b[3]);\\n\\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\\n}\\n\\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\\n  vec2 tmp[4];\\n\\n  for (int i = 0; i < 4; i++)\\n  {\\n    for (int j = 0; j < 4; j++)\\n    {\\n      tmp[j] = b[j + i * 4];\\n    }\\n    vec4_dot_fp64(a, tmp, out_val[i]);\\n  }\\n}\\n'\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVybGliL2ZwNjQvaW5kZXguanM/MjA0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuZXhwb3J0IHZhciBmcDY0ID0ge1xuICBpbnRlcmZhY2U6ICdmcDY0JyxcbiAgc291cmNlOiAnLy8gQ29weXJpZ2h0IChjKSAyMDE2IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XFxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXFxuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXFxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXFxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXFxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxcbi8vIFRIRSBTT0ZUV0FSRS5cXG51bmlmb3JtIGZsb2F0IE9ORTtcXG5cXG5jb25zdCB2ZWMyIEVfRlA2NCA9IHZlYzIoMi43MTgyODE3NDU5MTA2NDQ1ZSswMCwgOC4yNTQ4NDAzNjY4MTcwMDdlLTA4KTtcXG5jb25zdCB2ZWMyIExPRzJfRlA2NCA9IHZlYzIoMC42OTMxNDcxODI0NjQ1OTk2ZSswMCwgLTEuOTA0NjU0MjEyMTI1OTMzNmUtMDkpO1xcbmNvbnN0IHZlYzIgUElfRlA2NCA9IHZlYzIoMy4xNDE1OTI3NDEwMTI1NzMyLCAtOC43NDIyNzgwMTI2MTg5NTRlLTgpO1xcbmNvbnN0IHZlYzIgVFdPX1BJX0ZQNjQgPSB2ZWMyKDYuMjgzMTg1NDgyMDI1MTQ2NSwgLTEuNzQ4NDU1NjAyNTIzNzkwN2UtNyk7XFxuY29uc3QgdmVjMiBQSV8yX0ZQNjQgPSB2ZWMyKDEuNTcwNzk2MzcwNTA2Mjg2NiwgLTQuMzcxMTM5MDA2MzA5NDc3ZS04KTtcXG5jb25zdCB2ZWMyIFBJXzRfRlA2NCA9IHZlYzIoMC43ODUzOTgxODUyNTMxNDMzLCAtMi4xODU1Njk1MDMxNTQ3Mzg0ZS04KTtcXG5jb25zdCB2ZWMyIFBJXzE2X0ZQNjQgPSB2ZWMyKDAuMTk2MzQ5NTQ2MzEzMjg1ODMsIC01LjQ2MzkyMzc1Nzg4Njg0NmUtOSk7XFxuY29uc3QgdmVjMiBQSV8xNl8yX0ZQNjQgPSB2ZWMyKDAuMzkyNjk5MDkyNjI2NTcxNjYsIC0xLjA5Mjc4NDc1MTU3NzM2OTJlLTgpO1xcbmNvbnN0IHZlYzIgUElfMTZfM19GUDY0ID0gdmVjMigwLjU4OTA0ODYyNDAzODY5NjMsIC0xLjQ5MDYxMDA3OTgxMjg4MThlLTkpO1xcbmNvbnN0IHZlYzIgUElfMTgwX0ZQNjQgPSB2ZWMyKDAuMDE3NDUzMjkyMzg0NzQzNjksIDEuMzUxOTk2MDQ5ODM2NDkwMmUtMTApO1xcblxcbmNvbnN0IHZlYzIgU0lOX1RBQkxFXzBfRlA2NCA9IHZlYzIoMC4xOTUwOTAzMjM2ODY1OTk3MywgLTEuNjcwNDcxNDgzMzYxNTI0MmUtOSk7XFxuY29uc3QgdmVjMiBTSU5fVEFCTEVfMV9GUDY0ID0gdmVjMigwLjM4MjY4MzQyNjE0MTczODksIDYuMjIzMzUwODkwMTc3NjdlLTkpO1xcbmNvbnN0IHZlYzIgU0lOX1RBQkxFXzJfRlA2NCA9IHZlYzIoMC41NTU1NzAyNDQ3ODkxMjM1LCAtMS4xNzY5NTIxMzU3NTA3NTI5ZS04KTtcXG5jb25zdCB2ZWMyIFNJTl9UQUJMRV8zX0ZQNjQgPSB2ZWMyKDAuNzA3MTA2NzY5MDg0OTMwNCwgMS4yMTAxNjE3MDQxNzkzMTMzZS04KTtcXG5cXG5jb25zdCB2ZWMyIENPU19UQUJMRV8wX0ZQNjQgPSB2ZWMyKDAuOTgwNzg1MjUwNjYzNzU3MywgMi45NzM5NDczMTA2MzYwNDkyZS04KTtcXG5jb25zdCB2ZWMyIENPU19UQUJMRV8xX0ZQNjQgPSB2ZWMyKDAuOTIzODc5NTA0MjAzNzk2NCwgMi44MzA3NDkwMzUxNzY0Mzg2ZS04KTtcXG5jb25zdCB2ZWMyIENPU19UQUJMRV8yX0ZQNjQgPSB2ZWMyKDAuODMxNDY5NTk1NDMyMjgxNSwgMS42ODcwMjYzNzQxNTMwNzc4ZS04KTtcXG5jb25zdCB2ZWMyIENPU19UQUJMRV8zX0ZQNjQgPSB2ZWMyKDAuNzA3MTA2NzY5MDg0OTMwNCwgMS4yMTAxNjE3MTUyODE1NDM2ZS04KTtcXG5cXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzNfRlA2NCA9IHZlYzIoMS42NjY2NjY3MTYzMzcyMDRlLTAxLCAtNC45NjcwNTM4NzkzMTIyODllLTA5KTsgLy8gMS8zIVxcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfNF9GUDY0ID0gdmVjMig0LjE2NjY2Njc5MDg0MzAxZS0wMiwgLTEuMjQxNzYzNDY5ODI4MDcyMmUtMDkpOyAvLyAxLzQhXFxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF81X0ZQNjQgPSB2ZWMyKDguMzMzMzMzNzY3OTUwNTM1ZS0wMywgLTQuMzQ2MTcyMDMzMzc1OTVlLTEwKTsgLy8gMS81IVxcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfNl9GUDY0ID0gdmVjMigxLjM4ODg4ODkyMjUxOTk4MTllLTAzLCAtMy4zNjMxMDk0NDM3MTAzMjE1ZS0xMSk7IC8vIDEvNiFcXG5jb25zdCB2ZWMyIElOVkVSU0VfRkFDVE9SSUFMXzdfRlA2NCA9IHZlYzIoMS45ODQxMjcwMTEzODI5NTIzZS0wNCwgIC0yLjcyNTU5Njg3NDkzMzQ1NmUtMTIpOyAvLyAxLzchXFxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF84X0ZQNjQgPSB2ZWMyKDIuNDgwMTU4NzY0MjI4NjkwNGUtMDUsIC0zLjQwNjk5NjAyNTkwNDE4NGUtMTMpOyAvLyAxLzghXFxuY29uc3QgdmVjMiBJTlZFUlNFX0ZBQ1RPUklBTF85X0ZQNjQgPSB2ZWMyKDIuNzU1NzMxODg0NDYyODc1MzNlLTA2LCAzLjc5MzU3MTM5MzcwMzgxODZlLTE0KTsgLy8gMS85IVxcbmNvbnN0IHZlYzIgSU5WRVJTRV9GQUNUT1JJQUxfMTBfRlA2NCA9IHZlYzIoMi43NTU3MzE5OTgxNDk3MTNlLTA3LCAtNy41NzUxMTIzNjc4Njk4NzNlLTE1KTsgLy8gMS8xMCFcXG5cXG5mbG9hdCBuaW50KGZsb2F0IGQpIHtcXG4gICAgaWYgKGQgPT0gZmxvb3IoZCkpIHJldHVybiBkO1xcbiAgICByZXR1cm4gZmxvb3IoZCArIDAuNSk7XFxufVxcblxcbiNpZiBkZWZpbmVkKE5WSURJQV9GUDY0X1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRlA2NF9XT1JLQVJPVU5EKVxcbnZlYzIgc3BsaXQoZmxvYXQgYSkge1xcbiAgY29uc3QgZmxvYXQgU1BMSVQgPSA0MDk3LjA7XFxuICBmbG9hdCB0ID0gYSAqIFNQTElUO1xcbiAgZmxvYXQgYV9oaSA9IHQgKiBPTkUgLSAodCAtIGEpO1xcbiAgZmxvYXQgYV9sbyA9IGEgKiBPTkUgLSBhX2hpO1xcbiAgcmV0dXJuIHZlYzIoYV9oaSwgYV9sbyk7XFxufVxcbiNlbHNlXFxudmVjMiBzcGxpdChmbG9hdCBhKSB7XFxuICBjb25zdCBmbG9hdCBTUExJVCA9IDQwOTcuMDtcXG4gIGZsb2F0IHQgPSBhICogU1BMSVQ7XFxuICBmbG9hdCBhX2hpID0gdCAtICh0IC0gYSk7XFxuICBmbG9hdCBhX2xvID0gYSAtIGFfaGk7XFxuICByZXR1cm4gdmVjMihhX2hpLCBhX2xvKTtcXG59XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQoTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRVFVQVRJT05fV09SS0FST1VORClcXG52ZWMyIHF1aWNrVHdvU3VtKGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gIGZsb2F0IHN1bSA9IChhICsgYikgKiBPTkU7XFxuICBmbG9hdCBlcnIgPSBiIC0gKHN1bSAtIGEpICogT05FO1xcbiAgcmV0dXJuIHZlYzIoc3VtLCBlcnIpO1xcbn1cXG4jZWxzZVxcbnZlYzIgcXVpY2tUd29TdW0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgZmxvYXQgc3VtID0gYSArIGI7XFxuICBmbG9hdCBlcnIgPSBiIC0gKHN1bSAtIGEpO1xcbiAgcmV0dXJuIHZlYzIoc3VtLCBlcnIpO1xcbn1cXG4jZW5kaWZcXG5cXG52ZWMyIG5pbnRfZnA2NCh2ZWMyIGEpIHtcXG4gICAgZmxvYXQgaGkgPSBuaW50KGEueCk7XFxuICAgIGZsb2F0IGxvO1xcbiAgICB2ZWMyIHRtcDtcXG4gICAgaWYgKGhpID09IGEueCkge1xcbiAgICAgICAgbG8gPSBuaW50KGEueSk7XFxuICAgICAgICB0bXAgPSBxdWlja1R3b1N1bShoaSwgbG8pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbG8gPSAwLjA7XFxuICAgICAgICBpZiAoYWJzKGhpIC0gYS54KSA9PSAwLjUgJiYgYS55IDwgMC4wKSB7XFxuICAgICAgICAgICAgaGkgLT0gMS4wO1xcbiAgICAgICAgfVxcbiAgICAgICAgdG1wID0gdmVjMihoaSwgbG8pO1xcbiAgICB9XFxuICAgIHJldHVybiB0bXA7XFxufVxcblxcbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXFxuXFxuLyogVGhlIHB1cnBvc2Ugb2YgdGhpcyB3b3JrYXJvdW5kIGlzIHRvIHByZXZlbnQgY29tcGlsZXJzIGZyb21cXG5vcHRpbWl6aW5nIGF3YXkgbmVjZXNzYXJ5IGFyaXRobWV0aWMgb3BlcmF0aW9ucyBieSBzd2FwcGluZyB0aGVpciBzZXF1ZW5jZXNcXG5vciB0cmFuc2Zvcm0gdGhlIGVxdWF0aW9uIHRvIHNvbWUgXFwnZXF1aXZhbGVudFxcJyBmcm9tLlxcblxcblRoZSBtZXRob2QgaXMgdG8gbXVsdGlwbHkgYW4gYXJ0aWZpY2FsIHZhcmlhYmxlLCBPTkUsIHdoaWNoIHdpbGwgYmUga25vd24gdG9cXG50aGUgY29tcGlsZXIgdG8gYmUgb25lIG9ubHkgYXQgdGhlIHJ1bnRpbWUuIFRoZSB3aG9sZSBleHByZXNzaW9uIGlzIHRoZW4gcmVwcmVzZW50ZWRcXG5hcyBhIHBvbHlub21pYWwgd2l0aCByZXNwZWN0aXZlIHRvIE9ORS4gSW4gdGhlIGNvZWZmaWNpZW50cyBvZiBhbGwgdGVybXMsIG9ubHkgb25lIGFcXG5hbmQgb25lIGIgc2hvdWxkIGFwcGVhclxcblxcbmVyciA9IChhICsgYikgKiBPTkVeNiAtIGEgKiBPTkVeNSAtIChhICsgYikgKiBPTkVeNCArIGEgKiBPTkVeMyAtIGIgLSAoYSArIGIpICogT05FXjIgKyBhICogT05FXFxuKi9cXG5cXG52ZWMyIHR3b1N1bShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICBmbG9hdCBzID0gKGEgKyBiKTtcXG4gIGZsb2F0IHYgPSAocyAqIE9ORSAtIGEpICogT05FO1xcbiAgZmxvYXQgZXJyID0gKGEgLSAocyAtIHYpICogT05FKSAqIE9ORSAqIE9ORSAqIE9ORSArIChiIC0gdik7XFxuICByZXR1cm4gdmVjMihzLCBlcnIpO1xcbn1cXG4jZWxzZVxcbnZlYzIgdHdvU3VtKGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gIGZsb2F0IHMgPSBhICsgYjtcXG4gIGZsb2F0IHYgPSBzIC0gYTtcXG4gIGZsb2F0IGVyciA9IChhIC0gKHMgLSB2KSkgKyAoYiAtIHYpO1xcbiAgcmV0dXJuIHZlYzIocywgZXJyKTtcXG59XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQoTlZJRElBX0VRVUFUSU9OX1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRVFVQVRJT05fV09SS0FST1VORClcXG4vKiBTYW1lIHRoaW5nIGFzIGluIHR3b1N1bSgpICovXFxudmVjMiB0d29TdWIoZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgZmxvYXQgcyA9IChhIC0gYik7XFxuICBmbG9hdCB2ID0gKHMgKiBPTkUgLSBhKSAqIE9ORTtcXG4gIGZsb2F0IGVyciA9IChhIC0gKHMgLSB2KSAqIE9ORSkgKiBPTkUgKiBPTkUgKiBPTkUgLSAoYiArIHYpO1xcbiAgcmV0dXJuIHZlYzIocywgZXJyKTtcXG59XFxuI2Vsc2VcXG52ZWMyIHR3b1N1YihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICBmbG9hdCBzID0gYSAtIGI7XFxuICBmbG9hdCB2ID0gcyAtIGE7XFxuICBmbG9hdCBlcnIgPSAoYSAtIChzIC0gdikpIC0gKGIgKyB2KTtcXG4gIHJldHVybiB2ZWMyKHMsIGVycik7XFxufVxcbiNlbmRpZlxcblxcbnZlYzIgdHdvUHJvZChmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICBmbG9hdCBwcm9kID0gYSAqIGI7XFxuICB2ZWMyIGFfZnA2NCA9IHNwbGl0KGEpO1xcbiAgdmVjMiBiX2ZwNjQgPSBzcGxpdChiKTtcXG4gIGZsb2F0IGVyciA9ICgoYV9mcDY0LnggKiBiX2ZwNjQueCAtIHByb2QpICsgYV9mcDY0LnggKiBiX2ZwNjQueSArXFxuICAgIGFfZnA2NC55ICogYl9mcDY0LngpICsgYV9mcDY0LnkgKiBiX2ZwNjQueTtcXG4gIHJldHVybiB2ZWMyKHByb2QsIGVycik7XFxufVxcblxcbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXFxudmVjMiB0d29TcXIoZmxvYXQgYSkge1xcbiAgZmxvYXQgcHJvZCA9IGEgKiBhO1xcbiAgdmVjMiBhX2ZwNjQgPSBzcGxpdChhKTtcXG5cXG4gIGZsb2F0IGVyciA9ICgoYV9mcDY0LnggKiBhX2ZwNjQueCAtIHByb2QpICogT05FICsgMi4wICogYV9mcDY0LnggKiBhX2ZwNjQueSAqIE9ORSAqIE9ORSkgKyBhX2ZwNjQueSAqIGFfZnA2NC55ICogT05FICogT05FICogT05FO1xcbiAgcmV0dXJuIHZlYzIocHJvZCwgZXJyKTtcXG59XFxuI2Vsc2VcXG52ZWMyIHR3b1NxcihmbG9hdCBhKSB7XFxuICBmbG9hdCBwcm9kID0gYSAqIGE7XFxuICB2ZWMyIGFfZnA2NCA9IHNwbGl0KGEpO1xcblxcbiAgZmxvYXQgZXJyID0gKChhX2ZwNjQueCAqIGFfZnA2NC54IC0gcHJvZCkgKyAyLjAgKiBhX2ZwNjQueCAqIGFfZnA2NC55KSArIGFfZnA2NC55ICogYV9mcDY0Lnk7XFxuICByZXR1cm4gdmVjMihwcm9kLCBlcnIpO1xcbn1cXG4jZW5kaWZcXG5cXG52ZWMyIHN1bV9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XFxuICB2ZWMyIHMsIHQ7XFxuICBzID0gdHdvU3VtKGEueCwgYi54KTtcXG4gIHQgPSB0d29TdW0oYS55LCBiLnkpO1xcbiAgcy55ICs9IHQueDtcXG4gIHMgPSBxdWlja1R3b1N1bShzLngsIHMueSk7XFxuICBzLnkgKz0gdC55O1xcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcXG4gIHJldHVybiBzO1xcbn1cXG5cXG52ZWMyIHN1Yl9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XFxuICB2ZWMyIHMsIHQ7XFxuICBzID0gdHdvU3ViKGEueCwgYi54KTtcXG4gIHQgPSB0d29TdWIoYS55LCBiLnkpO1xcbiAgcy55ICs9IHQueDtcXG4gIHMgPSBxdWlja1R3b1N1bShzLngsIHMueSk7XFxuICBzLnkgKz0gdC55O1xcbiAgcyA9IHF1aWNrVHdvU3VtKHMueCwgcy55KTtcXG4gIHJldHVybiBzO1xcbn1cXG5cXG52ZWMyIG11bF9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XFxuICB2ZWMyIHByb2QgPSB0d29Qcm9kKGEueCwgYi54KTtcXG4gIC8vIHkgY29tcG9uZW50IGlzIGZvciB0aGUgZXJyb3JcXG4gIHByb2QueSArPSBhLnggKiBiLnk7XFxuICBwcm9kLnkgKz0gYS55ICogYi54O1xcbiAgcHJvZCA9IHF1aWNrVHdvU3VtKHByb2QueCwgcHJvZC55KTtcXG4gIHJldHVybiBwcm9kO1xcbn1cXG5cXG52ZWMyIGRpdl9mcDY0KHZlYzIgYSwgdmVjMiBiKSB7XFxuICBmbG9hdCB4biA9IDEuMCAvIGIueDtcXG4gIHZlYzIgeW4gPSBhICogeG47XFxuICBmbG9hdCBkaWZmID0gKHN1Yl9mcDY0KGEsIG11bF9mcDY0KGIsIHluKSkpLng7XFxuICB2ZWMyIHByb2QgPSB0d29Qcm9kKHhuLCBkaWZmKTtcXG4gIHJldHVybiBzdW1fZnA2NCh5biwgcHJvZCk7XFxufVxcblxcbnZlYzIgc3FydF9mcDY0KHZlYzIgYSkge1xcblxcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xcbiAgaWYgKGEueCA8IDAuMCkgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xcblxcbiAgZmxvYXQgeCA9IDEuMCAvIHNxcnQoYS54KTtcXG4gIGZsb2F0IHluID0gYS54ICogeDtcXG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcXG4gIHZlYzIgeW5fc3FyID0gdHdvU3FyKHluKSAqIE9ORTtcXG4jZWxzZVxcbiAgdmVjMiB5bl9zcXIgPSB0d29TcXIoeW4pO1xcbiNlbmRpZlxcbiAgZmxvYXQgZGlmZiA9IHN1Yl9mcDY0KGEsIHluX3NxcikueDtcXG4gIHZlYzIgcHJvZCA9IHR3b1Byb2QoeCAqIDAuNSwgZGlmZik7XFxuICByZXR1cm4gc3VtX2ZwNjQodmVjMih5biwgMC4wKSwgcHJvZCk7XFxufVxcblxcbi8qIGtfcG93ZXIgY29udHJvbHMgaG93IG11Y2ggcmFuZ2UgcmVkdWN0aW9uIHdlIHdvdWxkIGxpa2UgdG8gaGF2ZVxcblJhbmdlIHJlZHVjdGlvbiB1c2VzIHRoZSBmb2xsb3dpbmcgbWV0aG9kOlxcbmFzc3VtZSBhID0ga19wb3dlciAqIHIgKyBtICogbG9nKDIpLCBrIGFuZCBtIGJlaW5nIGludGVnZXJzLlxcblNldCBrX3Bvd2VyID0gNCAod2UgY2FuIGNob29zZSBvdGhlciBrIHRvIHRyYWRlIGFjY3VyYWN5IHdpdGggcGVyZm9ybWFuY2UuXFxud2Ugb25seSBuZWVkIHRvIGNhbGN1bGF0ZSBleHAocikgYW5kIHVzaW5nIGV4cChhKSA9IDJebSAqIGV4cChyKV5rX3Bvd2VyO1xcbiovXFxuXFxudmVjMiBleHBfZnA2NCh2ZWMyIGEpIHtcXG4gIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXNlIHR3byBudW1iZXJzIG1hdGNoXFxuICAvLyBhcyBiaXQtd2lzZSBzaGlmdCBpcyBub3QgYXZhaWxhYmxlIGluIEdMU0wgMS4wXFxuICBjb25zdCBpbnQga19wb3dlciA9IDQ7XFxuICBjb25zdCBmbG9hdCBrID0gMTYuMDtcXG5cXG4gIGNvbnN0IGZsb2F0IGludl9rID0gMS4wIC8gaztcXG5cXG4gIGlmIChhLnggPD0gLTg4LjApIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcXG4gIGlmIChhLnggPj0gODguMCkgcmV0dXJuIHZlYzIoMS4wIC8gMC4wLCAxLjAgLyAwLjApO1xcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkgcmV0dXJuIHZlYzIoMS4wLCAwLjApO1xcbiAgaWYgKGEueCA9PSAxLjAgJiYgYS55ID09IDAuMCkgcmV0dXJuIEVfRlA2NDtcXG5cXG4gIGZsb2F0IG0gPSBmbG9vcihhLnggLyBMT0cyX0ZQNjQueCArIDAuNSk7XFxuICB2ZWMyIHIgPSBzdWJfZnA2NChhLCBtdWxfZnA2NChMT0cyX0ZQNjQsIHZlYzIobSwgMC4wKSkpICogaW52X2s7XFxuICB2ZWMyIHMsIHQsIHA7XFxuXFxuICBwID0gbXVsX2ZwNjQociwgcik7XFxuICBzID0gc3VtX2ZwNjQociwgcCAqIDAuNSk7XFxuICBwID0gbXVsX2ZwNjQocCwgcik7XFxuICB0ID0gbXVsX2ZwNjQocCwgSU5WRVJTRV9GQUNUT1JJQUxfM19GUDY0KTtcXG5cXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcXG4gIHAgPSBtdWxfZnA2NChwLCByKTtcXG4gIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF80X0ZQNjQpO1xcblxcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xcbiAgcCA9IG11bF9mcDY0KHAsIHIpO1xcbiAgdCA9IG11bF9mcDY0KHAsIElOVkVSU0VfRkFDVE9SSUFMXzVfRlA2NCk7XFxuXFxuICAvLyBzID0gc3VtX2ZwNjQocywgdCk7XFxuICAvLyBwID0gbXVsX2ZwNjQocCwgcik7XFxuICAvLyB0ID0gbXVsX2ZwNjQocCwgSU5WRVJTRV9GQUNUT1JJQUxfNl9GUDY0KTtcXG5cXG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcXG4gIC8vIHAgPSBtdWxfZnA2NChwLCByKTtcXG4gIC8vIHQgPSBtdWxfZnA2NChwLCBJTlZFUlNFX0ZBQ1RPUklBTF83X0ZQNjQpO1xcblxcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xcblxcblxcbiAgLy8gQXQgdGhpcyBwb2ludCwgcyA9IGV4cChyKSAtIDE7IGJ1dCBhZnRlciBmb2xsb3dpbmcgNCByZWN1cnNpb25zLCB3ZSB3aWxsIGdldCBleHAocikgXiA1MTIgLSAxLlxcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBrX3Bvd2VyOyBpKyspIHtcXG4gICAgcyA9IHN1bV9mcDY0KHMgKiAyLjAsIG11bF9mcDY0KHMsIHMpKTtcXG4gIH1cXG5cXG4jaWYgZGVmaW5lZChOVklESUFfRlA2NF9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0ZQNjRfV09SS0FST1VORClcXG4gIHMgPSBzdW1fZnA2NChzLCB2ZWMyKE9ORSwgMC4wKSk7XFxuI2Vsc2VcXG4gIHMgPSBzdW1fZnA2NChzLCB2ZWMyKDEuMCwgMC4wKSk7XFxuI2VuZGlmXFxuXFxuICByZXR1cm4gcyAqIHBvdygyLjAsIG0pO1xcbi8vICAgcmV0dXJuIHI7XFxufVxcblxcbnZlYzIgbG9nX2ZwNjQodmVjMiBhKVxcbntcXG4gIGlmIChhLnggPT0gMS4wICYmIGEueSA9PSAwLjApIHJldHVybiB2ZWMyKDAuMCwgMC4wKTtcXG4gIGlmIChhLnggPD0gMC4wKSByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XFxuICB2ZWMyIHggPSB2ZWMyKGxvZyhhLngpLCAwLjApO1xcbiAgdmVjMiBzO1xcbiNpZiBkZWZpbmVkKE5WSURJQV9GUDY0X1dPUktBUk9VTkQpIHx8IGRlZmluZWQoSU5URUxfRlA2NF9XT1JLQVJPVU5EKVxcbiAgcyA9IHZlYzIoT05FLCAwLjApO1xcbiNlbHNlXFxuICBzID0gdmVjMigxLjAsIDAuMCk7XFxuI2VuZGlmXFxuXFxuICB4ID0gc3ViX2ZwNjQoc3VtX2ZwNjQoeCwgbXVsX2ZwNjQoYSwgZXhwX2ZwNjQoLXgpKSksIHMpO1xcbiAgcmV0dXJuIHg7XFxufVxcblxcbnZlYzIgc2luX3RheWxvcl9mcDY0KHZlYzIgYSkge1xcbiAgdmVjMiByLCBzLCB0LCB4O1xcblxcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xcbiAgICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XFxuICB9XFxuXFxuICB4ID0gLW11bF9mcDY0KGEsIGEpO1xcbiAgcyA9IGE7XFxuICByID0gYTtcXG5cXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcXG4gIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF8zX0ZQNjQpO1xcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xcblxcbiAgciA9IG11bF9mcDY0KHIsIHgpO1xcbiAgdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzVfRlA2NCk7XFxuICBzID0gc3VtX2ZwNjQocywgdCk7XFxuXFxuICAvKiBrZWVwIHRoZSBmb2xsb3dpbmcgY29tbWVudGVkIGNvZGUgaW4gY2FzZSB3ZSBuZWVkIHRoZW1cXG4gIGZvciBleHRyYSBhY2N1cmFjeSBmcm9tIHRoZSBUYXlsb3IgZXhwYW5zaW9uKi9cXG5cXG4gIC8vIHIgPSBtdWxfZnA2NChyLCB4KTtcXG4gIC8vIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF83X0ZQNjQpO1xcbiAgLy8gcyA9IHN1bV9mcDY0KHMsIHQpO1xcblxcbiAgLy8gciA9IG11bF9mcDY0KHIsIHgpO1xcbiAgLy8gdCA9IG11bF9mcDY0KHIsIElOVkVSU0VfRkFDVE9SSUFMXzlfRlA2NCk7XFxuICAvLyBzID0gc3VtX2ZwNjQocywgdCk7XFxuXFxuICByZXR1cm4gcztcXG59XFxuXFxudmVjMiBjb3NfdGF5bG9yX2ZwNjQodmVjMiBhKSB7XFxuICB2ZWMyIHIsIHMsIHQsIHg7XFxuXFxuICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSB7XFxuICAgIHJldHVybiB2ZWMyKDEuMCwgMC4wKTtcXG4gIH1cXG5cXG4gIHggPSAtbXVsX2ZwNjQoYSwgYSk7XFxuICByID0geDtcXG4gIHMgPSBzdW1fZnA2NCh2ZWMyKDEuMCwgMC4wKSwgciAqIDAuNSk7XFxuXFxuICByID0gbXVsX2ZwNjQociwgeCk7XFxuICB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfNF9GUDY0KTtcXG4gIHMgPSBzdW1fZnA2NChzLCB0KTtcXG5cXG4gIHIgPSBtdWxfZnA2NChyLCB4KTtcXG4gIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF82X0ZQNjQpO1xcbiAgcyA9IHN1bV9mcDY0KHMsIHQpO1xcblxcbiAgLyoga2VlcCB0aGUgZm9sbG93aW5nIGNvbW1lbnRlZCBjb2RlIGluIGNhc2Ugd2UgbmVlZCB0aGVtXFxuICBmb3IgZXh0cmEgYWNjdXJhY3kgZnJvbSB0aGUgVGF5bG9yIGV4cGFuc2lvbiovXFxuXFxuICAvLyByID0gbXVsX2ZwNjQociwgeCk7XFxuICAvLyB0ID0gbXVsX2ZwNjQociwgSU5WRVJTRV9GQUNUT1JJQUxfOF9GUDY0KTtcXG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcXG5cXG4gIC8vIHIgPSBtdWxfZnA2NChyLCB4KTtcXG4gIC8vIHQgPSBtdWxfZnA2NChyLCBJTlZFUlNFX0ZBQ1RPUklBTF8xMF9GUDY0KTtcXG4gIC8vIHMgPSBzdW1fZnA2NChzLCB0KTtcXG5cXG4gIHJldHVybiBzO1xcbn1cXG5cXG52b2lkIHNpbmNvc190YXlsb3JfZnA2NCh2ZWMyIGEsIG91dCB2ZWMyIHNpbl90LCBvdXQgdmVjMiBjb3NfdCkge1xcbiAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xcbiAgICBzaW5fdCA9IHZlYzIoMC4wLCAwLjApO1xcbiAgICBjb3NfdCA9IHZlYzIoMS4wLCAwLjApO1xcbiAgfVxcblxcbiAgc2luX3QgPSBzaW5fdGF5bG9yX2ZwNjQoYSk7XFxuICBjb3NfdCA9IHNxcnRfZnA2NChzdWJfZnA2NCh2ZWMyKDEuMCwgMC4wKSwgbXVsX2ZwNjQoc2luX3QsIHNpbl90KSkpO1xcbn1cXG5cXG52ZWMyIHNpbl9mcDY0KHZlYzIgYSkge1xcbiAgICBpZiAoYS54ID09IDAuMCAmJiBhLnkgPT0gMC4wKSB7XFxuICAgICAgICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XFxuICAgIH1cXG5cXG4gICAgLy8gMnBpIHJhbmdlIHJlZHVjdGlvblxcbiAgICB2ZWMyIHogPSBuaW50X2ZwNjQoZGl2X2ZwNjQoYSwgVFdPX1BJX0ZQNjQpKTtcXG4gICAgdmVjMiByID0gc3ViX2ZwNjQoYSwgbXVsX2ZwNjQoVFdPX1BJX0ZQNjQsIHopKTtcXG5cXG4gICAgdmVjMiB0O1xcbiAgICBmbG9hdCBxID0gZmxvb3Ioci54IC8gUElfMl9GUDY0LnggKyAwLjUpO1xcbiAgICBpbnQgaiA9IGludChxKTtcXG5cXG4gICAgaWYgKGogPCAtMiB8fCBqID4gMikge1xcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xcbiAgICB9XFxuXFxuICAgIHQgPSBzdWJfZnA2NChyLCBtdWxfZnA2NChQSV8yX0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xcblxcbiAgICBxID0gZmxvb3IodC54IC8gUElfMTZfRlA2NC54ICsgMC41KTtcXG4gICAgaW50IGsgPSBpbnQocSk7XFxuXFxuICAgIGlmIChrID09IDApIHtcXG4gICAgICAgIGlmIChqID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gc2luX3RheWxvcl9mcDY0KHQpO1xcbiAgICAgICAgfSBlbHNlIGlmIChqID09IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gY29zX3RheWxvcl9mcDY0KHQpO1xcbiAgICAgICAgfSBlbHNlIGlmIChqID09IC0xKSB7XFxuICAgICAgICAgICAgcmV0dXJuIC1jb3NfdGF5bG9yX2ZwNjQodCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiAtc2luX3RheWxvcl9mcDY0KHQpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGludCBhYnNfayA9IGludChhYnMoZmxvYXQoaykpKTtcXG5cXG4gICAgaWYgKGFic19rID4gNCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdCA9IHN1Yl9mcDY0KHQsIG11bF9mcDY0KFBJXzE2X0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xcbiAgICB9XFxuXFxuICAgIHZlYzIgdSA9IHZlYzIoMC4wLCAwLjApO1xcbiAgICB2ZWMyIHYgPSB2ZWMyKDAuMCwgMC4wKTtcXG5cXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxcbiAgICBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDEuMCkgPCAwLjUpIHtcXG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMF9GUDY0O1xcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XFxuICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDIuMCkgPCAwLjUpIHtcXG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XFxuICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDMuMCkgPCAwLjUpIHtcXG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XFxuICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDQuMCkgPCAwLjUpIHtcXG4gICAgICAgIHUgPSBDT1NfVEFCTEVfM19GUDY0O1xcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XFxuICAgIH1cXG4jZWxzZVxcbiAgICBpZiAoYWJzX2sgPT0gMSkge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8wX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcXG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSAyKSB7XFxuICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcXG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMV9GUDY0O1xcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDMpIHtcXG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XFxuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gNCkge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8zX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcXG4gICAgfVxcbiNlbmRpZlxcblxcbiAgICB2ZWMyIHNpbl90LCBjb3NfdDtcXG4gICAgc2luY29zX3RheWxvcl9mcDY0KHQsIHNpbl90LCBjb3NfdCk7XFxuXFxuXFxuXFxuICAgIHZlYzIgcmVzdWx0ID0gdmVjMigwLjAsIDAuMCk7XFxuICAgIGlmIChqID09IDApIHtcXG4gICAgICAgIGlmIChrID4gMCkge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xcbiAgICAgICAgaWYgKGsgPiAwKSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXN1bHQgPSBzdW1fZnA2NChtdWxfZnA2NCh1LCBjb3NfdCksIG11bF9mcDY0KHYsIHNpbl90KSk7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xcbiAgICAgICAgaWYgKGsgPiAwKSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodiwgc2luX3QpLCBtdWxfZnA2NCh1LCBjb3NfdCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXN1bHQgPSAtc3VtX2ZwNjQobXVsX2ZwNjQodiwgc2luX3QpLCBtdWxfZnA2NCh1LCBjb3NfdCkpO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGsgPiAwKSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gLXN1bV9mcDY0KG11bF9mcDY0KHUsIHNpbl90KSwgbXVsX2ZwNjQodiwgY29zX3QpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodiwgY29zX3QpLCBtdWxfZnA2NCh1LCBzaW5fdCkpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXN1bHQ7XFxufVxcblxcbnZlYzIgY29zX2ZwNjQodmVjMiBhKSB7XFxuICAgIGlmIChhLnggPT0gMC4wICYmIGEueSA9PSAwLjApIHtcXG4gICAgICAgIHJldHVybiB2ZWMyKDEuMCwgMC4wKTtcXG4gICAgfVxcblxcbiAgICAvLyAycGkgcmFuZ2UgcmVkdWN0aW9uXFxuICAgIHZlYzIgeiA9IG5pbnRfZnA2NChkaXZfZnA2NChhLCBUV09fUElfRlA2NCkpO1xcbiAgICB2ZWMyIHIgPSBzdWJfZnA2NChhLCBtdWxfZnA2NChUV09fUElfRlA2NCwgeikpO1xcblxcbiAgICB2ZWMyIHQ7XFxuICAgIGZsb2F0IHEgPSBmbG9vcihyLnggLyBQSV8yX0ZQNjQueCArIDAuNSk7XFxuICAgIGludCBqID0gaW50KHEpO1xcblxcbiAgICBpZiAoaiA8IC0yIHx8IGogPiAyKSB7XFxuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XFxuICAgIH1cXG5cXG4gICAgdCA9IHN1Yl9mcDY0KHIsIG11bF9mcDY0KFBJXzJfRlA2NCwgdmVjMihxLCAwLjApKSk7XFxuXFxuICAgIHEgPSBmbG9vcih0LnggLyBQSV8xNl9GUDY0LnggKyAwLjUpO1xcbiAgICBpbnQgayA9IGludChxKTtcXG5cXG4gICAgaWYgKGsgPT0gMCkge1xcbiAgICAgICAgaWYgKGogPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBjb3NfdGF5bG9yX2ZwNjQodCk7XFxuICAgICAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xcbiAgICAgICAgICAgIHJldHVybiAtc2luX3RheWxvcl9mcDY0KHQpO1xcbiAgICAgICAgfSBlbHNlIGlmIChqID09IC0xKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNpbl90YXlsb3JfZnA2NCh0KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIC1jb3NfdGF5bG9yX2ZwNjQodCk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgaW50IGFic19rID0gaW50KGFicyhmbG9hdChrKSkpO1xcblxcbiAgICBpZiAoYWJzX2sgPiA0KSB7XFxuICAgICAgICByZXR1cm4gdmVjMigwLjAgLyAwLjAsIDAuMCAvIDAuMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB0ID0gc3ViX2ZwNjQodCwgbXVsX2ZwNjQoUElfMTZfRlA2NCwgdmVjMihxLCAwLjApKSk7XFxuICAgIH1cXG5cXG4gICAgdmVjMiB1ID0gdmVjMigwLjAsIDAuMCk7XFxuICAgIHZlYzIgdiA9IHZlYzIoMC4wLCAwLjApO1xcblxcbiNpZiBkZWZpbmVkKE5WSURJQV9FUVVBVElPTl9XT1JLQVJPVU5EKSB8fCBkZWZpbmVkKElOVEVMX0VRVUFUSU9OX1dPUktBUk9VTkQpXFxuICAgIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMS4wKSA8IDAuNSkge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8wX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzBfRlA2NDtcXG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMi4wKSA8IDAuNSkge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8xX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcXG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMy4wKSA8IDAuNSkge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcXG4gICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gNC4wKSA8IDAuNSkge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8zX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzNfRlA2NDtcXG4gICAgfVxcbiNlbHNlXFxuICAgIGlmIChhYnNfayA9PSAxKSB7XFxuICAgICAgICB1ID0gQ09TX1RBQkxFXzBfRlA2NDtcXG4gICAgICAgIHYgPSBTSU5fVEFCTEVfMF9GUDY0O1xcbiAgICB9IGVsc2UgaWYgKGFic19rID09IDIpIHtcXG4gICAgICAgIHUgPSBDT1NfVEFCTEVfMV9GUDY0O1xcbiAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XFxuICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMykge1xcbiAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XFxuICAgICAgICB2ID0gU0lOX1RBQkxFXzJfRlA2NDtcXG4gICAgfSBlbHNlIGlmIChhYnNfayA9PSA0KSB7XFxuICAgICAgICB1ID0gQ09TX1RBQkxFXzNfRlA2NDtcXG4gICAgICAgIHYgPSBTSU5fVEFCTEVfM19GUDY0O1xcbiAgICB9XFxuI2VuZGlmXFxuXFxuICAgIHZlYzIgc2luX3QsIGNvc190O1xcbiAgICBzaW5jb3NfdGF5bG9yX2ZwNjQodCwgc2luX3QsIGNvc190KTtcXG5cXG4gICAgdmVjMiByZXN1bHQgPSB2ZWMyKDAuMCwgMC4wKTtcXG4gICAgaWYgKGogPT0gMCkge1xcbiAgICAgICAgaWYgKGsgPiAwKSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gc3ViX2ZwNjQobXVsX2ZwNjQodSwgY29zX3QpLCBtdWxfZnA2NCh2LCBzaW5fdCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXN1bHQgPSBzdW1fZnA2NChtdWxfZnA2NCh1LCBjb3NfdCksIG11bF9mcDY0KHYsIHNpbl90KSk7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XFxuICAgICAgICBpZiAoayA+IDApIHtcXG4gICAgICAgICAgICByZXN1bHQgPSAtc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh2LCBjb3NfdCksIG11bF9mcDY0KHUsIHNpbl90KSk7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSBpZiAoaiA9PSAtMSkge1xcbiAgICAgICAgaWYgKGsgPiAwKSB7XFxuICAgICAgICAgICAgcmVzdWx0ID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoayA+IDApIHtcXG4gICAgICAgICAgICByZXN1bHQgPSBzdWJfZnA2NChtdWxfZnA2NCh2LCBzaW5fdCksIG11bF9mcDY0KHUsIGNvc190KSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IC1zdW1fZnA2NChtdWxfZnA2NCh1LCBjb3NfdCksIG11bF9mcDY0KHYsIHNpbl90KSk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxudmVjMiB0YW5fZnA2NCh2ZWMyIGEpIHtcXG4gICAgdmVjMiBzaW5fYTtcXG4gICAgdmVjMiBjb3NfYTtcXG5cXG4gICAgaWYgKGEueCA9PSAwLjAgJiYgYS55ID09IDAuMCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xcbiAgICB9XFxuXFxuICAgIC8vIDJwaSByYW5nZSByZWR1Y3Rpb25cXG4gICAgdmVjMiB6ID0gbmludF9mcDY0KGRpdl9mcDY0KGEsIFRXT19QSV9GUDY0KSk7XFxuICAgIHZlYzIgciA9IHN1Yl9mcDY0KGEsIG11bF9mcDY0KFRXT19QSV9GUDY0LCB6KSk7XFxuXFxuICAgIHZlYzIgdDtcXG4gICAgZmxvYXQgcSA9IGZsb29yKHIueCAvIFBJXzJfRlA2NC54ICsgMC41KTtcXG4gICAgaW50IGogPSBpbnQocSk7XFxuXFxuXFxuICAgIGlmIChqIDwgLTIgfHwgaiA+IDIpIHtcXG4gICAgICAgIHJldHVybiB2ZWMyKDAuMCAvIDAuMCwgMC4wIC8gMC4wKTtcXG4gICAgfVxcblxcbiAgICB0ID0gc3ViX2ZwNjQociwgbXVsX2ZwNjQoUElfMl9GUDY0LCB2ZWMyKHEsIDAuMCkpKTtcXG5cXG4gICAgcSA9IGZsb29yKHQueCAvIFBJXzE2X0ZQNjQueCArIDAuNSk7XFxuICAgIGludCBrID0gaW50KHEpO1xcbiAgICBpbnQgYWJzX2sgPSBpbnQoYWJzKGZsb2F0KGspKSk7XFxuXFxuICAgIC8vIFdlIGp1c3QgY2FuXFwndCBnZXQgUEkvMTYgKiAzLjAgdmVyeSBhY2N1cmF0ZWx5LlxcbiAgICAvLyBzbyBsZXRcXCdzIGp1c3Qgc3RvcmUgaXRcXG4gICAgaWYgKGFic19rID4gNCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wIC8gMC4wLCAwLjAgLyAwLjApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdCA9IHN1Yl9mcDY0KHQsIG11bF9mcDY0KFBJXzE2X0ZQNjQsIHZlYzIocSwgMC4wKSkpO1xcbiAgICB9XFxuXFxuXFxuICAgIHZlYzIgdSA9IHZlYzIoMC4wLCAwLjApO1xcbiAgICB2ZWMyIHYgPSB2ZWMyKDAuMCwgMC4wKTtcXG5cXG4gICAgdmVjMiBzaW5fdCwgY29zX3Q7XFxuICAgIHZlYzIgcywgYztcXG4gICAgc2luY29zX3RheWxvcl9mcDY0KHQsIHNpbl90LCBjb3NfdCk7XFxuXFxuICAgIGlmIChrID09IDApIHtcXG4gICAgICAgIHMgPSBzaW5fdDtcXG4gICAgICAgIGMgPSBjb3NfdDtcXG4gICAgfSBlbHNlIHtcXG4jaWYgZGVmaW5lZChOVklESUFfRVFVQVRJT05fV09SS0FST1VORCkgfHwgZGVmaW5lZChJTlRFTF9FUVVBVElPTl9XT1JLQVJPVU5EKVxcbiAgICAgICAgaWYgKGFicyhmbG9hdChhYnNfaykgLSAxLjApIDwgMC41KSB7XFxuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8wX0ZQNjQ7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XFxuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XFxuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8xX0ZQNjQ7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8xX0ZQNjQ7XFxuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAzLjApIDwgMC41KSB7XFxuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8yX0ZQNjQ7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yX0ZQNjQ7XFxuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSA0LjApIDwgMC41KSB7XFxuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8zX0ZQNjQ7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XFxuICAgICAgICB9XFxuI2Vsc2VcXG4gICAgICAgIGlmIChhYnNfayA9PSAxKSB7XFxuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8wX0ZQNjQ7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8wX0ZQNjQ7XFxuICAgICAgICB9IGVsc2UgaWYgKGFic19rID09IDIpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzFfRlA2NDtcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzFfRlA2NDtcXG4gICAgICAgIH0gZWxzZSBpZiAoYWJzX2sgPT0gMykge1xcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMl9GUDY0O1xcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMl9GUDY0O1xcbiAgICAgICAgfSBlbHNlIGlmIChhYnNfayA9PSA0KSB7XFxuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8zX0ZQNjQ7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8zX0ZQNjQ7XFxuICAgICAgICB9XFxuI2VuZGlmXFxuICAgICAgICBpZiAoayA+IDApIHtcXG4gICAgICAgICAgICBzID0gc3VtX2ZwNjQobXVsX2ZwNjQodSwgc2luX3QpLCBtdWxfZnA2NCh2LCBjb3NfdCkpO1xcbiAgICAgICAgICAgIGMgPSBzdWJfZnA2NChtdWxfZnA2NCh1LCBjb3NfdCksIG11bF9mcDY0KHYsIHNpbl90KSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHMgPSBzdWJfZnA2NChtdWxfZnA2NCh1LCBzaW5fdCksIG11bF9mcDY0KHYsIGNvc190KSk7XFxuICAgICAgICAgICAgYyA9IHN1bV9mcDY0KG11bF9mcDY0KHUsIGNvc190KSwgbXVsX2ZwNjQodiwgc2luX3QpKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoaiA9PSAwKSB7XFxuICAgICAgICBzaW5fYSA9IHM7XFxuICAgICAgICBjb3NfYSA9IGM7XFxuICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XFxuICAgICAgICBzaW5fYSA9IGM7XFxuICAgICAgICBjb3NfYSA9IC1zO1xcbiAgICB9IGVsc2UgaWYgKGogPT0gLTEpIHtcXG4gICAgICAgIHNpbl9hID0gLWM7XFxuICAgICAgICBjb3NfYSA9IHM7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBzaW5fYSA9IC1zO1xcbiAgICAgICAgY29zX2EgPSAtYztcXG4gICAgfVxcbiAgICByZXR1cm4gZGl2X2ZwNjQoc2luX2EsIGNvc19hKTtcXG59XFxuXFxudmVjMiByYWRpYW5zX2ZwNjQodmVjMiBkZWdyZWUpIHtcXG4gIHJldHVybiBtdWxfZnA2NChkZWdyZWUsIFBJXzE4MF9GUDY0KTtcXG59XFxuXFxuLy8gVmVjdG9yIGZ1bmN0aW9uc1xcbi8vIHZlYzIgZnVuY3Rpb25zXFxudm9pZCB2ZWMyX3N1bV9mcDY0KHZlYzIgYVsyXSwgdmVjMiBiWzJdLCBvdXQgdmVjMiBvdXRfdmFsWzJdKSB7XFxuICAgIG91dF92YWxbMF0gPSBzdW1fZnA2NChhWzBdLCBiWzBdKTtcXG4gICAgb3V0X3ZhbFsxXSA9IHN1bV9mcDY0KGFbMV0sIGJbMV0pO1xcbn1cXG5cXG52b2lkIHZlYzJfc3ViX2ZwNjQodmVjMiBhWzJdLCB2ZWMyIGJbMl0sIG91dCB2ZWMyIG91dF92YWxbMl0pIHtcXG4gICAgb3V0X3ZhbFswXSA9IHN1Yl9mcDY0KGFbMF0sIGJbMF0pO1xcbiAgICBvdXRfdmFsWzFdID0gc3ViX2ZwNjQoYVsxXSwgYlsxXSk7XFxufVxcblxcbnZvaWQgdmVjMl9taXhfZnA2NCh2ZWMyIHhbMl0sIHZlYzIgeVsyXSwgZmxvYXQgYSwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xcbiAgdmVjMiByYW5nZVsyXTtcXG4gIHZlYzJfc3ViX2ZwNjQoeSwgeCwgcmFuZ2UpO1xcbiAgdmVjMiBwb3J0aW9uWzJdO1xcbiAgcG9ydGlvblswXSA9IHJhbmdlWzBdICogYTtcXG4gIHBvcnRpb25bMV0gPSByYW5nZVsxXSAqIGE7XFxuICB2ZWMyX3N1bV9mcDY0KHgsIHBvcnRpb24sIG91dF92YWwpO1xcbn1cXG5cXG52ZWMyIHZlYzJfbGVuZ3RoX2ZwNjQodmVjMiB4WzJdKSB7XFxuICByZXR1cm4gc3FydF9mcDY0KHN1bV9mcDY0KG11bF9mcDY0KHhbMF0sIHhbMF0pLCBtdWxfZnA2NCh4WzFdLCB4WzFdKSkpO1xcbn1cXG5cXG52ZWMyIHZlYzJfZGlzdGFuY2VfZnA2NCh2ZWMyIHhbMl0sIHZlYzIgeVsyXSkge1xcbiAgdmVjMiBkaWZmWzJdO1xcbiAgdmVjMl9zdWJfZnA2NCh4LCB5LCBkaWZmKTtcXG4gIHJldHVybiB2ZWMyX2xlbmd0aF9mcDY0KGRpZmYpO1xcbn1cXG5cXG4vLyB2ZWMzIGZ1bmN0aW9uc1xcbnZvaWQgdmVjM19zdWJfZnA2NCh2ZWMyIGFbM10sIHZlYzIgYlszXSwgb3V0IHZlYzIgb3V0X3ZhbFszXSkge1xcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyBpKyspIHtcXG4gICAgb3V0X3ZhbFtpXSA9IHN1bV9mcDY0KGFbaV0sIGJbaV0pO1xcbiAgfVxcbn1cXG5cXG52b2lkIHZlYzNfc3VtX2ZwNjQodmVjMiBhWzNdLCB2ZWMyIGJbM10sIG91dCB2ZWMyIG91dF92YWxbM10pIHtcXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgaSsrKSB7XFxuICAgIG91dF92YWxbaV0gPSBzdW1fZnA2NChhW2ldLCBiW2ldKTtcXG4gIH1cXG59XFxuXFxudmVjMiB2ZWMzX2xlbmd0aF9mcDY0KHZlYzIgeFszXSkge1xcbiAgcmV0dXJuIHNxcnRfZnA2NChzdW1fZnA2NChzdW1fZnA2NChtdWxfZnA2NCh4WzBdLCB4WzBdKSwgbXVsX2ZwNjQoeFsxXSwgeFsxXSkpLCBtdWxfZnA2NCh4WzJdLCB4WzJdKSkpO1xcbn1cXG5cXG52ZWMyIHZlYzNfZGlzdGFuY2VfZnA2NCh2ZWMyIHhbM10sIHZlYzIgeVszXSkge1xcbiAgdmVjMiBkaWZmWzNdO1xcbiAgdmVjM19zdWJfZnA2NCh4LCB5LCBkaWZmKTtcXG4gIHJldHVybiB2ZWMzX2xlbmd0aF9mcDY0KGRpZmYpO1xcbn1cXG5cXG4vLyB2ZWM0IGZ1bmN0aW9uc1xcbnZvaWQgdmVjNF9mcDY0KHZlYzQgYSwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xcbiAgb3V0X3ZhbFswXS54ID0gYVswXTtcXG4gIG91dF92YWxbMF0ueSA9IDAuMDtcXG5cXG4gIG91dF92YWxbMV0ueCA9IGFbMV07XFxuICBvdXRfdmFsWzFdLnkgPSAwLjA7XFxuXFxuICBvdXRfdmFsWzJdLnggPSBhWzJdO1xcbiAgb3V0X3ZhbFsyXS55ID0gMC4wO1xcblxcbiAgb3V0X3ZhbFszXS54ID0gYVszXTtcXG4gIG91dF92YWxbM10ueSA9IDAuMDtcXG59XFxuXFxudm9pZCB2ZWM0X3NjYWxhcl9tdWxfZnA2NCh2ZWMyIGFbNF0sIHZlYzIgYiwgb3V0IHZlYzIgb3V0X3ZhbFs0XSkge1xcbiAgb3V0X3ZhbFswXSA9IG11bF9mcDY0KGFbMF0sIGIpO1xcbiAgb3V0X3ZhbFsxXSA9IG11bF9mcDY0KGFbMV0sIGIpO1xcbiAgb3V0X3ZhbFsyXSA9IG11bF9mcDY0KGFbMl0sIGIpO1xcbiAgb3V0X3ZhbFszXSA9IG11bF9mcDY0KGFbM10sIGIpO1xcbn1cXG5cXG52b2lkIHZlYzRfc3VtX2ZwNjQodmVjMiBhWzRdLCB2ZWMyIGJbNF0sIG91dCB2ZWMyIG91dF92YWxbNF0pIHtcXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKSB7XFxuICAgIG91dF92YWxbaV0gPSBzdW1fZnA2NChhW2ldLCBiW2ldKTtcXG4gIH1cXG59XFxuXFxudm9pZCB2ZWM0X2RvdF9mcDY0KHZlYzIgYVs0XSwgdmVjMiBiWzRdLCBvdXQgdmVjMiBvdXRfdmFsKSB7XFxuICB2ZWMyIHZbNF07XFxuXFxuICB2WzBdID0gbXVsX2ZwNjQoYVswXSwgYlswXSk7XFxuICB2WzFdID0gbXVsX2ZwNjQoYVsxXSwgYlsxXSk7XFxuICB2WzJdID0gbXVsX2ZwNjQoYVsyXSwgYlsyXSk7XFxuICB2WzNdID0gbXVsX2ZwNjQoYVszXSwgYlszXSk7XFxuXFxuICBvdXRfdmFsID0gc3VtX2ZwNjQoc3VtX2ZwNjQodlswXSwgdlsxXSksIHN1bV9mcDY0KHZbMl0sIHZbM10pKTtcXG59XFxuXFxudm9pZCBtYXQ0X3ZlYzRfbXVsX2ZwNjQodmVjMiBiWzE2XSwgdmVjMiBhWzRdLCBvdXQgdmVjMiBvdXRfdmFsWzRdKSB7XFxuICB2ZWMyIHRtcFs0XTtcXG5cXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKVxcbiAge1xcbiAgICBmb3IgKGludCBqID0gMDsgaiA8IDQ7IGorKylcXG4gICAge1xcbiAgICAgIHRtcFtqXSA9IGJbaiArIGkgKiA0XTtcXG4gICAgfVxcbiAgICB2ZWM0X2RvdF9mcDY0KGEsIHRtcCwgb3V0X3ZhbFtpXSk7XFxuICB9XFxufVxcbidcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2hhZGVybGliL2ZwNjQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 73 */
/* exports provided: lighting */
/* exports used: lighting */
/*!*****************************************!*\
  !*** ./src/shaderlib/lighting/index.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return lighting; });\n\n\n\nvar lighting = {\n  interface: 'lighting',\n  source: '// lighting\\n\\n#define NUM_OF_LIGHTS 2\\nuniform vec3 cameraPos;\\nuniform vec3 lightsPosition[16];\\nuniform vec2 lightsStrength[16];\\nuniform float ambientRatio;\\nuniform float diffuseRatio;\\nuniform float specularRatio;\\n\\nfloat getLightWeight(vec4 position_worldspace, vec3 normals_worldspace) {\\n  float lightWeight = 0.0;\\n\\n  vec3 position_worldspace_vec3 = position_worldspace.xyz / position_worldspace.w;\\n  vec3 normals_worldspace_vec3 = normals_worldspace.xzy;\\n\\n  vec3 camera_pos_worldspace = cameraPos;\\n  vec3 view_direction = normalize(camera_pos_worldspace - position_worldspace_vec3);\\n\\n  for (int i = 0; i < NUM_OF_LIGHTS; i++) {\\n    vec3 light_position_worldspace = project_position(lightsPosition[i]);\\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace_vec3);\\n\\n    vec3 halfway_direction = normalize(light_direction + view_direction);\\n    float lambertian = dot(light_direction, normals_worldspace_vec3);\\n    float specular = 0.0;\\n    if (lambertian > 0.0) {\\n      float specular_angle = max(dot(normals_worldspace_vec3, halfway_direction), 0.0);\\n      specular = pow(specular_angle, 32.0);\\n    }\\n    lambertian = max(lambertian, 0.0);\\n    lightWeight += (ambientRatio + lambertian * diffuseRatio + specular * specularRatio) * lightsStrength[i].x;\\n\\n  }\\n\\n  return lightWeight;\\n}\\n\\n'\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVybGliL2xpZ2h0aW5nL2luZGV4LmpzP2RmY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuZXhwb3J0IHZhciBsaWdodGluZyA9IHtcbiAgaW50ZXJmYWNlOiAnbGlnaHRpbmcnLFxuICBzb3VyY2U6ICcvLyBsaWdodGluZ1xcblxcbiNkZWZpbmUgTlVNX09GX0xJR0hUUyAyXFxudW5pZm9ybSB2ZWMzIGNhbWVyYVBvcztcXG51bmlmb3JtIHZlYzMgbGlnaHRzUG9zaXRpb25bMTZdO1xcbnVuaWZvcm0gdmVjMiBsaWdodHNTdHJlbmd0aFsxNl07XFxudW5pZm9ybSBmbG9hdCBhbWJpZW50UmF0aW87XFxudW5pZm9ybSBmbG9hdCBkaWZmdXNlUmF0aW87XFxudW5pZm9ybSBmbG9hdCBzcGVjdWxhclJhdGlvO1xcblxcbmZsb2F0IGdldExpZ2h0V2VpZ2h0KHZlYzQgcG9zaXRpb25fd29ybGRzcGFjZSwgdmVjMyBub3JtYWxzX3dvcmxkc3BhY2UpIHtcXG4gIGZsb2F0IGxpZ2h0V2VpZ2h0ID0gMC4wO1xcblxcbiAgdmVjMyBwb3NpdGlvbl93b3JsZHNwYWNlX3ZlYzMgPSBwb3NpdGlvbl93b3JsZHNwYWNlLnh5eiAvIHBvc2l0aW9uX3dvcmxkc3BhY2UudztcXG4gIHZlYzMgbm9ybWFsc193b3JsZHNwYWNlX3ZlYzMgPSBub3JtYWxzX3dvcmxkc3BhY2UueHp5O1xcblxcbiAgdmVjMyBjYW1lcmFfcG9zX3dvcmxkc3BhY2UgPSBjYW1lcmFQb3M7XFxuICB2ZWMzIHZpZXdfZGlyZWN0aW9uID0gbm9ybWFsaXplKGNhbWVyYV9wb3Nfd29ybGRzcGFjZSAtIHBvc2l0aW9uX3dvcmxkc3BhY2VfdmVjMyk7XFxuXFxuICBmb3IgKGludCBpID0gMDsgaSA8IE5VTV9PRl9MSUdIVFM7IGkrKykge1xcbiAgICB2ZWMzIGxpZ2h0X3Bvc2l0aW9uX3dvcmxkc3BhY2UgPSBwcm9qZWN0X3Bvc2l0aW9uKGxpZ2h0c1Bvc2l0aW9uW2ldKTtcXG4gICAgdmVjMyBsaWdodF9kaXJlY3Rpb24gPSBub3JtYWxpemUobGlnaHRfcG9zaXRpb25fd29ybGRzcGFjZSAtIHBvc2l0aW9uX3dvcmxkc3BhY2VfdmVjMyk7XFxuXFxuICAgIHZlYzMgaGFsZndheV9kaXJlY3Rpb24gPSBub3JtYWxpemUobGlnaHRfZGlyZWN0aW9uICsgdmlld19kaXJlY3Rpb24pO1xcbiAgICBmbG9hdCBsYW1iZXJ0aWFuID0gZG90KGxpZ2h0X2RpcmVjdGlvbiwgbm9ybWFsc193b3JsZHNwYWNlX3ZlYzMpO1xcbiAgICBmbG9hdCBzcGVjdWxhciA9IDAuMDtcXG4gICAgaWYgKGxhbWJlcnRpYW4gPiAwLjApIHtcXG4gICAgICBmbG9hdCBzcGVjdWxhcl9hbmdsZSA9IG1heChkb3Qobm9ybWFsc193b3JsZHNwYWNlX3ZlYzMsIGhhbGZ3YXlfZGlyZWN0aW9uKSwgMC4wKTtcXG4gICAgICBzcGVjdWxhciA9IHBvdyhzcGVjdWxhcl9hbmdsZSwgMzIuMCk7XFxuICAgIH1cXG4gICAgbGFtYmVydGlhbiA9IG1heChsYW1iZXJ0aWFuLCAwLjApO1xcbiAgICBsaWdodFdlaWdodCArPSAoYW1iaWVudFJhdGlvICsgbGFtYmVydGlhbiAqIGRpZmZ1c2VSYXRpbyArIHNwZWN1bGFyICogc3BlY3VsYXJSYXRpbykgKiBsaWdodHNTdHJlbmd0aFtpXS54O1xcblxcbiAgfVxcblxcbiAgcmV0dXJuIGxpZ2h0V2VpZ2h0O1xcbn1cXG5cXG4nXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3NoYWRlcmxpYi9saWdodGluZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 74 */
/* exports provided: project */
/* exports used: project */
/*!****************************************!*\
  !*** ./src/shaderlib/project/index.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return project; });\n\n\nvar project = {\n  interface: 'project',\n  source: 'const float TILE_SIZE = 512.0;\\nconst float PI = 3.1415926536;\\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\\n\\nconst float PROJECT_LINEAR = 0.;\\nconst float PROJECT_MERCATOR = 1.;\\nconst float PROJECT_MERCATOR_OFFSETS = 2.;\\n\\nuniform float projectionMode;\\nuniform float projectionScale;\\nuniform vec4 projectionCenter;\\nuniform vec3 projectionPixelsPerUnit;\\n\\nuniform mat4 projectionMatrix;\\nuniform mat4 projectionMatrixUncentered;\\n\\n#ifdef INTEL_TAN_WORKAROUND\\n\\n// All these functions are for substituting tan() function from Intel GPU only\\nconst float TWO_PI = 6.2831854820251465;\\nconst float PI_2 = 1.5707963705062866;\\nconst float PI_16 = 0.1963495463132858;\\n\\nconst float SIN_TABLE_0 = 0.19509032368659973;\\nconst float SIN_TABLE_1 = 0.3826834261417389;\\nconst float SIN_TABLE_2 = 0.5555702447891235;\\nconst float SIN_TABLE_3 = 0.7071067690849304;\\n\\nconst float COS_TABLE_0 = 0.9807852506637573;\\nconst float COS_TABLE_1 = 0.9238795042037964;\\nconst float COS_TABLE_2 = 0.8314695954322815;\\nconst float COS_TABLE_3 = 0.7071067690849304;\\n\\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\\n\\nfloat sin_taylor_fp32(float a) {\\n  float r, s, t, x;\\n\\n  if (a == 0.0) {\\n    return 0.0;\\n  }\\n\\n  x = -a * a;\\n  s = a;\\n  r = a;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_3;\\n  s = s + t;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_5;\\n  s = s + t;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_7;\\n  s = s + t;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_9;\\n  s = s + t;\\n\\n  return s;\\n}\\n\\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\\n  if (a == 0.0) {\\n    sin_t = 0.0;\\n    cos_t = 1.0;\\n  }\\n  sin_t = sin_taylor_fp32(a);\\n  cos_t = sqrt(1.0 - sin_t * sin_t);\\n}\\n\\nfloat tan_taylor_fp32(float a) {\\n    float sin_a;\\n    float cos_a;\\n\\n    if (a == 0.0) {\\n        return 0.0;\\n    }\\n\\n    // 2pi range reduction\\n    float z = floor(a / TWO_PI);\\n    float r = a - TWO_PI * z;\\n\\n    float t;\\n    float q = floor(r / PI_2 + 0.5);\\n    int j = int(q);\\n\\n    if (j < -2 || j > 2) {\\n        return 0.0 / 0.0;\\n    }\\n\\n    t = r - PI_2 * q;\\n\\n    q = floor(t / PI_16 + 0.5);\\n    int k = int(q);\\n    int abs_k = int(abs(float(k)));\\n\\n    if (abs_k > 4) {\\n        return 0.0 / 0.0;\\n    } else {\\n        t = t - PI_16 * q;\\n    }\\n\\n    float u = 0.0;\\n    float v = 0.0;\\n\\n    float sin_t, cos_t;\\n    float s, c;\\n    sincos_taylor_fp32(t, sin_t, cos_t);\\n\\n    if (k == 0) {\\n        s = sin_t;\\n        c = cos_t;\\n    } else {\\n        if (abs(float(abs_k) - 1.0) < 0.5) {\\n            u = COS_TABLE_0;\\n            v = SIN_TABLE_0;\\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\\n            u = COS_TABLE_1;\\n            v = SIN_TABLE_1;\\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\\n            u = COS_TABLE_2;\\n            v = SIN_TABLE_2;\\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\\n            u = COS_TABLE_3;\\n            v = SIN_TABLE_3;\\n        }\\n        if (k > 0) {\\n            s = u * sin_t + v * cos_t;\\n            c = u * cos_t - v * sin_t;\\n        } else {\\n            s = u * sin_t - v * cos_t;\\n            c = u * cos_t + v * sin_t;\\n        }\\n    }\\n\\n    if (j == 0) {\\n        sin_a = s;\\n        cos_a = c;\\n    } else if (j == 1) {\\n        sin_a = c;\\n        cos_a = -s;\\n    } else if (j == -1) {\\n        sin_a = -c;\\n        cos_a = s;\\n    } else {\\n        sin_a = -s;\\n        cos_a = -c;\\n    }\\n    return sin_a / cos_a;\\n}\\n#endif\\n\\nfloat tan_fp32(float a) {\\n#ifdef INTEL_TAN_WORKAROUND\\n  return tan_taylor_fp32(a);\\n#else\\n  return tan(a);\\n#endif\\n}\\n\\n//\\n// Scaling offsets\\n//\\n\\nfloat project_scale(float meters) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    return meters;\\n  } else {\\n    return meters * projectionPixelsPerUnit.x;\\n  }\\n}\\n\\nvec2 project_scale(vec2 meters) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    return meters;\\n  } else {\\n    return vec2(\\n      meters.x * projectionPixelsPerUnit.x,\\n      meters.y * projectionPixelsPerUnit.x\\n    );\\n  }\\n}\\n\\nvec3 project_scale(vec3 meters) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    return meters;\\n  } else {\\n    return vec3(\\n      meters.x * projectionPixelsPerUnit.x,\\n      meters.y * projectionPixelsPerUnit.x,\\n      meters.z * projectionPixelsPerUnit.x\\n    );\\n  }\\n}\\n\\nvec4 project_scale(vec4 meters) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    return meters;\\n  } else {\\n    return vec4(\\n      meters.x * projectionPixelsPerUnit.x,\\n      meters.y * projectionPixelsPerUnit.x,\\n      meters.z * projectionPixelsPerUnit.x,\\n      meters.w\\n    );\\n  }\\n}\\n\\n//\\n// Projecting positions\\n//\\n\\n// non-linear projection: lnglats => unit tile [0-1, 0-1]\\nvec2 project_mercator_(vec2 lnglat) {\\n  return vec2(\\n    radians(lnglat.x) + PI,\\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\\n  );\\n}\\n\\nvec2 project_position(vec2 position) {\\n  // if (projectionMode == PROJECT_LINEAR) {\\n  //   return (position + vec2(TILE_SIZE / 2.0)) * projectionScale;\\n  // }\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    return position;\\n    return project_scale(position);\\n  }\\n  // Covers projectionMode == PROJECT_MERCATOR\\n  return project_mercator_(position) * WORLD_SCALE * projectionScale;\\n}\\n\\nvec3 project_position(vec3 position) {\\n  return vec3(project_position(position.xy), project_scale(position.z));\\n}\\n\\nvec4 project_position(vec4 position) {\\n  return vec4(project_position(position.xyz), position.w);\\n}\\n\\n//\\n\\nvec4 project_to_clipspace(vec4 position) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    position = position * projectionPixelsPerUnit.x;\\n  }\\n  return projectionMatrix * position + projectionCenter;\\n}\\n\\n// Backwards compatibility\\n\\nfloat scale(float position) {\\n  return project_scale(position);\\n}\\n\\nvec2 scale(vec2 position) {\\n  return project_scale(position);\\n}\\n\\nvec3 scale(vec3 position) {\\n  return project_scale(position);\\n}\\n\\nvec4 scale(vec4 position) {\\n  return project_scale(position);\\n}\\n\\nvec2 preproject(vec2 position) {\\n  return project_position(position);\\n}\\n\\nvec3 preproject(vec3 position) {\\n  return project_position(position);\\n}\\n\\nvec4 preproject(vec4 position) {\\n  return project_position(position);\\n}\\n\\nvec4 project(vec4 position) {\\n  return project_to_clipspace(position);\\n}\\n'\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVybGliL3Byb2plY3QvaW5kZXguanM/MjgyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuZXhwb3J0IHZhciBwcm9qZWN0ID0ge1xuICBpbnRlcmZhY2U6ICdwcm9qZWN0JyxcbiAgc291cmNlOiAnY29uc3QgZmxvYXQgVElMRV9TSVpFID0gNTEyLjA7XFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzY7XFxuY29uc3QgZmxvYXQgV09STERfU0NBTEUgPSBUSUxFX1NJWkUgLyAoUEkgKiAyLjApO1xcblxcbmNvbnN0IGZsb2F0IFBST0pFQ1RfTElORUFSID0gMC47XFxuY29uc3QgZmxvYXQgUFJPSkVDVF9NRVJDQVRPUiA9IDEuO1xcbmNvbnN0IGZsb2F0IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUyA9IDIuO1xcblxcbnVuaWZvcm0gZmxvYXQgcHJvamVjdGlvbk1vZGU7XFxudW5pZm9ybSBmbG9hdCBwcm9qZWN0aW9uU2NhbGU7XFxudW5pZm9ybSB2ZWM0IHByb2plY3Rpb25DZW50ZXI7XFxudW5pZm9ybSB2ZWMzIHByb2plY3Rpb25QaXhlbHNQZXJVbml0O1xcblxcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZDtcXG5cXG4jaWZkZWYgSU5URUxfVEFOX1dPUktBUk9VTkRcXG5cXG4vLyBBbGwgdGhlc2UgZnVuY3Rpb25zIGFyZSBmb3Igc3Vic3RpdHV0aW5nIHRhbigpIGZ1bmN0aW9uIGZyb20gSW50ZWwgR1BVIG9ubHlcXG5jb25zdCBmbG9hdCBUV09fUEkgPSA2LjI4MzE4NTQ4MjAyNTE0NjU7XFxuY29uc3QgZmxvYXQgUElfMiA9IDEuNTcwNzk2MzcwNTA2Mjg2NjtcXG5jb25zdCBmbG9hdCBQSV8xNiA9IDAuMTk2MzQ5NTQ2MzEzMjg1ODtcXG5cXG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMCA9IDAuMTk1MDkwMzIzNjg2NTk5NzM7XFxuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzEgPSAwLjM4MjY4MzQyNjE0MTczODk7XFxuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzIgPSAwLjU1NTU3MDI0NDc4OTEyMzU7XFxuY29uc3QgZmxvYXQgU0lOX1RBQkxFXzMgPSAwLjcwNzEwNjc2OTA4NDkzMDQ7XFxuXFxuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzAgPSAwLjk4MDc4NTI1MDY2Mzc1NzM7XFxuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzEgPSAwLjkyMzg3OTUwNDIwMzc5NjQ7XFxuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzIgPSAwLjgzMTQ2OTU5NTQzMjI4MTU7XFxuY29uc3QgZmxvYXQgQ09TX1RBQkxFXzMgPSAwLjcwNzEwNjc2OTA4NDkzMDQ7XFxuXFxuY29uc3QgZmxvYXQgSU5WRVJTRV9GQUNUT1JJQUxfMyA9IDEuNjY2NjY2NzE2MzM3MjA0ZS0wMTsgLy8gMS8zIVxcbmNvbnN0IGZsb2F0IElOVkVSU0VfRkFDVE9SSUFMXzUgPSA4LjMzMzMzMzc2Nzk1MDUzNWUtMDM7IC8vIDEvNSFcXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF83ID0gMS45ODQxMjcwMTEzODI5NTIzZS0wNDsgLy8gMS83IVxcbmNvbnN0IGZsb2F0IElOVkVSU0VfRkFDVE9SSUFMXzkgPSAyLjc1NTczMTg4NDQ2Mjg3NTMzZS0wNjsgLy8gMS85IVxcblxcbmZsb2F0IHNpbl90YXlsb3JfZnAzMihmbG9hdCBhKSB7XFxuICBmbG9hdCByLCBzLCB0LCB4O1xcblxcbiAgaWYgKGEgPT0gMC4wKSB7XFxuICAgIHJldHVybiAwLjA7XFxuICB9XFxuXFxuICB4ID0gLWEgKiBhO1xcbiAgcyA9IGE7XFxuICByID0gYTtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfMztcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfNTtcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfNztcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfOTtcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHJldHVybiBzO1xcbn1cXG5cXG52b2lkIHNpbmNvc190YXlsb3JfZnAzMihmbG9hdCBhLCBvdXQgZmxvYXQgc2luX3QsIG91dCBmbG9hdCBjb3NfdCkge1xcbiAgaWYgKGEgPT0gMC4wKSB7XFxuICAgIHNpbl90ID0gMC4wO1xcbiAgICBjb3NfdCA9IDEuMDtcXG4gIH1cXG4gIHNpbl90ID0gc2luX3RheWxvcl9mcDMyKGEpO1xcbiAgY29zX3QgPSBzcXJ0KDEuMCAtIHNpbl90ICogc2luX3QpO1xcbn1cXG5cXG5mbG9hdCB0YW5fdGF5bG9yX2ZwMzIoZmxvYXQgYSkge1xcbiAgICBmbG9hdCBzaW5fYTtcXG4gICAgZmxvYXQgY29zX2E7XFxuXFxuICAgIGlmIChhID09IDAuMCkge1xcbiAgICAgICAgcmV0dXJuIDAuMDtcXG4gICAgfVxcblxcbiAgICAvLyAycGkgcmFuZ2UgcmVkdWN0aW9uXFxuICAgIGZsb2F0IHogPSBmbG9vcihhIC8gVFdPX1BJKTtcXG4gICAgZmxvYXQgciA9IGEgLSBUV09fUEkgKiB6O1xcblxcbiAgICBmbG9hdCB0O1xcbiAgICBmbG9hdCBxID0gZmxvb3IociAvIFBJXzIgKyAwLjUpO1xcbiAgICBpbnQgaiA9IGludChxKTtcXG5cXG4gICAgaWYgKGogPCAtMiB8fCBqID4gMikge1xcbiAgICAgICAgcmV0dXJuIDAuMCAvIDAuMDtcXG4gICAgfVxcblxcbiAgICB0ID0gciAtIFBJXzIgKiBxO1xcblxcbiAgICBxID0gZmxvb3IodCAvIFBJXzE2ICsgMC41KTtcXG4gICAgaW50IGsgPSBpbnQocSk7XFxuICAgIGludCBhYnNfayA9IGludChhYnMoZmxvYXQoaykpKTtcXG5cXG4gICAgaWYgKGFic19rID4gNCkge1xcbiAgICAgICAgcmV0dXJuIDAuMCAvIDAuMDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHQgPSB0IC0gUElfMTYgKiBxO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IHUgPSAwLjA7XFxuICAgIGZsb2F0IHYgPSAwLjA7XFxuXFxuICAgIGZsb2F0IHNpbl90LCBjb3NfdDtcXG4gICAgZmxvYXQgcywgYztcXG4gICAgc2luY29zX3RheWxvcl9mcDMyKHQsIHNpbl90LCBjb3NfdCk7XFxuXFxuICAgIGlmIChrID09IDApIHtcXG4gICAgICAgIHMgPSBzaW5fdDtcXG4gICAgICAgIGMgPSBjb3NfdDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMS4wKSA8IDAuNSkge1xcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMDtcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzA7XFxuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAyLjApIDwgMC41KSB7XFxuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8xO1xcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMTtcXG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDMuMCkgPCAwLjUpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzI7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8yO1xcbiAgICAgICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gNC4wKSA8IDAuNSkge1xcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMztcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzM7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoayA+IDApIHtcXG4gICAgICAgICAgICBzID0gdSAqIHNpbl90ICsgdiAqIGNvc190O1xcbiAgICAgICAgICAgIGMgPSB1ICogY29zX3QgLSB2ICogc2luX3Q7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHMgPSB1ICogc2luX3QgLSB2ICogY29zX3Q7XFxuICAgICAgICAgICAgYyA9IHUgKiBjb3NfdCArIHYgKiBzaW5fdDtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoaiA9PSAwKSB7XFxuICAgICAgICBzaW5fYSA9IHM7XFxuICAgICAgICBjb3NfYSA9IGM7XFxuICAgIH0gZWxzZSBpZiAoaiA9PSAxKSB7XFxuICAgICAgICBzaW5fYSA9IGM7XFxuICAgICAgICBjb3NfYSA9IC1zO1xcbiAgICB9IGVsc2UgaWYgKGogPT0gLTEpIHtcXG4gICAgICAgIHNpbl9hID0gLWM7XFxuICAgICAgICBjb3NfYSA9IHM7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBzaW5fYSA9IC1zO1xcbiAgICAgICAgY29zX2EgPSAtYztcXG4gICAgfVxcbiAgICByZXR1cm4gc2luX2EgLyBjb3NfYTtcXG59XFxuI2VuZGlmXFxuXFxuZmxvYXQgdGFuX2ZwMzIoZmxvYXQgYSkge1xcbiNpZmRlZiBJTlRFTF9UQU5fV09SS0FST1VORFxcbiAgcmV0dXJuIHRhbl90YXlsb3JfZnAzMihhKTtcXG4jZWxzZVxcbiAgcmV0dXJuIHRhbihhKTtcXG4jZW5kaWZcXG59XFxuXFxuLy9cXG4vLyBTY2FsaW5nIG9mZnNldHNcXG4vL1xcblxcbmZsb2F0IHByb2plY3Rfc2NhbGUoZmxvYXQgbWV0ZXJzKSB7XFxuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XFxuICAgIHJldHVybiBtZXRlcnM7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gbWV0ZXJzICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueDtcXG4gIH1cXG59XFxuXFxudmVjMiBwcm9qZWN0X3NjYWxlKHZlYzIgbWV0ZXJzKSB7XFxuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XFxuICAgIHJldHVybiBtZXRlcnM7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gdmVjMihcXG4gICAgICBtZXRlcnMueCAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXFxuICAgICAgbWV0ZXJzLnkgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54XFxuICAgICk7XFxuICB9XFxufVxcblxcbnZlYzMgcHJvamVjdF9zY2FsZSh2ZWMzIG1ldGVycykge1xcbiAgaWYgKHByb2plY3Rpb25Nb2RlID09IFBST0pFQ1RfTUVSQ0FUT1JfT0ZGU0VUUykge1xcbiAgICByZXR1cm4gbWV0ZXJzO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIHZlYzMoXFxuICAgICAgbWV0ZXJzLnggKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxcbiAgICAgIG1ldGVycy55ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcXG4gICAgICBtZXRlcnMueiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LnhcXG4gICAgKTtcXG4gIH1cXG59XFxuXFxudmVjNCBwcm9qZWN0X3NjYWxlKHZlYzQgbWV0ZXJzKSB7XFxuICBpZiAocHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUl9PRkZTRVRTKSB7XFxuICAgIHJldHVybiBtZXRlcnM7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gdmVjNChcXG4gICAgICBtZXRlcnMueCAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0LngsXFxuICAgICAgbWV0ZXJzLnkgKiBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdC54LFxcbiAgICAgIG1ldGVycy56ICogcHJvamVjdGlvblBpeGVsc1BlclVuaXQueCxcXG4gICAgICBtZXRlcnMud1xcbiAgICApO1xcbiAgfVxcbn1cXG5cXG4vL1xcbi8vIFByb2plY3RpbmcgcG9zaXRpb25zXFxuLy9cXG5cXG4vLyBub24tbGluZWFyIHByb2plY3Rpb246IGxuZ2xhdHMgPT4gdW5pdCB0aWxlIFswLTEsIDAtMV1cXG52ZWMyIHByb2plY3RfbWVyY2F0b3JfKHZlYzIgbG5nbGF0KSB7XFxuICByZXR1cm4gdmVjMihcXG4gICAgcmFkaWFucyhsbmdsYXQueCkgKyBQSSxcXG4gICAgUEkgLSBsb2codGFuX2ZwMzIoUEkgKiAwLjI1ICsgcmFkaWFucyhsbmdsYXQueSkgKiAwLjUpKVxcbiAgKTtcXG59XFxuXFxudmVjMiBwcm9qZWN0X3Bvc2l0aW9uKHZlYzIgcG9zaXRpb24pIHtcXG4gIC8vIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX0xJTkVBUikge1xcbiAgLy8gICByZXR1cm4gKHBvc2l0aW9uICsgdmVjMihUSUxFX1NJWkUgLyAyLjApKSAqIHByb2plY3Rpb25TY2FsZTtcXG4gIC8vIH1cXG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xcbiAgICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XFxuICB9XFxuICAvLyBDb3ZlcnMgcHJvamVjdGlvbk1vZGUgPT0gUFJPSkVDVF9NRVJDQVRPUlxcbiAgcmV0dXJuIHByb2plY3RfbWVyY2F0b3JfKHBvc2l0aW9uKSAqIFdPUkxEX1NDQUxFICogcHJvamVjdGlvblNjYWxlO1xcbn1cXG5cXG52ZWMzIHByb2plY3RfcG9zaXRpb24odmVjMyBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHZlYzMocHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbi54eSksIHByb2plY3Rfc2NhbGUocG9zaXRpb24ueikpO1xcbn1cXG5cXG52ZWM0IHByb2plY3RfcG9zaXRpb24odmVjNCBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHZlYzQocHJvamVjdF9wb3NpdGlvbihwb3NpdGlvbi54eXopLCBwb3NpdGlvbi53KTtcXG59XFxuXFxuLy9cXG5cXG52ZWM0IHByb2plY3RfdG9fY2xpcHNwYWNlKHZlYzQgcG9zaXRpb24pIHtcXG4gIGlmIChwcm9qZWN0aW9uTW9kZSA9PSBQUk9KRUNUX01FUkNBVE9SX09GRlNFVFMpIHtcXG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiAqIHByb2plY3Rpb25QaXhlbHNQZXJVbml0Lng7XFxuICB9XFxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeCAqIHBvc2l0aW9uICsgcHJvamVjdGlvbkNlbnRlcjtcXG59XFxuXFxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcXG5cXG5mbG9hdCBzY2FsZShmbG9hdCBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xcbn1cXG5cXG52ZWMyIHNjYWxlKHZlYzIgcG9zaXRpb24pIHtcXG4gIHJldHVybiBwcm9qZWN0X3NjYWxlKHBvc2l0aW9uKTtcXG59XFxuXFxudmVjMyBzY2FsZSh2ZWMzIHBvc2l0aW9uKSB7XFxuICByZXR1cm4gcHJvamVjdF9zY2FsZShwb3NpdGlvbik7XFxufVxcblxcbnZlYzQgc2NhbGUodmVjNCBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3Rfc2NhbGUocG9zaXRpb24pO1xcbn1cXG5cXG52ZWMyIHByZXByb2plY3QodmVjMiBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xcbn1cXG5cXG52ZWMzIHByZXByb2plY3QodmVjMyBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xcbn1cXG5cXG52ZWM0IHByZXByb2plY3QodmVjNCBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3RfcG9zaXRpb24ocG9zaXRpb24pO1xcbn1cXG5cXG52ZWM0IHByb2plY3QodmVjNCBwb3NpdGlvbikge1xcbiAgcmV0dXJuIHByb2plY3RfdG9fY2xpcHNwYWNlKHBvc2l0aW9uKTtcXG59XFxuJ1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJsaWIvcHJvamVjdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 75 */
/* exports provided: project64 */
/* exports used: project64 */
/*!******************************************!*\
  !*** ./src/shaderlib/project64/index.js ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path__ = __webpack_require__(/*! path */ 1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return project64; });\n\n\nvar project64 = {\n  interface: 'project64',\n  source: 'const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\\n\\nuniform vec2 projectionScaleFP64;\\nuniform vec2 projectionFP64[16];\\n\\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) { //longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw\\n\\n#if defined(NVIDIA_FP64_WORKAROUND)\\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\\n#else\\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\\n#endif\\n  out_val[1] = sub_fp64(PI_FP64, log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\\n  return;\\n}\\n\\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\\n\\n  vec2 pos_fp64[2];\\n  mercatorProject_fp64(position_fp64, pos_fp64);\\n  vec2 x_fp64 = mul_fp64(pos_fp64[0], projectionScaleFP64);\\n  vec2 y_fp64 = mul_fp64(pos_fp64[1], projectionScaleFP64);\\n  out_val[0] = mul_fp64(x_fp64, WORLD_SCALE_FP64);\\n  out_val[1] = mul_fp64(y_fp64, WORLD_SCALE_FP64);\\n\\n  return;\\n}\\n\\nvec4 project_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\\n  vec2 vertex_pos_clipspace[4];\\n  mat4_vec4_mul_fp64(projectionFP64, vertex_pos_modelspace, vertex_pos_clipspace);\\n  return vec4(\\n    vertex_pos_clipspace[0].x,\\n    vertex_pos_clipspace[1].x,\\n    vertex_pos_clipspace[2].x,\\n    vertex_pos_clipspace[3].x\\n    );\\n}\\n'\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2hhZGVybGliL3Byb2plY3Q2NC9pbmRleC5qcz8xNWNkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5leHBvcnQgdmFyIHByb2plY3Q2NCA9IHtcbiAgaW50ZXJmYWNlOiAncHJvamVjdDY0JyxcbiAgc291cmNlOiAnY29uc3QgdmVjMiBXT1JMRF9TQ0FMRV9GUDY0ID0gdmVjMig4MS40ODczMjc1NzU2ODM2LCAwLjAwMDAwMzI4NzM2NjgyMzIwMTQwOTcpO1xcblxcbnVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uU2NhbGVGUDY0O1xcbnVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uRlA2NFsxNl07XFxuXFxudm9pZCBtZXJjYXRvclByb2plY3RfZnA2NCh2ZWM0IGxuZ2xhdF9mcDY0LCBvdXQgdmVjMiBvdXRfdmFsWzJdKSB7IC8vbG9uZ2l0dWRlOiBsbmdsYXRfZnA2NC54eTsgbGF0aXR1ZGU6IGxuZ2xhdF9mcDY0Lnp3XFxuXFxuI2lmIGRlZmluZWQoTlZJRElBX0ZQNjRfV09SS0FST1VORClcXG4gIG91dF92YWxbMF0gPSBzdW1fZnA2NChyYWRpYW5zX2ZwNjQobG5nbGF0X2ZwNjQueHkpLCBQSV9GUDY0ICogT05FKTtcXG4jZWxzZVxcbiAgb3V0X3ZhbFswXSA9IHN1bV9mcDY0KHJhZGlhbnNfZnA2NChsbmdsYXRfZnA2NC54eSksIFBJX0ZQNjQpO1xcbiNlbmRpZlxcbiAgb3V0X3ZhbFsxXSA9IHN1Yl9mcDY0KFBJX0ZQNjQsIGxvZ19mcDY0KHRhbl9mcDY0KHN1bV9mcDY0KFBJXzRfRlA2NCwgcmFkaWFuc19mcDY0KGxuZ2xhdF9mcDY0Lnp3KSAvIDIuMCkpKSk7XFxuICByZXR1cm47XFxufVxcblxcbnZvaWQgcHJvamVjdF9wb3NpdGlvbl9mcDY0KHZlYzQgcG9zaXRpb25fZnA2NCwgb3V0IHZlYzIgb3V0X3ZhbFsyXSkge1xcblxcbiAgdmVjMiBwb3NfZnA2NFsyXTtcXG4gIG1lcmNhdG9yUHJvamVjdF9mcDY0KHBvc2l0aW9uX2ZwNjQsIHBvc19mcDY0KTtcXG4gIHZlYzIgeF9mcDY0ID0gbXVsX2ZwNjQocG9zX2ZwNjRbMF0sIHByb2plY3Rpb25TY2FsZUZQNjQpO1xcbiAgdmVjMiB5X2ZwNjQgPSBtdWxfZnA2NChwb3NfZnA2NFsxXSwgcHJvamVjdGlvblNjYWxlRlA2NCk7XFxuICBvdXRfdmFsWzBdID0gbXVsX2ZwNjQoeF9mcDY0LCBXT1JMRF9TQ0FMRV9GUDY0KTtcXG4gIG91dF92YWxbMV0gPSBtdWxfZnA2NCh5X2ZwNjQsIFdPUkxEX1NDQUxFX0ZQNjQpO1xcblxcbiAgcmV0dXJuO1xcbn1cXG5cXG52ZWM0IHByb2plY3RfdG9fY2xpcHNwYWNlX2ZwNjQodmVjMiB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbNF0pIHtcXG4gIHZlYzIgdmVydGV4X3Bvc19jbGlwc3BhY2VbNF07XFxuICBtYXQ0X3ZlYzRfbXVsX2ZwNjQocHJvamVjdGlvbkZQNjQsIHZlcnRleF9wb3NfbW9kZWxzcGFjZSwgdmVydGV4X3Bvc19jbGlwc3BhY2UpO1xcbiAgcmV0dXJuIHZlYzQoXFxuICAgIHZlcnRleF9wb3NfY2xpcHNwYWNlWzBdLngsXFxuICAgIHZlcnRleF9wb3NfY2xpcHNwYWNlWzFdLngsXFxuICAgIHZlcnRleF9wb3NfY2xpcHNwYWNlWzJdLngsXFxuICAgIHZlcnRleF9wb3NfY2xpcHNwYWNlWzNdLnhcXG4gICAgKTtcXG59XFxuJ1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zaGFkZXJsaWIvcHJvamVjdDY0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 76 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 77 */
/* unknown exports provided */
/* exports used: version */
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ (function(module, exports) {

eval("module.exports = {\n\t\"name\": \"deck.gl\",\n\t\"description\": \"A suite of 3D-enabled data visualization overlays, suitable for react-map-gl\",\n\t\"license\": \"MIT\",\n\t\"version\": \"4.0.0-beta.3\",\n\t\"keywords\": [\n\t\t\"webgl\",\n\t\t\"visualization\",\n\t\t\"overlay\",\n\t\t\"layer\"\n\t],\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"https://github.com/uber/deck.gl.git\"\n\t},\n\t\"main\": \"dist/index.js\",\n\t\"module\": \"dist-es6/index.js\",\n\t\"files\": [\n\t\t\"dist\",\n\t\t\"dist-es6\",\n\t\t\"src\"\n\t],\n\t\"scripts\": {\n\t\t\"start\": \"(cd examples/main && yarn && npm run start-local)\",\n\t\t\"build-clean\": \"rm -fr dist dist-es6 && mkdir -p dist dist-es6 \",\n\t\t\"build-es6\": \"rm -fr dist-es6 && babel src --out-dir dist-es6 --plugins=static-fs --source-maps inline\",\n\t\t\"build-es5\": \"rm -fr dist && babel src --out-dir dist --plugins=static-fs,transform-es2015-modules-commonjs --source-maps inline\",\n\t\t\"build-buble\": \"buble dist-es6 -o dist --no modules --y dangerousForOf --objectAssign\",\n\t\t\"build\": \"npm run build-clean && npm run build-es6 && npm run build-es5 && webpack -d --display-modules\",\n\t\t\"lint\": \"eslint src test examples && npm run lint-yarn\",\n\t\t\"lint-yarn\": \"find . -name yarn.lock -exec grep -l unpm.u {} \\\\;\",\n\t\t\"publish-prod\": \"npm run build && npm run test && npm run test-dist && npm publish\",\n\t\t\"publish-beta\": \"npm run build && npm run test && npm run test-dist && npm publish --tag beta\",\n\t\t\"test\": \"npm run lint && npm run test-node\",\n\t\t\"test-node\": \"node test/node.js\",\n\t\t\"test-dist\": \"node test/node-dist.js\",\n\t\t\"test-browser\": \"webpack-dev-server --config webpack.config.test-browser.js --progress --hot --open --port 3010\",\n\t\t\"bench\": \"node test/bench/node.js\",\n\t\t\"bench-browser\": \"webpack-dev-server --config webpack.config.bench-browser.js --progress --hot --open --port 3011\",\n\t\t\"test-fp64\": \"(cd test/fp64-test && webpack-dev-server --config webpack.config.test-fp64.js --progress --hot --open)\",\n\t\t\"test-rendering\": \"(cd test/rendering-test && webpack-dev-server --config webpack.config.test-rendering.js --progress --hot --open)\"\n\t},\n\t\"dependencies\": {\n\t\t\"d3-hexbin\": \"^0.2.1\",\n\t\t\"earcut\": \"^2.0.6\",\n\t\t\"file-loader\": \"^0.9.0\",\n\t\t\"gl-matrix\": \"^2.3.2\",\n\t\t\"lodash.flatten\": \"^4.4.0\",\n\t\t\"lodash.flattendeep\": \"^4.4.0\",\n\t\t\"viewport-mercator-project\": \"3.0.0-beta4\"\n\t},\n\t\"devDependencies\": {\n\t\t\"babel-cli\": \"^6.22.2\",\n\t\t\"babel-core\": \"^6.22.1\",\n\t\t\"babel-loader\": \"^6.2.10\",\n\t\t\"babel-plugin-static-fs\": \"^1.1.0\",\n\t\t\"babel-plugin-transform-es2015-modules-commonjs\": \"^6.22.0\",\n\t\t\"babel-polyfill\": \"^6.20.0\",\n\t\t\"babel-preset-es2015\": \"^6.4.3\",\n\t\t\"benchmark\": \"^2.1.3\",\n\t\t\"brfs-babel\": \"^1.0.0\",\n\t\t\"buble\": \"^0.15.1\",\n\t\t\"buble-loader\": \"^0.4.0\",\n\t\t\"colorbrewer\": \"^1.0.0\",\n\t\t\"eslint\": \"^3.0.0\",\n\t\t\"eslint-config-uber-es2015\": \"^3.0.0\",\n\t\t\"eslint-config-uber-jsx\": \"^3.0.0\",\n\t\t\"eslint-plugin-react\": \"~6.7.0\",\n\t\t\"faucet\": \"0.0.1\",\n\t\t\"gl\": \"^4.0.3\",\n\t\t\"immutable\": \"^3.8.1\",\n\t\t\"luma.gl\": \"3.0.0-beta.9\",\n\t\t\"module-alias\": \"^2.0.0\",\n\t\t\"pre-commit\": \"^1.2.2\",\n\t\t\"raw-loader\": \"^0.5.1\",\n\t\t\"react\": \"^15.4.0\",\n\t\t\"react-addons-test-utils\": \"^15.4.2\",\n\t\t\"react-dom\": \"^15.4.0\",\n\t\t\"reify\": \"^0.4.4\",\n\t\t\"tap-browser-color\": \"^0.1.2\",\n\t\t\"tape\": \"^4.5.1\",\n\t\t\"tape-catch\": \"^1.0.4\",\n\t\t\"transform-loader\": \"^0.2.3\",\n\t\t\"uglify-js\": \"^2.6.1\",\n\t\t\"url-loader\": \"^0.5.7\",\n\t\t\"webpack\": \"^2.2.0\",\n\t\t\"webpack-dev-server\": \"^2.2.0\"\n\t},\n\t\"peerDependencies\": {\n\t\t\"luma.gl\": \"3.0.0-beta.9\",\n\t\t\"react\": \"0.14.x - 15.x\",\n\t\t\"react-dom\": \"0.14.x - 15.x\"\n\t},\n\t\"babel\": {\n\t\t\"presets\": [\n\t\t\t[\n\t\t\t\t\"es2015\",\n\t\t\t\t{\n\t\t\t\t\t\"modules\": false\n\t\t\t\t}\n\t\t\t]\n\t\t]\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlLmpzb24/ZWQ4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJuYW1lXCI6IFwiZGVjay5nbFwiLFxuXHRcImRlc2NyaXB0aW9uXCI6IFwiQSBzdWl0ZSBvZiAzRC1lbmFibGVkIGRhdGEgdmlzdWFsaXphdGlvbiBvdmVybGF5cywgc3VpdGFibGUgZm9yIHJlYWN0LW1hcC1nbFwiLFxuXHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XCJ2ZXJzaW9uXCI6IFwiNC4wLjAtYmV0YS4zXCIsXG5cdFwia2V5d29yZHNcIjogW1xuXHRcdFwid2ViZ2xcIixcblx0XHRcInZpc3VhbGl6YXRpb25cIixcblx0XHRcIm92ZXJsYXlcIixcblx0XHRcImxheWVyXCJcblx0XSxcblx0XCJyZXBvc2l0b3J5XCI6IHtcblx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wuZ2l0XCJcblx0fSxcblx0XCJtYWluXCI6IFwiZGlzdC9pbmRleC5qc1wiLFxuXHRcIm1vZHVsZVwiOiBcImRpc3QtZXM2L2luZGV4LmpzXCIsXG5cdFwiZmlsZXNcIjogW1xuXHRcdFwiZGlzdFwiLFxuXHRcdFwiZGlzdC1lczZcIixcblx0XHRcInNyY1wiXG5cdF0sXG5cdFwic2NyaXB0c1wiOiB7XG5cdFx0XCJzdGFydFwiOiBcIihjZCBleGFtcGxlcy9tYWluICYmIHlhcm4gJiYgbnBtIHJ1biBzdGFydC1sb2NhbClcIixcblx0XHRcImJ1aWxkLWNsZWFuXCI6IFwicm0gLWZyIGRpc3QgZGlzdC1lczYgJiYgbWtkaXIgLXAgZGlzdCBkaXN0LWVzNiBcIixcblx0XHRcImJ1aWxkLWVzNlwiOiBcInJtIC1mciBkaXN0LWVzNiAmJiBiYWJlbCBzcmMgLS1vdXQtZGlyIGRpc3QtZXM2IC0tcGx1Z2lucz1zdGF0aWMtZnMgLS1zb3VyY2UtbWFwcyBpbmxpbmVcIixcblx0XHRcImJ1aWxkLWVzNVwiOiBcInJtIC1mciBkaXN0ICYmIGJhYmVsIHNyYyAtLW91dC1kaXIgZGlzdCAtLXBsdWdpbnM9c3RhdGljLWZzLHRyYW5zZm9ybS1lczIwMTUtbW9kdWxlcy1jb21tb25qcyAtLXNvdXJjZS1tYXBzIGlubGluZVwiLFxuXHRcdFwiYnVpbGQtYnVibGVcIjogXCJidWJsZSBkaXN0LWVzNiAtbyBkaXN0IC0tbm8gbW9kdWxlcyAtLXkgZGFuZ2Vyb3VzRm9yT2YgLS1vYmplY3RBc3NpZ25cIixcblx0XHRcImJ1aWxkXCI6IFwibnBtIHJ1biBidWlsZC1jbGVhbiAmJiBucG0gcnVuIGJ1aWxkLWVzNiAmJiBucG0gcnVuIGJ1aWxkLWVzNSAmJiB3ZWJwYWNrIC1kIC0tZGlzcGxheS1tb2R1bGVzXCIsXG5cdFx0XCJsaW50XCI6IFwiZXNsaW50IHNyYyB0ZXN0IGV4YW1wbGVzICYmIG5wbSBydW4gbGludC15YXJuXCIsXG5cdFx0XCJsaW50LXlhcm5cIjogXCJmaW5kIC4gLW5hbWUgeWFybi5sb2NrIC1leGVjIGdyZXAgLWwgdW5wbS51IHt9IFxcXFw7XCIsXG5cdFx0XCJwdWJsaXNoLXByb2RcIjogXCJucG0gcnVuIGJ1aWxkICYmIG5wbSBydW4gdGVzdCAmJiBucG0gcnVuIHRlc3QtZGlzdCAmJiBucG0gcHVibGlzaFwiLFxuXHRcdFwicHVibGlzaC1iZXRhXCI6IFwibnBtIHJ1biBidWlsZCAmJiBucG0gcnVuIHRlc3QgJiYgbnBtIHJ1biB0ZXN0LWRpc3QgJiYgbnBtIHB1Ymxpc2ggLS10YWcgYmV0YVwiLFxuXHRcdFwidGVzdFwiOiBcIm5wbSBydW4gbGludCAmJiBucG0gcnVuIHRlc3Qtbm9kZVwiLFxuXHRcdFwidGVzdC1ub2RlXCI6IFwibm9kZSB0ZXN0L25vZGUuanNcIixcblx0XHRcInRlc3QtZGlzdFwiOiBcIm5vZGUgdGVzdC9ub2RlLWRpc3QuanNcIixcblx0XHRcInRlc3QtYnJvd3NlclwiOiBcIndlYnBhY2stZGV2LXNlcnZlciAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy50ZXN0LWJyb3dzZXIuanMgLS1wcm9ncmVzcyAtLWhvdCAtLW9wZW4gLS1wb3J0IDMwMTBcIixcblx0XHRcImJlbmNoXCI6IFwibm9kZSB0ZXN0L2JlbmNoL25vZGUuanNcIixcblx0XHRcImJlbmNoLWJyb3dzZXJcIjogXCJ3ZWJwYWNrLWRldi1zZXJ2ZXIgLS1jb25maWcgd2VicGFjay5jb25maWcuYmVuY2gtYnJvd3Nlci5qcyAtLXByb2dyZXNzIC0taG90IC0tb3BlbiAtLXBvcnQgMzAxMVwiLFxuXHRcdFwidGVzdC1mcDY0XCI6IFwiKGNkIHRlc3QvZnA2NC10ZXN0ICYmIHdlYnBhY2stZGV2LXNlcnZlciAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy50ZXN0LWZwNjQuanMgLS1wcm9ncmVzcyAtLWhvdCAtLW9wZW4pXCIsXG5cdFx0XCJ0ZXN0LXJlbmRlcmluZ1wiOiBcIihjZCB0ZXN0L3JlbmRlcmluZy10ZXN0ICYmIHdlYnBhY2stZGV2LXNlcnZlciAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy50ZXN0LXJlbmRlcmluZy5qcyAtLXByb2dyZXNzIC0taG90IC0tb3BlbilcIlxuXHR9LFxuXHRcImRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJkMy1oZXhiaW5cIjogXCJeMC4yLjFcIixcblx0XHRcImVhcmN1dFwiOiBcIl4yLjAuNlwiLFxuXHRcdFwiZmlsZS1sb2FkZXJcIjogXCJeMC45LjBcIixcblx0XHRcImdsLW1hdHJpeFwiOiBcIl4yLjMuMlwiLFxuXHRcdFwibG9kYXNoLmZsYXR0ZW5cIjogXCJeNC40LjBcIixcblx0XHRcImxvZGFzaC5mbGF0dGVuZGVlcFwiOiBcIl40LjQuMFwiLFxuXHRcdFwidmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdFwiOiBcIjMuMC4wLWJldGE0XCJcblx0fSxcblx0XCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwiYmFiZWwtY2xpXCI6IFwiXjYuMjIuMlwiLFxuXHRcdFwiYmFiZWwtY29yZVwiOiBcIl42LjIyLjFcIixcblx0XHRcImJhYmVsLWxvYWRlclwiOiBcIl42LjIuMTBcIixcblx0XHRcImJhYmVsLXBsdWdpbi1zdGF0aWMtZnNcIjogXCJeMS4xLjBcIixcblx0XHRcImJhYmVsLXBsdWdpbi10cmFuc2Zvcm0tZXMyMDE1LW1vZHVsZXMtY29tbW9uanNcIjogXCJeNi4yMi4wXCIsXG5cdFx0XCJiYWJlbC1wb2x5ZmlsbFwiOiBcIl42LjIwLjBcIixcblx0XHRcImJhYmVsLXByZXNldC1lczIwMTVcIjogXCJeNi40LjNcIixcblx0XHRcImJlbmNobWFya1wiOiBcIl4yLjEuM1wiLFxuXHRcdFwiYnJmcy1iYWJlbFwiOiBcIl4xLjAuMFwiLFxuXHRcdFwiYnVibGVcIjogXCJeMC4xNS4xXCIsXG5cdFx0XCJidWJsZS1sb2FkZXJcIjogXCJeMC40LjBcIixcblx0XHRcImNvbG9yYnJld2VyXCI6IFwiXjEuMC4wXCIsXG5cdFx0XCJlc2xpbnRcIjogXCJeMy4wLjBcIixcblx0XHRcImVzbGludC1jb25maWctdWJlci1lczIwMTVcIjogXCJeMy4wLjBcIixcblx0XHRcImVzbGludC1jb25maWctdWJlci1qc3hcIjogXCJeMy4wLjBcIixcblx0XHRcImVzbGludC1wbHVnaW4tcmVhY3RcIjogXCJ+Ni43LjBcIixcblx0XHRcImZhdWNldFwiOiBcIjAuMC4xXCIsXG5cdFx0XCJnbFwiOiBcIl40LjAuM1wiLFxuXHRcdFwiaW1tdXRhYmxlXCI6IFwiXjMuOC4xXCIsXG5cdFx0XCJsdW1hLmdsXCI6IFwiMy4wLjAtYmV0YS45XCIsXG5cdFx0XCJtb2R1bGUtYWxpYXNcIjogXCJeMi4wLjBcIixcblx0XHRcInByZS1jb21taXRcIjogXCJeMS4yLjJcIixcblx0XHRcInJhdy1sb2FkZXJcIjogXCJeMC41LjFcIixcblx0XHRcInJlYWN0XCI6IFwiXjE1LjQuMFwiLFxuXHRcdFwicmVhY3QtYWRkb25zLXRlc3QtdXRpbHNcIjogXCJeMTUuNC4yXCIsXG5cdFx0XCJyZWFjdC1kb21cIjogXCJeMTUuNC4wXCIsXG5cdFx0XCJyZWlmeVwiOiBcIl4wLjQuNFwiLFxuXHRcdFwidGFwLWJyb3dzZXItY29sb3JcIjogXCJeMC4xLjJcIixcblx0XHRcInRhcGVcIjogXCJeNC41LjFcIixcblx0XHRcInRhcGUtY2F0Y2hcIjogXCJeMS4wLjRcIixcblx0XHRcInRyYW5zZm9ybS1sb2FkZXJcIjogXCJeMC4yLjNcIixcblx0XHRcInVnbGlmeS1qc1wiOiBcIl4yLjYuMVwiLFxuXHRcdFwidXJsLWxvYWRlclwiOiBcIl4wLjUuN1wiLFxuXHRcdFwid2VicGFja1wiOiBcIl4yLjIuMFwiLFxuXHRcdFwid2VicGFjay1kZXYtc2VydmVyXCI6IFwiXjIuMi4wXCJcblx0fSxcblx0XCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcImx1bWEuZ2xcIjogXCIzLjAuMC1iZXRhLjlcIixcblx0XHRcInJlYWN0XCI6IFwiMC4xNC54IC0gMTUueFwiLFxuXHRcdFwicmVhY3QtZG9tXCI6IFwiMC4xNC54IC0gMTUueFwiXG5cdH0sXG5cdFwiYmFiZWxcIjoge1xuXHRcdFwicHJlc2V0c1wiOiBbXG5cdFx0XHRbXG5cdFx0XHRcdFwiZXMyMDE1XCIsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRcIm1vZHVsZXNcIjogZmFsc2Vcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdF1cblx0fVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2UuanNvblxuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 78 */
/* unknown exports provided */
/* exports used: hexbin */
/*!****************************!*\
  !*** external "d3-hexbin" ***!
  \****************************/
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_78__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJkMy1oZXhiaW5cIj82NzlhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83OF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZDMtaGV4YmluXCJcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 79 */
/* exports provided: assembleShaders, Layer, CompositeLayer, LayerManager, AttributeManager, COORDINATE_SYSTEM, PerspectiveViewport, ArcLayer, GridLayer, PointDensityGridLayer, PointDensityHexagonLayer, HexagonLayer, IconLayer, LineLayer, PointCloudLayer, ScatterplotLayer, ScreenGridLayer, PathLayer, PolygonLayer, GeoJsonLayer, ScatterplotLayer64, ArcLayer64, LineLayer64, ChoroplethLayer, ChoroplethLayer64, ExtrudedChoroplethLayer64, DeckGL, default, experimental */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_utils__ = __webpack_require__(/*! ./shader-utils */ 4);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"assembleShaders\", function() { return __WEBPACK_IMPORTED_MODULE_0__shader_utils__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib__ = __webpack_require__(/*! ./lib */ 2);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Layer\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"CompositeLayer\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"b\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"LayerManager\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"c\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"AttributeManager\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"d\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"COORDINATE_SYSTEM\", function() { return __WEBPACK_IMPORTED_MODULE_1__lib__[\"e\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_viewports_perspective_viewport__ = __webpack_require__(/*! ./lib/viewports/perspective-viewport */ 25);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PerspectiveViewport\", function() { return __WEBPACK_IMPORTED_MODULE_2__lib_viewports_perspective_viewport__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__layers_core_arc_layer_arc_layer__ = __webpack_require__(/*! ./layers/core/arc-layer/arc-layer */ 18);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ArcLayer\", function() { return __WEBPACK_IMPORTED_MODULE_3__layers_core_arc_layer_arc_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__layers_core_grid_layer_grid_layer__ = __webpack_require__(/*! ./layers/core/grid-layer/grid-layer */ 19);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"GridLayer\", function() { return __WEBPACK_IMPORTED_MODULE_4__layers_core_grid_layer_grid_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__layers_core_point_density_grid_layer_point_density_grid_layer__ = __webpack_require__(/*! ./layers/core/point-density-grid-layer/point-density-grid-layer */ 39);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PointDensityGridLayer\", function() { return __WEBPACK_IMPORTED_MODULE_5__layers_core_point_density_grid_layer_point_density_grid_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__layers_core_point_density_hexagon_layer_point_density_hexagon_layer__ = __webpack_require__(/*! ./layers/core/point-density-hexagon-layer/point-density-hexagon-layer */ 40);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PointDensityHexagonLayer\", function() { return __WEBPACK_IMPORTED_MODULE_6__layers_core_point_density_hexagon_layer_point_density_hexagon_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__layers_core_hexagon_layer_hexagon_layer__ = __webpack_require__(/*! ./layers/core/hexagon-layer/hexagon-layer */ 20);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"HexagonLayer\", function() { return __WEBPACK_IMPORTED_MODULE_7__layers_core_hexagon_layer_hexagon_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__layers_core_icon_layer_icon_layer__ = __webpack_require__(/*! ./layers/core/icon-layer/icon-layer */ 37);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"IconLayer\", function() { return __WEBPACK_IMPORTED_MODULE_8__layers_core_icon_layer_icon_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__layers_core_line_layer_line_layer__ = __webpack_require__(/*! ./layers/core/line-layer/line-layer */ 21);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"LineLayer\", function() { return __WEBPACK_IMPORTED_MODULE_9__layers_core_line_layer_line_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__layers_core_point_cloud_layer_point_cloud_layer__ = __webpack_require__(/*! ./layers/core/point-cloud-layer/point-cloud-layer */ 38);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PointCloudLayer\", function() { return __WEBPACK_IMPORTED_MODULE_10__layers_core_point_cloud_layer_point_cloud_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__layers_core_scatterplot_layer_scatterplot_layer__ = __webpack_require__(/*! ./layers/core/scatterplot-layer/scatterplot-layer */ 12);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ScatterplotLayer\", function() { return __WEBPACK_IMPORTED_MODULE_11__layers_core_scatterplot_layer_scatterplot_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__layers_core_screen_grid_layer_screen_grid_layer__ = __webpack_require__(/*! ./layers/core/screen-grid-layer/screen-grid-layer */ 41);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ScreenGridLayer\", function() { return __WEBPACK_IMPORTED_MODULE_12__layers_core_screen_grid_layer_screen_grid_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__layers_core_path_layer_path_layer__ = __webpack_require__(/*! ./layers/core/path-layer/path-layer */ 22);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PathLayer\", function() { return __WEBPACK_IMPORTED_MODULE_13__layers_core_path_layer_path_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__layers_core_polygon_layer_polygon_layer__ = __webpack_require__(/*! ./layers/core/polygon-layer/polygon-layer */ 23);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"PolygonLayer\", function() { return __WEBPACK_IMPORTED_MODULE_14__layers_core_polygon_layer_polygon_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__layers_core_geojson_layer_geojson_layer__ = __webpack_require__(/*! ./layers/core/geojson-layer/geojson-layer */ 36);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoJsonLayer\", function() { return __WEBPACK_IMPORTED_MODULE_15__layers_core_geojson_layer_geojson_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__layers_fp64_scatterplot_layer_scatterplot_layer_64__ = __webpack_require__(/*! ./layers/fp64/scatterplot-layer/scatterplot-layer-64 */ 46);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ScatterplotLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_16__layers_fp64_scatterplot_layer_scatterplot_layer_64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__layers_fp64_arc_layer_arc_layer_64__ = __webpack_require__(/*! ./layers/fp64/arc-layer/arc-layer-64 */ 44);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ArcLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_17__layers_fp64_arc_layer_arc_layer_64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__layers_fp64_line_layer_line_layer_64__ = __webpack_require__(/*! ./layers/fp64/line-layer/line-layer-64 */ 45);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"LineLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_18__layers_fp64_line_layer_line_layer_64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__layers_deprecated_choropleth_layer_choropleth_layer__ = __webpack_require__(/*! ./layers/deprecated/choropleth-layer/choropleth-layer */ 24);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ChoroplethLayer\", function() { return __WEBPACK_IMPORTED_MODULE_19__layers_deprecated_choropleth_layer_choropleth_layer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__layers_deprecated_choropleth_layer_64_choropleth_layer_64__ = __webpack_require__(/*! ./layers/deprecated/choropleth-layer-64/choropleth-layer-64 */ 42);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ChoroplethLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_20__layers_deprecated_choropleth_layer_64_choropleth_layer_64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__layers_deprecated_extruded_choropleth_layer_64_extruded_choropleth_layer_64__ = __webpack_require__(/*! ./layers/deprecated/extruded-choropleth-layer-64/extruded-choropleth-layer-64 */ 43);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtrudedChoroplethLayer64\", function() { return __WEBPACK_IMPORTED_MODULE_21__layers_deprecated_extruded_choropleth_layer_64_extruded_choropleth_layer_64__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__react_deckgl__ = __webpack_require__(/*! ./react/deckgl */ 13);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"DeckGL\", function() { return __WEBPACK_IMPORTED_MODULE_22__react_deckgl__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return __WEBPACK_IMPORTED_MODULE_22__react_deckgl__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__lib_utils_container__ = __webpack_require__(/*! ./lib/utils/container */ 8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__experimental_lib__ = __webpack_require__(/*! ./experimental/lib */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__experimental_effects_reflection_effect__ = __webpack_require__(/*! ./experimental/effects/reflection-effect */ 17);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"experimental\", function() { return experimental; });\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable max-len */\n\n// Utilities\n\n\n// Lib\n\n\n\n\n// Core Layers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// 64-bit Layers\n\n\n\n\n// Deprecated Layers\n\n\n\n\n// React exports\n\n\n\n// Experimental Features (May change in minor version bumps, use at your own risk)\n\n\n\n\nvar experimental = {\n  get: __WEBPACK_IMPORTED_MODULE_23__lib_utils_container__[\"get\"],\n  EffectManager: __WEBPACK_IMPORTED_MODULE_24__experimental_lib__[\"a\" /* EffectManager */],\n  Effect: __WEBPACK_IMPORTED_MODULE_24__experimental_lib__[\"b\" /* Effect */],\n  ReflectionEffect: __WEBPACK_IMPORTED_MODULE_25__experimental_effects_reflection_effect__[\"a\" /* default */]\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/NDU5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vLyBVdGlsaXRpZXNcbmV4cG9ydCB7IGFzc2VtYmxlU2hhZGVycyB9IGZyb20gJy4vc2hhZGVyLXV0aWxzJztcblxuLy8gTGliXG5leHBvcnQgeyBMYXllciwgQ29tcG9zaXRlTGF5ZXIsIExheWVyTWFuYWdlciwgQXR0cmlidXRlTWFuYWdlciB9IGZyb20gJy4vbGliJztcbmV4cG9ydCB7IENPT1JESU5BVEVfU1lTVEVNIH0gZnJvbSAnLi9saWInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQZXJzcGVjdGl2ZVZpZXdwb3J0IH0gZnJvbSAnLi9saWIvdmlld3BvcnRzL3BlcnNwZWN0aXZlLXZpZXdwb3J0JztcblxuLy8gQ29yZSBMYXllcnNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXJjTGF5ZXIgfSBmcm9tICcuL2xheWVycy9jb3JlL2FyYy1sYXllci9hcmMtbGF5ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcmlkTGF5ZXIgfSBmcm9tICcuL2xheWVycy9jb3JlL2dyaWQtbGF5ZXIvZ3JpZC1sYXllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvaW50RGVuc2l0eUdyaWRMYXllciB9IGZyb20gJy4vbGF5ZXJzL2NvcmUvcG9pbnQtZGVuc2l0eS1ncmlkLWxheWVyL3BvaW50LWRlbnNpdHktZ3JpZC1sYXllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvaW50RGVuc2l0eUhleGFnb25MYXllciB9IGZyb20gJy4vbGF5ZXJzL2NvcmUvcG9pbnQtZGVuc2l0eS1oZXhhZ29uLWxheWVyL3BvaW50LWRlbnNpdHktaGV4YWdvbi1sYXllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEhleGFnb25MYXllciB9IGZyb20gJy4vbGF5ZXJzL2NvcmUvaGV4YWdvbi1sYXllci9oZXhhZ29uLWxheWVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSWNvbkxheWVyIH0gZnJvbSAnLi9sYXllcnMvY29yZS9pY29uLWxheWVyL2ljb24tbGF5ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lTGF5ZXIgfSBmcm9tICcuL2xheWVycy9jb3JlL2xpbmUtbGF5ZXIvbGluZS1sYXllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvaW50Q2xvdWRMYXllciB9IGZyb20gJy4vbGF5ZXJzL2NvcmUvcG9pbnQtY2xvdWQtbGF5ZXIvcG9pbnQtY2xvdWQtbGF5ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTY2F0dGVycGxvdExheWVyIH0gZnJvbSAnLi9sYXllcnMvY29yZS9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNjcmVlbkdyaWRMYXllciB9IGZyb20gJy4vbGF5ZXJzL2NvcmUvc2NyZWVuLWdyaWQtbGF5ZXIvc2NyZWVuLWdyaWQtbGF5ZXInO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhdGhMYXllciB9IGZyb20gJy4vbGF5ZXJzL2NvcmUvcGF0aC1sYXllci9wYXRoLWxheWVyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9seWdvbkxheWVyIH0gZnJvbSAnLi9sYXllcnMvY29yZS9wb2x5Z29uLWxheWVyL3BvbHlnb24tbGF5ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHZW9Kc29uTGF5ZXIgfSBmcm9tICcuL2xheWVycy9jb3JlL2dlb2pzb24tbGF5ZXIvZ2VvanNvbi1sYXllcic7XG5cbi8vIDY0LWJpdCBMYXllcnNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2NhdHRlcnBsb3RMYXllcjY0IH0gZnJvbSAnLi9sYXllcnMvZnA2NC9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllci02NCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEFyY0xheWVyNjQgfSBmcm9tICcuL2xheWVycy9mcDY0L2FyYy1sYXllci9hcmMtbGF5ZXItNjQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lTGF5ZXI2NCB9IGZyb20gJy4vbGF5ZXJzL2ZwNjQvbGluZS1sYXllci9saW5lLWxheWVyLTY0JztcblxuLy8gRGVwcmVjYXRlZCBMYXllcnNcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hvcm9wbGV0aExheWVyIH0gZnJvbSAnLi9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaG9yb3BsZXRoTGF5ZXI2NCB9IGZyb20gJy4vbGF5ZXJzL2RlcHJlY2F0ZWQvY2hvcm9wbGV0aC1sYXllci02NC9jaG9yb3BsZXRoLWxheWVyLTY0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXh0cnVkZWRDaG9yb3BsZXRoTGF5ZXI2NCB9IGZyb20gJy4vbGF5ZXJzL2RlcHJlY2F0ZWQvZXh0cnVkZWQtY2hvcm9wbGV0aC1sYXllci02NC9leHRydWRlZC1jaG9yb3BsZXRoLWxheWVyLTY0JztcblxuLy8gUmVhY3QgZXhwb3J0c1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEZWNrR0wgfSBmcm9tICcuL3JlYWN0L2RlY2tnbCc7XG5leHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9yZWFjdC9kZWNrZ2wnO1xuXG4vLyBFeHBlcmltZW50YWwgRmVhdHVyZXMgKE1heSBjaGFuZ2UgaW4gbWlub3IgdmVyc2lvbiBidW1wcywgdXNlIGF0IHlvdXIgb3duIHJpc2spXG5pbXBvcnQgeyBnZXQgfSBmcm9tICcuL2xpYi91dGlscy9jb250YWluZXInO1xuaW1wb3J0IHsgRWZmZWN0TWFuYWdlciwgRWZmZWN0IH0gZnJvbSAnLi9leHBlcmltZW50YWwvbGliJztcbmltcG9ydCB7IGRlZmF1bHQgYXMgUmVmbGVjdGlvbkVmZmVjdCB9IGZyb20gJy4vZXhwZXJpbWVudGFsL2VmZmVjdHMvcmVmbGVjdGlvbi1lZmZlY3QnO1xuXG5leHBvcnQgdmFyIGV4cGVyaW1lbnRhbCA9IHtcbiAgZ2V0OiBnZXQsXG4gIEVmZmVjdE1hbmFnZXI6IEVmZmVjdE1hbmFnZXIsXG4gIEVmZmVjdDogRWZmZWN0LFxuICBSZWZsZWN0aW9uRWZmZWN0OiBSZWZsZWN0aW9uRWZmZWN0XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);
});