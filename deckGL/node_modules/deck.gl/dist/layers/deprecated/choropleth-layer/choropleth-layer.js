'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lib = require('../../../lib');

var _shaderUtils = require('../../../shader-utils');

var _utils = require('../../../lib/utils');

var _geojson = require('./geojson');

var _luma = require('luma.gl');

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

var _path = require('path');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var DEFAULT_COLOR = [0, 0, 255, 255];

var defaultProps = {
  getColor: function getColor(feature) {
    return _utils.Container.get(feature, 'properties.color');
  },
  drawContour: false,
  strokeWidth: 1
};

var ChoroplethLayer = function (_Layer) {
  _inherits(ChoroplethLayer, _Layer);

  function ChoroplethLayer() {
    _classCallCheck(this, ChoroplethLayer);

    return _possibleConstructorReturn(this, (ChoroplethLayer.__proto__ || Object.getPrototypeOf(ChoroplethLayer)).apply(this, arguments));
  }

  _createClass(ChoroplethLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return {
        vs: '// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#define SHADER_NAME choropleth-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 colors;\nattribute vec3 pickingColors;\n\nuniform float opacity;\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// PICKING\nuniform float pickingEnabled;\nvarying vec4 vPickingColor;\nvoid picking_setPickColor(vec3 pickingColor) {\n  vPickingColor = vec4(pickingColor,  1.);\n}\nvec4 picking_setNormalAndPickColors(vec4 color, vec3 pickingColor) {\n  vec4 pickingColor4 = vec4(pickingColor.rgb, 1.);\n  vPickingColor = mix(color, pickingColor4, pickingEnabled);\n  return vPickingColor;\n}\n\n// PICKING\n// vec4 getColor(vec4 color, float opacity, vec3 pickingColor, float renderPickingBuffer) {\n//   vec4 color4 = vec4(color.xyz / 255., color.w / 255. * opacity);\n//   vec4 pickingColor4 = vec4(pickingColor / 255., 1.);\n//   return mix(color4, pickingColor4, renderPickingBuffer);\n// }\n\nvoid main(void) {\n\n  vec4 color = vec4(colors.rgb, colors.a * opacity) / 255.;\n\n  picking_setNormalAndPickColors(\n    color,\n    pickingColors / 255.\n  );\n\n  vec3 p = project_position(positions);\n  gl_Position = project_to_clipspace(vec4(p, 1.));\n}\n',
        fs: '// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#define SHADER_NAME choropleth-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// PICKING\n// uniform bool pickingEnabled;\nvarying vec4 vPickingColor;\nvec4 picking_getColor() {\n  return vPickingColor;\n}\n// PICKING\n\nvoid main(void) {\n  gl_FragColor = picking_getColor();\n}\n'
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;
      var attributeManager = this.state.attributeManager;

      attributeManager.addDynamic({
        // Primtive attributes
        indices: { size: 1, update: this.calculateIndices, isIndexed: true },
        positions: { size: 3, update: this.calculatePositions },
        colors: { size: 4, type: _luma.GL.UNSIGNED_BYTE, update: this.calculateColors },
        // Instanced attributes
        pickingColors: {
          size: 3,
          type: _luma.GL.UNSIGNED_BYTE,
          update: this.calculatePickingColors,
          noAlloc: true
        }
      });

      var IndexType = gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array;

      this.setState({
        model: this.getModel(gl),
        numInstances: 0,
        IndexType: IndexType
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;
      var attributeManager = this.state.attributeManager;

      if (changeFlags.dataChanged) {
        this.state.choropleths = (0, _geojson.extractPolygons)(props.data);
        attributeManager.invalidateAll();
      }

      if (oldProps.opacity !== props.opacity) {
        this.setUniforms({ opacity: props.opacity });
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var gl = this.context.gl;

      var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);
      gl.lineWidth(lineWidth);
      this.state.model.render(uniforms);
      // Setting line width back to 1 is here to workaround a Google Chrome bug
      // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with
      // correct parameter
      // This is not happening on Safari and Firefox
      gl.lineWidth(1.0);
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(opts) {
      var info = _get(ChoroplethLayer.prototype.__proto__ || Object.getPrototypeOf(ChoroplethLayer.prototype), 'getPickingInfo', this).call(this, opts);
      var index = this.decodePickingColor(info.color);
      var feature = index >= 0 ? _utils.Container.get(this.props.data, ['features', index]) : null;
      info.feature = feature;
      info.object = feature;
      return info;
    }
  }, {
    key: 'getModel',
    value: function getModel(gl) {
      var shaders = (0, _shaderUtils.assembleShaders)(gl, this.getShaders());

      return new _luma.Model({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: new _luma.Geometry({
          drawMode: this.props.drawContour ? _luma.GL.LINES : _luma.GL.TRIANGLES
        }),
        vertexCount: 0,
        isIndexed: true
      });
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      var _this2 = this;

      // adjust index offset for multiple choropleths
      var offsets = this.state.choropleths.reduce(function (acc, choropleth) {
        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + choropleth.reduce(function (count, polygon) {
          return count + polygon.length;
        }, 0)]);
      }, [0]);
      var IndexType = this.state.IndexType;

      if (IndexType === Uint16Array && offsets[offsets.length - 1] > 65535) {
        throw new Error('Vertex count exceeds browser\'s limit');
      }

      var indices = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        return _this2.props.drawContour ?
        // 1. get sequentially ordered indices of each choropleth contour
        // 2. offset them by the number of indices in previous choropleths
        calculateContourIndices(choropleth).map(function (index) {
          return index + offsets[choroplethIndex];
        }) :
        // 1. get triangulated indices for the internal areas
        // 2. offset them by the number of indices in previous choropleths
        calculateSurfaceIndices(choropleth).map(function (index) {
          return index + offsets[choroplethIndex];
        });
      });

      attribute.value = new IndexType((0, _utils.flatten)(indices));
      attribute.target = _luma.GL.ELEMENT_ARRAY_BUFFER;
      this.state.model.setVertexCount(attribute.value.length / attribute.size);
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      var vertices = (0, _utils.flatten)(this.state.choropleths);
      attribute.value = new Float32Array(vertices);
    }
  }, {
    key: 'calculateColors',
    value: function calculateColors(attribute) {
      var _props = this.props,
          data = _props.data,
          getColor = _props.getColor;

      var features = _utils.Container.get(data, 'features');
      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        var feature = _utils.Container.get(features, choropleth.featureIndex);
        var color = getColor(feature) || DEFAULT_COLOR;
        // Ensure alpha is set
        if (isNaN(color[3])) {
          color[3] = DEFAULT_COLOR[3];
        }
        return choropleth.map(function (polygon) {
          return polygon.map(function (vertex) {
            return color;
          });
        });
      });

      attribute.value = new Uint8Array((0, _utils.flatten)(colors));
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      var _this3 = this;

      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        var featureIndex = choropleth.featureIndex;

        var color = _this3.props.drawContour ? [0, 0, 0] : [(featureIndex + 1) % 256, Math.floor((featureIndex + 1) / 256) % 256, Math.floor((featureIndex + 1) / 256 / 256) % 256];
        return choropleth.map(function (polygon) {
          return polygon.map(function (vertex) {
            return color;
          });
        });
      });

      attribute.value = new Uint8Array((0, _utils.flatten)(colors));
    }
  }]);

  return ChoroplethLayer;
}(_lib.Layer);

exports.default = ChoroplethLayer;


ChoroplethLayer.layerName = 'ChoroplethLayer';
ChoroplethLayer.defaultProps = defaultProps;

/*
 * get vertex indices for drawing choropleth contour
 * @param {[Number,Number,Number][][]} choropleth
 * @returns {[Number]} indices
 */
function calculateContourIndices(choropleth) {
  var offset = 0;

  return choropleth.reduce(function (acc, polygon) {
    var numVertices = polygon.length;

    // use vertex pairs for gl.LINES => [0, 1, 1, 2, 2, ..., n-2, n-2, n-1]
    var indices = [].concat(_toConsumableArray(acc), [offset]);
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset + numVertices - 1);

    offset += numVertices;
    return indices;
  }, []);
}

/*
 * get vertex indices for drawing choropleth mesh
 * @param {[Number,Number,Number][][]} choropleth
 * @returns {[Number]} indices
 */
function calculateSurfaceIndices(choropleth) {
  var holes = null;

  if (choropleth.length > 1) {
    holes = choropleth.reduce(function (acc, polygon) {
      return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);
    }, [0]).slice(1, choropleth.length);
  }

  return (0, _earcut2.default)((0, _utils.flatten)(choropleth), holes, 3);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvZGVwcmVjYXRlZC9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXIuanMiXSwibmFtZXMiOlsiREVGQVVMVF9DT0xPUiIsImRlZmF1bHRQcm9wcyIsImdldENvbG9yIiwiZ2V0IiwiZmVhdHVyZSIsImRyYXdDb250b3VyIiwic3Ryb2tlV2lkdGgiLCJDaG9yb3BsZXRoTGF5ZXIiLCJ2cyIsImZzIiwiZ2wiLCJjb250ZXh0IiwiYXR0cmlidXRlTWFuYWdlciIsInN0YXRlIiwiYWRkRHluYW1pYyIsImluZGljZXMiLCJzaXplIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5kaWNlcyIsImlzSW5kZXhlZCIsInBvc2l0aW9ucyIsImNhbGN1bGF0ZVBvc2l0aW9ucyIsImNvbG9ycyIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiY2FsY3VsYXRlQ29sb3JzIiwicGlja2luZ0NvbG9ycyIsImNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMiLCJub0FsbG9jIiwiSW5kZXhUeXBlIiwiZ2V0RXh0ZW5zaW9uIiwiVWludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsInNldFN0YXRlIiwibW9kZWwiLCJnZXRNb2RlbCIsIm51bUluc3RhbmNlcyIsIm9sZFByb3BzIiwicHJvcHMiLCJjaGFuZ2VGbGFncyIsImRhdGFDaGFuZ2VkIiwiY2hvcm9wbGV0aHMiLCJkYXRhIiwiaW52YWxpZGF0ZUFsbCIsIm9wYWNpdHkiLCJzZXRVbmlmb3JtcyIsInVuaWZvcm1zIiwibGluZVdpZHRoIiwic2NyZWVuVG9EZXZpY2VQaXhlbHMiLCJyZW5kZXIiLCJvcHRzIiwiaW5mbyIsImluZGV4IiwiZGVjb2RlUGlja2luZ0NvbG9yIiwiY29sb3IiLCJvYmplY3QiLCJzaGFkZXJzIiwiZ2V0U2hhZGVycyIsImlkIiwiZ2VvbWV0cnkiLCJkcmF3TW9kZSIsIkxJTkVTIiwiVFJJQU5HTEVTIiwidmVydGV4Q291bnQiLCJhdHRyaWJ1dGUiLCJvZmZzZXRzIiwicmVkdWNlIiwiYWNjIiwiY2hvcm9wbGV0aCIsImxlbmd0aCIsImNvdW50IiwicG9seWdvbiIsIkVycm9yIiwibWFwIiwiY2hvcm9wbGV0aEluZGV4IiwiY2FsY3VsYXRlQ29udG91ckluZGljZXMiLCJjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyIsInZhbHVlIiwidGFyZ2V0IiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJzZXRWZXJ0ZXhDb3VudCIsInZlcnRpY2VzIiwiRmxvYXQzMkFycmF5IiwiZmVhdHVyZXMiLCJmZWF0dXJlSW5kZXgiLCJpc05hTiIsIlVpbnQ4QXJyYXkiLCJNYXRoIiwiZmxvb3IiLCJsYXllck5hbWUiLCJvZmZzZXQiLCJudW1WZXJ0aWNlcyIsImkiLCJwdXNoIiwiaG9sZXMiLCJzbGljZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBOzs7Ozs7Ozs7OytlQTNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFXQSxJQUFNQSxnQkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLEdBQVAsRUFBWSxHQUFaLENBQXRCOztBQUVBLElBQU1DLGVBQWU7QUFDbkJDLFlBQVU7QUFBQSxXQUFXLGlCQUFVQyxHQUFWLENBQWNDLE9BQWQsRUFBdUIsa0JBQXZCLENBQVg7QUFBQSxHQURTO0FBRW5CQyxlQUFhLEtBRk07QUFHbkJDLGVBQWE7QUFITSxDQUFyQjs7SUFNcUJDLGU7Ozs7Ozs7Ozs7O2lDQUNOO0FBQ1gsYUFBTztBQUNMQyxpeUVBREs7QUFFTEM7QUFGSyxPQUFQO0FBSUQ7OztzQ0FFaUI7QUFBQSxVQUNUQyxFQURTLEdBQ0gsS0FBS0MsT0FERixDQUNURCxFQURTO0FBQUEsVUFHVEUsZ0JBSFMsR0FHVyxLQUFLQyxLQUhoQixDQUdURCxnQkFIUzs7QUFJaEJBLHVCQUFpQkUsVUFBakIs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QUFDQSxRQUFNdEQsdUNBQWNvRCxHQUFkLElBQW1CdUIsTUFBbkIsRUFBTjtBQUNBLFNBQUssSUFBSUUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxjQUFjLENBQWxDLEVBQXFDQyxHQUFyQyxFQUEwQztBQUN4QzdFLGNBQVE4RSxJQUFSLENBQWFELElBQUlGLE1BQWpCLEVBQXlCRSxJQUFJRixNQUE3QjtBQUNEO0FBQ0QzRSxZQUFROEUsSUFBUixDQUFhSCxTQUFTQyxXQUFULEdBQXVCLENBQXBDOztBQUVBRCxjQUFVQyxXQUFWO0FBQ0EsV0FBTzVFLE9BQVA7QUFDRCxHQVpNLEVBWUosRUFaSSxDQUFQO0FBYUQ7O0FBRUQ7Ozs7O0FBS0EsU0FBUzZELHVCQUFULENBQWlDUixVQUFqQyxFQUE2QztBQUMzQyxNQUFJMEIsUUFBUSxJQUFaOztBQUVBLE1BQUkxQixXQUFXQyxNQUFYLEdBQW9CLENBQXhCLEVBQTJCO0FBQ3pCeUIsWUFBUTFCLFdBQVdGLE1BQVgsQ0FDTixVQUFDQyxHQUFELEVBQU1JLE9BQU47QUFBQSwwQ0FBc0JKLEdBQXRCLElBQTJCQSxJQUFJQSxJQUFJRSxNQUFKLEdBQWEsQ0FBakIsSUFBc0JFLFFBQVFGLE1BQXpEO0FBQUEsS0FETSxFQUVOLENBQUMsQ0FBRCxDQUZNLEVBR04wQixLQUhNLENBR0EsQ0FIQSxFQUdHM0IsV0FBV0MsTUFIZCxDQUFSO0FBSUQ7O0FBRUQsU0FBTyxzQkFBTyxvQkFBUUQsVUFBUixDQUFQLEVBQTRCMEIsS0FBNUIsRUFBbUMsQ0FBbkMsQ0FBUDtBQUNEIiwiZmlsZSI6ImNob3JvcGxldGgtbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHthc3NlbWJsZVNoYWRlcnN9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQge0NvbnRhaW5lciwgZmxhdHRlbn0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcbmltcG9ydCB7ZXh0cmFjdFBvbHlnb25zfSBmcm9tICcuL2dlb2pzb24nO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcbmltcG9ydCB7cmVhZEZpbGVTeW5jfSBmcm9tICdmcyc7XG5pbXBvcnQge2pvaW59IGZyb20gJ3BhdGgnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDI1NSwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBnZXRDb2xvcjogZmVhdHVyZSA9PiBDb250YWluZXIuZ2V0KGZlYXR1cmUsICdwcm9wZXJ0aWVzLmNvbG9yJyksXG4gIGRyYXdDb250b3VyOiBmYWxzZSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENob3JvcGxldGhMYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdnM6IHJlYWRGaWxlU3luYyhqb2luKF9fZGlybmFtZSwgJy4vY2hvcm9wbGV0aC1sYXllci12ZXJ0ZXguZ2xzbCcpLCAndXRmOCcpLFxuICAgICAgZnM6IHJlYWRGaWxlU3luYyhqb2luKF9fZGlybmFtZSwgJy4vY2hvcm9wbGV0aC1sYXllci1mcmFnbWVudC5nbHNsJyksICd1dGY4JylcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkRHluYW1pYyh7XG4gICAgICAvLyBQcmltdGl2ZSBhdHRyaWJ1dGVzXG4gICAgICBpbmRpY2VzOiB7c2l6ZTogMSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluZGljZXMsIGlzSW5kZXhlZDogdHJ1ZX0sXG4gICAgICBwb3NpdGlvbnM6IHtzaXplOiAzLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zfSxcbiAgICAgIGNvbG9yczoge3NpemU6IDQsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVDb2xvcnN9LFxuICAgICAgLy8gSW5zdGFuY2VkIGF0dHJpYnV0ZXNcbiAgICAgIHBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMsXG4gICAgICAgIG5vQWxsb2M6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IEluZGV4VHlwZSA9IGdsLmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWwoZ2wpLFxuICAgICAgbnVtSW5zdGFuY2VzOiAwLFxuICAgICAgSW5kZXhUeXBlXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5zdGF0ZS5jaG9yb3BsZXRocyA9IGV4dHJhY3RQb2x5Z29ucyhwcm9wcy5kYXRhKTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH1cblxuICAgIGlmIChvbGRQcm9wcy5vcGFjaXR5ICE9PSBwcm9wcy5vcGFjaXR5KSB7XG4gICAgICB0aGlzLnNldFVuaWZvcm1zKHtvcGFjaXR5OiBwcm9wcy5vcGFjaXR5fSk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBsaW5lV2lkdGggPSB0aGlzLnNjcmVlblRvRGV2aWNlUGl4ZWxzKHRoaXMucHJvcHMuc3Ryb2tlV2lkdGgpO1xuICAgIGdsLmxpbmVXaWR0aChsaW5lV2lkdGgpO1xuICAgIHRoaXMuc3RhdGUubW9kZWwucmVuZGVyKHVuaWZvcm1zKTtcbiAgICAvLyBTZXR0aW5nIGxpbmUgd2lkdGggYmFjayB0byAxIGlzIGhlcmUgdG8gd29ya2Fyb3VuZCBhIEdvb2dsZSBDaHJvbWUgYnVnXG4gICAgLy8gZ2wuY2xlYXIoKSBhbmQgZ2wuaXNFbmFibGVkKCkgd2lsbCByZXR1cm4gR0xfSU5WQUxJRF9WQUxVRSBldmVuIHdpdGhcbiAgICAvLyBjb3JyZWN0IHBhcmFtZXRlclxuICAgIC8vIFRoaXMgaXMgbm90IGhhcHBlbmluZyBvbiBTYWZhcmkgYW5kIEZpcmVmb3hcbiAgICBnbC5saW5lV2lkdGgoMS4wKTtcbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKG9wdHMpIHtcbiAgICBjb25zdCBpbmZvID0gc3VwZXIuZ2V0UGlja2luZ0luZm8ob3B0cyk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmRlY29kZVBpY2tpbmdDb2xvcihpbmZvLmNvbG9yKTtcbiAgICBjb25zdCBmZWF0dXJlID0gaW5kZXggPj0gMCA/IENvbnRhaW5lci5nZXQodGhpcy5wcm9wcy5kYXRhLCBbJ2ZlYXR1cmVzJywgaW5kZXhdKSA6IG51bGw7XG4gICAgaW5mby5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICBpbmZvLm9iamVjdCA9IGZlYXR1cmU7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBnZXRNb2RlbChnbCkge1xuICAgIGNvbnN0IHNoYWRlcnMgPSBhc3NlbWJsZVNoYWRlcnMoZ2wsIHRoaXMuZ2V0U2hhZGVycygpKTtcblxuICAgIHJldHVybiBuZXcgTW9kZWwoe1xuICAgICAgZ2wsXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHZzOiBzaGFkZXJzLnZzLFxuICAgICAgZnM6IHNoYWRlcnMuZnMsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgPyBHTC5MSU5FUyA6IEdMLlRSSUFOR0xFU1xuICAgICAgfSksXG4gICAgICB2ZXJ0ZXhDb3VudDogMCxcbiAgICAgIGlzSW5kZXhlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlSW5kaWNlcyhhdHRyaWJ1dGUpIHtcbiAgICAvLyBhZGp1c3QgaW5kZXggb2Zmc2V0IGZvciBtdWx0aXBsZSBjaG9yb3BsZXRoc1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLnJlZHVjZShcbiAgICAgIChhY2MsIGNob3JvcGxldGgpID0+IFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gK1xuICAgICAgICBjaG9yb3BsZXRoLnJlZHVjZSgoY291bnQsIHBvbHlnb24pID0+IGNvdW50ICsgcG9seWdvbi5sZW5ndGgsIDApXSxcbiAgICAgIFswXVxuICAgICk7XG4gICAgY29uc3Qge0luZGV4VHlwZX0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChJbmRleFR5cGUgPT09IFVpbnQxNkFycmF5ICYmIG9mZnNldHNbb2Zmc2V0cy5sZW5ndGggLSAxXSA+IDY1NTM1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBjb3VudCBleGNlZWRzIGJyb3dzZXJcXCdzIGxpbWl0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMubWFwKFxuICAgICAgKGNob3JvcGxldGgsIGNob3JvcGxldGhJbmRleCkgPT4gdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/XG4gICAgICAgIC8vIDEuIGdldCBzZXF1ZW50aWFsbHkgb3JkZXJlZCBpbmRpY2VzIG9mIGVhY2ggY2hvcm9wbGV0aCBjb250b3VyXG4gICAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBjaG9yb3BsZXRoc1xuICAgICAgICBjYWxjdWxhdGVDb250b3VySW5kaWNlcyhjaG9yb3BsZXRoKS5tYXAoaW5kZXggPT4gaW5kZXggKyBvZmZzZXRzW2Nob3JvcGxldGhJbmRleF0pIDpcbiAgICAgICAgLy8gMS4gZ2V0IHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGZvciB0aGUgaW50ZXJuYWwgYXJlYXNcbiAgICAgICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIGNob3JvcGxldGhzXG4gICAgICAgIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKGNob3JvcGxldGgpLm1hcChpbmRleCA9PiBpbmRleCArIG9mZnNldHNbY2hvcm9wbGV0aEluZGV4XSlcbiAgICApO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEluZGV4VHlwZShmbGF0dGVuKGluZGljZXMpKTtcbiAgICBhdHRyaWJ1dGUudGFyZ2V0ID0gR0wuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRWZXJ0ZXhDb3VudChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoIC8gYXR0cmlidXRlLnNpemUpO1xuICB9XG5cbiAgY2FsY3VsYXRlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gZmxhdHRlbih0aGlzLnN0YXRlLmNob3JvcGxldGhzKTtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBmZWF0dXJlcyA9IENvbnRhaW5lci5nZXQoZGF0YSwgJ2ZlYXR1cmVzJyk7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5tYXAoXG4gICAgICAoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBDb250YWluZXIuZ2V0KGZlYXR1cmVzLCBjaG9yb3BsZXRoLmZlYXR1cmVJbmRleCk7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3IoZmVhdHVyZSkgfHwgREVGQVVMVF9DT0xPUjtcbiAgICAgICAgLy8gRW5zdXJlIGFscGhhIGlzIHNldFxuICAgICAgICBpZiAoaXNOYU4oY29sb3JbM10pKSB7XG4gICAgICAgICAgY29sb3JbM10gPSBERUZBVUxUX0NPTE9SWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaG9yb3BsZXRoLm1hcChwb2x5Z29uID0+IHBvbHlnb24ubWFwKHZlcnRleCA9PiBjb2xvcikpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgVWludDhBcnJheShmbGF0dGVuKGNvbG9ycykpO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgcGlja2luZyBjb2xvcnMgY2FsY3VsYXRpb25cbiAgY2FsY3VsYXRlUGlja2luZ0NvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBjb2xvcnMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcChcbiAgICAgIChjaG9yb3BsZXRoLCBjaG9yb3BsZXRoSW5kZXgpID0+IHtcbiAgICAgICAgY29uc3Qge2ZlYXR1cmVJbmRleH0gPSBjaG9yb3BsZXRoO1xuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgPyBbMCwgMCwgMF0gOiBbXG4gICAgICAgICAgKGZlYXR1cmVJbmRleCArIDEpICUgMjU2LFxuICAgICAgICAgIE1hdGguZmxvb3IoKGZlYXR1cmVJbmRleCArIDEpIC8gMjU2KSAlIDI1NixcbiAgICAgICAgICBNYXRoLmZsb29yKChmZWF0dXJlSW5kZXggKyAxKSAvIDI1NiAvIDI1NikgJSAyNTZcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGNob3JvcGxldGgubWFwKHBvbHlnb24gPT4gcG9seWdvbi5tYXAodmVydGV4ID0+IGNvbG9yKSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBVaW50OEFycmF5KGZsYXR0ZW4oY29sb3JzKSk7XG4gIH1cbn1cblxuQ2hvcm9wbGV0aExheWVyLmxheWVyTmFtZSA9ICdDaG9yb3BsZXRoTGF5ZXInO1xuQ2hvcm9wbGV0aExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuLypcbiAqIGdldCB2ZXJ0ZXggaW5kaWNlcyBmb3IgZHJhd2luZyBjaG9yb3BsZXRoIGNvbnRvdXJcbiAqIEBwYXJhbSB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW119IGNob3JvcGxldGhcbiAqIEByZXR1cm5zIHtbTnVtYmVyXX0gaW5kaWNlc1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVDb250b3VySW5kaWNlcyhjaG9yb3BsZXRoKSB7XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIHJldHVybiBjaG9yb3BsZXRoLnJlZHVjZSgoYWNjLCBwb2x5Z29uKSA9PiB7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgIC8vIHVzZSB2ZXJ0ZXggcGFpcnMgZm9yIGdsLkxJTkVTID0+IFswLCAxLCAxLCAyLCAyLCAuLi4sIG4tMiwgbi0yLCBuLTFdXG4gICAgY29uc3QgaW5kaWNlcyA9IFsuLi5hY2MsIG9mZnNldF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2gob2Zmc2V0ICsgbnVtVmVydGljZXMgLSAxKTtcblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfSwgW10pO1xufVxuXG4vKlxuICogZ2V0IHZlcnRleCBpbmRpY2VzIGZvciBkcmF3aW5nIGNob3JvcGxldGggbWVzaFxuICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXX0gY2hvcm9wbGV0aFxuICogQHJldHVybnMge1tOdW1iZXJdfSBpbmRpY2VzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKGNob3JvcGxldGgpIHtcbiAgbGV0IGhvbGVzID0gbnVsbDtcblxuICBpZiAoY2hvcm9wbGV0aC5sZW5ndGggPiAxKSB7XG4gICAgaG9sZXMgPSBjaG9yb3BsZXRoLnJlZHVjZShcbiAgICAgIChhY2MsIHBvbHlnb24pID0+IFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyBwb2x5Z29uLmxlbmd0aF0sXG4gICAgICBbMF1cbiAgICApLnNsaWNlKDEsIGNob3JvcGxldGgubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBlYXJjdXQoZmxhdHRlbihjaG9yb3BsZXRoKSwgaG9sZXMsIDMpO1xufVxuIl19