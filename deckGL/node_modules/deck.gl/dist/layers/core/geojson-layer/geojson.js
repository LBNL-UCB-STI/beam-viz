'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGeojsonFeatures = getGeojsonFeatures;
exports.separateGeojsonFeatures = separateGeojsonFeatures;

var _lib = require('../../../lib');

var _utils = require('../../../lib/utils');

/**
 * "Normalizes" complete or partial GeoJSON data into iterable list of features
 * Can accept GeoJSON geometry or "Feature", "FeatureCollection" in addition
 * to plain arrays and iterables.
 * Works by extracting the feature array or wrapping single objects in an array,
 * so that subsequent code can simply iterate over features.
 *
 * @param {object} geojson - geojson data
 * @param {Object|Array} data - geojson object (FeatureCollection, Feature or
 *  Geometry) or array of features
 * @return {Array|"iteratable"} - iterable list of features
 */
function getGeojsonFeatures(geojson) {
  // If array, assume this is a list of features
  if (Array.isArray(geojson)) {
    return geojson;
  }

  var type = (0, _lib.get)(geojson, 'type');
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'Polygon':
    case 'MultiPolygon':
    case 'GeometryCollection':
      // Wrap the geometry object in a 'Feature' object and wrap in an array
      return [{ type: 'Feature', properties: {}, geometry: geojson }];
    case 'Feature':
      // Wrap the feature in a 'Features' array
      return [geojson];
    case 'FeatureCollection':
      // Just return the 'Features' array from the collection
      return (0, _lib.get)(geojson, 'features');
    default:
      throw new Error('Unknown geojson type');
  }
}

// Linearize
function separateGeojsonFeatures(features) {
  var pointFeatures = [];
  var lineFeatures = [];
  var polygonFeatures = [];
  var polygonOutlineFeatures = [];

  _utils.Container.forEach(features, function (feature) {
    var type = (0, _lib.get)(feature, 'geometry.type');
    var coordinates = (0, _lib.get)(feature, 'geometry.coordinates');
    var properties = (0, _lib.get)(feature, 'properties');
    switch (type) {
      case 'Point':
        pointFeatures.push(feature);
        break;
      case 'MultiPoint':
        // TODO - split multipoints
        _utils.Container.forEach(coordinates, function (point) {
          pointFeatures.push({ geometry: { coordinates: point }, properties: properties, feature: feature });
        });
        break;
      case 'LineString':
        lineFeatures.push(feature);
        break;
      case 'MultiLineString':
        // Break multilinestrings into multiple lines with same properties
        _utils.Container.forEach(coordinates, function (path) {
          lineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });
        });
        break;
      case 'Polygon':
        polygonFeatures.push(feature);
        // Break polygon into multiple lines with same properties
        _utils.Container.forEach(coordinates, function (path) {
          polygonOutlineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });
        });
        break;
      case 'MultiPolygon':
        // Break multipolygons into multiple polygons with same properties
        _utils.Container.forEach(coordinates, function (polygon) {
          polygonFeatures.push({ geometry: { coordinates: polygon }, properties: properties, feature: feature });
          // Break polygon into multiple lines with same properties
          _utils.Container.forEach(polygon, function (path) {
            polygonOutlineFeatures.push({ geometry: { coordinates: path }, properties: properties, feature: feature });
          });
        });
        break;
      // Not yet supported
      case 'GeometryCollection':
      default:
        throw new Error('GeoJsonLayer: ' + type + ' not supported.');
    }
  });

  return {
    pointFeatures: pointFeatures,
    lineFeatures: lineFeatures,
    polygonFeatures: polygonFeatures,
    polygonOutlineFeatures: polygonOutlineFeatures
  };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9nZW9qc29uLWxheWVyL2dlb2pzb24uanMiXSwibmFtZXMiOlsiZ2V0R2VvanNvbkZlYXR1cmVzIiwic2VwYXJhdGVHZW9qc29uRmVhdHVyZXMiLCJnZW9qc29uIiwiQXJyYXkiLCJpc0FycmF5IiwidHlwZSIsInByb3BlcnRpZXMiLCJnZW9tZXRyeSIsIkVycm9yIiwiZmVhdHVyZXMiLCJwb2ludEZlYXR1cmVzIiwibGluZUZlYXR1cmVzIiwicG9seWdvbkZlYXR1cmVzIiwicG9seWdvbk91dGxpbmVGZWF0dXJlcyIsImZvckVhY2giLCJmZWF0dXJlIiwiY29vcmRpbmF0ZXMiLCJwdXNoIiwicG9pbnQiLCJwYXRoIiwicG9seWdvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFlZ0JBLGtCLEdBQUFBLGtCO1FBK0JBQyx1QixHQUFBQSx1Qjs7QUE5Q2hCOztBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZTyxTQUFTRCxrQkFBVCxDQUE0QkUsT0FBNUIsRUFBcUM7QUFDMUM7QUFDQSxNQUFJQyxNQUFNQyxPQUFOLENBQWNGLE9BQWQsQ0FBSixFQUE0QjtBQUMxQixXQUFPQSxPQUFQO0FBQ0Q7O0FBRUQsTUFBTUcsT0FBTyxjQUFJSCxPQUFKLEVBQWEsTUFBYixDQUFiO0FBQ0EsVUFBUUcsSUFBUjtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssaUJBQUw7QUFDQSxTQUFLLFNBQUw7QUFDQSxTQUFLLGNBQUw7QUFDQSxTQUFLLG9CQUFMO0FBQ0U7QUFDQSxhQUFPLENBQ0wsRUFBQ0EsTUFBTSxTQUFQLEVBQWtCQyxZQUFZLEVBQTlCLEVBQWtDQyxVQUFVTCxPQUE1QyxFQURLLENBQVA7QUFHRixTQUFLLFNBQUw7QUFDRTtBQUNBLGFBQU8sQ0FBQ0EsT0FBRCxDQUFQO0FBQ0YsU0FBSyxtQkFBTDtBQUNFO0FBQ0EsYUFBTyxjQUFJQSxPQUFKLEVBQWEsVUFBYixDQUFQO0FBQ0Y7QUFDRSxZQUFNLElBQUlNLEtBQUosQ0FBVSxzQkFBVixDQUFOO0FBbkJGO0FBcUJEOztBQUVEO0FBQ08sU0FBU1AsdUJBQVQsQ0FBaUNRLFFBQWpDLEVBQTJDO0FBQ2hELE1BQU1DLGdCQUFnQixFQUF0QjtBQUNBLE1BQU1DLGVBQWUsRUFBckI7QUFDQSxNQUFNQyxrQkFBa0IsRUFBeEI7QUFDQSxNQUFNQyx5QkFBeUIsRUFBL0I7O0FBRUEsbUJBQVVDLE9BQVYsQ0FBa0JMLFFBQWxCLEVBQTRCLG1CQUFXO0FBQ3JDLFFBQU1KLE9BQU8sY0FBSVUsT0FBSixFQUFhLGVBQWIsQ0FBYjtBQUNBLFFBQU1DLGNBQWMsY0FBSUQsT0FBSixFQUFhLHNCQUFiLENBQXBCO0FBQ0EsUUFBTVQsYUFBYSxjQUFJUyxPQUFKLEVBQWEsWUFBYixDQUFuQjtBQUNBLFlBQVFWLElBQVI7QUFDQSxXQUFLLE9BQUw7QUFDRUssc0JBQWNPLElBQWQsQ0FBbUJGLE9BQW5CO0FBQ0E7QUFDRixXQUFLLFlBQUw7QUFDRTtBQUNBLHlCQUFVRCxPQUFWLENBQWtCRSxXQUFsQixFQUErQixpQkFBUztBQUN0Q04sd0JBQWNPLElBQWQsQ0FBbUIsRUFBQ1YsVUFBVSxFQUFDUyxhQUFhRSxLQUFkLEVBQVgsRUFBaUNaLHNCQUFqQyxFQUE2Q1MsZ0JBQTdDLEVBQW5CO0FBQ0QsU0FGRDtBQUdBO0FBQ0YsV0FBSyxZQUFMO0FBQ0VKLHFCQUFhTSxJQUFiLENBQWtCRixPQUFsQjtBQUNBO0FBQ0YsV0FBSyxpQkFBTDtBQUNFO0FBQ0EseUJBQVVELE9BQVYsQ0FBa0JFLFdBQWxCLEVBQStCLGdCQUFRO0FBQ3JDTCx1QkFBYU0sSUFBYixDQUFrQixFQUFDVixVQUFVLEVBQUNTLGFBQWFHLElBQWQsRUFBWCxFQUFnQ2Isc0JBQWhDLEVBQTRDUyxnQkFBNUMsRUFBbEI7QUFDRCxTQUZEO0FBR0E7QUFDRixXQUFLLFNBQUw7QUFDRUgsd0JBQWdCSyxJQUFoQixDQUFxQkYsT0FBckI7QUFDQTtBQUNBLHlCQUFVRCxPQUFWLENBQWtCRSxXQUFsQixFQUErQixnQkFBUTtBQUNyQ0gsaUNBQXVCSSxJQUF2QixDQUE0QixFQUFDVixVQUFVLEVBQUNTLGFBQWFHLElBQWQsRUFBWCxFQUFnQ2Isc0JBQWhDLEVBQTRDUyxnQkFBNUMsRUFBNUI7QUFDRCxTQUZEO0FBR0E7QUFDRixXQUFLLGNBQUw7QUFDRTtBQUNBLHlCQUFVRCxPQUFWLENBQWtCRSxXQUFsQixFQUErQixtQkFBVztBQUN4Q0osMEJBQWdCSyxJQUFoQixDQUFxQixFQUFDVixVQUFVLEVBQUNTLGFBQWFJLE9BQWQsRUFBWCxFQUFtQ2Qsc0JBQW5DLEVBQStDUyxnQkFBL0MsRUFBckI7QUFDQTtBQUNBLDJCQUFVRCxPQUFWLENBQWtCTSxPQUFsQixFQUEyQixnQkFBUTtBQUNqQ1AsbUNBQXVCSSxJQUF2QixDQUE0QixFQUFDVixVQUFVLEVBQUNTLGFBQWFHLElBQWQsRUFBWCxFQUFnQ2Isc0JBQWhDLEVBQTRDUyxnQkFBNUMsRUFBNUI7QUFDRCxXQUZEO0FBR0QsU0FORDtBQU9BO0FBQ0E7QUFDRixXQUFLLG9CQUFMO0FBQ0E7QUFDRSxjQUFNLElBQUlQLEtBQUosb0JBQTJCSCxJQUEzQixxQkFBTjtBQXZDRjtBQXlDRCxHQTdDRDs7QUErQ0EsU0FBTztBQUNMSyxnQ0FESztBQUVMQyw4QkFGSztBQUdMQyxvQ0FISztBQUlMQztBQUpLLEdBQVA7QUFNRCIsImZpbGUiOiJnZW9qc29uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZXR9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQge0NvbnRhaW5lcn0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcblxuLyoqXG4gKiBcIk5vcm1hbGl6ZXNcIiBjb21wbGV0ZSBvciBwYXJ0aWFsIEdlb0pTT04gZGF0YSBpbnRvIGl0ZXJhYmxlIGxpc3Qgb2YgZmVhdHVyZXNcbiAqIENhbiBhY2NlcHQgR2VvSlNPTiBnZW9tZXRyeSBvciBcIkZlYXR1cmVcIiwgXCJGZWF0dXJlQ29sbGVjdGlvblwiIGluIGFkZGl0aW9uXG4gKiB0byBwbGFpbiBhcnJheXMgYW5kIGl0ZXJhYmxlcy5cbiAqIFdvcmtzIGJ5IGV4dHJhY3RpbmcgdGhlIGZlYXR1cmUgYXJyYXkgb3Igd3JhcHBpbmcgc2luZ2xlIG9iamVjdHMgaW4gYW4gYXJyYXksXG4gKiBzbyB0aGF0IHN1YnNlcXVlbnQgY29kZSBjYW4gc2ltcGx5IGl0ZXJhdGUgb3ZlciBmZWF0dXJlcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ2VvanNvbiAtIGdlb2pzb24gZGF0YVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdGEgLSBnZW9qc29uIG9iamVjdCAoRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmUgb3JcbiAqICBHZW9tZXRyeSkgb3IgYXJyYXkgb2YgZmVhdHVyZXNcbiAqIEByZXR1cm4ge0FycmF5fFwiaXRlcmF0YWJsZVwifSAtIGl0ZXJhYmxlIGxpc3Qgb2YgZmVhdHVyZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdlb2pzb25GZWF0dXJlcyhnZW9qc29uKSB7XG4gIC8vIElmIGFycmF5LCBhc3N1bWUgdGhpcyBpcyBhIGxpc3Qgb2YgZmVhdHVyZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkoZ2VvanNvbikpIHtcbiAgICByZXR1cm4gZ2VvanNvbjtcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSBnZXQoZ2VvanNvbiwgJ3R5cGUnKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgJ1BvaW50JzpcbiAgY2FzZSAnTXVsdGlQb2ludCc6XG4gIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICBjYXNlICdQb2x5Z29uJzpcbiAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAvLyBXcmFwIHRoZSBnZW9tZXRyeSBvYmplY3QgaW4gYSAnRmVhdHVyZScgb2JqZWN0IGFuZCB3cmFwIGluIGFuIGFycmF5XG4gICAgcmV0dXJuIFtcbiAgICAgIHt0eXBlOiAnRmVhdHVyZScsIHByb3BlcnRpZXM6IHt9LCBnZW9tZXRyeTogZ2VvanNvbn1cbiAgICBdO1xuICBjYXNlICdGZWF0dXJlJzpcbiAgICAvLyBXcmFwIHRoZSBmZWF0dXJlIGluIGEgJ0ZlYXR1cmVzJyBhcnJheVxuICAgIHJldHVybiBbZ2VvanNvbl07XG4gIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAvLyBKdXN0IHJldHVybiB0aGUgJ0ZlYXR1cmVzJyBhcnJheSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAgcmV0dXJuIGdldChnZW9qc29uLCAnZmVhdHVyZXMnKTtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZ2VvanNvbiB0eXBlJyk7XG4gIH1cbn1cblxuLy8gTGluZWFyaXplXG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGVHZW9qc29uRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgY29uc3QgcG9pbnRGZWF0dXJlcyA9IFtdO1xuICBjb25zdCBsaW5lRmVhdHVyZXMgPSBbXTtcbiAgY29uc3QgcG9seWdvbkZlYXR1cmVzID0gW107XG4gIGNvbnN0IHBvbHlnb25PdXRsaW5lRmVhdHVyZXMgPSBbXTtcblxuICBDb250YWluZXIuZm9yRWFjaChmZWF0dXJlcywgZmVhdHVyZSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldChmZWF0dXJlLCAnZ2VvbWV0cnkudHlwZScpO1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gZ2V0KGZlYXR1cmUsICdnZW9tZXRyeS5jb29yZGluYXRlcycpO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBnZXQoZmVhdHVyZSwgJ3Byb3BlcnRpZXMnKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgICBwb2ludEZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgIC8vIFRPRE8gLSBzcGxpdCBtdWx0aXBvaW50c1xuICAgICAgQ29udGFpbmVyLmZvckVhY2goY29vcmRpbmF0ZXMsIHBvaW50ID0+IHtcbiAgICAgICAgcG9pbnRGZWF0dXJlcy5wdXNoKHtnZW9tZXRyeToge2Nvb3JkaW5hdGVzOiBwb2ludH0sIHByb3BlcnRpZXMsIGZlYXR1cmV9KTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICBsaW5lRmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAvLyBCcmVhayBtdWx0aWxpbmVzdHJpbmdzIGludG8gbXVsdGlwbGUgbGluZXMgd2l0aCBzYW1lIHByb3BlcnRpZXNcbiAgICAgIENvbnRhaW5lci5mb3JFYWNoKGNvb3JkaW5hdGVzLCBwYXRoID0+IHtcbiAgICAgICAgbGluZUZlYXR1cmVzLnB1c2goe2dlb21ldHJ5OiB7Y29vcmRpbmF0ZXM6IHBhdGh9LCBwcm9wZXJ0aWVzLCBmZWF0dXJlfSk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgcG9seWdvbkZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAvLyBCcmVhayBwb2x5Z29uIGludG8gbXVsdGlwbGUgbGluZXMgd2l0aCBzYW1lIHByb3BlcnRpZXNcbiAgICAgIENvbnRhaW5lci5mb3JFYWNoKGNvb3JkaW5hdGVzLCBwYXRoID0+IHtcbiAgICAgICAgcG9seWdvbk91dGxpbmVGZWF0dXJlcy5wdXNoKHtnZW9tZXRyeToge2Nvb3JkaW5hdGVzOiBwYXRofSwgcHJvcGVydGllcywgZmVhdHVyZX0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgLy8gQnJlYWsgbXVsdGlwb2x5Z29ucyBpbnRvIG11bHRpcGxlIHBvbHlnb25zIHdpdGggc2FtZSBwcm9wZXJ0aWVzXG4gICAgICBDb250YWluZXIuZm9yRWFjaChjb29yZGluYXRlcywgcG9seWdvbiA9PiB7XG4gICAgICAgIHBvbHlnb25GZWF0dXJlcy5wdXNoKHtnZW9tZXRyeToge2Nvb3JkaW5hdGVzOiBwb2x5Z29ufSwgcHJvcGVydGllcywgZmVhdHVyZX0pO1xuICAgICAgICAvLyBCcmVhayBwb2x5Z29uIGludG8gbXVsdGlwbGUgbGluZXMgd2l0aCBzYW1lIHByb3BlcnRpZXNcbiAgICAgICAgQ29udGFpbmVyLmZvckVhY2gocG9seWdvbiwgcGF0aCA9PiB7XG4gICAgICAgICAgcG9seWdvbk91dGxpbmVGZWF0dXJlcy5wdXNoKHtnZW9tZXRyeToge2Nvb3JkaW5hdGVzOiBwYXRofSwgcHJvcGVydGllcywgZmVhdHVyZX0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBOb3QgeWV0IHN1cHBvcnRlZFxuICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR2VvSnNvbkxheWVyOiAke3R5cGV9IG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHBvaW50RmVhdHVyZXMsXG4gICAgbGluZUZlYXR1cmVzLFxuICAgIHBvbHlnb25GZWF0dXJlcyxcbiAgICBwb2x5Z29uT3V0bGluZUZlYXR1cmVzXG4gIH07XG59XG4iXX0=