'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lib = require('../../../lib');

var _gridLayer = require('../grid-layer/grid-layer');

var _gridLayer2 = _interopRequireDefault(_gridLayer);

var _gridAggregator = require('./grid-aggregator');

var _scaleUtils = require('../../../utils/scale-utils');

var _colorUtils = require('../../../utils/color-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var defaultCellSize = 1000;
var defaultElevationRange = [0, 1000];
var defaultElevationScale = 1;

var defaultProps = {
  cellSize: defaultCellSize,
  colorRange: _colorUtils.defaultColorRange,
  elevationRange: defaultElevationRange,
  elevationScale: defaultElevationScale,
  getPosition: function getPosition(x) {
    return x.position;
  }
};

function noop() {}

function _needsReProjectPoints(oldProps, props) {
  return oldProps.cellSize !== props.cellSize;
}

var PointDensityGridLayer = function (_Layer) {
  _inherits(PointDensityGridLayer, _Layer);

  function PointDensityGridLayer() {
    _classCallCheck(this, PointDensityGridLayer);

    return _possibleConstructorReturn(this, (PointDensityGridLayer.__proto__ || Object.getPrototypeOf(PointDensityGridLayer)).apply(this, arguments));
  }

  _createClass(PointDensityGridLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        gridOffset: { yOffset: 0.0089, xOffset: 0.0113 },
        layerData: [],
        countRange: null,
        pickedCell: null
      };
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      if (changeFlags.dataChanged || _needsReProjectPoints(oldProps, props)) {
        var _props = this.props,
            data = _props.data,
            cellSize = _props.cellSize,
            getPosition = _props.getPosition;

        var _pointToDensityGridDa = (0, _gridAggregator.pointToDensityGridData)(data, cellSize, getPosition),
            gridOffset = _pointToDensityGridDa.gridOffset,
            layerData = _pointToDensityGridDa.layerData,
            countRange = _pointToDensityGridDa.countRange;

        Object.assign(this.state, { gridOffset: gridOffset, layerData: layerData, countRange: countRange });
      }
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(opts) {
      var info = _get(PointDensityGridLayer.prototype.__proto__ || Object.getPrototypeOf(PointDensityGridLayer.prototype), 'getPickingInfo', this).call(this, opts);
      var pickedCell = this.state.pickedCell;

      return Object.assign(info, {
        layer: this,
        // override index with cell index
        index: pickedCell ? pickedCell.index : -1,
        picked: Boolean(pickedCell),
        // override object with picked cell
        object: pickedCell
      });
    }
  }, {
    key: '_onHoverSublayer',
    value: function _onHoverSublayer(info) {

      this.state.pickedCell = info.picked && info.index > -1 ? this.state.layerData[info.index] : null;
    }
  }, {
    key: '_onGetSublayerColor',
    value: function _onGetSublayerColor(cell) {
      var colorRange = this.props.colorRange;

      var colorDomain = this.props.colorDomain || this.state.countRange;

      return (0, _scaleUtils.ordinalScale)(colorDomain, colorRange, cell.count);
    }
  }, {
    key: '_onGetSublayerElevation',
    value: function _onGetSublayerElevation(cell) {
      var elevationRange = this.props.elevationRange;

      var elevationDomain = this.props.elevationDomain || [0, this.state.countRange[1]];
      return (0, _scaleUtils.linearScale)(elevationDomain, elevationRange, cell.count);
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      var id = this.props.id;


      return new _gridLayer2.default(Object.assign({}, this.props, {
        id: id + '-density-grid',
        data: this.state.layerData,
        latOffset: this.state.gridOffset.yOffset,
        lonOffset: this.state.gridOffset.xOffset,
        getColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        getPosition: function getPosition(d) {
          return d.position;
        },
        // Override user's onHover and onClick props
        onHover: this._onHoverSublayer.bind(this),
        onClick: noop,
        updateTriggers: {
          getColor: { colorRange: this.props.colorRange },
          getElevation: { elevationRange: this.props.elevationRange }
        }
      }));
    }
  }]);

  return PointDensityGridLayer;
}(_lib.Layer);

exports.default = PointDensityGridLayer;


PointDensityGridLayer.layerName = 'PointDensityGridLayer';
PointDensityGridLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wb2ludC1kZW5zaXR5LWdyaWQtbGF5ZXIvcG9pbnQtZGVuc2l0eS1ncmlkLWxheWVyLmpzIl0sIm5hbWVzIjpbImRlZmF1bHRDZWxsU2l6ZSIsImRlZmF1bHRFbGV2YXRpb25SYW5nZSIsImRlZmF1bHRFbGV2YXRpb25TY2FsZSIsImRlZmF1bHRQcm9wcyIsImNlbGxTaXplIiwiY29sb3JSYW5nZSIsImVsZXZhdGlvblJhbmdlIiwiZWxldmF0aW9uU2NhbGUiLCJnZXRQb3NpdGlvbiIsIngiLCJwb3NpdGlvbiIsIm5vb3AiLCJfbmVlZHNSZVByb2plY3RQb2ludHMiLCJvbGRQcm9wcyIsInByb3BzIiwiUG9pbnREZW5zaXR5R3JpZExheWVyIiwic3RhdGUiLCJncmlkT2Zmc2V0IiwieU9mZnNldCIsInhPZmZzZXQiLCJsYXllckRhdGEiLCJjb3VudFJhbmdlIiwicGlja2VkQ2VsbCIsImNoYW5nZUZsYWdzIiwiZGF0YUNoYW5nZWQiLCJkYXRhIiwiT2JqZWN0IiwiYXNzaWduIiwib3B0cyIsImluZm8iLCJsYXllciIsImluZGV4IiwicGlja2VkIiwiQm9vbGVhbiIsIm9iamVjdCIsImNlbGwiLCJjb2xvckRvbWFpbiIsImNvdW50IiwiZWxldmF0aW9uRG9tYWluIiwiaWQiLCJsYXRPZmZzZXQiLCJsb25PZmZzZXQiLCJnZXRDb2xvciIsIl9vbkdldFN1YmxheWVyQ29sb3IiLCJiaW5kIiwiZ2V0RWxldmF0aW9uIiwiX29uR2V0U3VibGF5ZXJFbGV2YXRpb24iLCJkIiwib25Ib3ZlciIsIl9vbkhvdmVyU3VibGF5ZXIiLCJvbkNsaWNrIiwidXBkYXRlVHJpZ2dlcnMiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7Ozs7QUFFQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7K2VBekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QlosWUFBdEIsR0FBcUNBLFlBQXJDIiwiZmlsZSI6InBvaW50LWRlbnNpdHktZ3JpZC1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uLy4uLy4uL2xpYic7XG5pbXBvcnQgR3JpZExheWVyIGZyb20gJy4uL2dyaWQtbGF5ZXIvZ3JpZC1sYXllcic7XG5cbmltcG9ydCB7cG9pbnRUb0RlbnNpdHlHcmlkRGF0YX0gZnJvbSAnLi9ncmlkLWFnZ3JlZ2F0b3InO1xuaW1wb3J0IHtvcmRpbmFsU2NhbGUsIGxpbmVhclNjYWxlfSBmcm9tICcuLi8uLi8uLi91dGlscy9zY2FsZS11dGlscyc7XG5pbXBvcnQge2RlZmF1bHRDb2xvclJhbmdlfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb2xvci11dGlscyc7XG5cbmNvbnN0IGRlZmF1bHRDZWxsU2l6ZSA9IDEwMDA7XG5jb25zdCBkZWZhdWx0RWxldmF0aW9uUmFuZ2UgPSBbMCwgMTAwMF07XG5jb25zdCBkZWZhdWx0RWxldmF0aW9uU2NhbGUgPSAxO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGNlbGxTaXplOiBkZWZhdWx0Q2VsbFNpemUsXG4gIGNvbG9yUmFuZ2U6IGRlZmF1bHRDb2xvclJhbmdlLFxuICBlbGV2YXRpb25SYW5nZTogZGVmYXVsdEVsZXZhdGlvblJhbmdlLFxuICBlbGV2YXRpb25TY2FsZTogZGVmYXVsdEVsZXZhdGlvblNjYWxlLFxuICBnZXRQb3NpdGlvbjogeCA9PiB4LnBvc2l0aW9uXG59O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gX25lZWRzUmVQcm9qZWN0UG9pbnRzKG9sZFByb3BzLCBwcm9wcykge1xuICByZXR1cm4gb2xkUHJvcHMuY2VsbFNpemUgIT09IHByb3BzLmNlbGxTaXplO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludERlbnNpdHlHcmlkTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZ3JpZE9mZnNldDoge3lPZmZzZXQ6IDAuMDA4OSwgeE9mZnNldDogMC4wMTEzfSxcbiAgICAgIGxheWVyRGF0YTogW10sXG4gICAgICBjb3VudFJhbmdlOiBudWxsLFxuICAgICAgcGlja2VkQ2VsbDogbnVsbFxuICAgIH07XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh7b2xkUHJvcHMsIHByb3BzLCBjaGFuZ2VGbGFnc30pIHtcbiAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQgfHwgX25lZWRzUmVQcm9qZWN0UG9pbnRzKG9sZFByb3BzLCBwcm9wcykpIHtcbiAgICAgIGNvbnN0IHtkYXRhLCBjZWxsU2l6ZSwgZ2V0UG9zaXRpb259ID0gdGhpcy5wcm9wcztcblxuICAgICAgY29uc3Qge2dyaWRPZmZzZXQsIGxheWVyRGF0YSwgY291bnRSYW5nZX0gPVxuICAgICAgICBwb2ludFRvRGVuc2l0eUdyaWREYXRhKGRhdGEsIGNlbGxTaXplLCBnZXRQb3NpdGlvbik7XG5cbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwge2dyaWRPZmZzZXQsIGxheWVyRGF0YSwgY291bnRSYW5nZX0pO1xuICAgIH1cbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKG9wdHMpIHtcbiAgICBjb25zdCBpbmZvID0gc3VwZXIuZ2V0UGlja2luZ0luZm8ob3B0cyk7XG4gICAgY29uc3QgcGlja2VkQ2VsbCA9IHRoaXMuc3RhdGUucGlja2VkQ2VsbDtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGluZm8sIHtcbiAgICAgIGxheWVyOiB0aGlzLFxuICAgICAgLy8gb3ZlcnJpZGUgaW5kZXggd2l0aCBjZWxsIGluZGV4XG4gICAgICBpbmRleDogcGlja2VkQ2VsbCA/IHBpY2tlZENlbGwuaW5kZXggOiAtMSxcbiAgICAgIHBpY2tlZDogQm9vbGVhbihwaWNrZWRDZWxsKSxcbiAgICAgIC8vIG92ZXJyaWRlIG9iamVjdCB3aXRoIHBpY2tlZCBjZWxsXG4gICAgICBvYmplY3Q6IHBpY2tlZENlbGxcbiAgICB9KTtcbiAgfVxuXG4gIF9vbkhvdmVyU3VibGF5ZXIoaW5mbykge1xuXG4gICAgdGhpcy5zdGF0ZS5waWNrZWRDZWxsID0gaW5mby5waWNrZWQgJiYgaW5mby5pbmRleCA+IC0xID9cbiAgICAgIHRoaXMuc3RhdGUubGF5ZXJEYXRhW2luZm8uaW5kZXhdIDogbnVsbDtcbiAgfVxuXG4gIF9vbkdldFN1YmxheWVyQ29sb3IoY2VsbCkge1xuICAgIGNvbnN0IHtjb2xvclJhbmdlfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgY29sb3JEb21haW4gPSB0aGlzLnByb3BzLmNvbG9yRG9tYWluIHx8IHRoaXMuc3RhdGUuY291bnRSYW5nZTtcblxuICAgIHJldHVybiBvcmRpbmFsU2NhbGUoY29sb3JEb21haW4sIGNvbG9yUmFuZ2UsIGNlbGwuY291bnQpO1xuICB9XG5cbiAgX29uR2V0U3VibGF5ZXJFbGV2YXRpb24oY2VsbCkge1xuICAgIGNvbnN0IHtlbGV2YXRpb25SYW5nZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGVsZXZhdGlvbkRvbWFpbiA9IHRoaXMucHJvcHMuZWxldmF0aW9uRG9tYWluIHx8IFswLCB0aGlzLnN0YXRlLmNvdW50UmFuZ2VbMV1dO1xuICAgIHJldHVybiBsaW5lYXJTY2FsZShlbGV2YXRpb25Eb21haW4sIGVsZXZhdGlvblJhbmdlLCBjZWxsLmNvdW50KTtcbiAgfVxuXG4gIHJlbmRlckxheWVycygpIHtcbiAgICBjb25zdCB7aWR9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiBuZXcgR3JpZExheWVyKE9iamVjdC5hc3NpZ24oe30sXG4gICAgICB0aGlzLnByb3BzLCB7XG4gICAgICAgIGlkOiBgJHtpZH0tZGVuc2l0eS1ncmlkYCxcbiAgICAgICAgZGF0YTogdGhpcy5zdGF0ZS5sYXllckRhdGEsXG4gICAgICAgIGxhdE9mZnNldDogdGhpcy5zdGF0ZS5ncmlkT2Zmc2V0LnlPZmZzZXQsXG4gICAgICAgIGxvbk9mZnNldDogdGhpcy5zdGF0ZS5ncmlkT2Zmc2V0LnhPZmZzZXQsXG4gICAgICAgIGdldENvbG9yOiB0aGlzLl9vbkdldFN1YmxheWVyQ29sb3IuYmluZCh0aGlzKSxcbiAgICAgICAgZ2V0RWxldmF0aW9uOiB0aGlzLl9vbkdldFN1YmxheWVyRWxldmF0aW9uLmJpbmQodGhpcyksXG4gICAgICAgIGdldFBvc2l0aW9uOiBkID0+IGQucG9zaXRpb24sXG4gICAgICAgIC8vIE92ZXJyaWRlIHVzZXIncyBvbkhvdmVyIGFuZCBvbkNsaWNrIHByb3BzXG4gICAgICAgIG9uSG92ZXI6IHRoaXMuX29uSG92ZXJTdWJsYXllci5iaW5kKHRoaXMpLFxuICAgICAgICBvbkNsaWNrOiBub29wLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldENvbG9yOiB7Y29sb3JSYW5nZTogdGhpcy5wcm9wcy5jb2xvclJhbmdlfSxcbiAgICAgICAgICBnZXRFbGV2YXRpb246IHtlbGV2YXRpb25SYW5nZTogdGhpcy5wcm9wcy5lbGV2YXRpb25SYW5nZX1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuICB9XG59XG5cblBvaW50RGVuc2l0eUdyaWRMYXllci5sYXllck5hbWUgPSAnUG9pbnREZW5zaXR5R3JpZExheWVyJztcblBvaW50RGVuc2l0eUdyaWRMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=