'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lib = require('../../../lib');

var _shaderUtils = require('../../../shader-utils');

var _luma = require('luma.gl');

var _path = require('path');

var _utils = require('../../../lib/utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

function positionsAreEqual(v1, v2) {
  // Hex positions are expected to change entirely, not to maintain some
  // positions and change others. Right now we only check a single vertex,
  // because H3 guarantees order, but even if that wasn't true, this would only
  // return a false positive for adjacent hexagons, which is close enough for
  // our purposes.
  return v1 === v2 || v1 && v2 && v1[0][0] === v2[0][0] && v1[0][1] === v2[0][1];
}

var DEFAULT_COLOR = [255, 0, 255, 255];

var defaultProps = {
  extruded: true,
  hexagonVertices: null,
  opacity: 0.8,
  coverage: 1,
  elevationScale: 1,
  getCentroid: function getCentroid(x) {
    return x.centroid;
  },
  getColor: function getColor(x) {
    return x.color;
  },
  getElevation: function getElevation(x) {
    return x.elevation;
  },
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.4,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [1.2, 0.0, 0.8, 0.0],
    numberOfLights: 2
  }
};

var HexagonLayer = function (_Layer) {
  _inherits(HexagonLayer, _Layer);

  function HexagonLayer(props) {
    _classCallCheck(this, HexagonLayer);

    var missingProps = false;
    if (!props.hexagonVertices && (!props.radius || !Number.isFinite(props.angle))) {
      _utils.log.once(0, 'HexagonLayer: Either hexagonVertices or radius and angel are ' + 'needed to calculate primitive hexagon.');
      missingProps = true;
    } else if (props.hexagonVertices && (!Array.isArray(props.hexagonVertices) || props.hexagonVertices.length < 6)) {
      _utils.log.once(0, 'HexagonLayer: HexagonVertices needs to be an array of 6 points');

      missingProps = true;
    }

    if (missingProps) {
      _utils.log.once(0, 'Now using 1000 meter as default radius, 0 as default angel');
      props.radius = 1000;
      props.angle = 0;
    }

    return _possibleConstructorReturn(this, (HexagonLayer.__proto__ || Object.getPrototypeOf(HexagonLayer)).call(this, props));
  }

  /**
   * DeckGL calls initializeState when GL context is available
   * Essentially a deferred constructor
   */


  _createClass(HexagonLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({ model: this.getModel(gl) });

      var attributeManager = this.state.attributeManager;
      /* eslint-disable max-len */

      attributeManager.addInstanced({
        instancePositions: { size: 3, accessor: ['getCentroid', 'getElevation'], update: this.calculateInstancePositions },
        instanceColors: { size: 4, type: gl.UNSIGNED_BYTE, accessor: 'getColor', update: this.calculateInstanceColors }
      });
      /* eslint-enable max-len */

      this.updateRadiusAngle();
    }
  }, {
    key: 'updateState',
    value: function updateState(opt) {
      _get(HexagonLayer.prototype.__proto__ || Object.getPrototypeOf(HexagonLayer.prototype), 'updateState', this).call(this, opt);

      var viewportChanged = opt.changeFlags.viewportChanged;
      var model = this.state.model;

      // Update the positions in the model if they've changes

      var verticesChanged = !positionsAreEqual(opt.oldProps.hexagonVertices, opt.props.hexagonVertices);

      if (model && (verticesChanged || viewportChanged)) {
        this.updateRadiusAngle();
      }

      this.updateUniforms();
    }
  }, {
    key: 'updateRadiusAngle',
    value: function updateRadiusAngle() {
      var angle = void 0;
      var radius = void 0;
      var hexagonVertices = this.props.hexagonVertices;


      if (Array.isArray(hexagonVertices) && hexagonVertices.length >= 6) {

        // calculate angle and vertices from hexagonVertices if provided
        var vertices = this.props.hexagonVertices;

        var vertex0 = vertices[0];
        var vertex3 = vertices[3];

        // transform to space coordinates
        var spaceCoord0 = this.projectFlat(vertex0);
        var spaceCoord3 = this.projectFlat(vertex3);

        // distance between two close centroids
        var dx = spaceCoord0[0] - spaceCoord3[0];
        var dy = spaceCoord0[1] - spaceCoord3[1];
        var dxy = Math.sqrt(dx * dx + dy * dy);

        // Calculate angle that the perpendicular hexagon vertex axis is tilted
        angle = Math.acos(dx / dxy) * -Math.sign(dy) + Math.PI / 2;
        radius = dxy / 2;
      } else if (this.props.radius && Number.isFinite(this.props.angle)) {

        // if no hexagonVertices provided, try use radius & angle
        var viewport = this.context.viewport;

        var _viewport$getDistance = viewport.getDistanceScales(),
            pixelsPerMeter = _viewport$getDistance.pixelsPerMeter;

        angle = this.props.angle;
        radius = this.props.radius * pixelsPerMeter[0];
      }

      this.setUniforms({
        angle: angle,
        radius: radius
      });
    }
  }, {
    key: 'getCylinderGeometry',
    value: function getCylinderGeometry(radius) {
      return new _luma.CylinderGeometry({
        radius: radius,
        topRadius: radius,
        bottomRadius: radius,
        topCap: true,
        bottomCap: true,
        height: 1,
        nradial: 6,
        nvertical: 1
      });
    }
  }, {
    key: 'updateUniforms',
    value: function updateUniforms() {
      var _props = this.props,
          opacity = _props.opacity,
          elevationScale = _props.elevationScale,
          extruded = _props.extruded,
          coverage = _props.coverage,
          lightSettings = _props.lightSettings;


      this.setUniforms(Object.assign({}, {
        extruded: extruded,
        opacity: opacity,
        coverage: coverage,
        elevationScale: elevationScale
      }, lightSettings));
    }
  }, {
    key: 'getShaders',
    value: function getShaders() {
      var vertex = '#define SHADER_NAME extruded-hexagon-layer-vs\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec3 instancePositions;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Picking uniforms\n// Set to 1.0 if rendering picking buffer, 0.0 if rendering for display\nuniform float renderPickingBuffer;\nuniform vec3 selectedPickingColor;\n\n// Custom uniforms\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform float extruded;\nuniform float coverage;\nuniform float elevationScale;\n\n// Result\nvarying vec4 vColor;\n\n// A magic number to scale elevation so that 1 unit approximate to 1 meter.\n#define ELEVATION_SCALE 0.8\n\n\nvoid main(void) {\n\n  // rotate primitive position and normal\n  mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n  vec2 rPos = rotationMatrix * positions.xz;\n  vec2 rNorm = rotationMatrix * normals.xz;\n\n  vec3 rotatedPositions = vec3(rPos.x, positions.y, rPos.y);\n  vec3 rotatedNormals = vec3(rNorm.x, normals.y, rNorm.y);\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar gemoetry height are between -0.5 to 0.5, transform it to between 0, 1\n  float elevation = 0.0;\n\n  if (extruded > 0.5) {\n    elevation = project_scale(instancePositions.z * (positions.y + 0.5) * ELEVATION_SCALE * elevationScale);\n}\n\n  float dotRadius = radius * clamp(coverage, 0.0, 1.0);\n  // // project center of hexagon\n\n  vec4 centroidPosition = vec4(project_position(instancePositions.xy), elevation, 0.0);\n\n  vec4 position_worldspace = centroidPosition + vec4(vec2(rotatedPositions.xz * dotRadius), 0., 1.);\n\n  gl_Position = project_to_clipspace(position_worldspace);\n\n  // render display\n  if (renderPickingBuffer < 0.5) {\n\n    // TODO: we should allow the user to specify the color for "selected element"\n    // check whether hexagon is currently picked.\n    float selected = isPicked(instancePickingColors, selectedPickingColor);\n\n    // Light calculations\n    // Worldspace is the linear space after Mercator projection\n\n    vec3 normals_worldspace = rotatedNormals;\n\n    float lightWeight = 1.0;\n\n    if (extruded > 0.5) {\n      lightWeight = getLightWeight(\n        position_worldspace,\n        normals_worldspace\n      );\n    }\n\n    vec3 lightWeightedColor = lightWeight * instanceColors.rgb;\n\n    // Color: Either opacity-multiplied instance color, or picking color\n    vec4 color = vec4(lightWeightedColor, opacity * instanceColors.a) / 255.0;\n\n    vColor = color;\n\n  } else {\n\n    vec4 pickingColor = vec4(instancePickingColors / 255.0, 1.0);\n    vColor = pickingColor;\n\n  }\n}\n';
      var picking = '// whether is point picked\nfloat isPicked(vec3 pickingColors, vec3 selectedColor) {\n return float(pickingColors.x == selectedColor.x\n && pickingColors.y == selectedColor.y\n && pickingColors.z == selectedColor.z);\n}\n';
      var vs = picking.concat(vertex);
      return {
        vs: vs,
        fs: '// See: npm glsl-shader-name\n#define SHADER_NAME extruded-hexagon-layer-fs\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n}\n',
        modules: ['lighting']
      };
    }
  }, {
    key: 'getModel',
    value: function getModel(gl) {
      var shaders = (0, _shaderUtils.assembleShaders)(gl, this.getShaders());

      return new _luma.Model({
        gl: gl,
        id: this.props.id,
        vs: shaders.vs,
        fs: shaders.fs,
        geometry: this.getCylinderGeometry(1),
        isInstanced: true
      });
    }
  }, {
    key: 'draw',
    value: function draw(_ref) {
      var uniforms = _ref.uniforms;

      _get(HexagonLayer.prototype.__proto__ || Object.getPrototypeOf(HexagonLayer.prototype), 'draw', this).call(this, { uniforms: Object.assign({}, uniforms) });
    }
  }, {
    key: 'calculateInstancePositions',
    value: function calculateInstancePositions(attribute) {
      var _props2 = this.props,
          data = _props2.data,
          getCentroid = _props2.getCentroid,
          getElevation = _props2.getElevation;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var _getCentroid = getCentroid(object),
              _getCentroid2 = _slicedToArray(_getCentroid, 2),
              lon = _getCentroid2[0],
              lat = _getCentroid2[1];

          var elevation = getElevation(object);
          value[i + 0] = lon;
          value[i + 1] = lat;
          value[i + 2] = elevation || this.props.elevation;
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'calculateInstanceColors',
    value: function calculateInstanceColors(attribute) {
      var _props3 = this.props,
          data = _props3.data,
          getColor = _props3.getColor;
      var value = attribute.value,
          size = attribute.size;

      var i = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;

          var color = getColor(object) || DEFAULT_COLOR;

          value[i + 0] = color[0];
          value[i + 1] = color[1];
          value[i + 2] = color[2];
          value[i + 3] = Number.isFinite(color[3]) ? color[3] : DEFAULT_COLOR[3];
          i += size;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }]);

  return HexagonLayer;
}(_lib.Layer);

exports.default = HexagonLayer;


HexagonLayer.layerName = 'HexagonLayer';
HexagonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9oZXhhZ29uLWxheWVyL2hleGFnb24tbGF5ZXIuanMiXSwibmFtZXMiOlsicG9zaXRpb25zQXJlRXF1YWwiLCJ2MSIsInYyIiwiREVGQVVMVF9DT0xPUiIsImRlZmF1bHRQcm9wcyIsImV4dHJ1ZGVkIiwiaGV4YWdvblZlcnRpY2VzIiwib3BhY2l0eSIsImNvdmVyYWdlIiwiZWxldmF0aW9uU2NhbGUiLCJnZXRDZW50cm9pZCIsIngiLCJjZW50cm9pZCIsImdldENvbG9yIiwiY29sb3IiLCJnZXRFbGV2YXRpb24iLCJlbGV2YXRpb24iLCJsaWdodFNldHRpbmdzIiwibGlnaHRzUG9zaXRpb24iLCJhbWJpZW50UmF0aW8iLCJkaWZmdXNlUmF0aW8iLCJzcGVjdWxhclJhdGlvIiwibGlnaHRzU3RyZW5ndGgiLCJudW1iZXJPZkxpZ2h0cyIsIkhleGFnb25MYXllciIsInByb3BzIiwibWlzc2luZ1Byb3BzIiwicmFkaXVzIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJhbmdsZSIsIm9uY2UiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJnbCIsImNvbnRleHQiLCJzZXRTdGF0ZSIsIm1vZGVsIiwiZ2V0TW9kZWwiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwic3RhdGUiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBvc2l0aW9ucyIsInNpemUiLCJhY2Nlc3NvciIsInVwZGF0ZSIsImNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zIiwiaW5zdGFuY2VDb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUluc3RhbmNlQ29sb3JzIiwidXBkYXRlUmFkaXVzQW5nbGUiLCJvcHQiLCJ2aWV3cG9ydENoYW5nZWQiLCJjaGFuZ2VGbGFncyIsInZlcnRpY2VzQ2hhbmdlZCIsIm9sZFByb3BzIiwidXBkYXRlVW5pZm9ybXMiLCJ2ZXJ0aWNlcyIsInZlcnRleDAiLCJ2ZXJ0ZXgzIiwic3BhY2VDb29yZDAiLCJwcm9qZWN0RmxhdCIsInNwYWNlQ29vcmQzIiwiZHgiLCJkeSIsImR4eSIsIk1hdGgiLCJzcXJ0IiwiYWNvcyIsInNpZ24iLCJQSSIsInZpZXdwb3J0IiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJwaXhlbHNQZXJNZXRlciIsInNldFVuaWZvcm1zIiwidG9wUmFkaXVzIiwiYm90dG9tUmFkaXVzIiwidG9wQ2FwIiwiYm90dG9tQ2FwIiwiaGVpZ2h0IiwibnJhZGlhbCIsIm52ZXJ0aWNhbCIsIk9iamVjdCIsImFzc2lnbiIsInZlcnRleCIsInBpY2tpbmciLCJ2cyIsImNvbmNhdCIsImZzIiwibW9kdWxlcyIsInNoYWRlcnMiLCJnZXRTaGFkZXJzIiwiaWQiLCJnZW9tZXRyeSIsImdldEN5bGluZGVyR2VvbWV0cnkiLCJpc0luc3RhbmNlZCIsInVuaWZvcm1zIiwiYXR0cmlidXRlIiwiZGF0YSIsInZhbHVlIiwiaSIsIm9iamVjdCIsImxvbiIsImxhdCIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOzs7Ozs7K2VBekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVNBLFNBQVNBLGlCQUFULENBQTJCQyxFQUEzQixFQUErQkMsRUFBL0IsRUFBbUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9ELE9BQU9DLEVBQVAsSUFDTEQsTUFBTUMsRUFBTixJQUFZRCxHQUFHLENBQUgsRUFBTSxDQUFOLE1BQWFDLEdBQUcsQ0FBSCxFQUFNLENBQU4sQ0FBekIsSUFBcUNELEdBQUcsQ0FBSCxFQUFNLENBQU4sTUFBYUMsR0FBRyxDQUFILEVBQU0sQ0FBTixDQURwRDtBQUdEOztBQUVELElBQU1DLGdCQUFnQixDQUFDLEdBQUQsRUFBTSxDQUFOLEVBQVMsR0FBVCxFQUFjLEdBQWQsQ0FBdEI7O0FBRUEsSUFB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anMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLi8uLi9saWInO1xuaW1wb3J0IHthc3NlbWJsZVNoYWRlcnN9IGZyb20gJy4uLy4uLy4uL3NoYWRlci11dGlscyc7XG5pbXBvcnQge01vZGVsLCBDeWxpbmRlckdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7cmVhZEZpbGVTeW5jfSBmcm9tICdmcyc7XG5pbXBvcnQge2pvaW59IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4uLy4uLy4uL2xpYi91dGlscyc7XG5cbmZ1bmN0aW9uIHBvc2l0aW9uc0FyZUVxdWFsKHYxLCB2Mikge1xuICAvLyBIZXggcG9zaXRpb25zIGFyZSBleHBlY3RlZCB0byBjaGFuZ2UgZW50aXJlbHksIG5vdCB0byBtYWludGFpbiBzb21lXG4gIC8vIHBvc2l0aW9ucyBhbmQgY2hhbmdlIG90aGVycy4gUmlnaHQgbm93IHdlIG9ubHkgY2hlY2sgYSBzaW5nbGUgdmVydGV4LFxuICAvLyBiZWNhdXNlIEgzIGd1YXJhbnRlZXMgb3JkZXIsIGJ1dCBldmVuIGlmIHRoYXQgd2Fzbid0IHRydWUsIHRoaXMgd291bGQgb25seVxuICAvLyByZXR1cm4gYSBmYWxzZSBwb3NpdGl2ZSBmb3IgYWRqYWNlbnQgaGV4YWdvbnMsIHdoaWNoIGlzIGNsb3NlIGVub3VnaCBmb3JcbiAgLy8gb3VyIHB1cnBvc2VzLlxuICByZXR1cm4gdjEgPT09IHYyIHx8IChcbiAgICB2MSAmJiB2MiAmJiB2MVswXVswXSA9PT0gdjJbMF1bMF0gJiYgdjFbMF1bMV0gPT09IHYyWzBdWzFdXG4gICk7XG59XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMjU1LCAwLCAyNTUsIDI1NV07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgZXh0cnVkZWQ6IHRydWUsXG4gIGhleGFnb25WZXJ0aWNlczogbnVsbCxcbiAgb3BhY2l0eTogMC44LFxuICBjb3ZlcmFnZTogMSxcbiAgZWxldmF0aW9uU2NhbGU6IDEsXG4gIGdldENlbnRyb2lkOiB4ID0+IHguY2VudHJvaWQsXG4gIGdldENvbG9yOiB4ID0+IHguY29sb3IsXG4gIGdldEVsZXZhdGlvbjogeCA9PiB4LmVsZXZhdGlvbixcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMDAsIDUwMDBdLFxuICAgIGFtYmllbnRSYXRpbzogMC40LFxuICAgIGRpZmZ1c2VSYXRpbzogMC42LFxuICAgIHNwZWN1bGFyUmF0aW86IDAuOCxcbiAgICBsaWdodHNTdHJlbmd0aDogWzEuMiwgMC4wLCAwLjgsIDAuMF0sXG4gICAgbnVtYmVyT2ZMaWdodHM6IDJcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGV4YWdvbkxheWVyIGV4dGVuZHMgTGF5ZXIge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgbGV0IG1pc3NpbmdQcm9wcyA9IGZhbHNlO1xuICAgIGlmICghcHJvcHMuaGV4YWdvblZlcnRpY2VzICYmICghcHJvcHMucmFkaXVzIHx8ICFOdW1iZXIuaXNGaW5pdGUocHJvcHMuYW5nbGUpKSkge1xuICAgICAgbG9nLm9uY2UoMCwgJ0hleGFnb25MYXllcjogRWl0aGVyIGhleGFnb25WZXJ0aWNlcyBvciByYWRpdXMgYW5kIGFuZ2VsIGFyZSAnICtcbiAgICAgICAgJ25lZWRlZCB0byBjYWxjdWxhdGUgcHJpbWl0aXZlIGhleGFnb24uJyk7XG4gICAgICBtaXNzaW5nUHJvcHMgPSB0cnVlO1xuXG4gICAgfSBlbHNlIGlmIChwcm9wcy5oZXhhZ29uVmVydGljZXMgJiYgKCFBcnJheS5pc0FycmF5KHByb3BzLmhleGFnb25WZXJ0aWNlcykgfHxcbiAgICAgIHByb3BzLmhleGFnb25WZXJ0aWNlcy5sZW5ndGggPCA2KSkge1xuICAgICAgbG9nLm9uY2UoMCwgJ0hleGFnb25MYXllcjogSGV4YWdvblZlcnRpY2VzIG5lZWRzIHRvIGJlIGFuIGFycmF5IG9mIDYgcG9pbnRzJyk7XG5cbiAgICAgIG1pc3NpbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG1pc3NpbmdQcm9wcykge1xuICAgICAgbG9nLm9uY2UoMCwgJ05vdyB1c2luZyAxMDAwIG1ldGVyIGFzIGRlZmF1bHQgcmFkaXVzLCAwIGFzIGRlZmF1bHQgYW5nZWwnKTtcbiAgICAgIHByb3BzLnJhZGl1cyA9IDEwMDA7XG4gICAgICBwcm9wcy5hbmdsZSA9IDA7XG4gICAgfVxuXG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY2tHTCBjYWxscyBpbml0aWFsaXplU3RhdGUgd2hlbiBHTCBjb250ZXh0IGlzIGF2YWlsYWJsZVxuICAgKiBFc3NlbnRpYWxseSBhIGRlZmVycmVkIGNvbnN0cnVjdG9yXG4gICAqL1xuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHttb2RlbDogdGhpcy5nZXRNb2RlbChnbCl9KTtcblxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7c2l6ZTogMywgYWNjZXNzb3I6IFsnZ2V0Q2VudHJvaWQnLCAnZ2V0RWxldmF0aW9uJ10sIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uc30sXG4gICAgICBpbnN0YW5jZUNvbG9yczoge3NpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIGFjY2Vzc29yOiAnZ2V0Q29sb3InLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VDb2xvcnN9XG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbiAgICB0aGlzLnVwZGF0ZVJhZGl1c0FuZ2xlKCk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZShvcHQpIHtcbiAgICBzdXBlci51cGRhdGVTdGF0ZShvcHQpO1xuXG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gb3B0LmNoYW5nZUZsYWdzLnZpZXdwb3J0Q2hhbmdlZDtcbiAgICBjb25zdCB7bW9kZWx9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb25zIGluIHRoZSBtb2RlbCBpZiB0aGV5J3ZlIGNoYW5nZXNcbiAgICBjb25zdCB2ZXJ0aWNlc0NoYW5nZWQgPVxuICAgICAgIXBvc2l0aW9uc0FyZUVxdWFsKG9wdC5vbGRQcm9wcy5oZXhhZ29uVmVydGljZXMsIG9wdC5wcm9wcy5oZXhhZ29uVmVydGljZXMpO1xuXG4gICAgaWYgKG1vZGVsICYmICh2ZXJ0aWNlc0NoYW5nZWQgfHwgdmlld3BvcnRDaGFuZ2VkKSkge1xuICAgICAgdGhpcy51cGRhdGVSYWRpdXNBbmdsZSgpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlVW5pZm9ybXMoKTtcbiAgfVxuXG4gIHVwZGF0ZVJhZGl1c0FuZ2xlKCkge1xuICAgIGxldCBhbmdsZTtcbiAgICBsZXQgcmFkaXVzO1xuICAgIGNvbnN0IHtoZXhhZ29uVmVydGljZXN9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGhleGFnb25WZXJ0aWNlcykgJiYgaGV4YWdvblZlcnRpY2VzLmxlbmd0aCA+PSA2KSB7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBhbmdsZSBhbmQgdmVydGljZXMgZnJvbSBoZXhhZ29uVmVydGljZXMgaWYgcHJvdmlkZWRcbiAgICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy5wcm9wcy5oZXhhZ29uVmVydGljZXM7XG5cbiAgICAgIGNvbnN0IHZlcnRleDAgPSB2ZXJ0aWNlc1swXTtcbiAgICAgIGNvbnN0IHZlcnRleDMgPSB2ZXJ0aWNlc1szXTtcblxuICAgICAgLy8gdHJhbnNmb3JtIHRvIHNwYWNlIGNvb3JkaW5hdGVzXG4gICAgICBjb25zdCBzcGFjZUNvb3JkMCA9IHRoaXMucHJvamVjdEZsYXQodmVydGV4MCk7XG4gICAgICBjb25zdCBzcGFjZUNvb3JkMyA9IHRoaXMucHJvamVjdEZsYXQodmVydGV4Myk7XG5cbiAgICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGNsb3NlIGNlbnRyb2lkc1xuICAgICAgY29uc3QgZHggPSBzcGFjZUNvb3JkMFswXSAtIHNwYWNlQ29vcmQzWzBdO1xuICAgICAgY29uc3QgZHkgPSBzcGFjZUNvb3JkMFsxXSAtIHNwYWNlQ29vcmQzWzFdO1xuICAgICAgY29uc3QgZHh5ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGFuZ2xlIHRoYXQgdGhlIHBlcnBlbmRpY3VsYXIgaGV4YWdvbiB2ZXJ0ZXggYXhpcyBpcyB0aWx0ZWRcbiAgICAgIGFuZ2xlID0gTWF0aC5hY29zKGR4IC8gZHh5KSAqIC1NYXRoLnNpZ24oZHkpICsgTWF0aC5QSSAvIDI7XG4gICAgICByYWRpdXMgPSBkeHkgLyAyO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnJhZGl1cyAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy5wcm9wcy5hbmdsZSkpIHtcblxuICAgICAgLy8gaWYgbm8gaGV4YWdvblZlcnRpY2VzIHByb3ZpZGVkLCB0cnkgdXNlIHJhZGl1cyAmIGFuZ2xlXG4gICAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgY29uc3Qge3BpeGVsc1Blck1ldGVyfSA9IHZpZXdwb3J0LmdldERpc3RhbmNlU2NhbGVzKCk7XG5cbiAgICAgIGFuZ2xlID0gdGhpcy5wcm9wcy5hbmdsZTtcbiAgICAgIHJhZGl1cyA9IHRoaXMucHJvcHMucmFkaXVzICogcGl4ZWxzUGVyTWV0ZXJbMF07XG5cbiAgICB9XG5cbiAgICB0aGlzLnNldFVuaWZvcm1zKHtcbiAgICAgIGFuZ2xlLFxuICAgICAgcmFkaXVzXG4gICAgfSk7XG4gIH1cblxuICBnZXRDeWxpbmRlckdlb21ldHJ5KHJhZGl1cykge1xuICAgIHJldHVybiBuZXcgQ3lsaW5kZXJHZW9tZXRyeSh7XG4gICAgICByYWRpdXMsXG4gICAgICB0b3BSYWRpdXM6IHJhZGl1cyxcbiAgICAgIGJvdHRvbVJhZGl1czogcmFkaXVzLFxuICAgICAgdG9wQ2FwOiB0cnVlLFxuICAgICAgYm90dG9tQ2FwOiB0cnVlLFxuICAgICAgaGVpZ2h0OiAxLFxuICAgICAgbnJhZGlhbDogNixcbiAgICAgIG52ZXJ0aWNhbDogMVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlVW5pZm9ybXMoKSB7XG4gICAgY29uc3Qge29wYWNpdHksIGVsZXZhdGlvblNjYWxlLCBleHRydWRlZCwgY292ZXJhZ2UsIGxpZ2h0U2V0dGluZ3N9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc2V0VW5pZm9ybXMoT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgZXh0cnVkZWQsXG4gICAgICBvcGFjaXR5LFxuICAgICAgY292ZXJhZ2UsXG4gICAgICBlbGV2YXRpb25TY2FsZVxuICAgIH0sXG4gICAgbGlnaHRTZXR0aW5ncykpO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICBjb25zdCB2ZXJ0ZXggPSByZWFkRmlsZVN5bmMoam9pbihfX2Rpcm5hbWUsICcuL2hleGFnb24tbGF5ZXItdmVydGV4Lmdsc2wnKSwgJ3V0ZjgnKTtcbiAgICBjb25zdCBwaWNraW5nID0gcmVhZEZpbGVTeW5jKGpvaW4oX19kaXJuYW1lLCAnLi9waWNraW5nLmdsc2wnKSwgJ3V0ZjgnKTtcbiAgICBjb25zdCB2cyA9IHBpY2tpbmcuY29uY2F0KHZlcnRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZzLFxuICAgICAgZnM6IHJlYWRGaWxlU3luYyhqb2luKF9fZGlybmFtZSwgJy4vaGV4YWdvbi1sYXllci1mcmFnbWVudC5nbHNsJyksICd1dGY4JyksXG4gICAgICBtb2R1bGVzOiBbJ2xpZ2h0aW5nJ11cbiAgICB9O1xuICB9XG5cbiAgZ2V0TW9kZWwoZ2wpIHtcbiAgICBjb25zdCBzaGFkZXJzID0gYXNzZW1ibGVTaGFkZXJzKGdsLCB0aGlzLmdldFNoYWRlcnMoKSk7XG5cbiAgICByZXR1cm4gbmV3IE1vZGVsKHtcbiAgICAgIGdsLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICB2czogc2hhZGVycy52cyxcbiAgICAgIGZzOiBzaGFkZXJzLmZzLFxuICAgICAgZ2VvbWV0cnk6IHRoaXMuZ2V0Q3lsaW5kZXJHZW9tZXRyeSgxKSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBzdXBlci5kcmF3KHt1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMpfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcblxuICAgIGNvbnN0IHtkYXRhLCBnZXRDZW50cm9pZCwgZ2V0RWxldmF0aW9ufSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge3ZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgZGF0YSkge1xuICAgICAgY29uc3QgW2xvbiwgbGF0XSA9IGdldENlbnRyb2lkKG9iamVjdCk7XG4gICAgICBjb25zdCBlbGV2YXRpb24gPSBnZXRFbGV2YXRpb24ob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGxvbjtcbiAgICAgIHZhbHVlW2kgKyAxXSA9IGxhdDtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGVsZXZhdGlvbiB8fCB0aGlzLnByb3BzLmVsZXZhdGlvbjtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7ZGF0YSwgZ2V0Q29sb3J9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7dmFsdWUsIHNpemV9ID0gYXR0cmlidXRlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKG9iamVjdCkgfHwgREVGQVVMVF9DT0xPUjtcblxuICAgICAgdmFsdWVbaSArIDBdID0gY29sb3JbMF07XG4gICAgICB2YWx1ZVtpICsgMV0gPSBjb2xvclsxXTtcbiAgICAgIHZhbHVlW2kgKyAyXSA9IGNvbG9yWzJdO1xuICAgICAgdmFsdWVbaSArIDNdID0gTnVtYmVyLmlzRmluaXRlKGNvbG9yWzNdKSA/IGNvbG9yWzNdIDogREVGQVVMVF9DT0xPUlszXTtcbiAgICAgIGkgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbn1cblxuSGV4YWdvbkxheWVyLmxheWVyTmFtZSA9ICdIZXhhZ29uTGF5ZXInO1xuSGV4YWdvbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==