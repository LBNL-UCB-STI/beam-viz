'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolygonTesselatorExtruded = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
// import {getPolygonVertexCount, getPolygonTriangleCount} from './polygon';


var _polygon = require('./polygon');

var Polygon = _interopRequireWildcard(_polygon);

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

var _lodash = require('lodash.flattendeep');

var _lodash2 = _interopRequireDefault(_lodash);

var _glMatrix = require('gl-matrix');

var _fp = require('../../../lib/utils/fp64');

var _utils = require('../../../lib/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// import {Container, flattenVertices, fillArray} from '../../../lib/utils';

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

var PolygonTesselatorExtruded = exports.PolygonTesselatorExtruded = function () {
  function PolygonTesselatorExtruded(_ref) {
    var polygons = _ref.polygons,
        _ref$getHeight = _ref.getHeight,
        getHeight = _ref$getHeight === undefined ? function (x) {
      return 1000;
    } : _ref$getHeight,
        _ref$getColor = _ref.getColor,
        getColor = _ref$getColor === undefined ? function (x) {
      return [0, 0, 0, 255];
    } : _ref$getColor,
        _ref$wireframe = _ref.wireframe,
        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,
        _ref$fp = _ref.fp64,
        fp64 = _ref$fp === undefined ? false : _ref$fp;

    _classCallCheck(this, PolygonTesselatorExtruded);

    this.fp64 = fp64;

    // Expensive operation, convert all polygons to arrays
    polygons = _utils.Container.map(polygons, function (complexPolygon, polygonIndex) {
      var height = getHeight(polygonIndex) || 0;
      return _utils.Container.map(Polygon.normalize(complexPolygon), function (polygon) {
        return _utils.Container.map(polygon, function (coord) {
          return [coord[0], coord[1], height];
        });
      });
    });

    var groupedVertices = polygons;
    this.groupedVertices = polygons;
    this.wireframe = wireframe;

    this.attributes = {};

    var positionsJS = calculatePositionsJS({ groupedVertices: groupedVertices, wireframe: wireframe });
    Object.assign(this.attributes, {
      positions: calculatePositions(positionsJS, this.fp64),
      indices: calculateIndices({ groupedVertices: groupedVertices, wireframe: wireframe }),
      normals: calculateNormals({ groupedVertices: groupedVertices, wireframe: wireframe }),
      // colors: calculateColors({groupedVertices, wireframe, getColor}),
      pickingColors: calculatePickingColors({ groupedVertices: groupedVertices, wireframe: wireframe })
    });
  }

  _createClass(PolygonTesselatorExtruded, [{
    key: 'indices',
    value: function indices() {
      return this.attributes.indices;
    }
  }, {
    key: 'positions',
    value: function positions() {
      return this.attributes.positions;
    }
  }, {
    key: 'normals',
    value: function normals() {
      return this.attributes.normals;
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$getColor = _ref2.getColor,
          getColor = _ref2$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref2$getColor;

      var groupedVertices = this.groupedVertices,
          wireframe = this.wireframe;

      return calculateColors({ groupedVertices: groupedVertices, wireframe: wireframe, getColor: getColor });
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      return this.attributes.pickingColors;
    }

    // updateTriggers: {
    //   positions: ['getHeight'],
    //   colors: ['getColors']
    //   pickingColors: 'none'
    // }

  }]);

  return PolygonTesselatorExtruded;
}();

function countVertices(vertices) {
  return vertices.reduce(function (count, polygon) {
    return count + polygon.length;
  }, 0);
}

function calculateIndices(_ref3) {
  var groupedVertices = _ref3.groupedVertices,
      _ref3$wireframe = _ref3.wireframe,
      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe;

  // adjust index offset for multiple buildings
  var multiplier = wireframe ? 2 : 5;
  var offsets = groupedVertices.reduce(function (acc, vertices) {
    return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + countVertices(vertices) * multiplier]);
  }, [0]);

  var indices = groupedVertices.map(function (vertices, buildingIndex) {
    return wireframe ?
    // 1. get sequentially ordered indices of each building wireframe
    // 2. offset them by the number of indices in previous buildings
    calculateContourIndices(vertices, offsets[buildingIndex]) :
    // 1. get triangulated indices for the internal areas
    // 2. offset them by the number of indices in previous buildings
    calculateSurfaceIndices(vertices, offsets[buildingIndex]);
  });

  return new Uint32Array((0, _lodash2.default)(indices));
}

// Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays
// Remarks:
// * each top vertex is on 3 surfaces
// * each bottom vertex is on 2 surfaces
function calculatePositionsJS(_ref4) {
  var groupedVertices = _ref4.groupedVertices,
      _ref4$wireframe = _ref4.wireframe,
      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;

  var positions = _utils.Container.map(groupedVertices, function (complexPolygon) {
    return _utils.Container.map(complexPolygon, function (vertices) {
      var topVertices = [].concat(vertices);
      var baseVertices = topVertices.map(function (v) {
        return [v[0], v[1], 0];
      });
      return wireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];
    });
  });
  return (0, _lodash2.default)(positions);
}

function calculatePositions(positionsJS, fp64) {
  var positionLow = void 0;
  if (fp64) {
    // We only need x, y component
    positionLow = new Float32Array(positionsJS / 3 * 2);
    for (var i = 0; i < positionsJS.length / 3; i++) {
      positionLow[i * 2 + 0] = (0, _fp.fp64ify)(positionsJS[i * 3 + 0])[1];
      positionLow[i * 2 + 1] = (0, _fp.fp64ify)(positionsJS[i * 3 + 1])[1];
    }
  }
  return { positions: new Float32Array(positionsJS), positions64xyLow: positionLow };
}

function calculateNormals(_ref5) {
  var groupedVertices = _ref5.groupedVertices,
      wireframe = _ref5.wireframe;

  var up = [0, 1, 0];

  var normals = groupedVertices.map(function (vertices, buildingIndex) {
    var topNormals = new Array(countVertices(vertices)).fill(up);
    var sideNormals = vertices.map(function (polygon) {
      return calculateSideNormals(polygon);
    });
    var sideNormalsForward = sideNormals.map(function (n) {
      return n[0];
    });
    var sideNormalsBackward = sideNormals.map(function (n) {
      return n[1];
    });

    return wireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];
  });

  return new Float32Array((0, _lodash2.default)(normals));
}

function calculateSideNormals(vertices) {
  var numVertices = vertices.length;
  var normals = [];

  for (var i = 0; i < numVertices - 1; i++) {
    var n = getNormal(vertices[i], vertices[i + 1]);
    normals.push(n);
  }

  return [[].concat(normals, [normals[0]]), [normals[0]].concat(normals)];
}

/*
function calculateColors({polygons, pointCount, getColor}) {
  const attribute = new Uint8Array(pointCount * 4);
  let i = 0;
  polygons.forEach((complexPolygon, polygonIndex) => {
    // Calculate polygon color
    const color = getColor(polygonIndex);
    color[3] = Number.isFinite(color[3]) ? color[3] : 255;

    const count = Polygon.getVertexCount(complexPolygon);
    fillArray({target: attribute, source: color, start: i, count});
    i += color.length * count;
  });
  return attribute;
}
*/

function calculateColors(_ref6) {
  var groupedVertices = _ref6.groupedVertices,
      getColor = _ref6.getColor,
      _ref6$wireframe = _ref6.wireframe,
      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;

  var colors = groupedVertices.map(function (complexPolygon, polygonIndex) {
    var color = getColor(polygonIndex);
    color[3] = Number.isFinite(color[3]) ? color[3] : 255;

    // const baseColor = Array.isArray(color) ? color[0] : color;
    // const topColor = Array.isArray(color) ? color[color.length - 1] : color;
    var numVertices = countVertices(complexPolygon);
    var topColors = new Array(numVertices).fill(color);
    var baseColors = new Array(numVertices).fill(color);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray((0, _lodash2.default)(colors));
}

function calculatePickingColors(_ref7) {
  var groupedVertices = _ref7.groupedVertices,
      _ref7$color = _ref7.color,
      color = _ref7$color === undefined ? [0, 0, 0] : _ref7$color,
      _ref7$wireframe = _ref7.wireframe,
      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;

  var colors = groupedVertices.map(function (vertices, buildingIndex) {
    // const baseColor = Array.isArray(color) ? color[0] : color;
    // const topColor = Array.isArray(color) ? color[color.length - 1] : color;
    var numVertices = countVertices(vertices);
    var topColors = new Array(numVertices).fill([0, 0, 0]);
    var baseColors = new Array(numVertices).fill([0, 0, 0]);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray((0, _lodash2.default)(colors));
}

function calculateContourIndices(vertices, offset) {
  var stride = countVertices(vertices);

  return vertices.map(function (polygon) {
    var indices = [offset];
    var numVertices = polygon.length;

    // building top
    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset);

    // building sides
    for (var _i = 0; _i < numVertices - 1; _i++) {
      indices.push(_i + offset, _i + stride + offset);
    }

    offset += numVertices;
    return indices;
  });
}

function calculateSurfaceIndices(vertices, offset) {
  var stride = countVertices(vertices);
  var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];

  function drawRectangle(i) {
    return quad.map(function (v) {
      return i + v[0] + stride * v[1] + offset;
    });
  }

  var holes = null;

  if (vertices.length > 1) {
    holes = vertices.reduce(function (acc, polygon) {
      return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);
    }, [0]).slice(1, vertices.length);
  }

  var topIndices = (0, _earcut2.default)((0, _lodash2.default)(vertices), holes, 3).map(function (index) {
    return index + offset;
  });

  var sideIndices = vertices.map(function (polygon) {
    var numVertices = polygon.length;
    // building top
    var indices = [];

    // building sides
    for (var i = 0; i < numVertices - 1; i++) {
      indices.push.apply(indices, _toConsumableArray(drawRectangle(i)));
    }

    offset += numVertices;
    return indices;
  });

  return [topIndices, sideIndices];
}

// helpers

// get normal vector of line segment
function getNormal(p1, p2) {
  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    return [1, 0, 0];
  }

  var degrees2radians = Math.PI / 180;
  var lon1 = degrees2radians * p1[0];
  var lon2 = degrees2radians * p2[0];
  var lat1 = degrees2radians * p1[1];
  var lat2 = degrees2radians * p2[1];
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return _glMatrix.vec3.normalize([], [b, 0, -a]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9sYXllcnMvY29yZS9wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwiREVGQVVMVF9DT0xPUiIsIlBvbHlnb25UZXNzZWxhdG9yRXh0cnVkZWQiLCJwb2x5Z29ucyIsImdldEhlaWdodCIsImdldENvbG9yIiwid2lyZWZyYW1lIiwiZnA2NCIsIm1hcCIsImNvbXBsZXhQb2x5Z29uIiwicG9seWdvbkluZGV4IiwiaGVpZ2h0Iiwibm9ybWFsaXplIiwicG9seWdvbiIsImNvb3JkIiwiZ3JvdXBlZFZlcnRpY2VzIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uc0pTIiwiY2FsY3VsYXRlUG9zaXRpb25zSlMiLCJPYmplY3QiLCJhc3NpZ24iLCJwb3NpdGlvbnMiLCJjYWxjdWxhdGVQb3NpdGlvbnMiLCJpbmRpY2VzIiwiY2FsY3VsYXRlSW5kaWNlcyIsIm5vcm1hbHMiLCJjYWxjdWxhdGVOb3JtYWxzIiwicGlja2luZ0NvbG9ycyIsImNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVDb2xvcnMiLCJjb3VudFZlcnRpY2VzIiwidmVydGljZXMiLCJyZWR1Y2UiLCJjb3VudCIsImxlbmd0aCIsIm11bHRpcGxpZXIiLCJvZmZzZXRzIiwiYWNjIiwiYnVpbGRpbmdJbmRleCIsImNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzIiwiY2FsY3VsYXRlU3VyZmFjZUluZGljZXMiLCJVaW50MzJBcnJheSIsInRvcFZlcnRpY2VzIiwiY29uY2F0IiwiYmFzZVZlcnRpY2VzIiwidiIsInBvc2l0aW9uTG93IiwiRmxvYXQzMkFycmF5IiwiaSIsInBvc2l0aW9uczY0eHlMb3ciLCJ1cCIsInRvcE5vcm1hbHMiLCJBcnJheSIsImZpbGwiLCJzaWRlTm9ybWFscyIsImNhbGN1bGF0ZVNpZGVOb3JtYWxzIiwic2lkZU5vcm1hbHNGb3J3YXJkIiwibiIsInNpZGVOb3JtYWxzQmFja3dhcmQiLCJudW1WZXJ0aWNlcyIsImdldE5vcm1hbCIsInB1c2giLCJjb2xvcnMiLCJjb2xvciIsIk51bWJlciIsImlzRmluaXRlIiwidG9wQ29sb3JzIiwiYmFzZUNvbG9ycyIsIlVpbnQ4Q2xhbXBlZEFycmF5Iiwib2Zmc2V0Iiwic3RyaWRlIiwicXVhZCIsImRyYXdSZWN0YW5nbGUiLCJob2xlcyIsInNsaWNlIiwidG9wSW5kaWNlcyIsImluZGV4Iiwic2lkZUluZGljZXMiLCJwMSIsInAyIiwiZGVncmVlczJyYWRpYW5zIiwiTWF0aCIsIlBJIiwibG9uMSIsImxvbjIiLCJsYXQxIiwibGF0MiIsImEiLCJzaW4iLCJjb3MiLCJiIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOzs7QUFEQTs7SUFBWUEsTzs7QUFFWjs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFDQTs7QUFFQSxJQUFNQyxnQkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxHQUFWLENBQXRCLEMsQ0FBc0M7O0lBRXpCQyx5QixXQUFBQSx5QjtBQUVYLDJDQU1HO0FBQUEsUUFMREMsUUFLQyxRQUxEQSxRQUtDO0FBQUEsOEJBSkRDLFNBSUM7QUFBQSxRQUpEQSxTQUlDLGtDQUpXO0FBQUEsYUFBSyxJQUFMO0FBQUEsS0FJWDtBQUFBLDZCQUhEQyxRQUdDO0FBQUEsUUFIREEsUUFHQyxpQ0FIVTtBQUFBLGFBQUssQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxHQUFWLENBQUw7QUFBQSxLQUdWO0FBQUEsOEJBRkRDLFNBRUM7QUFBQSxRQUZEQSxTQUVDLGtDQUZXLEtBRVg7QUFBQSx1QkFEREMsSUFDQztBQUFBLFFBRERBLElBQ0MsMkJBRE0sS0FDTjs7QUFBQTs7QUFDRCxTQUFLQSxJQUFMLEdBQVlBLElBQVo7O0FBRUE7QUFDQUosZUFBVyxpQkFBVUssR0FBVixDQUFjTCxRQUFkLEVBQXdCLFVBQUNNLGNBQUQsRUFBaUJDLFlBQWpCLEVBQWtDO0FBQ25FLFVBQU1DLFNB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InNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFBvbHlnb24gZnJvbSAnLi9wb2x5Z29uJztcbi8vIGltcG9ydCB7Z2V0UG9seWdvblZlcnRleENvdW50LCBnZXRQb2x5Z29uVHJpYW5nbGVDb3VudH0gZnJvbSAnLi9wb2x5Z29uJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcbmltcG9ydCBmbGF0dGVuRGVlcCBmcm9tICdsb2Rhc2guZmxhdHRlbmRlZXAnO1xuaW1wb3J0IHt2ZWMzfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IHtmcDY0aWZ5fSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMvZnA2NCc7XG5pbXBvcnQge0NvbnRhaW5lcn0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcbi8vIGltcG9ydCB7Q29udGFpbmVyLCBmbGF0dGVuVmVydGljZXMsIGZpbGxBcnJheX0gZnJvbSAnLi4vLi4vLi4vbGliL3V0aWxzJztcblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdOyAvLyBCbGFja1xuXG5leHBvcnQgY2xhc3MgUG9seWdvblRlc3NlbGF0b3JFeHRydWRlZCB7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHBvbHlnb25zLFxuICAgIGdldEhlaWdodCA9IHggPT4gMTAwMCxcbiAgICBnZXRDb2xvciA9IHggPT4gWzAsIDAsIDAsIDI1NV0sXG4gICAgd2lyZWZyYW1lID0gZmFsc2UsXG4gICAgZnA2NCA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLmZwNjQgPSBmcDY0O1xuXG4gICAgLy8gRXhwZW5zaXZlIG9wZXJhdGlvbiwgY29udmVydCBhbGwgcG9seWdvbnMgdG8gYXJyYXlzXG4gICAgcG9seWdvbnMgPSBDb250YWluZXIubWFwKHBvbHlnb25zLCAoY29tcGxleFBvbHlnb24sIHBvbHlnb25JbmRleCkgPT4ge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0SGVpZ2h0KHBvbHlnb25JbmRleCkgfHwgMDtcbiAgICAgIHJldHVybiBDb250YWluZXIubWFwKFBvbHlnb24ubm9ybWFsaXplKGNvbXBsZXhQb2x5Z29uKSxcbiAgICAgICAgcG9seWdvbiA9PiBDb250YWluZXIubWFwKHBvbHlnb24sIGNvb3JkID0+IFtjb29yZFswXSwgY29vcmRbMV0sIGhlaWdodF0pKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdyb3VwZWRWZXJ0aWNlcyA9IHBvbHlnb25zO1xuICAgIHRoaXMuZ3JvdXBlZFZlcnRpY2VzID0gcG9seWdvbnM7XG4gICAgdGhpcy53aXJlZnJhbWUgPSB3aXJlZnJhbWU7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGNvbnN0IHBvc2l0aW9uc0pTID0gY2FsY3VsYXRlUG9zaXRpb25zSlMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmF0dHJpYnV0ZXMsIHtcbiAgICAgIHBvc2l0aW9uczogY2FsY3VsYXRlUG9zaXRpb25zKHBvc2l0aW9uc0pTLCB0aGlzLmZwNjQpLFxuICAgICAgaW5kaWNlczogY2FsY3VsYXRlSW5kaWNlcyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KSxcbiAgICAgIG5vcm1hbHM6IGNhbGN1bGF0ZU5vcm1hbHMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSksXG4gICAgICAvLyBjb2xvcnM6IGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUsIGdldENvbG9yfSksXG4gICAgICBwaWNraW5nQ29sb3JzOiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0pXG4gICAgfSk7XG4gIH1cblxuICBpbmRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuaW5kaWNlcztcbiAgfVxuXG4gIHBvc2l0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9ucztcbiAgfVxuXG4gIG5vcm1hbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5ub3JtYWxzO1xuICB9XG5cbiAgY29sb3JzKHtnZXRDb2xvciA9IHggPT4gREVGQVVMVF9DT0xPUn0gPSB7fSkge1xuICAgIGNvbnN0IHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0gPSB0aGlzO1xuICAgIHJldHVybiBjYWxjdWxhdGVDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lLCBnZXRDb2xvcn0pO1xuICB9XG5cbiAgcGlja2luZ0NvbG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnBpY2tpbmdDb2xvcnM7XG4gIH1cblxuICAvLyB1cGRhdGVUcmlnZ2Vyczoge1xuICAvLyAgIHBvc2l0aW9uczogWydnZXRIZWlnaHQnXSxcbiAgLy8gICBjb2xvcnM6IFsnZ2V0Q29sb3JzJ11cbiAgLy8gICBwaWNraW5nQ29sb3JzOiAnbm9uZSdcbiAgLy8gfVxufVxuXG5mdW5jdGlvbiBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gIHJldHVybiB2ZXJ0aWNlcy5yZWR1Y2UoKGNvdW50LCBwb2x5Z29uKSA9PiBjb3VudCArIHBvbHlnb24ubGVuZ3RoLCAwKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSW5kaWNlcyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgYnVpbGRpbmdzXG4gIGNvbnN0IG11bHRpcGxpZXIgPSB3aXJlZnJhbWUgPyAyIDogNTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGdyb3VwZWRWZXJ0aWNlcy5yZWR1Y2UoXG4gICAgKGFjYywgdmVydGljZXMpID0+XG4gICAgICBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICsgY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykgKiBtdWx0aXBsaWVyXSxcbiAgICBbMF1cbiAgKTtcblxuICBjb25zdCBpbmRpY2VzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcCgodmVydGljZXMsIGJ1aWxkaW5nSW5kZXgpID0+XG4gICAgd2lyZWZyYW1lID9cbiAgICAgIC8vIDEuIGdldCBzZXF1ZW50aWFsbHkgb3JkZXJlZCBpbmRpY2VzIG9mIGVhY2ggYnVpbGRpbmcgd2lyZWZyYW1lXG4gICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgYnVpbGRpbmdzXG4gICAgICBjYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0c1tidWlsZGluZ0luZGV4XSkgOlxuICAgICAgLy8gMS4gZ2V0IHRyaWFuZ3VsYXRlZCBpbmRpY2VzIGZvciB0aGUgaW50ZXJuYWwgYXJlYXNcbiAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBidWlsZGluZ3NcbiAgICAgIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXRzW2J1aWxkaW5nSW5kZXhdKVxuICApO1xuXG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkoZmxhdHRlbkRlZXAoaW5kaWNlcykpO1xufVxuXG4vLyBDYWxjdWxhdGUgYSBmbGF0IHBvc2l0aW9uIGFycmF5IGluIEpTIC0gY2FuIGJlIG1hcHBlZCB0byAzMiBvciA2NCBiaXQgdHlwZWQgYXJyYXlzXG4vLyBSZW1hcmtzOlxuLy8gKiBlYWNoIHRvcCB2ZXJ0ZXggaXMgb24gMyBzdXJmYWNlc1xuLy8gKiBlYWNoIGJvdHRvbSB2ZXJ0ZXggaXMgb24gMiBzdXJmYWNlc1xuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zSlMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IENvbnRhaW5lci5tYXAoZ3JvdXBlZFZlcnRpY2VzLCBjb21wbGV4UG9seWdvbiA9PlxuICAgIENvbnRhaW5lci5tYXAoY29tcGxleFBvbHlnb24sIHZlcnRpY2VzID0+IHtcbiAgICAgIGNvbnN0IHRvcFZlcnRpY2VzID0gW10uY29uY2F0KHZlcnRpY2VzKTtcbiAgICAgIGNvbnN0IGJhc2VWZXJ0aWNlcyA9IHRvcFZlcnRpY2VzLm1hcCh2ID0+IFt2WzBdLCB2WzFdLCAwXSk7XG4gICAgICByZXR1cm4gd2lyZWZyYW1lID9cbiAgICAgICAgW3RvcFZlcnRpY2VzLCBiYXNlVmVydGljZXNdIDpcbiAgICAgICAgW3RvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgdG9wVmVydGljZXMsIGJhc2VWZXJ0aWNlcywgYmFzZVZlcnRpY2VzXTtcbiAgICB9KVxuICApO1xuICByZXR1cm4gZmxhdHRlbkRlZXAocG9zaXRpb25zKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zKHBvc2l0aW9uc0pTLCBmcDY0KSB7XG4gIGxldCBwb3NpdGlvbkxvdztcbiAgaWYgKGZwNjQpIHtcbiAgICAvLyBXZSBvbmx5IG5lZWQgeCwgeSBjb21wb25lbnRcbiAgICBwb3NpdGlvbkxvdyA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zSlMgLyAzICogMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnNKUy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgIHBvc2l0aW9uTG93W2kgKiAyICsgMF0gPSBmcDY0aWZ5KHBvc2l0aW9uc0pTW2kgKiAzICsgMF0pWzFdO1xuICAgICAgcG9zaXRpb25Mb3dbaSAqIDIgKyAxXSA9IGZwNjRpZnkocG9zaXRpb25zSlNbaSAqIDMgKyAxXSlbMV07XG4gICAgfVxuXG4gIH1cbiAgcmV0dXJuIHtwb3NpdGlvbnM6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zSlMpLCBwb3NpdGlvbnM2NHh5TG93OiBwb3NpdGlvbkxvd307XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vcm1hbHMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSkge1xuICBjb25zdCB1cCA9IFswLCAxLCAwXTtcblxuICBjb25zdCBub3JtYWxzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcCgodmVydGljZXMsIGJ1aWxkaW5nSW5kZXgpID0+IHtcbiAgICBjb25zdCB0b3BOb3JtYWxzID0gbmV3IEFycmF5KGNvdW50VmVydGljZXModmVydGljZXMpKS5maWxsKHVwKTtcbiAgICBjb25zdCBzaWRlTm9ybWFscyA9IHZlcnRpY2VzLm1hcChwb2x5Z29uID0+IGNhbGN1bGF0ZVNpZGVOb3JtYWxzKHBvbHlnb24pKTtcbiAgICBjb25zdCBzaWRlTm9ybWFsc0ZvcndhcmQgPSBzaWRlTm9ybWFscy5tYXAobiA9PiBuWzBdKTtcbiAgICBjb25zdCBzaWRlTm9ybWFsc0JhY2t3YXJkID0gc2lkZU5vcm1hbHMubWFwKG4gPT4gblsxXSk7XG5cbiAgICByZXR1cm4gd2lyZWZyYW1lID9cbiAgICBbdG9wTm9ybWFscywgdG9wTm9ybWFsc10gOlxuICAgIFt0b3BOb3JtYWxzLCBzaWRlTm9ybWFsc0ZvcndhcmQsIHNpZGVOb3JtYWxzQmFja3dhcmQsIHNpZGVOb3JtYWxzRm9yd2FyZCwgc2lkZU5vcm1hbHNCYWNrd2FyZF07XG4gIH0pO1xuXG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGZsYXR0ZW5EZWVwKG5vcm1hbHMpKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU2lkZU5vcm1hbHModmVydGljZXMpIHtcbiAgY29uc3QgbnVtVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gIGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgbiA9IGdldE5vcm1hbCh2ZXJ0aWNlc1tpXSwgdmVydGljZXNbaSArIDFdKTtcbiAgICBub3JtYWxzLnB1c2gobik7XG4gIH1cblxuICByZXR1cm4gW1suLi5ub3JtYWxzLCBub3JtYWxzWzBdXSwgW25vcm1hbHNbMF0sIC4uLm5vcm1hbHNdXTtcbn1cblxuLypcbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9ycyh7cG9seWdvbnMsIHBvaW50Q291bnQsIGdldENvbG9yfSkge1xuICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgVWludDhBcnJheShwb2ludENvdW50ICogNCk7XG4gIGxldCBpID0gMDtcbiAgcG9seWdvbnMuZm9yRWFjaCgoY29tcGxleFBvbHlnb24sIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIC8vIENhbGN1bGF0ZSBwb2x5Z29uIGNvbG9yXG4gICAgY29uc3QgY29sb3IgPSBnZXRDb2xvcihwb2x5Z29uSW5kZXgpO1xuICAgIGNvbG9yWzNdID0gTnVtYmVyLmlzRmluaXRlKGNvbG9yWzNdKSA/IGNvbG9yWzNdIDogMjU1O1xuXG4gICAgY29uc3QgY291bnQgPSBQb2x5Z29uLmdldFZlcnRleENvdW50KGNvbXBsZXhQb2x5Z29uKTtcbiAgICBmaWxsQXJyYXkoe3RhcmdldDogYXR0cmlidXRlLCBzb3VyY2U6IGNvbG9yLCBzdGFydDogaSwgY291bnR9KTtcbiAgICBpICs9IGNvbG9yLmxlbmd0aCAqIGNvdW50O1xuICB9KTtcbiAgcmV0dXJuIGF0dHJpYnV0ZTtcbn1cbiovXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCBnZXRDb2xvciwgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIGNvbnN0IGNvbG9ycyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoKGNvbXBsZXhQb2x5Z29uLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICBjb25zdCBjb2xvciA9IGdldENvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgY29sb3JbM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTU7XG5cbiAgICAvLyBjb25zdCBiYXNlQ29sb3IgPSBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yWzBdIDogY29sb3I7XG4gICAgLy8gY29uc3QgdG9wQ29sb3IgPSBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yW2NvbG9yLmxlbmd0aCAtIDFdIDogY29sb3I7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBjb3VudFZlcnRpY2VzKGNvbXBsZXhQb2x5Z29uKTtcbiAgICBjb25zdCB0b3BDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIGNvbnN0IGJhc2VDb2xvcnMgPSBuZXcgQXJyYXkobnVtVmVydGljZXMpLmZpbGwoY29sb3IpO1xuICAgIHJldHVybiB3aXJlZnJhbWUgP1xuICAgICAgW3RvcENvbG9ycywgYmFzZUNvbG9yc10gOlxuICAgICAgW3RvcENvbG9ycywgdG9wQ29sb3JzLCB0b3BDb2xvcnMsIGJhc2VDb2xvcnMsIGJhc2VDb2xvcnNdO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShmbGF0dGVuRGVlcChjb2xvcnMpKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGlja2luZ0NvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCBjb2xvciA9IFswLCAwLCAwXSwgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIGNvbnN0IGNvbG9ycyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoKHZlcnRpY2VzLCBidWlsZGluZ0luZGV4KSA9PiB7XG4gICAgLy8gY29uc3QgYmFzZUNvbG9yID0gQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvclswXSA6IGNvbG9yO1xuICAgIC8vIGNvbnN0IHRvcENvbG9yID0gQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvcltjb2xvci5sZW5ndGggLSAxXSA6IGNvbG9yO1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG4gICAgY29uc3QgdG9wQ29sb3JzID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKS5maWxsKFswLCAwLCAwXSk7XG4gICAgY29uc3QgYmFzZUNvbG9ycyA9IG5ldyBBcnJheShudW1WZXJ0aWNlcykuZmlsbChbMCwgMCwgMF0pO1xuICAgIHJldHVybiB3aXJlZnJhbWUgP1xuICAgICAgW3RvcENvbG9ycywgYmFzZUNvbG9yc10gOlxuICAgICAgW3RvcENvbG9ycywgdG9wQ29sb3JzLCB0b3BDb2xvcnMsIGJhc2VDb2xvcnMsIGJhc2VDb2xvcnNdO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShmbGF0dGVuRGVlcChjb2xvcnMpKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udG91ckluZGljZXModmVydGljZXMsIG9mZnNldCkge1xuICBjb25zdCBzdHJpZGUgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcblxuICByZXR1cm4gdmVydGljZXMubWFwKHBvbHlnb24gPT4ge1xuICAgIGNvbnN0IGluZGljZXMgPSBbb2Zmc2V0XTtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuXG4gICAgLy8gYnVpbGRpbmcgdG9wXG4gICAgLy8gdXNlIHZlcnRleCBwYWlycyBmb3IgR0wuTElORVMgPT4gWzAsIDEsIDEsIDIsIDIsIC4uLiwgbi0xLCBuLTEsIDBdXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2gob2Zmc2V0KTtcblxuICAgIC8vIGJ1aWxkaW5nIHNpZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBzdHJpZGUgKyBvZmZzZXQpO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBudW1WZXJ0aWNlcztcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXQpIHtcbiAgY29uc3Qgc3RyaWRlID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG4gIGNvbnN0IHF1YWQgPSBbXG4gICAgWzAsIDFdLCBbMCwgM10sIFsxLCAyXSxcbiAgICBbMSwgMl0sIFswLCAzXSwgWzEsIDRdXG4gIF07XG5cbiAgZnVuY3Rpb24gZHJhd1JlY3RhbmdsZShpKSB7XG4gICAgcmV0dXJuIHF1YWQubWFwKHYgPT4gaSArIHZbMF0gKyBzdHJpZGUgKiB2WzFdICsgb2Zmc2V0KTtcbiAgfVxuXG4gIGxldCBob2xlcyA9IG51bGw7XG5cbiAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICBob2xlcyA9IHZlcnRpY2VzLnJlZHVjZShcbiAgICAgIChhY2MsIHBvbHlnb24pID0+IFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyBwb2x5Z29uLmxlbmd0aF0sXG4gICAgICBbMF1cbiAgICApLnNsaWNlKDEsIHZlcnRpY2VzLmxlbmd0aCk7XG4gIH1cblxuICBjb25zdCB0b3BJbmRpY2VzID0gZWFyY3V0KGZsYXR0ZW5EZWVwKHZlcnRpY2VzKSwgaG9sZXMsIDMpLm1hcChpbmRleCA9PiBpbmRleCArIG9mZnNldCk7XG5cbiAgY29uc3Qgc2lkZUluZGljZXMgPSB2ZXJ0aWNlcy5tYXAocG9seWdvbiA9PiB7XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcbiAgICAvLyBidWlsZGluZyB0b3BcbiAgICBjb25zdCBpbmRpY2VzID0gW107XG5cbiAgICAvLyBidWlsZGluZyBzaWRlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgIGluZGljZXMucHVzaCguLi5kcmF3UmVjdGFuZ2xlKGkpKTtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gbnVtVmVydGljZXM7XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH0pO1xuXG4gIHJldHVybiBbdG9wSW5kaWNlcywgc2lkZUluZGljZXNdO1xufVxuXG4vLyBoZWxwZXJzXG5cbi8vIGdldCBub3JtYWwgdmVjdG9yIG9mIGxpbmUgc2VnbWVudFxuZnVuY3Rpb24gZ2V0Tm9ybWFsKHAxLCBwMikge1xuICBpZiAocDFbMF0gPT09IHAyWzBdICYmIHAxWzFdID09PSBwMlsxXSkge1xuICAgIHJldHVybiBbMSwgMCwgMF07XG4gIH1cblxuICBjb25zdCBkZWdyZWVzMnJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwO1xuICBjb25zdCBsb24xID0gZGVncmVlczJyYWRpYW5zICogcDFbMF07XG4gIGNvbnN0IGxvbjIgPSBkZWdyZWVzMnJhZGlhbnMgKiBwMlswXTtcbiAgY29uc3QgbGF0MSA9IGRlZ3JlZXMycmFkaWFucyAqIHAxWzFdO1xuICBjb25zdCBsYXQyID0gZGVncmVlczJyYWRpYW5zICogcDJbMV07XG4gIGNvbnN0IGEgPSBNYXRoLnNpbihsb24yIC0gbG9uMSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgY29uc3QgYiA9IE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obGF0MikgLVxuICAgIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcyhsb24yIC0gbG9uMSk7XG4gIHJldHVybiB2ZWMzLm5vcm1hbGl6ZShbXSwgW2IsIDAsIC1hXSk7XG59XG4iXX0=