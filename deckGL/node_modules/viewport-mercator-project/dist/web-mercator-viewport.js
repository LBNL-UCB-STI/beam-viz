'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.COORDINATE_SYSTEM = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _desc, _value, _class; // View and Projection Matrix calculations for mapbox-js style
// map view properties


var _viewport = require('./viewport');

var _viewport2 = _interopRequireDefault(_viewport);

var _glMatrix = require('gl-matrix');

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var WORLD_SCALE = TILE_SIZE / (2 * PI);

var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

// EXPORTS
var COORDINATE_SYSTEM = exports.COORDINATE_SYSTEM = {
  // Positions are interpreted as [lng,lat,elevation], distances as meters
  LNGLAT: 1.0,
  // Positions are interpreted as meter offsets, distances as meters
  METERS: 2.0,
  // Positions and distances are not transformed
  IDENTITY: 0.0
};

var WebMercatorViewport = (_class = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        mercatorEnabled = _ref.mercatorEnabled;

    _classCallCheck(this, WebMercatorViewport);

    // Viewport - support undefined arguments
    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0
    width = width || 1;
    height = height || 1;

    // Altitude - prevent division by 0
    // TODO - should we just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var viewMatrix = makeViewMatrixFromMercatorParams({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude
    });

    var projectionMatrix = makeProjectionMatrixFromMercatorParams({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude
    });

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrix, projectionMatrix: projectionMatrix }));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    _this.scale = Math.pow(2, zoom);

    _this._calculateDistanceScales();

    // Object.seal(this);
    // Object.freeze(this);
    return _this;
  }
  /* eslint-enable complexity */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          lng = _ref3[0],
          lat = _ref3[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      scale = scale * WORLD_SCALE;
      var lambda2 = lng * DEGREES_TO_RADIANS;
      var phi2 = lat * DEGREES_TO_RADIANS;
      var x = scale * (lambda2 + PI);
      var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5)));
      return [x, y];
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          x = _ref5[0],
          y = _ref5[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      scale = scale * WORLD_SCALE;
      var lambda2 = x / scale - PI;
      var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale)) - PI_4);
      return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
    }
  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return {
        pixelsPerMeter: this.pixelsPerMeter,
        metersPerPixel: this.metersPerPixel
      };
    }

    // INTERNAL METHODS

  }, {
    key: '_getParams',
    value: function _getParams() {
      return this.getDistanceScales();
    }

    /**
     * Calculate distance scales in meters around current lat/lon, both for
     * degrees and pixels.
     * In mercator projection mode, the distance scales vary significantly
     * with latitude.
     */

  }, {
    key: '_calculateDistanceScales',
    value: function _calculateDistanceScales() {
      // Approximately 111km per degree at equator
      var METERS_PER_DEGREE = 111000;
      var latitude = this.latitude,
          longitude = this.longitude;


      var latCosine = Math.cos(latitude * Math.PI / 180);

      var metersPerDegree = METERS_PER_DEGREE * latCosine;

      // Calculate number of pixels occupied by one degree longitude
      // around current lat/lon
      var pixelsPerDegreeX = _glMatrix.vec2.distance(this.projectFlat([longitude + 0.5, latitude]), this.projectFlat([longitude - 0.5, latitude]));
      // Calculate number of pixels occupied by one degree latitude
      // around current lat/lon
      var pixelsPerDegreeY = _glMatrix.vec2.distance(this.projectFlat([longitude, latitude + 0.5]), this.projectFlat([longitude, latitude - 0.5]));

      var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;
      var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;
      var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2;

      // const scale = 0.95;
      // const pixelsPerMeter = [
      //   pixelsPerMeterX * scale, pixelsPerMeterY * scale, pixelsPerMeterZ * scale
      // ];
      var worldSize = TILE_SIZE * this.scale;
      var altPixelsPerMeter = worldSize / (4e7 * latCosine);
      var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
      var metersPerPixel = [1 / pixelsPerMeterX, 1 / pixelsPerMeterY, 1 / pixelsPerMeterZ];

      // Main results, used for scaling offsets
      this.pixelsPerMeter = pixelsPerMeter;
      // Additional results
      this.metersPerPixel = metersPerPixel;
      // metersPerDegree,
      // degreesPerMeter: 1 / metersPerDegree
    }
  }]);

  return WebMercatorViewport;
}(_viewport2.default), (_applyDecoratedDescriptor(_class.prototype, 'getDistanceScales', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'getDistanceScales'), _class.prototype)), _class);
exports.default = WebMercatorViewport;


function projectFlat(_ref6, scale) {
  var _ref7 = _slicedToArray(_ref6, 2),
      lng = _ref7[0],
      lat = _ref7[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5)));
  return [x, y];
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js
function makeProjectionMatrixFromMercatorParams(_ref8) {
  var width = _ref8.width,
      height = _ref8.height,
      pitch = _ref8.pitch,
      altitude = _ref8.altitude;

  var pitchRadians = pitch * DEGREES_TO_RADIANS;

  // PROJECTION MATRIX: PROJECTS FROM CAMERA SPACE TO CLIPSPACE
  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  var projectionMatrix = _glMatrix.mat4.perspective((0, _viewport.createMat4)(), 2 * Math.atan(height / 2 / altitude), // fov in radians
  width / height, // aspect ratio
  0.1, // near plane
  farZ * 10.0 // far plane
  );

  return projectionMatrix;
}

function makeViewMatrixFromMercatorParams(_ref9) {
  var width = _ref9.width,
      height = _ref9.height,
      longitude = _ref9.longitude,
      latitude = _ref9.latitude,
      zoom = _ref9.zoom,
      pitch = _ref9.pitch,
      bearing = _ref9.bearing,
      altitude = _ref9.altitude;

  // Center x, y
  var scale = Math.pow(2, zoom);

  var _projectFlat2 = projectFlat([longitude, latitude], scale),
      _projectFlat3 = _slicedToArray(_projectFlat2, 2),
      centerX = _projectFlat3[0],
      centerY = _projectFlat3[1];

  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation


  var vm = (0, _viewport.createMat4)();

  // Move camera to altitude
  _glMatrix.mat4.translate(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  _glMatrix.mat4.scale(vm, vm, [1, -1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  _glMatrix.mat4.rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);
  _glMatrix.mat4.rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS);

  _glMatrix.mat4.translate(vm, vm, [-centerX, -centerY, 0]);

  return vm;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93ZWItbWVyY2F0b3Itdmlld3BvcnQuanMiXSwibmFtZXMiOlsiUEkiLCJNYXRoIiwiUElfNCIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIlJBRElBTlNfVE9fREVHUkVFUyIsIlRJTEVfU0laRSIsIldPUkxEX1NDQUxFIiwiREVGQVVMVF9NQVBfU1RBVEUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJwaXRjaCIsImJlYXJpbmciLCJhbHRpdHVkZSIsIkNPT1JESU5BVEVfU1lTVEVNIiwiTE5HTEFUIiwiTUVURVJTIiwiSURFTlRJVFkiLCJXZWJNZXJjYXRvclZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJtZXJjYXRvckVuYWJsZWQiLCJ1bmRlZmluZWQiLCJtYXgiLCJ2aWV3TWF0cml4IiwibWFrZVZpZXdNYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMiLCJwcm9qZWN0aW9uTWF0cml4IiwibWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMiLCJzY2FsZSIsInBvdyIsIl9jYWxjdWxhdGVEaXN0YW5jZVNjYWxlcyIsImxuZyIsImxhdCIsImxhbWJkYTIiLCJwaGkyIiwieCIsInkiLCJsb2ciLCJ0YW4iLCJhdGFuIiwiZXhwIiwicGl4ZWxzUGVyTWV0ZXIiLCJtZXRlcnNQZXJQaXhlbCIsImdldERpc3RhbmNlU2NhbGVzIiwiTUVURVJTX1BFUl9ERUdSRUUiLCJsYXRDb3NpbmUiLCJjb3MiLCJtZXRlcnNQZXJEZWdyZWUiLCJwaXhlbHNQZXJEZWdyZWVYIiwiZGlzdGFuY2UiLCJwcm9qZWN0RmxhdCIsInBpeGVsc1BlckRlZ3JlZVkiLCJwaXhlbHNQZXJNZXRlclgiLCJwaXhlbHNQZXJNZXRlclkiLCJwaXhlbHNQZXJNZXRlcloiLCJ3b3JsZFNpemUiLCJhbHRQaXhlbHNQZXJNZXRlciIsInBpdGNoUmFkaWFucyIsImhhbGZGb3YiLCJ0b3BIYWxmU3VyZmFjZURpc3RhbmNlIiwic2luIiwiZmFyWiIsInBlcnNwZWN0aXZlIiwiY2VudGVyWCIsImNlbnRlclkiLCJ2bSIsInRyYW5zbGF0ZSIsInJvdGF0ZVgiLCJyb3RhdGVaIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OzsyQkFBQTtBQUNBOzs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBO0FBQ0EsSUFBTUEsS0FBS0MsS0FBS0QsRUFBaEI7QUFDQSxJQUFNRSxPQUFPRixLQUFLLENBQWxCO0FBQ0EsSUFBTUcscUJBQXFCSCxLQUFLLEdBQWhDO0FBQ0EsSUFBTUkscUJBQXFCLE1BQU1KLEVBQWpDO0FBQ0EsSUFBTUssWUFBWSxHQUFsQjtBQUNBLElBQU1DLGNBQWNELGFBQWEsSUFBSUwsRUFBakIsQ0FBcEI7O0FBRUEsSUFBTU8sb0JBQW9CO0FBQ3hCQyxZQUFVLEVBRGM7QUFFeEJDLGFBQVcsQ0FBQyxHQUZZO0FBR3hCQyxRQUFNLEVBSGtCO0FBSXhCQyxTQUFPLENBSmlCO0FBS3hCQyxXQUFTLENBTGU7QUFNeEJDLFlBQVU7QUFOYyxDQUExQjs7QUFTQTtBQUNPLElBQU1DLGdEQUFvQjtBQUMvQjtBQUNBQyxVQUFRLEdBRnVCO0FBRy9CO0FBQ0FDLFVBQVEsR0FKdUI7QUFLL0I7QUFDQUMsWUFBVTtBQU5xQixDQUExQjs7SUFTY0MsbUI7OztBQUNuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDQTtBQUNBLGlDQVdRO0FBQUEsbUZBQUosRUFBSTtBQUFBLFFBVE5DLEtBU00sUUFUTkEsS0FTTTtBQUFBLFFBUk5DLE1BUU0sUUFSTkEsTUFRTTtBQUFBLFFBUE5aLFFBT00sUUFQTkEsUUFPTTtBQUFBLFFBTk5DLFNBTU0sUUFOTkEsU0FNTTtBQUFBLFFBTE5DLElBS00sUUFMTkEsSUFLTTtBQUFBLFFBSk5DLEtBSU0sUUFKTkEsS0FJTTtBQUFBLFFBSE5DLE9BR00sUUFITkEsT0FHTTtBQUFBLFFBRk5DLFFBRU0sUUFGTkEsUUFFTTtBQUFBLFFBRE5RLGVBQ00sUUFETkEsZUFDTTs7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WixDQUFaLEVBQW1Db0IsS0FBbkMsQ0FIMUI7QUFBQTtBQUFBLE1BR01tQyxPQUhOO0FBQUEsTUFHZUMsT0FIZjs7QUFLRDtBQUNBO0FBQ0E7OztBQUNBLE1BQU1DLEtBQUssMkJBQVg7O0FBRUE7QUFDQSxpQkFBS0MsU0FBTCxDQUFlRCxFQUFmLEVBQW1CQSxFQUFuQixFQUF1QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQ3BELFFBQVIsQ0FBdkI7O0FBRUE7QUFDQTtBQUNBLGlCQUFLZSxLQUFMLENBQVdxQyxFQUFYLEVBQWVBLEVBQWYsRUFBbUIsQ0FBQyxDQUFELEVBQUksQ0FBQyxDQUFMLEVBQVEsSUFBSTdDLE1BQVosQ0FBbkI7O0FBRUE7QUFDQSxpQkFBSytDLE9BQUwsQ0FBYUYsRUFBYixFQUFpQkEsRUFBakIsRUFBcUJ0RCxRQUFRUixrQkFBN0I7QUFDQSxpQkFBS2lFLE9BQUwsQ0FBYUgsRUFBYixFQUFpQkEsRUFBakIsRUFBcUIsQ0FBQ3JELE9BQUQsR0FBV1Qsa0JBQWhDOztBQUVBLGlCQUFLK0QsU0FBTCxDQUFlRCxFQUFmLEVBQW1CQSxFQUFuQixFQUF1QixDQUFDLENBQUNGLE9BQUYsRUFBVyxDQUFDQyxPQUFaLEVBQXFCLENBQXJCLENBQXZCOztBQUVBLFNBQU9DLEVBQVA7QUFDRCIsImZpbGUiOiJ3ZWItbWVyY2F0b3Itdmlld3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBjYWxjdWxhdGlvbnMgZm9yIG1hcGJveC1qcyBzdHlsZVxuLy8gbWFwIHZpZXcgcHJvcGVydGllc1xuaW1wb3J0IFZpZXdwb3J0LCB7Y3JlYXRlTWF0NH0gZnJvbSAnLi92aWV3cG9ydCc7XG5pbXBvcnQge21hdDQsIHZlYzJ9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnYXV0b2JpbmQtZGVjb3JhdG9yJztcblxuLy8gQ09OU1RBTlRTXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBQSV80ID0gUEkgLyA0O1xuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gUEkgLyAxODA7XG5jb25zdCBSQURJQU5TX1RPX0RFR1JFRVMgPSAxODAgLyBQSTtcbmNvbnN0IFRJTEVfU0laRSA9IDUxMjtcbmNvbnN0IFdPUkxEX1NDQUxFID0gVElMRV9TSVpFIC8gKDIgKiBQSSk7XG5cbmNvbnN0IERFRkFVTFRfTUFQX1NUQVRFID0ge1xuICBsYXRpdHVkZTogMzcsXG4gIGxvbmdpdHVkZTogLTEyMixcbiAgem9vbTogMTEsXG4gIHBpdGNoOiAwLFxuICBiZWFyaW5nOiAwLFxuICBhbHRpdHVkZTogMS41XG59O1xuXG4vLyBFWFBPUlRTXG5leHBvcnQgY29uc3QgQ09PUkRJTkFURV9TWVNURU0gPSB7XG4gIC8vIFBvc2l0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgYXMgW2xuZyxsYXQsZWxldmF0aW9uXSwgZGlzdGFuY2VzIGFzIG1ldGVyc1xuICBMTkdMQVQ6IDEuMCxcbiAgLy8gUG9zaXRpb25zIGFyZSBpbnRlcnByZXRlZCBhcyBtZXRlciBvZmZzZXRzLCBkaXN0YW5jZXMgYXMgbWV0ZXJzXG4gIE1FVEVSUzogMi4wLFxuICAvLyBQb3NpdGlvbnMgYW5kIGRpc3RhbmNlcyBhcmUgbm90IHRyYW5zZm9ybWVkXG4gIElERU5USVRZOiAwLjBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYk1lcmNhdG9yVmlld3BvcnQgZXh0ZW5kcyBWaWV3cG9ydCB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIENyZWF0ZXMgdmlldy9wcm9qZWN0aW9uIG1hdHJpY2VzIGZyb20gbWVyY2F0b3IgcGFyYW1zXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0IC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1lcmNhdG9yPXRydWUgLSBXaGV0aGVyIHRvIHVzZSBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQud2lkdGg9MSAtIFdpZHRoIG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5oZWlnaHQ9MSAtIEhlaWdodCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wdC5jZW50ZXI9WzAsIDBdIC0gQ2VudGVyIG9mIHZpZXdwb3J0XG4gICAqICAgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIG9yIFt4LCB5XVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnNjYWxlPTEgLSBFaXRoZXIgdXNlIHNjYWxlIG9yIHpvb21cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5waXRjaD0wIC0gQ2FtZXJhIGFuZ2xlIGluIGRlZ3JlZXMgKDAgaXMgc3RyYWlnaHQgZG93bilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5iZWFyaW5nPTAgLSBNYXAgcm90YXRpb24gaW4gZGVncmVlcyAoMCBtZWFucyBub3J0aCBpcyB1cClcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5hbHRpdHVkZT0gLSBBbHRpdHVkZSBvZiBjYW1lcmEgaW4gc2NyZWVuIHVuaXRzXG4gICAqXG4gICAqIFdlYiBtZXJjYXRvciBwcm9qZWN0aW9uIHNob3J0LWhhbmQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxhdGl0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sb25naXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0Lnpvb20gLSBTY2FsZSA9IE1hdGgucG93KDIsem9vbSkgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuc2NhbGUpXG5cbiAgICogTm90ZXM6XG4gICAqICAtIE9ubHkgb25lIG9mIGNlbnRlciBvciBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIGJlIHNwZWNpZmllZFxuICAgKiAgLSBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY2FuIG9ubHkgYmUgc3BlY2lmaWVkIHdoZW4gXCJtZXJjYXRvclwiIGlzIHRydWVcbiAgICogIC0gQWx0aXR1ZGUgaGFzIGEgZGVmYXVsdCB2YWx1ZSB0aGF0IG1hdGNoZXMgYXNzdW1wdGlvbnMgaW4gbWFwYm94LWdsXG4gICAqICAtIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGZvcmNlZCB0byAxIGlmIHN1cHBsaWVkIGFzIDAsIHRvIGF2b2lkXG4gICAqICAgIGRpdmlzaW9uIGJ5IHplcm8uIFRoaXMgaXMgaW50ZW5kZWQgdG8gcmVkdWNlIHRoZSBidXJkZW4gb2YgYXBwcyB0b1xuICAgKiAgICB0byBjaGVjayB2YWx1ZXMgYmVmb3JlIGluc3RhbnRpYXRpbmcgYSBWaWV3cG9ydC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIE1hcCBzdGF0ZVxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsYXRpdHVkZSxcbiAgICBsb25naXR1ZGUsXG4gICAgem9vbSxcbiAgICBwaXRjaCxcbiAgICBiZWFyaW5nLFxuICAgIGFsdGl0dWRlLFxuICAgIG1lcmNhdG9yRW5hYmxlZFxuICB9ID0ge30pIHtcbiAgICAvLyBWaWV3cG9ydCAtIHN1cHBvcnQgdW5kZWZpbmVkIGFyZ3VtZW50c1xuICAgIHdpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogREVGQVVMVF9NQVBfU1RBVEUud2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiBERUZBVUxUX01BUF9TVEFURS5oZWlnaHQ7XG4gICAgem9vbSA9IHpvb20gIT09IHVuZGVmaW5lZCA/IHpvb20gOiBERUZBVUxUX01BUF9TVEFURS56b29tO1xuICAgIGxhdGl0dWRlID0gbGF0aXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxhdGl0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUubGF0aXR1ZGU7XG4gICAgbG9uZ2l0dWRlID0gbG9uZ2l0dWRlICE9PSB1bmRlZmluZWQgPyBsb25naXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sb25naXR1ZGU7XG4gICAgYmVhcmluZyA9IGJlYXJpbmcgIT09IHVuZGVmaW5lZCA/IGJlYXJpbmcgOiBERUZBVUxUX01BUF9TVEFURS5iZWFyaW5nO1xuICAgIHBpdGNoID0gcGl0Y2ggIT09IHVuZGVmaW5lZCA/IHBpdGNoIDogREVGQVVMVF9NQVBfU1RBVEUucGl0Y2g7XG4gICAgYWx0aXR1ZGUgPSBhbHRpdHVkZSAhPT0gdW5kZWZpbmVkID8gYWx0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5hbHRpdHVkZTtcblxuICAgIC8vIFNpbGVudGx5IGFsbG93IGFwcHMgdG8gc2VuZCBpbiAwLDBcbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICAvLyBBbHRpdHVkZSAtIHByZXZlbnQgZGl2aXNpb24gYnkgMFxuICAgIC8vIFRPRE8gLSBzaG91bGQgd2UganVzdCB0aHJvdyBhbiBFcnJvciBpbnN0ZWFkP1xuICAgIGFsdGl0dWRlID0gTWF0aC5tYXgoMC43NSwgYWx0aXR1ZGUpO1xuXG4gICAgY29uc3Qgdmlld01hdHJpeCA9IG1ha2VWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tLFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGVcbiAgICB9KTtcblxuICAgIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZyxcbiAgICAgIGFsdGl0dWRlXG4gICAgfSk7XG5cbiAgICBzdXBlcih7d2lkdGgsIGhlaWdodCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeH0pO1xuXG4gICAgLy8gU2F2ZSBwYXJhbWV0ZXJzXG4gICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgdGhpcy5waXRjaCA9IHBpdGNoO1xuICAgIHRoaXMuYmVhcmluZyA9IGJlYXJpbmc7XG4gICAgdGhpcy5hbHRpdHVkZSA9IGFsdGl0dWRlO1xuXG4gICAgdGhpcy5zY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuXG4gICAgdGhpcy5fY2FsY3VsYXRlRGlzdGFuY2VTY2FsZXMoKTtcblxuICAgIC8vIE9iamVjdC5zZWFsKHRoaXMpO1xuICAgIC8vIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgX3Byb2plY3RGbGF0KFtsbmcsIGxhdF0sIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgKiBXT1JMRF9TQ0FMRTtcbiAgICBjb25zdCBsYW1iZGEyID0gbG5nICogREVHUkVFU19UT19SQURJQU5TO1xuICAgIGNvbnN0IHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gICAgY29uc3QgeCA9IHNjYWxlICogKGxhbWJkYTIgKyBQSSk7XG4gICAgY29uc3QgeSA9IHNjYWxlICogKFBJIC0gTWF0aC5sb2coTWF0aC50YW4oUElfNCArIHBoaTIgKiAwLjUpKSk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gICAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICAgKi9cbiAgX3VucHJvamVjdEZsYXQoW3gsIHldLCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlICogV09STERfU0NBTEU7XG4gICAgY29uc3QgbGFtYmRhMiA9IHggLyBzY2FsZSAtIFBJO1xuICAgIGNvbnN0IHBoaTIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChQSSAtIHkgLyBzY2FsZSkpIC0gUElfNCk7XG4gICAgcmV0dXJuIFtsYW1iZGEyICogUkFESUFOU19UT19ERUdSRUVTLCBwaGkyICogUkFESUFOU19UT19ERUdSRUVTXTtcbiAgfVxuXG4gIEBhdXRvYmluZFxuICBnZXREaXN0YW5jZVNjYWxlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGl4ZWxzUGVyTWV0ZXI6IHRoaXMucGl4ZWxzUGVyTWV0ZXIsXG4gICAgICBtZXRlcnNQZXJQaXhlbDogdGhpcy5tZXRlcnNQZXJQaXhlbFxuICAgIH07XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgX2dldFBhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaXN0YW5jZVNjYWxlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaW4gbWV0ZXJzIGFyb3VuZCBjdXJyZW50IGxhdC9sb24sIGJvdGggZm9yXG4gICAqIGRlZ3JlZXMgYW5kIHBpeGVscy5cbiAgICogSW4gbWVyY2F0b3IgcHJvamVjdGlvbiBtb2RlLCB0aGUgZGlzdGFuY2Ugc2NhbGVzIHZhcnkgc2lnbmlmaWNhbnRseVxuICAgKiB3aXRoIGxhdGl0dWRlLlxuICAgKi9cbiAgX2NhbGN1bGF0ZURpc3RhbmNlU2NhbGVzKCkge1xuICAgIC8vIEFwcHJveGltYXRlbHkgMTExa20gcGVyIGRlZ3JlZSBhdCBlcXVhdG9yXG4gICAgY29uc3QgTUVURVJTX1BFUl9ERUdSRUUgPSAxMTEwMDA7XG4gICAgY29uc3Qge2xhdGl0dWRlLCBsb25naXR1ZGV9ID0gdGhpcztcblxuICAgIGNvbnN0IGxhdENvc2luZSA9IE1hdGguY29zKGxhdGl0dWRlICogTWF0aC5QSSAvIDE4MCk7XG5cbiAgICBjb25zdCBtZXRlcnNQZXJEZWdyZWUgPSBNRVRFUlNfUEVSX0RFR1JFRSAqIGxhdENvc2luZTtcblxuICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgbG9uZ2l0dWRlXG4gICAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICAgIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVggPSB2ZWMyLmRpc3RhbmNlKFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlICsgMC41LCBsYXRpdHVkZV0pLFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlIC0gMC41LCBsYXRpdHVkZV0pXG4gICAgKTtcbiAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxhdGl0dWRlXG4gICAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICAgIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVkgPSB2ZWMyLmRpc3RhbmNlKFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSArIDAuNV0pLFxuICAgICAgdGhpcy5wcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSAtIDAuNV0pXG4gICAgKTtcblxuICAgIGNvbnN0IHBpeGVsc1Blck1ldGVyWCA9IHBpeGVsc1BlckRlZ3JlZVggLyBtZXRlcnNQZXJEZWdyZWU7XG4gICAgY29uc3QgcGl4ZWxzUGVyTWV0ZXJZID0gcGl4ZWxzUGVyRGVncmVlWSAvIG1ldGVyc1BlckRlZ3JlZTtcbiAgICBjb25zdCBwaXhlbHNQZXJNZXRlclogPSAocGl4ZWxzUGVyTWV0ZXJYICsgcGl4ZWxzUGVyTWV0ZXJZKSAvIDI7XG5cbiAgICAvLyBjb25zdCBzY2FsZSA9IDAuOTU7XG4gICAgLy8gY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbXG4gICAgLy8gICBwaXhlbHNQZXJNZXRlclggKiBzY2FsZSwgcGl4ZWxzUGVyTWV0ZXJZICogc2NhbGUsIHBpeGVsc1Blck1ldGVyWiAqIHNjYWxlXG4gICAgLy8gXTtcbiAgICBjb25zdCB3b3JsZFNpemUgPSBUSUxFX1NJWkUgKiB0aGlzLnNjYWxlO1xuICAgIGNvbnN0IGFsdFBpeGVsc1Blck1ldGVyID0gd29ybGRTaXplIC8gKDRlNyAqIGxhdENvc2luZSk7XG4gICAgY29uc3QgcGl4ZWxzUGVyTWV0ZXIgPSBbXG4gICAgICBhbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXIsIGFsdFBpeGVsc1Blck1ldGVyXG4gICAgXTtcbiAgICBjb25zdCBtZXRlcnNQZXJQaXhlbCA9IFtcbiAgICAgIDEgLyBwaXhlbHNQZXJNZXRlclgsIDEgLyBwaXhlbHNQZXJNZXRlclksIDEgLyBwaXhlbHNQZXJNZXRlclpcbiAgICBdO1xuXG4gICAgLy8gTWFpbiByZXN1bHRzLCB1c2VkIGZvciBzY2FsaW5nIG9mZnNldHNcbiAgICB0aGlzLnBpeGVsc1Blck1ldGVyID0gcGl4ZWxzUGVyTWV0ZXI7XG4gICAgLy8gQWRkaXRpb25hbCByZXN1bHRzXG4gICAgdGhpcy5tZXRlcnNQZXJQaXhlbCA9IG1ldGVyc1BlclBpeGVsO1xuICAgIC8vIG1ldGVyc1BlckRlZ3JlZSxcbiAgICAvLyBkZWdyZWVzUGVyTWV0ZXI6IDEgLyBtZXRlcnNQZXJEZWdyZWVcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9qZWN0RmxhdChbbG5nLCBsYXRdLCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlICogV09STERfU0NBTEU7XG4gIGNvbnN0IGxhbWJkYTIgPSBsbmcgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBoaTIgPSBsYXQgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHggPSBzY2FsZSAqIChsYW1iZGEyICsgUEkpO1xuICBjb25zdCB5ID0gc2NhbGUgKiAoUEkgLSBNYXRoLmxvZyhNYXRoLnRhbihQSV80ICsgcGhpMiAqIDAuNSkpKTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuLy8gQVRUUklCVVRJT046XG4vLyB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpeCBjcmVhdGlvbiBpcyBpbnRlbnRpb25hbGx5IGtlcHQgY29tcGF0aWJsZSB3aXRoXG4vLyBtYXBib3gtZ2wncyBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgdGhhdCBzZWFtbGVzcyBpbnRlcm9wZXJhdGlvblxuLy8gd2l0aCBtYXBib3ggYW5kIHJlYWN0LW1hcC1nbC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qc1xuZnVuY3Rpb24gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBwaXRjaCxcbiAgYWx0aXR1ZGVcbn0pIHtcbiAgY29uc3QgcGl0Y2hSYWRpYW5zID0gcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlM7XG5cbiAgLy8gUFJPSkVDVElPTiBNQVRSSVg6IFBST0pFQ1RTIEZST00gQ0FNRVJBIFNQQUNFIFRPIENMSVBTUEFDRVxuICAvLyBGaW5kIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgcG9pbnQgdG8gdGhlIGNlbnRlciB0b3BcbiAgLy8gaW4gYWx0aXR1ZGUgdW5pdHMgdXNpbmcgbGF3IG9mIHNpbmVzLlxuICBjb25zdCBoYWxmRm92ID0gTWF0aC5hdGFuKDAuNSAvIGFsdGl0dWRlKTtcbiAgY29uc3QgdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSA9XG4gICAgTWF0aC5zaW4oaGFsZkZvdikgKiBhbHRpdHVkZSAvIE1hdGguc2luKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zIC0gaGFsZkZvdik7XG5cbiAgLy8gQ2FsY3VsYXRlIHogdmFsdWUgb2YgdGhlIGZhcnRoZXN0IGZyYWdtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICBjb25zdCBmYXJaID0gTWF0aC5jb3MoTWF0aC5QSSAvIDIgLSBwaXRjaFJhZGlhbnMpICogdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSArIGFsdGl0dWRlO1xuXG4gIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBtYXQ0LnBlcnNwZWN0aXZlKFxuICAgIGNyZWF0ZU1hdDQoKSxcbiAgICAyICogTWF0aC5hdGFuKChoZWlnaHQgLyAyKSAvIGFsdGl0dWRlKSwgLy8gZm92IGluIHJhZGlhbnNcbiAgICB3aWR0aCAvIGhlaWdodCwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgMC4xLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWFyIHBsYW5lXG4gICAgZmFyWiAqIDEwLjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFyIHBsYW5lXG4gICk7XG5cbiAgcmV0dXJuIHByb2plY3Rpb25NYXRyaXg7XG59XG5cbmZ1bmN0aW9uIG1ha2VWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbG9uZ2l0dWRlLFxuICBsYXRpdHVkZSxcbiAgem9vbSxcbiAgcGl0Y2gsXG4gIGJlYXJpbmcsXG4gIGFsdGl0dWRlXG59KSB7XG4gIC8vIENlbnRlciB4LCB5XG4gIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSk7XG4gIGNvbnN0IFtjZW50ZXJYLCBjZW50ZXJZXSA9IHByb2plY3RGbGF0KFtsb25naXR1ZGUsIGxhdGl0dWRlXSwgc2NhbGUpO1xuXG4gIC8vIFZJRVcgTUFUUklYOiBQUk9KRUNUUyBGUk9NIFZJUlRVQUwgUElYRUxTIFRPIENBTUVSQSBTUEFDRVxuICAvLyBOb3RlOiBBcyB1c3VhbCwgbWF0cml4IG9wZXJhdGlvbiBvcmRlcnMgc2hvdWxkIGJlIHJlYWQgaW4gcmV2ZXJzZVxuICAvLyBzaW5jZSB2ZWN0b3JzIHdpbGwgYmUgbXVsdGlwbGllZCBmcm9tIHRoZSByaWdodCBkdXJpbmcgdHJhbnNmb3JtYXRpb25cbiAgY29uc3Qgdm0gPSBjcmVhdGVNYXQ0KCk7XG5cbiAgLy8gTW92ZSBjYW1lcmEgdG8gYWx0aXR1ZGVcbiAgbWF0NC50cmFuc2xhdGUodm0sIHZtLCBbMCwgMCwgLWFsdGl0dWRlXSk7XG5cbiAgLy8gQWZ0ZXIgdGhlIHJvdGF0ZVgsIHogdmFsdWVzIGFyZSBpbiBwaXhlbCB1bml0cy4gQ29udmVydCB0aGVtIHRvXG4gIC8vIGFsdGl0dWRlIHVuaXRzLiAxIGFsdGl0dWRlIHVuaXQgPSB0aGUgc2NyZWVuIGhlaWdodC5cbiAgbWF0NC5zY2FsZSh2bSwgdm0sIFsxLCAtMSwgMSAvIGhlaWdodF0pO1xuXG4gIC8vIFJvdGF0ZSBieSBiZWFyaW5nLCBhbmQgdGhlbiBieSBwaXRjaCAod2hpY2ggdGlsdHMgdGhlIHZpZXcpXG4gIG1hdDQucm90YXRlWCh2bSwgdm0sIHBpdGNoICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgbWF0NC5yb3RhdGVaKHZtLCB2bSwgLWJlYXJpbmcgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuXG4gIG1hdDQudHJhbnNsYXRlKHZtLCB2bSwgWy1jZW50ZXJYLCAtY2VudGVyWSwgMF0pO1xuXG4gIHJldHVybiB2bTtcbn1cbiJdfQ==