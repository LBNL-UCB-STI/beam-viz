'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _desc, _value, _class; // View and Projection Matrix management

// gl-matrix is a large dependency for a small module.
// However since it is used by mapbox etc, it should already be present
// in most target application bundles.


exports.createMat4 = createMat4;

var _glMatrix = require('gl-matrix');

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var IDENTITY = createMat4();

var Viewport = (_class = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
   */
  /* eslint-disable complexity */
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$width = _ref.width,
        width = _ref$width === undefined ? 1 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? 1 : _ref$height,
        _ref$viewMatrix = _ref.viewMatrix,
        viewMatrix = _ref$viewMatrix === undefined ? IDENTITY : _ref$viewMatrix,
        _ref$projectionMatrix = _ref.projectionMatrix,
        projectionMatrix = _ref$projectionMatrix === undefined ? IDENTITY : _ref$projectionMatrix;

    _classCallCheck(this, Viewport);

    // Silently allow apps to send in 0,0
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;

    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;

    // Note: As usual, matrix operations should be applied in "reverse" order
    // since vectors will be multiplied in from the right during transformation
    var vpm = createMat4();
    _glMatrix.mat4.multiply(vpm, vpm, this.projectionMatrix);
    _glMatrix.mat4.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;

    // Calculate matrices and scales needed for projection
    /**
     * Builds matrices that converts preprojected lngLats to screen pixels
     * and vice versa.
     * Note: Currently returns bottom-left coordinates!
     * Note: Starts with the GL projection matrix and adds steps to the
     *       scale and translate that matrix onto the window.
     * Note: WebGL controls clip space to screen projection with gl.viewport
     *       and does not need this step.
     */
    var m = createMat4();

    // Scale with viewport window's width and height in pixels
    _glMatrix.mat4.scale(m, m, [this.width, this.height, 1]);
    // Convert to (0, 1)
    _glMatrix.mat4.translate(m, m, [0.5, 0.5, 0]);
    _glMatrix.mat4.scale(m, m, [0.5, 0.5, 1]);
    // Project to clip space (-1, 1)
    _glMatrix.mat4.multiply(m, m, this.viewProjectionMatrix);

    var mInverse = _glMatrix.mat4.invert(createMat4(), m);
    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;
  }
  /* eslint-enable complexity */

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && _glMatrix.mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && _glMatrix.mat4.equals(viewport.viewMatrix, this.viewMatrix);
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? false : _ref2$topLeft;

      var Z = xyz[2] || 0;
      // console.error('projecting non-linear', xyz);

      var _projectFlat = this.projectFlat(xyz),
          _projectFlat2 = _slicedToArray(_projectFlat, 2),
          X = _projectFlat2[0],
          Y = _projectFlat2[1];

      var v = [X, Y, Z, 1];
      // console.error('projecting linear', v);
      // vec4.sub(v, v, [this.centerX, this.centerY, 0, 0]);
      _glMatrix.vec4.transformMat4(v, v, this.pixelProjectionMatrix);
      // Divide by w
      var scale = 1 / v[3];
      _glMatrix.vec4.multiply(v, v, [scale, scale, scale, scale]);
      // console.error('projected', v);
      var x = v[0],
          z = v[2];

      var y = topLeft ? this.height - v[1] : v[1];
      return xyz.length === 2 ? [x, y] : [x, y, z];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$topLeft = _ref3.topLeft,
          topLeft = _ref3$topLeft === undefined ? false : _ref3$topLeft;

      // console.error('unprojecting linear', xyz);
      var _xyz = _slicedToArray(xyz, 3),
          _xyz$ = _xyz[0],
          x = _xyz$ === undefined ? 0 : _xyz$,
          _xyz$2 = _xyz[1],
          y = _xyz$2 === undefined ? 0 : _xyz$2,
          _xyz$3 = _xyz[2],
          z = _xyz$3 === undefined ? 0 : _xyz$3;
      // const y2 = topLeft ? this.height - 1 - y : y;


      var y2 = topLeft ? this.height - y : y;
      var v = [x, y2, z, 1];
      _glMatrix.vec4.transformMat4(v, v, this.pixelUnprojectionMatrix);
      var scale = 1 / v[3];
      _glMatrix.vec4.multiply(v, v, [scale, scale, scale, scale]);
      // console.error('unprojecting non-linear', v);

      var _unprojectFlat = this.unprojectFlat(v),
          _unprojectFlat2 = _slicedToArray(_unprojectFlat, 2),
          x0 = _unprojectFlat2[0],
          y0 = _unprojectFlat2[1];
      // console.error('unprojected', [x0, y0]);


      var z0 = v[2];

      return xyz.length === 2 ? [x0, y0] : [x0, y0, z0];
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          x = _ref5[0],
          y = _ref5[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._projectFlat.apply(this, arguments);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._unprojectFlat.apply(this, arguments);
    }

    // _projectFlat(xyz, scale = this.scale) {
    //   return xyz;
    // }

    // _unprojectFlat(xyz, scale = this.scale) {
    //   return xyz;
    // }

  }, {
    key: 'getMatrices',
    value: function getMatrices() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$modelMatrix = _ref6.modelMatrix,
          modelMatrix = _ref6$modelMatrix === undefined ? null : _ref6$modelMatrix,
          opts = _objectWithoutProperties(_ref6, ['modelMatrix']);

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = _glMatrix.mat4.multiply([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = _glMatrix.mat4.multiply([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = _glMatrix.mat4.invert([], pixelProjectionMatrix);
      }

      var matrices = _extends({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,

        // project/unproject between pixels and world
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,

        width: this.width,
        height: this.height,
        scale: this.scale

      }, this._getParams());

      return matrices;
    }

    // INTERNAL METHODS

    // Can be subclassed to add additional fields to `getMatrices`

  }, {
    key: '_getParams',
    value: function _getParams() {
      return {};
    }
  }]);

  return Viewport;
}(), (_applyDecoratedDescriptor(_class.prototype, 'project', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'project'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'unproject', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'unproject'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'projectFlat', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'projectFlat'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'unprojectFlat', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'unprojectFlat'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'getMatrices', [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, 'getMatrices'), _class.prototype)), _class);

// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()

exports.default = Viewport;
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJjcmVhdGVNYXQ0IiwiSURFTlRJVFkiLCJWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJzY2FsZSIsInZwbSIsIm11bHRpcGx5Iiwidmlld1Byb2plY3Rpb25NYXRyaXgiLCJtIiwidHJhbnNsYXRlIiwibUludmVyc2UiLCJpbnZlcnQiLCJFcnJvciIsInBpeGVsUHJvamVjdGlvbk1hdHJpeCIsInBpeGVsVW5wcm9qZWN0aW9uTWF0cml4Iiwidmlld3BvcnQiLCJlcXVhbHMiLCJ4eXoiLCJ0b3BMZWZ0IiwiWiIsInByb2plY3RGbGF0IiwiWCIsIlkiLCJ2IiwidHJhbnNmb3JtTWF0NCIsIngiLCJ6IiwieSIsImxlbmd0aCIsInkyIiwidW5wcm9qZWN0RmxhdCIsIngwIiwieTAiLCJ6MCIsIl9wcm9qZWN0RmxhdCIsImFyZ3VtZW50cyIsIl91bnByb2plY3RGbGF0IiwibW9kZWxNYXRyaXgiLCJvcHRzIiwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCIsIm1hdHJpY2VzIiwiX2dldFBhcmFtcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OzsyQkFBQTs7QUFFQTtBQUNBO0FBQ0E7OztRQXNPZ0JBLFUsR0FBQUEsVTs7QUFyT2hCOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQyxXQUFXRCxZQUFqQjs7SUFFcUJFLFE7QUFDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFDQSxzQkFPUTtBQUFBLG1GQUFKLEVBQUk7QUFBQSwwQkFMTkMsS0FLTTtBQUFBLFFBTE5BLEtBS00sOEJBTEUsQ0FLRjtBQUFBLDJCQUpOQyxNQUlNO0FBQUEsUUFKTkEsTUFJTSwrQkFKRyxDQUlIO0FBQUEsK0JBRk5DLFVBRU07QUFBQSxRQUZOQSxVQUVNLG1DQUZPSixRQUVQO0FBQUEscUNBRE5LLGdC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QkFBc0IsS0FBS0Esb0JBRnZCO0FBR0pMLG9CQUFZLEtBQUtBLFVBSGI7QUFJSkMsMEJBQWtCLEtBQUtBLGdCQUpuQjs7QUFNSjtBQUNBVSxvREFQSTtBQVFKQyx3REFSSTs7QUFVSmQsZUFBTyxLQUFLQSxLQVZSO0FBV0pDLGdCQUFRLEtBQUtBLE1BWFQ7QUFZSkcsZUFBTyxLQUFLQTs7QUFaUixTQWdCRCxLQUFLcUMsVUFBTCxFQWhCQyxDQUFOOztBQW1CQSxhQUFPRCxRQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7aUNBQ2E7QUFDWCxhQUFPLEVBQVA7QUFDRDs7Ozs7O0FBR0g7O2tCQS9OcUJ6QyxRO0FBZ09kLFNBQVNGLFVBQVQsR0FBc0I7QUFDM0IsU0FBTyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLENBQXhDLEVBQTJDLENBQTNDLEVBQThDLENBQTlDLENBQVA7QUFDRCIsImZpbGUiOiJ2aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFZpZXcgYW5kIFByb2plY3Rpb24gTWF0cml4IG1hbmFnZW1lbnRcblxuLy8gZ2wtbWF0cml4IGlzIGEgbGFyZ2UgZGVwZW5kZW5jeSBmb3IgYSBzbWFsbCBtb2R1bGUuXG4vLyBIb3dldmVyIHNpbmNlIGl0IGlzIHVzZWQgYnkgbWFwYm94IGV0YywgaXQgc2hvdWxkIGFscmVhZHkgYmUgcHJlc2VudFxuLy8gaW4gbW9zdCB0YXJnZXQgYXBwbGljYXRpb24gYnVuZGxlcy5cbmltcG9ydCB7bWF0NCwgdmVjNH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBhdXRvYmluZCBmcm9tICdhdXRvYmluZC1kZWNvcmF0b3InO1xuXG5jb25zdCBJREVOVElUWSA9IGNyZWF0ZU1hdDQoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBNYW5hZ2VzIGNvb3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjay5nbC5cbiAgICpcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWVyY2F0b3I9dHJ1ZSAtIFdoZXRoZXIgdG8gdXNlIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC53aWR0aD0xIC0gV2lkdGggb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmhlaWdodD0xIC0gSGVpZ2h0IG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtBcnJheX0gb3B0LmNlbnRlcj1bMCwgMF0gLSBDZW50ZXIgb2Ygdmlld3BvcnRcbiAgICogICBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gb3IgW3gsIHldXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuc2NhbGU9MSAtIEVpdGhlciB1c2Ugc2NhbGUgb3Igem9vbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnBpdGNoPTAgLSBDYW1lcmEgYW5nbGUgaW4gZGVncmVlcyAoMCBpcyBzdHJhaWdodCBkb3duKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmJlYXJpbmc9MCAtIE1hcCByb3RhdGlvbiBpbiBkZWdyZWVzICgwIG1lYW5zIG5vcnRoIGlzIHVwKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmFsdGl0dWRlPSAtIEFsdGl0dWRlIG9mIGNhbWVyYSBpbiBzY3JlZW4gdW5pdHNcbiAgICpcbiAgICogV2ViIG1lcmNhdG9yIHByb2plY3Rpb24gc2hvcnQtaGFuZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubGF0aXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxvbmdpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuem9vbSAtIFNjYWxlID0gTWF0aC5wb3coMix6b29tKSBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5zY2FsZSlcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8vIFdpbmRvdyB3aWR0aC9oZWlnaHQgaW4gcGl4ZWxzIChmb3IgcGl4ZWwgcHJvamVjdGlvbilcbiAgICB3aWR0aCA9IDEsXG4gICAgaGVpZ2h0ID0gMSxcbiAgICAvLyBEZXNjXG4gICAgdmlld01hdHJpeCA9IElERU5USVRZLFxuICAgIHByb2plY3Rpb25NYXRyaXggPSBJREVOVElUWVxuICB9ID0ge30pIHtcbiAgICAvLyBTaWxlbnRseSBhbGxvdyBhcHBzIHRvIHNlbmQgaW4gMCwwXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMTtcbiAgICB0aGlzLnNjYWxlID0gMTtcblxuICAgIHRoaXMudmlld01hdHJpeCA9IHZpZXdNYXRyaXg7XG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gcHJvamVjdGlvbk1hdHJpeDtcblxuICAgIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9ucyBzaG91bGQgYmUgYXBwbGllZCBpbiBcInJldmVyc2VcIiBvcmRlclxuICAgIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGluIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICAgIGNvbnN0IHZwbSA9IGNyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgIG1hdDQubXVsdGlwbHkodnBtLCB2cG0sIHRoaXMudmlld01hdHJpeCk7XG4gICAgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCA9IHZwbTtcblxuICAgIC8vIENhbGN1bGF0ZSBtYXRyaWNlcyBhbmQgc2NhbGVzIG5lZWRlZCBmb3IgcHJvamVjdGlvblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBtYXRyaWNlcyB0aGF0IGNvbnZlcnRzIHByZXByb2plY3RlZCBsbmdMYXRzIHRvIHNjcmVlbiBwaXhlbHNcbiAgICAgKiBhbmQgdmljZSB2ZXJzYS5cbiAgICAgKiBOb3RlOiBDdXJyZW50bHkgcmV0dXJucyBib3R0b20tbGVmdCBjb29yZGluYXRlcyFcbiAgICAgKiBOb3RlOiBTdGFydHMgd2l0aCB0aGUgR0wgcHJvamVjdGlvbiBtYXRyaXggYW5kIGFkZHMgc3RlcHMgdG8gdGhlXG4gICAgICogICAgICAgc2NhbGUgYW5kIHRyYW5zbGF0ZSB0aGF0IG1hdHJpeCBvbnRvIHRoZSB3aW5kb3cuXG4gICAgICogTm90ZTogV2ViR0wgY29udHJvbHMgY2xpcCBzcGFjZSB0byBzY3JlZW4gcHJvamVjdGlvbiB3aXRoIGdsLnZpZXdwb3J0XG4gICAgICogICAgICAgYW5kIGRvZXMgbm90IG5lZWQgdGhpcyBzdGVwLlxuICAgICAqL1xuICAgIGNvbnN0IG0gPSBjcmVhdGVNYXQ0KCk7XG5cbiAgICAvLyBTY2FsZSB3aXRoIHZpZXdwb3J0IHdpbmRvdydzIHdpZHRoIGFuZCBoZWlnaHQgaW4gcGl4ZWxzXG4gICAgbWF0NC5zY2FsZShtLCBtLCBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDFdKTtcbiAgICAvLyBDb252ZXJ0IHRvICgwLCAxKVxuICAgIG1hdDQudHJhbnNsYXRlKG0sIG0sIFswLjUsIDAuNSwgMF0pO1xuICAgIG1hdDQuc2NhbGUobSwgbSwgWzAuNSwgMC41LCAxXSk7XG4gICAgLy8gUHJvamVjdCB0byBjbGlwIHNwYWNlICgtMSwgMSlcbiAgICBtYXQ0Lm11bHRpcGx5KG0sIG0sIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgY29uc3QgbUludmVyc2UgPSBtYXQ0LmludmVydChjcmVhdGVNYXQ0KCksIG0pO1xuICAgIGlmICghbUludmVyc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGl4ZWwgcHJvamVjdCBtYXRyaXggbm90IGludmVydGlibGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IG07XG4gICAgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IG1JbnZlcnNlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIC8vIFR3byB2aWV3cG9ydHMgYXJlIGVxdWFsIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGlkZW50aWNhbCwgYW5kIGlmXG4gIC8vIHRoZWlyIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cmljZXMgYXJlIChhcHByb3hpbWF0ZWx5KSBlcXVhbC5cbiAgZXF1YWxzKHZpZXdwb3J0KSB7XG4gICAgaWYgKCEodmlld3BvcnQgaW5zdGFuY2VvZiBWaWV3cG9ydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlld3BvcnQud2lkdGggPT09IHRoaXMud2lkdGggJiZcbiAgICAgIHZpZXdwb3J0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiZcbiAgICAgIG1hdDQuZXF1YWxzKHZpZXdwb3J0LnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCkgJiZcbiAgICAgIG1hdDQuZXF1YWxzKHZpZXdwb3J0LnZpZXdNYXRyaXgsIHRoaXMudmlld01hdHJpeCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvamVjdHMgeHl6IChwb3NzaWJseSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlKSB0byBwaXhlbCBjb29yZGluYXRlcyBpbiB3aW5kb3dcbiAgICogdXNpbmcgdmlld3BvcnQgcHJvamVjdGlvbiBwYXJhbWV0ZXJzXG4gICAqIC0gW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIHRvIFt4LCB5XVxuICAgKiAtIFtsb25naXR1ZGUsIGxhdGl0dWRlLCBaXSA9PiBbeCwgeSwgel1cbiAgICogTm90ZTogQnkgZGVmYXVsdCwgcmV0dXJucyB0b3AtbGVmdCBjb29yZGluYXRlcyBmb3IgY2FudmFzL1NWRyB0eXBlIHJlbmRlclxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXRaIC0gW2xuZywgbGF0XSBvciBbbG5nLCBsYXQsIFpdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy50b3BMZWZ0PXRydWUgLSBXaGV0aGVyIHByb2plY3RlZCBjb29yZHMgYXJlIHRvcCBsZWZ0XG4gICAqIEByZXR1cm4ge0FycmF5fSAtIFt4LCB5XSBvciBbeCwgeSwgel0gaW4gdG9wIGxlZnQgY29vcmRzXG4gICAqL1xuICBAYXV0b2JpbmQgcHJvamVjdCh4eXosIHt0b3BMZWZ0ID0gZmFsc2V9ID0ge30pIHtcbiAgICBjb25zdCBaID0geHl6WzJdIHx8IDA7XG4gICAgLy8gY29uc29sZS5lcnJvcigncHJvamVjdGluZyBub24tbGluZWFyJywgeHl6KTtcbiAgICBjb25zdCBbWCwgWV0gPSB0aGlzLnByb2plY3RGbGF0KHh5eik7XG4gICAgY29uc3QgdiA9IFtYLCBZLCBaLCAxXTtcbiAgICAvLyBjb25zb2xlLmVycm9yKCdwcm9qZWN0aW5nIGxpbmVhcicsIHYpO1xuICAgIC8vIHZlYzQuc3ViKHYsIHYsIFt0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgMCwgMF0pO1xuICAgIHZlYzQudHJhbnNmb3JtTWF0NCh2LCB2LCB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgLy8gRGl2aWRlIGJ5IHdcbiAgICBjb25zdCBzY2FsZSA9IDEgLyB2WzNdO1xuICAgIHZlYzQubXVsdGlwbHkodiwgdiwgW3NjYWxlLCBzY2FsZSwgc2NhbGUsIHNjYWxlXSk7XG4gICAgLy8gY29uc29sZS5lcnJvcigncHJvamVjdGVkJywgdik7XG4gICAgY29uc3QgW3gsICwgel0gPSB2O1xuICAgIGNvbnN0IHkgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSB2WzFdIDogdlsxXTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IFt4LCB5XSA6IFt4LCB5LCB6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3QgcGl4ZWwgY29vcmRpbmF0ZXMgb24gc2NyZWVuIG9udG8gd29ybGQgY29vcmRpbmF0ZXMsXG4gICAqIChwb3NzaWJseSBbbG9uLCBsYXRdKSBvbiBtYXAuXG4gICAqIC0gW3gsIHldID0+IFtsbmcsIGxhdF1cbiAgICogLSBbeCwgeSwgel0gPT4gW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge0FycmF5fSB4eXogLVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbbG5nLCBsYXQsIFpdIG9yIFtYLCBZLCBaXVxuICAgKi9cbiAgQGF1dG9iaW5kIHVucHJvamVjdCh4eXosIHt0b3BMZWZ0ID0gZmFsc2V9ID0ge30pIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCd1bnByb2plY3RpbmcgbGluZWFyJywgeHl6KTtcbiAgICBjb25zdCBbeCA9IDAsIHkgPSAwLCB6ID0gMF0gPSB4eXo7XG4gICAgLy8gY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSAxIC0geSA6IHk7XG4gICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8gdGhpcy5oZWlnaHQgLSB5IDogeTtcbiAgICBjb25zdCB2ID0gW3gsIHkyLCB6LCAxXTtcbiAgICB2ZWM0LnRyYW5zZm9ybU1hdDQodiwgdiwgdGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgY29uc3Qgc2NhbGUgPSAxIC8gdlszXTtcbiAgICB2ZWM0Lm11bHRpcGx5KHYsIHYsIFtzY2FsZSwgc2NhbGUsIHNjYWxlLCBzY2FsZV0pO1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3VucHJvamVjdGluZyBub24tbGluZWFyJywgdik7XG4gICAgY29uc3QgW3gwLCB5MF0gPSB0aGlzLnVucHJvamVjdEZsYXQodik7XG4gICAgLy8gY29uc29sZS5lcnJvcigndW5wcm9qZWN0ZWQnLCBbeDAsIHkwXSk7XG4gICAgY29uc3QgWywgLCB6MF0gPSB2O1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW3gwLCB5MF0gOiBbeDAsIHkwLCB6MF07XG4gIH1cblxuICAvLyBOT05fTElORUFSIFBST0pFQ1RJT04gSE9PS1NcbiAgLy8gVXNlZCBmb3Igd2ViIG1lcmFjdG9yIHByb2plY3Rpb25cblxuICAvKipcbiAgICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAgICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICogcGVyc3BlY3RpdmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gICAqL1xuICBAYXV0b2JpbmQgcHJvamVjdEZsYXQoW3gsIHldLCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvamVjdEZsYXQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gICAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICAgKi9cbiAgQGF1dG9iaW5kIHVucHJvamVjdEZsYXQoeHl6LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5fdW5wcm9qZWN0RmxhdCguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gX3Byb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gIC8vICAgcmV0dXJuIHh5ejtcbiAgLy8gfVxuXG4gIC8vIF91bnByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gIC8vICAgcmV0dXJuIHh5ejtcbiAgLy8gfVxuXG4gIEBhdXRvYmluZCBnZXRNYXRyaWNlcyh7bW9kZWxNYXRyaXggPSBudWxsLCAuLi5vcHRzfSA9IHt9KSB7XG4gICAgbGV0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4O1xuICAgIGxldCBwaXhlbFByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeDtcbiAgICBsZXQgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4O1xuXG4gICAgaWYgKG1vZGVsTWF0cml4KSB7XG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5tdWx0aXBseShbXSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5tdWx0aXBseShbXSwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICAgIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5pbnZlcnQoW10sIHBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0cmljZXMgPSB7XG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgdmlld1Byb2plY3Rpb25NYXRyaXg6IHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgICB2aWV3TWF0cml4OiB0aGlzLnZpZXdNYXRyaXgsXG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiB0aGlzLnByb2plY3Rpb25NYXRyaXgsXG5cbiAgICAgIC8vIHByb2plY3QvdW5wcm9qZWN0IGJldHdlZW4gcGl4ZWxzIGFuZCB3b3JsZFxuICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsXG5cbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIHNjYWxlOiB0aGlzLnNjYWxlLFxuXG4gICAgICAvLyBTdWJjbGFzcyBjYW4gYWRkIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAvLyBUT0RPIC0gRnJhZ2lsZTogYmV0dGVyIHRvIG1ha2UgYmFzZSBWaWV3cG9ydCBjbGFzcyBhd2FyZSBvZiBhbGwgcGFyYW1zXG4gICAgICAuLi50aGlzLl9nZXRQYXJhbXMoKVxuICAgIH07XG5cbiAgICByZXR1cm4gbWF0cmljZXM7XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgLy8gQ2FuIGJlIHN1YmNsYXNzZWQgdG8gYWRkIGFkZGl0aW9uYWwgZmllbGRzIHRvIGBnZXRNYXRyaWNlc2BcbiAgX2dldFBhcmFtcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuLy8gSGVscGVyLCBhdm9pZHMgbG93LXByZWNpc2lvbiAzMiBiaXQgbWF0cmljZXMgZnJvbSBnbC1tYXRyaXggbWF0NC5jcmVhdGUoKVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hdDQoKSB7XG4gIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG59XG4iXX0=